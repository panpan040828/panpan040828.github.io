---
layout: post
title: 寻路算法
date: 2016-04-22
categories: 算法学习
tags: [算法]
description: 
---

最近在做百度前端技术学院第二阶段的《听指令的小方块》这个任务时，遇到了要写一个寻路算法，于是便研究了一下。

寻路算法指的是已知起点A、终点B，在不穿过障碍物的情况下，找到由A到B的最短路径。

传统的寻路算法一般是按照单元格来划分地图，寻路算法包括A* 、递归、非递归、广度优先、深度优先、使用堆栈等。这篇博客介绍的是A*算法。

### 一. A* 算法的原理

首先，我们需要用到一个公式：

	F = G + H
	F为从起点经过该点的到终点总路程
	G为从起点到该点的路程，称为“已走路程”->不需要考虑障碍物，可沿斜方移动
	H为从该点到终点的路程，称为“预计路程”->不需要考虑障碍物，只考虑水平、垂直移动

A* 算法是从起点开始，然后检测每一个节点，直到找到终点。

我们需要两个列表：**开启列表**和**关闭列表**。

**开启列表：**每检测一个节点，将节点放到**开启列表**，将该节点周围的节点（不包括障碍物、已关闭的节点）放到**开启列表**中，将A存到父节点中；

**关闭列表：**检测完了之后，把检测完了的节点放到**关闭列表**。

http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html

每检测一个节点时，需要计算开启列表中的所有节点的F值，选取一个F值最小的节点，作为下一个检测节点，开启其周围的节点。

若周围的节点已经存在在开启列表中，计算新的G值（经过前面两点到此点的值），若新G值更低，计算F；若新G值更高，则不做计算。

对每一个节点都做这个操作，直到找到终点为止。

路径：沿着父节点进行运动，就是最短路径。

    把起始格添加到 "开启列表" 
    do 
    { 
       寻找开启列表中F值最低的格子, 我们称它为当前格. 
       把它切换到关闭列表. 
       对当前格相邻的8格中的每一个 
      if (它不可通过 || 已经在 "关闭列表" 中) 
      { 
    		什么也不做. 
      } 
      if (它不在开启列表中) 
      { 
    	把它添加进 "开启列表", 把当前格作为这一格的父节点, 计算这一格的 FGH 
     	 if (它已经在开启列表中) 
      	 { 
    		if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
    		{ 
    			把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. 
   			} 
    	 } 
		while( 目标格已经在 "开启列表", 这时候路径被找到) 
    	如果开启列表已经空了, 说明路径不存在.

	最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.

### 二. 使用寻路算法做的一个小游戏

demo地址：[http://panpanfish.com/myDemo/task3-46.html](http://panpanfish.com/myDemo/task3-46.html)

代码地址：
[https://github.com/panpan040828/myDemo/blob/master/task3-46.html](https://github.com/panpan040828/myDemo/blob/master/task3-46.html "王牌特工的代码地址")







