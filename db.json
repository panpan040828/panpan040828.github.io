{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/icon.jpg","path":"uploads/icon.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/algolia-instant-search/instantsearch.min.css","path":"vendors/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/20160428/task3-46.jpg","path":"uploads/post/20160428/task3-46.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/20160329/broswer-caching.jpg","path":"uploads/post/20160329/broswer-caching.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/baidu-ife-task1.jpg","path":"uploads/post/demo/baidu-ife-task1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/baidu-ife-task2.jpg","path":"uploads/post/demo/baidu-ife-task2.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/prototype.jpg","path":"uploads/post/demo/prototype.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/scope.jpg","path":"uploads/post/demo/scope.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/float-center.jpg","path":"uploads/post/demo/float-center.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/20160509/async.jpg","path":"uploads/post/20160509/async.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/flex-wrap-reverse.jpg","path":"uploads/post/demo/flex-wrap-reverse.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/20160329/http-caching.jpg","path":"uploads/post/20160329/http-caching.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/collapse/1.jpg","path":"uploads/post/demo/collapse/1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/collapse/4.jpg","path":"uploads/post/demo/collapse/4.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/collapse/3.jpg","path":"uploads/post/demo/collapse/3.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/collapse/5.jpg","path":"uploads/post/demo/collapse/5.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/20160524/node.jpg","path":"uploads/post/20160524/node.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/post/demo/collapse/2.jpg","path":"uploads/post/demo/collapse/2.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/algolia-instant-search/instantsearch.min.js","path":"vendors/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1471489136000},{"_id":"source/CNAME","hash":"8c9d14b6b963ac334a6a1e89ab4badaa4bac47b4","modified":1461036412000},{"_id":"source/favicon.ico","hash":"1d91ae2b3d239d46086041c2f9e34e3808bae750","modified":1464588146000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1463412204000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1463412204000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1463412204000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1463412204000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1463412204000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1463412204000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1463412204000},{"_id":"themes/next/_config.yml","hash":"1302824a0f3cd768e5e9c8eccdcc025dd34eada1","modified":1464592790000},{"_id":"themes/next/bower.json","hash":"da86af5830fd69a06cad274f403ee793c3cde402","modified":1463412204000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1463412204000},{"_id":"themes/next/gulpfile.coffee","hash":"6c155a3925b3b1faf3c3c6a53fc2216168fd0609","modified":1463412204000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1463412204000},{"_id":"source/_posts/2016-03-01-maoyanpc项目记录.md","hash":"baf1eaa6620dc63761e56ebcc6e2dfab1a61b3b9","modified":1473251186000},{"_id":"source/_posts/2016-03-01-《锋利的jQuery》.md","hash":"706e2e48ae660e4a4fbcc7fc5648d16c135d8d72","modified":1467978586000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1488974550000},{"_id":"source/categories/index.md","hash":"3955154a33d32a18e007ff23ff0a024c94ded1f1","modified":1464574506000},{"_id":"source/_posts/2016-03-01-编写可维护的js.md","hash":"42d61f3163f526735d62a78d9c2d2aa68700ec51","modified":1472953034000},{"_id":"source/_posts/2016-03-01-用jekyll搭建博客.md","hash":"ea112dd503085c2c67979f333b40ce578317279f","modified":1464702662000},{"_id":"source/_posts/2016-03-01-在做demo过程中遇到解决兼容性问题记录.md","hash":"5c5fe0f0d7304c1c97a194844f5fcf0100c8640d","modified":1470897332000},{"_id":"source/_posts/2016-03-03-浏览器渲染页面.md","hash":"a24e5405cbc7589c0c1f1c6827f3831326d4adc5","modified":1471683430000},{"_id":"source/_posts/2016-03-04-jQuery Ajax.md","hash":"73dafef4e52a0ba47c267237a28f58b87958c665","modified":1464318974000},{"_id":"source/_posts/2016-03-07-性能优化资源的非覆盖式发布.md","hash":"29586c417928bcb56b22f535a8981fca061ceadd","modified":1473391844000},{"_id":"source/_posts/2016-03-05-gulp.md","hash":"071c8bbae7544916baae12d3abf7b6fc992276e8","modified":1472032190000},{"_id":"source/_posts/2016-03-12-js中的垃圾回收.md","hash":"52b10dff3bb5645e1bf0cc4b9d8c3942f0cf7708","modified":1472366712000},{"_id":"source/_posts/2016-03-15-Baidu-IFE-task1-1-6.md","hash":"9fbf4dda751e4a0eac89fb77a8c1829b761cb8f0","modified":1465802034000},{"_id":"source/_posts/2016-03-15-模拟报纸排版.md","hash":"cc541003faef35d58b51049bc489fb746cedf8d4","modified":1467553940000},{"_id":"source/_posts/2016-03-15-常见的两栏式布局.md","hash":"0d74bc7ca41ebfd17310e1f951c44817f71df329","modified":1467553934000},{"_id":"source/_posts/2016-03-16-break、continue、return.md","hash":"fbada65130c3bb97c3551711cf7ed8cd960633cc","modified":1471506180000},{"_id":"source/_posts/2016-03-22-javaScript继承问题.md","hash":"98c147a3081592f5068d0465d32bd4137912da95","modified":1476533758000},{"_id":"source/_posts/2016-03-22-原型指针__proto__和原型对象.md","hash":"64fad3b25728a9a3994e8b76eb0e99081011c896","modified":1476531888000},{"_id":"source/_posts/2016-03-25-js里获取dom节点的方法.md","hash":"ccc5972785cdfb16f93dd1077d511e98059d3c7a","modified":1471502054000},{"_id":"source/_posts/2016-03-25-CSS3 flexbox弹性布局.md","hash":"2a465c119fbf02a3192e7c8dea3e5784782a782e","modified":1470885552000},{"_id":"source/_posts/2016-03-27-异步加载脚本的几种方式.md","hash":"5e54d4d007143b24ea7456bc8586f94d2c8d8b84","modified":1473681738000},{"_id":"source/_posts/2016-03-29-浏览器本地存储.md","hash":"8209d0a207e340a8c6a5ad1a284ca0d1ffc8b9da","modified":1476273352000},{"_id":"source/_posts/2016-03-31-CSS选择器总结.md","hash":"7bfe99f1be0689f82fae02ad0990d7421d100f65","modified":1474342110000},{"_id":"source/_posts/2016-03-31-js实现快速排序和冒泡排序.md","hash":"6668996e37ec86ddbc0f83217c55f731834db4e5","modified":1476540544000},{"_id":"source/_posts/2016-03-31-js数组去重.md","hash":"b72a78597d5b5cca7b84f7b1499635431780d423","modified":1471961654000},{"_id":"source/_posts/2016-03-27-git使用.md","hash":"bc59b26ead3c4d001f3ad96d4e81e5bf5195eaf7","modified":1489041357000},{"_id":"source/_posts/2016-03-31-击鼓传花-用循环队列实现.md","hash":"6c5a9a862043bc69a9d02d8eb77ceb983a986049","modified":1461036412000},{"_id":"source/_posts/2016-04-04-Baidu-IFE-task1-7-12.md","hash":"2270d07035138319ef725b0e9f05a424f53625fd","modified":1465802284000},{"_id":"source/_posts/2016-04-04-模拟文件报表排版.md","hash":"f9b8de5ea92ee64c119356346096573aff73fb1f","modified":1465803570000},{"_id":"source/_posts/2016-03-31-洗牌算法.md","hash":"9530447d7c8c512a64703aae102cc1cb2e2a2c62","modified":1471786370000},{"_id":"source/_posts/2016-04-05-Baidu-IFE-task2-13-18.md","hash":"99fd3ad4161cb8581aec9d69a4cb219a99c8ad2f","modified":1464601386000},{"_id":"source/_posts/2016-04-05-清除浮动的几种方法.md","hash":"bb8a29eb746f6cfb7ab8582f357b571ec2eae293","modified":1474343094000},{"_id":"source/_posts/2016-04-04-用CSS实现tab页的切换.md","hash":"6e1e1f1c8cd5fa95f75ce8252120c9b45cdecdc1","modified":1467553886000},{"_id":"source/_posts/2016-04-05-浏览器事件模型.md","hash":"2bfb9ca6fa40df5d3c52b87428dddc0b66f2bfc4","modified":1471589934000},{"_id":"source/_posts/2016-04-06-实现轮播特效.md","hash":"44fd12702646a6104a70b31e027707f85f1eda34","modified":1467554004000},{"_id":"source/_posts/2016-04-19-万年历.md","hash":"dcd5e4cd2beab2f6a2be28943c8817d4fc1b81cc","modified":1470900392000},{"_id":"source/_posts/2016-04-22-寻路算法.md","hash":"c3e83e31ade6dbbb04560ac245e31beebfc40d81","modified":1464318632000},{"_id":"source/_posts/2016-04-23-js中对数组的一些操作.md","hash":"f01cb43c9d530a1bbbcccd66f086f681c7a287d3","modified":1472372796000},{"_id":"source/_posts/2016-04-23-js中的string类型.md","hash":"4898732344cff799f983eb7515b6099b36498833","modified":1471497638000},{"_id":"source/_posts/2016-04-26-HTML5游戏开发.md","hash":"fc8bf606491af2d2f6b9356e677f800633c5364a","modified":1461849748000},{"_id":"source/_posts/2016-04-25-HTML5中的canvas.md","hash":"0bff96007c0dc7bee7d6c19afe8a94177976e244","modified":1471934508000},{"_id":"source/_posts/2016-04-28- delete.md","hash":"c3243938855127e0b64672c3abd8551a025f1415","modified":1472439458000},{"_id":"source/_posts/2016-04-28-获取鼠标当前位置.md","hash":"f27925cd5179337ffcd639bf40f1cba181b32e0c","modified":1461849760000},{"_id":"source/_posts/2016-05-03-http1.0和http1.1的区别.md","hash":"ffa3b4823ad7057a1575af811e99d112c69506d2","modified":1471787752000},{"_id":"source/_posts/2016-04-28-使用H5和canvas开发的一个小游戏——王牌特工.md","hash":"a99f34feaabf3d1510ee9454bf9b626a36706b24","modified":1465802444000},{"_id":"source/_posts/2016-04-16-链式调用的原理.md","hash":"8d112bc38d83b4d108ec9140310a5657e7f8bba3","modified":1471590950000},{"_id":"source/_posts/2016-05-05-HTML5中的新特性.md","hash":"8a3365385524d3d7c98e9f7a67873ad0fce523ac","modified":1473649004000},{"_id":"source/_posts/2016-05-05-js中的函数以及闭包.md","hash":"aaacb22c7dc02e08542d9eff7e7c6453dcfd08ae","modified":1465648010000},{"_id":"source/_posts/2016-05-06-Ajax跨域问题.md","hash":"38f9c8524b5b15a4552469c7e54c059058d741ec","modified":1476541328000},{"_id":"source/_posts/2016-05-05-window对象和事件对象.md","hash":"cb79ba39856510c54d2e61c3a3c1fa1f0324d295","modified":1473494496000},{"_id":"source/_posts/2016-05-06-BFC.md","hash":"717a64236307b529c173de912e834aee54c2edc9","modified":1467553818000},{"_id":"source/_posts/2016-05-06-垂直居中和水平居中.md","hash":"0b9b7c21db42061f7c79659816dc91e15755db7a","modified":1473217538000},{"_id":"source/_posts/2016-05-06-CSS中的display和position.md","hash":"240bcb434ee01df58660ce3d1d21fbbe71fdc951","modified":1470884476000},{"_id":"source/_posts/2016-05-06-js中创建对象的方式.md","hash":"6a4a740f3d9b0007297360b6557b83fb888c32ab","modified":1474166216000},{"_id":"source/_posts/2016-05-06-自适应两栏布局.md","hash":"18d69522c24c02cc112503248dc44a34c152a7ab","modified":1467553806000},{"_id":"source/_posts/2016-05-08-js中的关键字in.md","hash":"530ca9f08672bfbc9b07bcf6cfd6a0e9a19af606","modified":1471861284000},{"_id":"source/_posts/2016-05-08-前端性能优化的经验.md","hash":"2c8ada0bda2d294aa929ac21174c22aadcd13f2d","modified":1473736764000},{"_id":"source/_posts/2016-05-08-变量声明提升.md","hash":"d1bf17ad60e052adfdda515d34d88d1a0b1d4248","modified":1471941286000},{"_id":"source/_posts/2016-05-09-js中的ajax.md","hash":"05f5be9ca50d30f0788737b059f043d8deb4db8d","modified":1471418420000},{"_id":"source/_posts/2016-05-08-js中的this对象.md","hash":"91282b9d02f39ec89f13a4f7febba5aaf4db9a43","modified":1471591442000},{"_id":"source/_posts/2016-05-09-js中的函数参数的传递.md","hash":"7e28d3d7b518fa6adf650c4ca8f84a6f94a67e1d","modified":1471575736000},{"_id":"source/_posts/2016-05-10-数组分块.md","hash":"33f7da9b59ce3d9bf6b3a05bc2e3caf96e13aeb6","modified":1473734172000},{"_id":"source/_posts/2016-05-13-听指令的小方块.md","hash":"3489f36ebef1842a8ebc7613e4934234375b975d","modified":1471933684000},{"_id":"source/_posts/2016-05-13-js中的同步和异步执行.md","hash":"bee01560216fc43a68cc4e75996063b1d9c8e632","modified":1470898120000},{"_id":"source/_posts/2016-05-09-js的消息机制.md","hash":"b6aadc59dcf21b0189433269a61428c5a49b515e","modified":1471579592000},{"_id":"source/_posts/2016-05-16-JSON.md","hash":"0ee5a5bb1d73863d7c96927810d630a295bc1134","modified":1474163684000},{"_id":"source/_posts/2016-05-16-函数节流.md","hash":"0c808617ae3acf5effffa1b73c97e41c3e4a3dbe","modified":1473753276000},{"_id":"source/_posts/2016-05-15-js中的call和apply和bind.md","hash":"a35407ff9215ad4ee314f59f32da9c39da0c729e","modified":1471962664000},{"_id":"source/_posts/2016-05-16-将url参数解析成字典对象.md","hash":"1e6dbd26eb43d23302224df8cb741f11ca93090a","modified":1473236638000},{"_id":"source/_posts/2016-05-16-纯函数.md","hash":"54bb2bbca95b6d7425575d7e4216007b1bfcbb5c","modified":1463405312000},{"_id":"source/_posts/2016-05-16-js 基本数据类型.md","hash":"e27b349531bac10cf21908490d94e13fbd0329e0","modified":1472309012000},{"_id":"source/_posts/2016-05-17-GET和POST的区别.md","hash":"a8afbbdb03aac8b631d7b4eede5f7a8e0f8964ff","modified":1471679720000},{"_id":"source/_posts/2016-05-17-js中的设计模式.md","hash":"4312282ad627bb4762e103ef7aba2874b461c0b0","modified":1467641484000},{"_id":"source/_posts/2016-05-17-css中的像素.md","hash":"70ee35125475143f9e8753c38b0166dc2a0c2287","modified":1473234788000},{"_id":"source/_posts/2016-05-17-css3中的新属性.md","hash":"928332d5ad802c2dac663ee84fba63c05ff50579","modified":1473233938000},{"_id":"source/_posts/2016-05-18-一个旋转的圆.md","hash":"c862d65b25bc6207403f31c730dbd34b431e98c6","modified":1467553736000},{"_id":"source/_posts/2016-05-18-订阅发布模式.md","hash":"963a10f01692b85ae45c9a22fe534e403e2a8c5c","modified":1471962210000},{"_id":"source/_posts/2016-05-19-数据库安全与防护.md","hash":"a216fc20430e4dd2af458819baca3556b7b02f23","modified":1464600188000},{"_id":"source/_posts/2016-05-19-数据库技术.md","hash":"377582984ee852b07be6ba79f6aa5cfef4d1e3de","modified":1464600118000},{"_id":"source/_posts/2016-05-19-数据库SQL语言.md","hash":"4bbd0e1b677c74906bc918171cc970fa96b2aa9f","modified":1464702216000},{"_id":"source/_posts/2016-05-23-node.js的模块机制.md","hash":"09519409dbdfc01d37c293d80475cc9ddac87443","modified":1464600020000},{"_id":"source/_posts/2016-05-23-什么是node.js.md","hash":"e5f7e54ad27e89e46a8e0a69a00229058b54daf5","modified":1464004834000},{"_id":"source/_posts/2016-05-19-数据库设计.md","hash":"56bbc4caccb59aef2c2ee9cea688ad8973de0c7b","modified":1463995950000},{"_id":"source/_posts/2016-05-17-计算机网络7层协议.md","hash":"82bc6fe03ae689a50e3731a1396f6d8a78ea498c","modified":1471679738000},{"_id":"source/_posts/2016-05-25-浏览器输入url之后.md","hash":"3ba74f50f54e3cda64cb1636cadfe66cf7d3e798","modified":1471684956000},{"_id":"source/_posts/2016-05-24-js中的DOM操作.md","hash":"fcca87b93539f2201d246543fba052e8038b62a5","modified":1473664646000},{"_id":"source/_posts/2016-05-27-http协议.md","hash":"422e88836ebc4ed4a9d46595bf4b9b4c669b192a","modified":1476541790000},{"_id":"source/_posts/2016-06-01-web sovkets协议.md","hash":"9aa7a29ced48dfcf507a8d851f1fbc448493fae4","modified":1464771936000},{"_id":"source/_posts/2016-06-02-配置PHP环境.md","hash":"f4f7342c28409f764847c6383ef356120acf1c43","modified":1464873220000},{"_id":"source/_posts/2016-06-03-js模块化编程.md","hash":"d6e51ec3944739446cdcc0d32f21e4b4cff7abb1","modified":1465008356000},{"_id":"source/_posts/2016-06-07-HTML5中的元素的拖放.md","hash":"05121ec5e675533785258bab44388147f9c95fc9","modified":1465265948000},{"_id":"source/_posts/2016-06-07-js中获取元素的样式.md","hash":"5f9bf33e32003435b6de5539de93c3adb9790dd8","modified":1465634798000},{"_id":"source/_posts/2016-06-08-事件类型.md","hash":"2afb6b80df540e2638a69cb2b84431f7a5d5f694","modified":1465353414000},{"_id":"source/_posts/2016-06-12-二维数组根据某一列进行排序.md","hash":"28745fde9ac30997e3151b40b50773a8853a62f3","modified":1471786090000},{"_id":"source/_posts/2016-06-12-微型调查问卷平台组件——冻结行列表格.md","hash":"8ab960a8d4a5061d85fc6d2227514cc203d182a0","modified":1465910284000},{"_id":"source/_posts/2016-06-12-微型调查问卷平台组件——排序表格.md","hash":"6061583c682d19bcbe74207f8b6fbb17770d1b45","modified":1465799964000},{"_id":"source/_posts/2016-06-14-元素视图属性.md","hash":"2daae5cb3b3ab1b1b07b937d02f189de50010886","modified":1476517168000},{"_id":"source/_posts/2016-06-14-文档类型声明.md","hash":"2e2eb936ecd633db70648576eb38b0f6f83ca907","modified":1466231460000},{"_id":"source/_posts/2016-06-15-表单脚本.md","hash":"557230b94732d2b4a1a41080da4f63afbe52d4cf","modified":1476520954000},{"_id":"source/_posts/2016-06-16-如何避免表单的重复提交.md","hash":"0e4664eb76a3803d6f61794368c4ba8fc61da022","modified":1474728030000},{"_id":"source/_posts/2016-06-17-浏览器的标签页是用多线程还是多进程实现.md","hash":"666cb62427700e9f43d91edc4e3153ebcbead321","modified":1466151168000},{"_id":"source/_posts/2016-06-16-session和cookie的区别.md","hash":"8da7b30217fa6b5db0270a923173b57453376ed4","modified":1471682498000},{"_id":"source/_posts/2016-06-17-浏览器跨标签页通信.md","hash":"4c145e1f0d65436c11a7c3ef9ffb2b2cddcc92ef","modified":1474370656000},{"_id":"source/_posts/2016-06-18-编写高质量代码——HTML、CSS.md","hash":"27519bd2b5a661f572878bf92d25f252822582b1","modified":1467553696000},{"_id":"source/_posts/2016-06-20-微型调查问卷平台组件——日历组件.md","hash":"0899b2d25e90966cb9552214f1c6112a0fd35407","modified":1468487722000},{"_id":"source/_posts/2016-06-21-编写高质量代码——javaScript.md","hash":"5da71d04d5f5016c7f5d2920fade0fedf6f21f72","modified":1467164506000},{"_id":"source/_posts/2016-06-17-研究登陆信息和登陆状态.md","hash":"44f30e0019ee8ac11de494dbe97f5b0dc0664d71","modified":1466147154000},{"_id":"source/_posts/2016-06-24-DOM扩展.md","hash":"0aa2ec1ca99086fc61b77acf2691762bf4e76803","modified":1467079576000},{"_id":"source/_posts/2016-06-27-编写高质量代码实践——用js实现tab页切换.md","hash":"8e84a8bcbd5271362bd1ba46a8af4592895e97fd","modified":1467728186000},{"_id":"source/_posts/2016-06-29-CSS预处理器.md","hash":"4804b415eec290faf4e77c7f7b8a2c0927941891","modified":1467430162000},{"_id":"source/_posts/2016-06-28-面向过程or面向对象编程.md","hash":"f8764bff32d473bc6d43c8ab34fd1f8fd9d162f5","modified":1467105660000},{"_id":"source/_posts/2016-06-30-折腾sublime插件.md","hash":"012884052fba17e34f9484842eee69a601d36587","modified":1473064056000},{"_id":"source/_posts/2016-07-01-实现侧边栏——学习使用sass和requireJS.md","hash":"57bc8ee3fef2d208d5c6025727bbede9d5b37ca5","modified":1467553430000},{"_id":"source/_posts/2016-07-06-js中的错误处理与调试.md","hash":"ff7ef4ab0313b3749dca6f2faced9127adadc381","modified":1472366776000},{"_id":"source/_posts/2016-07-06-js中运算符的优先级.md","hash":"d14a15343d11377bd8e66ce9b0e54ecd12c18717","modified":1467773146000},{"_id":"source/_posts/2016-07-13-微型调查问卷平台.md","hash":"61bedfa79f7d5fbe0f628b48921b3879ff0d7336","modified":1471923270000},{"_id":"source/_posts/2016-07-01-js模块化编程之requireJS.md","hash":"e73984435c627c84a85cd587bf10af27728b7022","modified":1472307954000},{"_id":"source/_posts/2016-07-15-动态改变div的高度.md","hash":"97d9073d52e80a2b9631e86713d1506f211c7d58","modified":1468677784000},{"_id":"source/_posts/2016-07-06-微型调查问卷平台组件——弹出层.md","hash":"a0fafff785b057ec2752b3eae4fde0cb004929c9","modified":1473736600000},{"_id":"source/_posts/2016-08-04-学习koa.js.md","hash":"e77a892caae1c35cf43a703e85dfe4ff48467511","modified":1476624464000},{"_id":"source/_posts/2016-08-04-charles的使用.md","hash":"bfe11ab1bd153d78017d08889133031167a79dd3","modified":1470878490000},{"_id":"source/_posts/2016-07-31-ECMAScript 6入门.md","hash":"95eb70f17ba9283514233c088b84b1e09e2e2563","modified":1476626174000},{"_id":"source/_posts/2016-08-01-用原生js实现由className获取dom节点.md","hash":"60e7a551af045764deaae32339864fbeda68ee75","modified":1471509338000},{"_id":"source/_posts/2016-08-16- webpack.md","hash":"65d3a8d310b1f424cd97ad34b1ae8088b3d31b50","modified":1473253114000},{"_id":"source/_posts/2016-08-11-css3动画的回调处理.md","hash":"7df0211c3ce80dde58efbbe72ae02198b18ed587","modified":1471683096000},{"_id":"source/_posts/2016-08-05-对mvc的理解.md","hash":"3711c98bcfb679794a1982cd0395e993a5faafc0","modified":1471836074000},{"_id":"source/_posts/2016-08-16-学习react.md","hash":"299d37ccb7e5d2ecc94932f640af1bd8060e5e1d","modified":1476446788000},{"_id":"source/_posts/2016-09-03-Two Sum.md","hash":"93e682a65a820a91579c4e05810b49ccd57990c1","modified":1472904304000},{"_id":"source/_posts/2016-09-03-响应式布局.md","hash":"57ded3eef1e46143ee9fb486ce915b8174b3a145","modified":1473217416000},{"_id":"source/_posts/2016-09-03-斐波那契数列.md","hash":"27ad9532992ac62687ac6c79c469ac6b487197fa","modified":1472874738000},{"_id":"source/_posts/2016-08-28-数据结构与算法——javaScript.md","hash":"28273ab6b3c79c8e927114942a57d72e0917509a","modified":1472524530000},{"_id":"source/_posts/2016-09-09-js中的正则表达式.md","hash":"ffe7e50c2914784e1bb9ff1a381d2e9931ce2b38","modified":1473413096000},{"_id":"source/_posts/2016-09-12-react中的虚拟dom.md","hash":"5812c338b3f42e1607ef84c8f0bf3454abbf55fc","modified":1476447198000},{"_id":"source/_posts/2016-09-18-二分查找.md","hash":"c76b08513f9224f480147c0cc993e5fbcce8e1cc","modified":1474206094000},{"_id":"source/_posts/2016-09-12-web worker.md","hash":"f473047b731bd930943887d5d6a9b26854a0d162","modified":1473661120000},{"_id":"source/_posts/2016-09-20-字典.md","hash":"6588ad12ae5747980c57ebc3a1723beb26945353","modified":1476582554000},{"_id":"source/_posts/2016-09-21-javaScript中的异步编程方法.md","hash":"84b8ad2710c5141b03d526d524bbaa5de255a31a","modified":1476450606000},{"_id":"source/_posts/2016-09-20-时间戳.md","hash":"d0c80d5fb94cfbc627d40ace9135354b08e32c9d","modified":1474373714000},{"_id":"source/_posts/2016-09-20-二叉树的遍历——找出和为n的路径.md","hash":"b6fd6bb4d3ee7a582da04f4326e088b0217d92fa","modified":1476581864000},{"_id":"source/_posts/2016-09-21-js中的两种作用域.md","hash":"26517ffb840f5b345e4bb8173f2968c109612ee9","modified":1474450080000},{"_id":"source/_posts/2016-09-22-实现lazyload.md","hash":"35515b747faf967dc5ce0a04dfedc49d9b17b7bd","modified":1476517484000},{"_id":"source/_posts/2017-03-09-一台电脑对应多个git账户.md","hash":"d3fe512673e8c76f628b86e7f8a7e437cb4ab2c9","modified":1489109973000},{"_id":"source/_posts/2016-09-23-使用koa搭建服务器模拟跨域.md","hash":"8f2a9e188163db868cd271507289e16279deb153","modified":1474639824000},{"_id":"source/_posts/2017-03-08-折腾博客系列之二.md","hash":"d90e976f3d751371b39249f6f950f76715c221e1","modified":1489046860000},{"_id":"source/tags/index.md","hash":"8353dda84dbc2014f7e0fcc2c6b78e32ff87a243","modified":1464575510000},{"_id":"source/demo/index.md","hash":"fc4828ee005e25c62dd65d867430bb996189b480","modified":1464575516000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1463412204000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1463412204000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1463412204000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1463412204000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1463412204000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1463412204000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1463412204000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1463412204000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1463412204000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1463412204000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"132427a393d7d47ed9e86a1f4519e0b9f42e07f1","modified":1464569984000},{"_id":"themes/next/layout/_layout.swig","hash":"53a9b0aded9457971c81f52495c41b6ec3bd453c","modified":1464591082000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1463412204000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1463412204000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1463412204000},{"_id":"themes/next/layout/demo.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1463412204000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1463412204000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1463412204000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1463412204000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1463412204000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1463412204000},{"_id":"themes/next/layout/page.swig","hash":"b8da04c7848314aabab19e068b823857781ee343","modified":1464595806000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1463412204000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1463412204000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1463412204000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1463412204000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1463412204000},{"_id":"themes/next/layout/_macro/post.swig","hash":"6578feba588183dda779b3df41d86d7414da1213","modified":1464592560000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"591faa8a6679590bad72484a92d2954d28d081c4","modified":1463412204000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1463412204000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1463412204000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1463412204000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"9f9aa80bc6fbf594c36a97e1ce14b3792e26d1c2","modified":1464592948000},{"_id":"themes/next/layout/_partials/head.swig","hash":"5d6b64233d93fad8bc8a1ce225e52364ee87259d","modified":1464588082000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1463412204000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1463412204000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1463412204000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1463412204000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ce466dc49ecdc426304cce570d0401ee0c627909","modified":1464596868000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1463412204000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1463412204000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1463412204000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1463412204000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1463412204000},{"_id":"themes/next/source/css/main.styl","hash":"95f28d8c176e4c6a767aaff27f8992683e2d5893","modified":1464589928000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1463412204000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1463412204000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1463412204000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1463412204000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1463412204000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1463412204000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1463412204000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1463412204000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1463412204000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1463412204000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1463412204000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1463412204000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1463412204000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1463412204000},{"_id":"themes/next/source/uploads/icon.jpg","hash":"0060e66a71a8ecafffb1dfe797b225cc33694920","modified":1458181696000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463412204000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1463412204000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1463412204000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1463412204000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"d5e303faf55ee76eb33cb60482e473785eb0f578","modified":1463412204000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1463412204000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1463412204000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1463412204000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1463412204000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1463412204000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1463412204000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1463412204000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"0d0a45940e330616ac34973cc9eda4e20d9f5418","modified":1463412204000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1463412204000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1463412204000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1463412204000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1463412204000},{"_id":"themes/next/source/css/_my/mycss.styl","hash":"29f656cfaaa230a01c4f427db129e7fdf40081be","modified":1464595302000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1463412204000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1463412204000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1463412204000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1463412204000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1463412204000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1463412204000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1463412204000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1463412204000},{"_id":"themes/next/source/vendors/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1463412204000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1463412204000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1463412204000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1463412204000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1463412204000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1463412204000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1463412204000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"2d00bb755c96cc813581e170bf85d90c4e6c1505","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1463412204000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1463412204000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1463412204000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1463412204000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1463412204000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1463412204000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"709962fef398f8dc905a8545b5ebc3a8f932d699","modified":1463412204000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"1f562a480e510fe9792990cb8f589ebea5f15af7","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1463412204000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1463412204000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1463412204000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1463412204000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1463412204000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1463412204000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"2cf4f437ed288a62451fc47d45e5f94a9b0b3bf9","modified":1464591548000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1463412204000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1463412204000},{"_id":"themes/next/source/uploads/post/20160428/task3-46.jpg","hash":"325413ae8995720de4828d6f3e5843dfc5b86cb5","modified":1461847004000},{"_id":"themes/next/source/uploads/post/20160329/broswer-caching.jpg","hash":"ff6628eea9ef8aa1d4e11179a8e7dfe6dc033e4b","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/baidu-ife-task1.jpg","hash":"f769bb3c74e6fe7ae354547b1c13b09bcaec3b61","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/baidu-ife-task2.jpg","hash":"2dfc96572ca6c348b3a55e36b1c85bb1fa682dcd","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/prototype.jpg","hash":"5641a7364769b07441cb087ba735bd27655bd407","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/scope.jpg","hash":"a317e2c2b219cf0a6e327cf252d7ae3b41e4390f","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/float-center.jpg","hash":"2c2f5770d3823d7354b49630ff09bfd7b95aa6fe","modified":1461036412000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1463412204000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1463412204000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"03bf1ac337dfe6f50fb25fd3e254a2bbfab26cc6","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"932e1ffa91a665b0a530a422b6bf0d7ed3187c3f","modified":1463412204000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1463412204000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1463412204000},{"_id":"themes/next/source/uploads/post/20160509/async.jpg","hash":"16d264d9698a7d3cca0af89c9e0821ff5f1ae5a2","modified":1462799752000},{"_id":"themes/next/source/uploads/post/demo/flex-wrap-reverse.jpg","hash":"f94f3427da9e6a07941db66d655b878d43bd7a4a","modified":1461036412000},{"_id":"themes/next/source/uploads/post/20160329/http-caching.jpg","hash":"0dcbf30a98c2c46919ab3e23e8da2d8527b15105","modified":1461036412000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"1214ac2c18e406c18d192baf3ec3fcc646bd2b72","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"e18575b6e9b60f713b571c0033facda82d6ebb22","modified":1463412204000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"ee59197f63a2c4c7b7f2ae135a745202235de8d4","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"3f57f29481d8144a7fad117a891a5d7551a7ec45","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"8bb13f11fbe4c19df01a70d2480f2924f9169e81","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1463412204000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5433b6bc9d8f0c4685e760b326445ac51245b0a8","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1463412204000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1463412204000},{"_id":"themes/next/source/uploads/post/demo/collapse/1.jpg","hash":"18ede5fba9b55134df1c649acfdd8c3b54fb1f61","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/collapse/4.jpg","hash":"68671f6b67dc34d38655ef86a59435830434eb67","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/collapse/3.jpg","hash":"34db451c238f5f92060600263f5fa97a201ce1f6","modified":1461036412000},{"_id":"themes/next/source/uploads/post/demo/collapse/5.jpg","hash":"287c4111800b7365664f475e53e00c65741188b6","modified":1461036412000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1463412204000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1463412204000},{"_id":"themes/next/source/uploads/post/20160524/node.jpg","hash":"5636ea7cfb577c6f1d0be41c4dccd4c83e21460d","modified":1464078890000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"596bf3a74878a13e2bf0e572e9467dfc17146b00","modified":1463412204000},{"_id":"themes/next/source/uploads/post/demo/collapse/2.jpg","hash":"26333286fb4c26f70439d5d2f533aa543f1bd3ab","modified":1461036412000},{"_id":"themes/next/source/vendors/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1463412204000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"a6955d04d00182a80e62fd0b4cef73b686afb858","modified":1463412204000},{"_id":"public/categories/index.html","hash":"801ac3b404d6c385473279b22f4af069ab0095d0","modified":1489110068464},{"_id":"public/tags/index.html","hash":"8bb426bf71a5da60ba2996620ab3a9a6df37b9ba","modified":1489110068464},{"_id":"public/demo/index.html","hash":"747f26368a86d58abcb58250253a2edd57e6f595","modified":1489110068464},{"_id":"public/2016/04/26/2016-04-26-HTML5游戏开发/index.html","hash":"a0e3b7060624d2084d8e061d87e769d22277aed9","modified":1489110068464},{"_id":"public/2016/03/01/2016-03-01-《锋利的jQuery》/index.html","hash":"58ed2907e73dbecbe5f9a94695393a68078a253e","modified":1489110068464},{"_id":"public/2016/03/01/2016-03-01-maoyanpc项目记录/index.html","hash":"d105d5225f894fb69056055cedee335d01cb0925","modified":1489110068464},{"_id":"public/archives/page/15/index.html","hash":"27df86e3cc5573dc86090acc5e9cc704505ebd5d","modified":1489110068464},{"_id":"public/archives/2016/03/page/3/index.html","hash":"52d87c68fcf34f81996de5511e144d5d1bbc498c","modified":1489110068464},{"_id":"public/archives/2016/05/page/5/index.html","hash":"6726a09eee22ac0cf48bcac2b28de4439736eb5d","modified":1489110068464},{"_id":"public/archives/2016/06/page/3/index.html","hash":"183843175b43dfba5d9472cf38e878b4aad4c3d7","modified":1489110068465},{"_id":"public/archives/2016/09/page/2/index.html","hash":"fd907c7e502e66531a3d93a90d6a613404908e54","modified":1489110068465},{"_id":"public/archives/2017/index.html","hash":"6a9698a83d859cdc20b51f924f29395443c147ae","modified":1489110068465},{"_id":"public/archives/2017/03/index.html","hash":"d747db737ab7358e5d67661fa8d4b0f812131a51","modified":1489110068465},{"_id":"public/categories/前端笔记/page/3/index.html","hash":"e7cf0f47e0ad75946b8ce9734d2f45f78216f730","modified":1489110068465},{"_id":"public/categories/搭建博客/index.html","hash":"3b6e59281f9e95900ac0bb6cc5a4310a2c7a9ac2","modified":1489110068465},{"_id":"public/categories/浏览器/index.html","hash":"c551274868b2f7925a60966cbee63dcf0f740697","modified":1489110068465},{"_id":"public/categories/性能优化/index.html","hash":"c728d18dccf5be53c7b98f795f074e23472902ca","modified":1489110068465},{"_id":"public/categories/工具/index.html","hash":"4afe75b152bc7f857ab3f3a67963de36585e3418","modified":1489110068465},{"_id":"public/categories/Demo/page/2/index.html","hash":"07259e252f81d7822b19e20367395945bd13e6a4","modified":1489110068465},{"_id":"public/categories/算法学习/page/2/index.html","hash":"3e94348496d29487b1a511ad15ebc7e7243bdd61","modified":1489110068465},{"_id":"public/categories/CSS/index.html","hash":"46162f96c4b9873276a837817253331c3f6af2e1","modified":1489110068465},{"_id":"public/categories/HTML/index.html","hash":"49d9476cd07a25d3331bd80ad930ca3367bf9184","modified":1489110068465},{"_id":"public/categories/http协议/index.html","hash":"e1307bb0d77293bfd3c0955bce5fdb0691639cec","modified":1489110068465},{"_id":"public/categories/数据库/index.html","hash":"9406f286bf3c413f2bffb855166861c57c458970","modified":1489110068465},{"_id":"public/categories/nodejs/index.html","hash":"8962e7dd9e13b34e32c8956382b572726bad6ad6","modified":1489110068465},{"_id":"public/categories/php/index.html","hash":"da2f1cedcfad1f538856f7a645505701efb0ee89","modified":1489110068465},{"_id":"public/categories/css/index.html","hash":"a88974231422c34635a4bd70d418e7bc404b0968","modified":1489110068465},{"_id":"public/categories/前端框架/index.html","hash":"efddae1774600245674fe25288132e78ed4c9a6d","modified":1489110068465},{"_id":"public/tags/jQuery/index.html","hash":"6f5a693f29c234e3922a7b340ce75df76aab8928","modified":1489110068465},{"_id":"public/tags/Ajax/index.html","hash":"02ea6e0e265575dfdfaa3cf0cede07cdb887488a","modified":1489110068465},{"_id":"public/tags/javaScript/page/7/index.html","hash":"1e8d7c973a86df8dcd83b37436ae5b46e67d868a","modified":1489110068465},{"_id":"public/tags/代码规范/index.html","hash":"c3f84a05bb8c8014c85b45ef07be2b2b99a2ac58","modified":1489110068465},{"_id":"public/tags/博客/index.html","hash":"a12b5a925ad8c2c4a8ac974b2db0812a41a7c34f","modified":1489110068466},{"_id":"public/tags/github/index.html","hash":"4075305b6e645411db318722066c8718d2d16a1b","modified":1489110068466},{"_id":"public/tags/浏览器/index.html","hash":"77c0af30f84669d3c2e029d6b98e898925846a9b","modified":1489110068466},{"_id":"public/tags/性能优化/index.html","hash":"e27d29d78c1025db584d8efdfe99240e71f3b934","modified":1489110068466},{"_id":"public/tags/工具/index.html","hash":"21788cd4af76313a1b7381ad1f6ba3f2ab12ba64","modified":1489110068466},{"_id":"public/tags/优化/index.html","hash":"807bc4714936001c9bf19ad1439bea8603887e12","modified":1489110068466},{"_id":"public/tags/BaiduIFE/index.html","hash":"f8cbf2f1e933f34776a618af4fd3a2898b0e851d","modified":1489110068466},{"_id":"public/tags/DOM/index.html","hash":"557372b079e8eaabd4704584466f7559987828e5","modified":1489110068466},{"_id":"public/tags/缓存/index.html","hash":"c38e82eb616dbe8c72a4b050552c577e03cb7fdf","modified":1489110068466},{"_id":"public/tags/算法/page/2/index.html","hash":"d22501f4996514cd35360b23a0bcd3c80a648b67","modified":1489110068466},{"_id":"public/tags/事件/index.html","hash":"f32eb948bd1a2fd8725750ba6d1fc3cc7fd7705e","modified":1489110068466},{"_id":"public/tags/javascript/index.html","hash":"68e0629d04782077d7a6ead677f54fc4a1cc142f","modified":1489110068466},{"_id":"public/tags/数组/index.html","hash":"6ee913ac7c46e9096adb2459916618e5082bd09b","modified":1489110068466},{"_id":"public/tags/字符串/index.html","hash":"527b65f0658878d2ce1e74eb64ce7b2790c74b04","modified":1489110068466},{"_id":"public/tags/HTML5/index.html","hash":"ee070591d8700b0862f51a9c2816d798198a95b1","modified":1489110068466},{"_id":"public/tags/http/index.html","hash":"b19f613bfa06df47453a4863cc4dfe7639967040","modified":1489110068466},{"_id":"public/tags/链式调用/index.html","hash":"b8a85c940c2d731d3c997be7e6256353a1a7bda8","modified":1489110068466},{"_id":"public/tags/函数/index.html","hash":"61597174e888e3258c880a0b3e4ac2681782ebd9","modified":1489110068466},{"_id":"public/tags/定时器/index.html","hash":"8f1cc7613486d0270b9c09eb918c2c90222fe4c7","modified":1489110068466},{"_id":"public/tags/JSON/index.html","hash":"90468a7c8a5ee0d42a8cfa0a964199b756d05892","modified":1489110068466},{"_id":"public/tags/设计模式/index.html","hash":"7f764bcbf4a682ffbad3cd311135e8c55adf43ba","modified":1489110068466},{"_id":"public/tags/数据库/index.html","hash":"67d19b3ac9e1bb659066f25240ea6ccc0b39bceb","modified":1489110068466},{"_id":"public/tags/nodejs/index.html","hash":"84892c0ddc4d01aa1965c1e8a37685ee69bcb3f6","modified":1489110068466},{"_id":"public/tags/计算机网络/index.html","hash":"bd02bfd3685a5a31c31408b4670a27fe11fe9dbc","modified":1489110068466},{"_id":"public/tags/php/index.html","hash":"766928bff849f597ed958d4b585de655877d078a","modified":1489110068466},{"_id":"public/tags/HTML/index.html","hash":"d4574a2cc3bde31a43aa78d1114244beceab58cc","modified":1489110068467},{"_id":"public/tags/读书笔记/index.html","hash":"a6e27d36293fadaf580f215bb14767f524784098","modified":1489110068467},{"_id":"public/tags/Sass/index.html","hash":"ac4212d35fc4105cd0ac164909ec014efbf10468","modified":1489110068467},{"_id":"public/tags/模块化/index.html","hash":"2e3a83661a968643a11ef0183698263f99135126","modified":1489110068467},{"_id":"public/tags/HTTP/index.html","hash":"fb2ed437bdafa2b94febe3475d0cff21ad2e628d","modified":1489110068467},{"_id":"public/tags/ES6/index.html","hash":"e89cf1bbbdd897d5b5bc84ff7f078c1196878e37","modified":1489110068467},{"_id":"public/tags/框架/index.html","hash":"7ab059cf22432f63151f4095cb4b94471138703e","modified":1489110068467},{"_id":"public/tags/koa/index.html","hash":"41ae2f00a81ad735297bab099c33fa6918ae2e6c","modified":1489110068467},{"_id":"public/2017/03/09/2017-03-09-一台电脑对应多个git账户/index.html","hash":"dce7d8e0aa8c6e1dd179601d99abb80882423c96","modified":1489110068467},{"_id":"public/2017/03/08/2017-03-08-折腾博客系列之二/index.html","hash":"545317a5407930c4c7cd6f27535f7ed90997322a","modified":1489110068467},{"_id":"public/2016/09/23/2016-09-23-使用koa搭建服务器模拟跨域/index.html","hash":"6b985a9b4a547555b06d7f5b3d9040ddd1b5a7f9","modified":1489110068467},{"_id":"public/2016/09/22/2016-09-22-实现lazyload/index.html","hash":"05e43380a152cb4bcdf8faf390e139a5453f21a5","modified":1489110068467},{"_id":"public/2016/09/21/2016-09-21-js中的两种作用域/index.html","hash":"9125fc477e74898914ca8fe7bb0693406184684f","modified":1489110068467},{"_id":"public/2016/09/21/2016-09-21-javaScript中的异步编程方法/index.html","hash":"11b3d997eb0dded9954f617d74809dd58fc97f63","modified":1489110068467},{"_id":"public/2016/09/20/2016-09-20-字典/index.html","hash":"7db295af921d4bb020f8ce24209c6eed9e19b328","modified":1489110068467},{"_id":"public/2016/09/20/2016-09-20-二叉树的遍历——找出和为n的路径/index.html","hash":"4d6d60d0d78eed8fbf86d3a09abcb93a2545c1b7","modified":1489110068467},{"_id":"public/2016/09/18/2016-09-20-时间戳/index.html","hash":"f716df671826e2e5bacfba497ad9a9503cf0cbb4","modified":1489110068467},{"_id":"public/2016/09/18/2016-09-18-二分查找/index.html","hash":"aa63afbf2e0673388bbc950cd13479629d106685","modified":1489110068467},{"_id":"public/2016/09/12/2016-09-12-web worker/index.html","hash":"aa1d4db6ff34df2fde5e9dc48690b860c8517a76","modified":1489110068467},{"_id":"public/2016/09/12/2016-09-12-react中的虚拟dom/index.html","hash":"844d5f4d542f3f569ec78170c51909b234b35aa3","modified":1489110068467},{"_id":"public/2016/09/09/2016-09-09-js中的正则表达式/index.html","hash":"50cf22d25cf04d222e893f4bd226d0a9717de128","modified":1489110068467},{"_id":"public/2016/09/03/2016-09-03-斐波那契数列/index.html","hash":"3c6c87775e1d88f89a9faf416cdf832784e53549","modified":1489110068467},{"_id":"public/2016/09/03/2016-09-03-响应式布局/index.html","hash":"dc5da9076b188a19cfffec248524f40e1bd9424f","modified":1489110068467},{"_id":"public/2016/09/03/2016-09-03-Two Sum/index.html","hash":"0ce50b27c6b68a6a26ecb8d9258d8541345f1a21","modified":1489110068468},{"_id":"public/2016/08/28/2016-08-28-数据结构与算法——javaScript/index.html","hash":"3c5a3ba7fa5bef8be4c46435ab87129335a372be","modified":1489110068468},{"_id":"public/2016/08/20/2016-03-01-编写可维护的js/index.html","hash":"19cc2ed82375938570d1056cf72093783ed395db","modified":1489110068468},{"_id":"public/2016/08/16/2016-08-16-学习react/index.html","hash":"cca414ebf497782de986abf7cde6e80a34ebe1fc","modified":1489110068468},{"_id":"public/2016/08/16/2016-08-16- webpack/index.html","hash":"2a5f111d27008fb985eae55872e43f7d4cf2316a","modified":1489110068468},{"_id":"public/2016/08/16/2016-03-12-js中的垃圾回收/index.html","hash":"de11ed3b656bf9b0351c644b4de781587a87a19b","modified":1489110068468},{"_id":"public/2016/08/11/2016-08-11-css3动画的回调处理/index.html","hash":"8b924d9fe2af664ade89988e78dcae30459145d3","modified":1489110068468},{"_id":"public/2016/08/05/2016-08-05-对mvc的理解/index.html","hash":"fbfdad26189d109a8126130f2c34e849c71b64c0","modified":1489110068468},{"_id":"public/2016/08/04/2016-08-04-charles的使用/index.html","hash":"19917cc04a1e2e1c13086dde3c0a67466dadbd40","modified":1489110068468},{"_id":"public/2016/08/04/2016-08-04-学习koa.js/index.html","hash":"edc80a948822d0e5b67debfff16ac6f53bab9152","modified":1489110068468},{"_id":"public/2016/08/01/2016-08-01-用原生js实现由className获取dom节点/index.html","hash":"a139ad6dd0804d6885de4febca643efdc332f6a7","modified":1489110068468},{"_id":"public/2016/07/15/2016-07-15-动态改变div的高度/index.html","hash":"9db663e101e99d0715e9b85e6fa915dbb63deeee","modified":1489110068468},{"_id":"public/2016/07/31/2016-07-31-ECMAScript 6入门/index.html","hash":"5d2db3972553f2e7ce2a07e48d9314767d456846","modified":1489110068468},{"_id":"public/2016/07/13/2016-07-13-微型调查问卷平台/index.html","hash":"5d9d13a6908e146832d3a9e2da0664bc45d5222a","modified":1489110068468},{"_id":"public/2016/07/06/2016-07-06-微型调查问卷平台组件——弹出层/index.html","hash":"596b978153a8f474619ad15407f176ba9de1facc","modified":1489110068468},{"_id":"public/2016/07/06/2016-07-06-js中的错误处理与调试/index.html","hash":"41410c537fba93015356bed2c1781f1850e700b8","modified":1489110068468},{"_id":"public/2016/07/06/2016-07-06-js中运算符的优先级/index.html","hash":"21c3f07cf8c427ce1b51ba07361b6e4e3d267ccb","modified":1489110068468},{"_id":"public/2016/07/03/2016-07-01-实现侧边栏——学习使用sass和requireJS/index.html","hash":"c6480af53f9ccb3d5eb40c5f6ef1589db752b6e0","modified":1489110068468},{"_id":"public/2016/07/01/2016-07-01-js模块化编程之requireJS/index.html","hash":"be5843ac4d84d789accde58bcee4de907163494d","modified":1489110068468},{"_id":"public/2016/06/30/2016-06-30-折腾sublime插件/index.html","hash":"a921fc02db720e6c6a9402c54a8e96b3650c3b26","modified":1489110068468},{"_id":"public/2016/06/29/2016-06-29-CSS预处理器/index.html","hash":"24cdc1ca71422d43487989c20822c9585d277583","modified":1489110068469},{"_id":"public/2016/06/28/2016-06-28-面向过程or面向对象编程/index.html","hash":"30619637d47ea7e71d2aab70983e2d3a321e613b","modified":1489110068469},{"_id":"public/2016/06/27/2016-06-27-编写高质量代码实践——用js实现tab页切换/index.html","hash":"303ec0dc6823ac1a143e2c59239d32e94146ed05","modified":1489110068469},{"_id":"public/2016/06/24/2016-06-24-DOM扩展/index.html","hash":"5577135d8e435c15fbfbc0fffd30b106c70bb14f","modified":1489110068469},{"_id":"public/2016/06/21/2016-06-21-编写高质量代码——javaScript/index.html","hash":"ff76bd46293ee7ba2a768e079f060b1345513b22","modified":1489110068469},{"_id":"public/2016/06/20/2016-06-20-微型调查问卷平台组件——日历组件/index.html","hash":"0a4097dbc0973c125693694244b538e50561a998","modified":1489110068469},{"_id":"public/2016/06/18/2016-06-18-编写高质量代码——HTML、CSS/index.html","hash":"e26d5b2cc7cbaae48751493e50dd6d5bfdf8afc6","modified":1489110068469},{"_id":"public/2016/06/17/2016-06-17-浏览器跨标签页通信/index.html","hash":"ad3d26790ae849d8d88bc5f7063dc7ee75f8f816","modified":1489110068469},{"_id":"public/2016/06/17/2016-06-17-浏览器的标签页是用多线程还是多进程实现/index.html","hash":"915496b511922ef9d021a7727103ab97bd7b2f1b","modified":1489110068469},{"_id":"public/2016/06/17/2016-06-17-研究登陆信息和登陆状态/index.html","hash":"151cecadb1239799f7a5b6fcea9b0f560cb497b5","modified":1489110068469},{"_id":"public/2016/06/16/2016-06-16-如何避免表单的重复提交/index.html","hash":"220540a936a4e9f9cd9504f880bca17b63efd34f","modified":1489110068469},{"_id":"public/2016/06/16/2016-06-16-session和cookie的区别/index.html","hash":"10688518544bf7a3eda33225473feddde6cbe728","modified":1489110068469},{"_id":"public/2016/06/15/2016-06-15-表单脚本/index.html","hash":"f4a1addac0757d88f3c4c9862f90c97aede59be0","modified":1489110068469},{"_id":"public/2016/06/14/2016-06-14-文档类型声明/index.html","hash":"a0c25eda0d56437831d170e969a3ad50fb22b0d4","modified":1489110068469},{"_id":"public/2016/06/14/2016-06-14-元素视图属性/index.html","hash":"040f54882834268a0262f197e04c9d9728788314","modified":1489110068469},{"_id":"public/2016/06/12/2016-06-12-微型调查问卷平台组件——排序表格/index.html","hash":"d668a780207c429afbf2f5d7212065a7a195c5e1","modified":1489110068469},{"_id":"public/2016/06/12/2016-06-12-微型调查问卷平台组件——冻结行列表格/index.html","hash":"53ca272edef64b73495af0f8f1dc5007844d7896","modified":1489110068469},{"_id":"public/2016/06/12/2016-06-12-二维数组根据某一列进行排序/index.html","hash":"bba169c46a858072ff5b6d468ebdba6366c25083","modified":1489110068469},{"_id":"public/2016/06/08/2016-06-08-事件类型/index.html","hash":"c45dfb12f2638de2ca364210f3086fb849a617bb","modified":1489110068469},{"_id":"public/2016/06/07/2016-06-07-HTML5中的元素的拖放/index.html","hash":"4d4d226ac5c2c47ef428ebb067de775e702eb760","modified":1489110068469},{"_id":"public/2016/06/07/2016-06-07-js中获取元素的样式/index.html","hash":"1fa96cdd1c3e2a362ee376560234d673a034bbe1","modified":1489110068469},{"_id":"public/2016/06/03/2016-06-03-js模块化编程/index.html","hash":"286d98fbcffc9c1e5d3fe6609633d998e7225e48","modified":1489110068470},{"_id":"public/2016/06/01/2016-06-01-web sovkets协议/index.html","hash":"8ceed8930c15d581889ac27aeb13761cae4496b6","modified":1489110068470},{"_id":"public/2016/06/01/2016-06-02-配置PHP环境/index.html","hash":"83b2a0f8454f594459e80fcd9335d15d07fdd526","modified":1489110068470},{"_id":"public/2016/05/27/2016-05-27-http协议/index.html","hash":"e5aa76b9a19d6ebfa574013093c9d5ebc10b0ad6","modified":1489110068470},{"_id":"public/2016/05/25/2016-05-25-浏览器输入url之后/index.html","hash":"00f6545beacea38023d864125adc41fc2014d442","modified":1489110068470},{"_id":"public/2016/05/24/2016-05-24-js中的DOM操作/index.html","hash":"7c6157ba356675a0409d6b769077682675c4758d","modified":1489110068470},{"_id":"public/2016/05/23/2016-05-23-什么是node.js/index.html","hash":"909fd5da38491ad2c7c62d3a36bc27c8ff580a97","modified":1489110068470},{"_id":"public/2016/05/23/2016-05-23-node.js的模块机制/index.html","hash":"9d244b01909b7351340d402fc640fc53a11834fa","modified":1489110068470},{"_id":"public/2016/05/19/2016-05-19-数据库SQL语言/index.html","hash":"fdab8af07cffcbed47750ccc9dba81b3647748bb","modified":1489110068470},{"_id":"public/2016/05/19/2016-05-19-数据库技术/index.html","hash":"2662dcf5a486e20bef68c1d7a9424df33709dcce","modified":1489110068470},{"_id":"public/2016/05/19/2016-05-19-数据库安全与防护/index.html","hash":"93295f06814acd105810b1af1e1ee0a2eda67668","modified":1489110068470},{"_id":"public/2016/05/19/2016-05-19-数据库设计/index.html","hash":"33affb6363c68326c25c9b0968bf4146ce218cfa","modified":1489110068470},{"_id":"public/2016/05/18/2016-05-18-一个旋转的圆/index.html","hash":"b317918bb0375d9d78932e937482fbf3a14a9458","modified":1489110068471},{"_id":"public/2016/05/18/2016-05-18-订阅发布模式/index.html","hash":"164242a6eb89460bef0f48f408b3f271d529d3ed","modified":1489110068471},{"_id":"public/2016/05/17/2016-05-17-css3中的新属性/index.html","hash":"6c607656e72c5846a5a717a4423717dff14fa2fb","modified":1489110068471},{"_id":"public/2016/05/17/2016-05-17-GET和POST的区别/index.html","hash":"5a740ac1c5549db5649bf08000e19d0c7141b85c","modified":1489110068471},{"_id":"public/2016/05/17/2016-05-17-计算机网络7层协议/index.html","hash":"c38fe80211199550f91ad2efd93fe611fe323648","modified":1489110068471},{"_id":"public/2016/05/17/2016-05-17-css中的像素/index.html","hash":"1e1d94d2786406ed03f01297abc67cb03f8cee3e","modified":1489110068472},{"_id":"public/2016/05/17/2016-05-17-js中的设计模式/index.html","hash":"31ea89a617f241226e864ec47f17a7b2b478fdfd","modified":1489110068472},{"_id":"public/2016/05/16/2016-05-16-纯函数/index.html","hash":"61c1de4d026a153faec22eb255bef59b288a010e","modified":1489110068472},{"_id":"public/2016/05/16/2016-05-16-函数节流/index.html","hash":"a016c721ca25756496309ff9aaf4140025c549e5","modified":1489110068472},{"_id":"public/2016/05/16/2016-05-16-将url参数解析成字典对象/index.html","hash":"8fb1614b5e4f093e210d041a60b41eba4e1e0d59","modified":1489110068472},{"_id":"public/2016/05/16/2016-05-16-JSON/index.html","hash":"31cadc76227fa9975d92afeb7c8e422c6831164b","modified":1489110068472},{"_id":"public/2016/05/16/2016-05-16-js 基本数据类型/index.html","hash":"7f607813a607718690fbf84bcf0508fe351ac582","modified":1489110068472},{"_id":"public/2016/05/16/2016-03-31-洗牌算法/index.html","hash":"dd600f780af6714142dc0ddf64ba7cafe62c1107","modified":1489110068472},{"_id":"public/2016/05/15/2016-05-15-js中的call和apply和bind/index.html","hash":"3300120fec14c7095e34cf6fca0ab942c9aed4e5","modified":1489110068472},{"_id":"public/2016/05/13/2016-05-13-听指令的小方块/index.html","hash":"0267765d15f76c225f24970e5c0207503224ac3c","modified":1489110068472},{"_id":"public/2016/05/13/2016-05-13-js中的同步和异步执行/index.html","hash":"6dec45d9a4f7bdaf08717ef92e8aeba1d5a1a7bc","modified":1489110068472},{"_id":"public/2016/05/10/2016-05-10-数组分块/index.html","hash":"88ee96ca82b84c9c800e2a4a48eeb69b03a01712","modified":1489110068472},{"_id":"public/2016/05/09/2016-05-09-js中的函数参数的传递/index.html","hash":"1c5a99585ce8973c1df5eac1cd4b86ddd8fe1fce","modified":1489110068472},{"_id":"public/2016/05/09/2016-05-09-js中的ajax/index.html","hash":"ecfdd8bb22dcc7752d46d46214e9d3e40b6702ba","modified":1489110068472},{"_id":"public/2016/05/09/2016-05-08-前端性能优化的经验/index.html","hash":"cd0302c016abbf10f41e32e338ad1e4bda95ed24","modified":1489110068472},{"_id":"public/2016/05/09/2016-05-09-js的消息机制/index.html","hash":"371e75754bf79fcafc6d5e0d72671c16c1ec1923","modified":1489110068472},{"_id":"public/2016/05/08/2016-05-08-js中的关键字in/index.html","hash":"14c29b7fa402b2f172002c06d10230adface7e4b","modified":1489110068472},{"_id":"public/2016/05/08/2016-05-08-变量声明提升/index.html","hash":"a1838ec56b7136fd031e8d2a30494f1691b2c168","modified":1489110068472},{"_id":"public/2016/05/08/2016-05-08-js中的this对象/index.html","hash":"17a2d3a7bb67f6dd956ab06b57d60bbc7cf84001","modified":1489110068472},{"_id":"public/2016/05/06/2016-05-06-CSS中的display和position/index.html","hash":"aa1af4c935123d314cd063bd4d4fcd1d5eef1bd8","modified":1489110068472},{"_id":"public/2016/05/06/2016-05-06-垂直居中和水平居中/index.html","hash":"66fef9aba4b06d148f904cd664022fac785b8ace","modified":1489110068472},{"_id":"public/2016/05/06/2016-05-06-BFC/index.html","hash":"6967eec126052bdc1c9a7c0b7119f95f55e4379c","modified":1489110068472},{"_id":"public/2016/05/06/2016-05-06-js中创建对象的方式/index.html","hash":"ccc2e22049a6af49a07b89a6d227c54c3925b0b4","modified":1489110068472},{"_id":"public/2016/05/06/2016-05-06-自适应两栏布局/index.html","hash":"b41783c626f22d5a6e35adfada9ba4c76ef40a0a","modified":1489110068472},{"_id":"public/2016/05/05/2016-05-05-window对象和事件对象/index.html","hash":"9ea44df176b3ccd3409c1bd49c229704a153b153","modified":1489110068473},{"_id":"public/2016/05/05/2016-05-05-js中的函数以及闭包/index.html","hash":"632097366deb08db73c6050dec9b5b23aab0ebed","modified":1489110068473},{"_id":"public/2016/05/05/2016-05-05-HTML5中的新特性/index.html","hash":"940fd08f0057eb5c2dcd090d4f64001cdce57725","modified":1489110068473},{"_id":"public/2016/05/03/2016-05-03-http1.0和http1.1的区别/index.html","hash":"cef05a544ffadb100a7ece14b3038971cf5ce6be","modified":1489110068473},{"_id":"public/2016/04/28/2016-04-28- delete/index.html","hash":"7ff1f6f6e3d89dbc10abcb803c3c80314a939e07","modified":1489110068473},{"_id":"public/2016/04/28/2016-04-28-使用H5和canvas开发的一个小游戏——王牌特工/index.html","hash":"b4529aa2fdc39ca69afff5865387bc48ba89185b","modified":1489110068473},{"_id":"public/2016/04/28/2016-04-28-获取鼠标当前位置/index.html","hash":"237334232ada0b106ad0f425d9131c18935c302a","modified":1489110068473},{"_id":"public/2016/04/25/2016-04-25-HTML5中的canvas/index.html","hash":"3cfb39c39f4297e10831140174a9dafa11965ee1","modified":1489110068473},{"_id":"public/2016/04/23/2016-04-23-js中的string类型/index.html","hash":"6ea6f0b598f19f7c3c5f7fdea090876acda4046f","modified":1489110068473},{"_id":"public/2016/04/23/2016-04-23-js中对数组的一些操作/index.html","hash":"d49870de94d8107e6a43a01c8034e770fab29044","modified":1489110068473},{"_id":"public/2016/04/22/2016-04-22-寻路算法/index.html","hash":"19956b4177399c928923d88678988cdc94efa868","modified":1489110068473},{"_id":"public/2016/04/22/2016-05-06-Ajax跨域问题/index.html","hash":"85293fe6e5a3dda17fd63229c5e6a93d6bf030bf","modified":1489110068473},{"_id":"public/2016/04/19/2016-04-19-万年历/index.html","hash":"c3ea7e1f130e00695335fc368b18937f290368ea","modified":1489110068473},{"_id":"public/2016/04/16/2016-04-16-链式调用的原理/index.html","hash":"c35aa0ab1c081d70bec75ba77c6abfc80c4b11d1","modified":1489110068473},{"_id":"public/2016/04/06/2016-04-06-实现轮播特效/index.html","hash":"500271a91afd9a54577014ffb6680d65b9a077a9","modified":1489110068473},{"_id":"public/2016/04/05/2016-04-05-Baidu-IFE-task2-13-18/index.html","hash":"0ced462ab9c1adb33c6a5d3d0d4b4b9cf61a83d5","modified":1489110068473},{"_id":"public/2016/04/05/2016-04-05-清除浮动的几种方法/index.html","hash":"b2979709c5eb15218ecdde16863f6ca129f731e2","modified":1489110068473},{"_id":"public/2016/04/05/2016-04-05-浏览器事件模型/index.html","hash":"1a33e90be2c20e6d2a4d81165a381ee814e458f5","modified":1489110068473},{"_id":"public/2016/04/04/2016-04-04-用CSS实现tab页的切换/index.html","hash":"8835ef629858afee6dd3b2ad00f8e44c2122f66f","modified":1489110068473},{"_id":"public/2016/04/04/2016-04-04-模拟文件报表排版/index.html","hash":"0d87c853abe5b446c27f435daa7d61e8eecc293c","modified":1489110068473},{"_id":"public/2016/04/04/2016-04-04-Baidu-IFE-task1-7-12/index.html","hash":"aedd200f88052bdc93e1a56292e47e23ce9af5b2","modified":1489110068473},{"_id":"public/2016/03/31/2016-03-31-击鼓传花-用循环队列实现/index.html","hash":"74a3b30d3f7720bc2f1fdca64be47d743f1c5eef","modified":1489110068473},{"_id":"public/2016/03/31/2016-03-31-js实现快速排序和冒泡排序/index.html","hash":"7d88d485e23412d31ff526bdbb7a4a126b70d4e5","modified":1489110068473},{"_id":"public/2016/03/31/2016-03-31-js数组去重/index.html","hash":"c5bd83f15a0a9c6c624b4fc16def8492e0fcf7a0","modified":1489110068474},{"_id":"public/2016/03/31/2016-03-31-CSS选择器总结/index.html","hash":"fcd30e3e56176d8398f012225f7c02bf3ab81688","modified":1489110068474},{"_id":"public/2016/03/29/2016-03-29-浏览器本地存储/index.html","hash":"925fd581937fb92ba4b1c65d70da60b346939501","modified":1489110068474},{"_id":"public/2016/03/25/2016-03-27-git使用/index.html","hash":"c70736af75fade5e653c4b22811dc87e4453f259","modified":1489110068474},{"_id":"public/2016/03/25/2016-03-27-异步加载脚本的几种方式/index.html","hash":"d15eb736bebb1f7df39bfb5afbd33a3913112aea","modified":1489110068474},{"_id":"public/2016/03/25/2016-03-25-CSS3 flexbox弹性布局/index.html","hash":"b6ef26f9cd9160bd9cf5d7a3f0c91c9aa092d0f2","modified":1489110068474},{"_id":"public/2016/03/25/2016-03-25-js里获取dom节点的方法/index.html","hash":"efe9cbf19743cfb2ab955ba5beb488c1b321b729","modified":1489110068474},{"_id":"public/2016/03/22/2016-03-22-javaScript继承问题/index.html","hash":"202a6ada9c031df540f7b6c2005e036250e756ee","modified":1489110068474},{"_id":"public/2016/03/22/2016-03-22-原型指针__proto__和原型对象/index.html","hash":"77890564e55a7b71c2766a1351ea87b6df52e886","modified":1489110068474},{"_id":"public/2016/03/16/2016-03-16-break、continue、return/index.html","hash":"f701684d4311ece51af21fd24d6b8235e927f5a4","modified":1489110068474},{"_id":"public/2016/03/15/2016-03-15-常见的两栏式布局/index.html","hash":"e97685faf29e5238f4f73c7c9c07f8c128534a15","modified":1489110068474},{"_id":"public/2016/03/15/2016-03-15-模拟报纸排版/index.html","hash":"84a5fe6baaae10b3a61ad64e47f766567a26546c","modified":1489110068474},{"_id":"public/2016/03/15/2016-03-15-Baidu-IFE-task1-1-6/index.html","hash":"b5b69bba607648be7bc641c676e2528f057cd12e","modified":1489110068474},{"_id":"public/2016/03/07/2016-03-07-性能优化资源的非覆盖式发布/index.html","hash":"9970be6e3be9d6062d37f73f1441fc526aeda53b","modified":1489110068474},{"_id":"public/2016/03/05/2016-03-05-gulp/index.html","hash":"66d4bd720742a0eb735effc13093e0372a942e9b","modified":1489110068474},{"_id":"public/2016/03/04/2016-03-04-jQuery Ajax/index.html","hash":"8cb95f5c1f59ec089007dc15c097b65010b85927","modified":1489110068474},{"_id":"public/2016/03/03/2016-03-03-浏览器渲染页面/index.html","hash":"5dd8fb04e17842ca411aca383c701e3e0164dfcf","modified":1489110068474},{"_id":"public/2016/03/01/2016-03-01-在做demo过程中遇到解决兼容性问题记录/index.html","hash":"5ba9fa4cc5dcd7dcd9ba200d9a9f943d2aaa2519","modified":1489110068474},{"_id":"public/2016/03/01/2016-03-01-用jekyll搭建博客/index.html","hash":"776519a110a87ad3b6fb229896c67d7e092eed7c","modified":1489110068474},{"_id":"public/archives/index.html","hash":"4afe3a0dca72c27c89090f4c69ab7c0132fa2738","modified":1489110068474},{"_id":"public/archives/page/2/index.html","hash":"1ac3d6f47d5677ff784891afed379ca8fc5f0a59","modified":1489110068475},{"_id":"public/archives/page/3/index.html","hash":"f5684aa5ffd9cf5c4174d0713ba137c9f6fdd08a","modified":1489110068475},{"_id":"public/archives/page/4/index.html","hash":"bf1f20966a571e383b1e353d9ad1b3d94d920229","modified":1489110068475},{"_id":"public/archives/page/5/index.html","hash":"f99bcbff19e11a18df68c824a735e713ace0f895","modified":1489110068475},{"_id":"public/archives/page/6/index.html","hash":"d414166ccb2c9da6260b54ec6512f3b3bb1c6112","modified":1489110068475},{"_id":"public/archives/page/7/index.html","hash":"e8e2be157df60966bf67bbf1225eaf2c66ea543d","modified":1489110068475},{"_id":"public/archives/page/8/index.html","hash":"a61eab34d8f0a9b23483036c6b8823a860da4954","modified":1489110068475},{"_id":"public/archives/page/9/index.html","hash":"9479bd208824043ca1b6fec36ec1aea63bcaac17","modified":1489110068475},{"_id":"public/archives/page/10/index.html","hash":"9f203292c3e5325858d7fe8ba699333461603c58","modified":1489110068475},{"_id":"public/archives/page/11/index.html","hash":"83885716375b7d3d389013e105e139357cc00b75","modified":1489110068475},{"_id":"public/archives/page/12/index.html","hash":"b252546861406a7ff1d54cfd04639cd3cb56386c","modified":1489110068475},{"_id":"public/archives/page/13/index.html","hash":"c9d910657292af8ca2c9c6848d22d708d45aee9c","modified":1489110068475},{"_id":"public/archives/page/14/index.html","hash":"5a68dc3affb5b56669d70cdeabbadeb25a05e606","modified":1489110068475},{"_id":"public/archives/2016/index.html","hash":"b04516aa27b0b602d04c4de5b92402befa7d60ae","modified":1489110068475},{"_id":"public/archives/2016/page/2/index.html","hash":"f107deb5f58e02ec5282b317788cbbe5e458eb2d","modified":1489110068475},{"_id":"public/archives/2016/page/3/index.html","hash":"caf3261866d49aa218ecce16b39a7542b123d30c","modified":1489110068475},{"_id":"public/archives/2016/page/4/index.html","hash":"38e25deb0965418fece67ffa99bd8b113b56f445","modified":1489110068475},{"_id":"public/archives/2016/page/5/index.html","hash":"8a0d6ea28ad5e55e4e259dc36d27276b80ffd507","modified":1489110068475},{"_id":"public/archives/2016/page/6/index.html","hash":"da88b2c5b3165590680c95d9f79bdaddb2b5412d","modified":1489110068475},{"_id":"public/archives/2016/page/7/index.html","hash":"b90873ee56bed4728591174874921303642d6f57","modified":1489110068475},{"_id":"public/archives/2016/page/8/index.html","hash":"4b3502cddd9b9603ecc938f2850b464a6f8125e1","modified":1489110068475},{"_id":"public/archives/2016/page/9/index.html","hash":"901d636a043c45b397e564236b291f160ed82ece","modified":1489110068476},{"_id":"public/archives/2016/page/10/index.html","hash":"5ef432e94aa2fb0c5b48d2a0b9d9ac80e44292dc","modified":1489110068476},{"_id":"public/archives/2016/page/11/index.html","hash":"9a829c2d17ed1867adf148ff340be9de43f75156","modified":1489110068476},{"_id":"public/archives/2016/page/12/index.html","hash":"21c628dad4b9cbaf7f90b3d9448f223d4cce8799","modified":1489110068476},{"_id":"public/archives/2016/page/13/index.html","hash":"e4432874f3417f64b531a87ef011da23a647a680","modified":1489110068476},{"_id":"public/archives/2016/page/14/index.html","hash":"132568ee331e4985f3cf87445bcddcf4c80d7186","modified":1489110068476},{"_id":"public/archives/2016/03/index.html","hash":"14e30543991a7f055293e1298b2b51552c8f2c3f","modified":1489110068476},{"_id":"public/archives/2016/03/page/2/index.html","hash":"e7cfbf45fb8c7bc275b6a981b0c1217ab7539007","modified":1489110068476},{"_id":"public/archives/2016/04/index.html","hash":"dc2ad122a59cd53abffc817cec4c5c45185175c2","modified":1489110068476},{"_id":"public/archives/2016/04/page/2/index.html","hash":"dae88c999dfc422506d1e6c880b4973d3664d0cc","modified":1489110068476},{"_id":"public/archives/2016/05/index.html","hash":"e9769f2c403b0ab526c44a399a04e1fa73c13bb5","modified":1489110068476},{"_id":"public/archives/2016/05/page/2/index.html","hash":"6ba68a8014470dbdef0cae9fc8e64499eddd4078","modified":1489110068476},{"_id":"public/archives/2016/05/page/3/index.html","hash":"b03882ff3f5b7e5514b97e8592a05ffb59209bde","modified":1489110068476},{"_id":"public/archives/2016/05/page/4/index.html","hash":"cf066b0cbe1515635039adaa57e9feac0c853c92","modified":1489110068476},{"_id":"public/archives/2016/06/index.html","hash":"31a8adcb153944a189efc6899b1f03dd0b0c14cb","modified":1489110068476},{"_id":"public/archives/2016/06/page/2/index.html","hash":"6148e67c1e160b7714780cdf59818e90c003a516","modified":1489110068476},{"_id":"public/archives/2016/07/index.html","hash":"7d0d72d6373de2b15aec28dc9c0bdaa6fa1eff1e","modified":1489110068476},{"_id":"public/archives/2016/08/index.html","hash":"e19720991fb65e4878f10031decfad7c0d13b486","modified":1489110068476},{"_id":"public/archives/2016/09/index.html","hash":"7146ab52a0a244e0836607f74ba2677bdbe06fee","modified":1489110068476},{"_id":"public/categories/前端笔记/index.html","hash":"fcd27ab074262dc732a5557d5dd71c4f69842771","modified":1489110068476},{"_id":"public/categories/前端笔记/page/2/index.html","hash":"66846d282cb1b62a590aa54a76c737a233a11411","modified":1489110068476},{"_id":"public/categories/javaScript/index.html","hash":"ffa6da9b8722660db537ea282066d5238e8708ab","modified":1489110068476},{"_id":"public/categories/javaScript/page/2/index.html","hash":"c7310184309342378fa238f5724ccf0b34680686","modified":1489110068476},{"_id":"public/categories/javaScript/page/3/index.html","hash":"ae7e531b24a4ec80359658b0d1d376894e839c1a","modified":1489110068477},{"_id":"public/categories/javaScript/page/4/index.html","hash":"ef68d46b8d97e3e593575f6516469853bff9ac32","modified":1489110068477},{"_id":"public/categories/Demo/index.html","hash":"b5b01da6ee32e9d97e97dbefc386f4e2c7597409","modified":1489110068477},{"_id":"public/categories/算法学习/index.html","hash":"d1d740d3d7c82368f1a5fb965ad26314b915511d","modified":1489110068477},{"_id":"public/index.html","hash":"5f9f0973063ed743d9323a8454d550a6a4c65fbb","modified":1489110068477},{"_id":"public/page/2/index.html","hash":"d6e68565e0863e48c6e69dee5f9bbfba27f86554","modified":1489110068477},{"_id":"public/page/3/index.html","hash":"e06e36160015a6759a85fc89381d70d7bca33765","modified":1489110068477},{"_id":"public/page/4/index.html","hash":"95dc4d5a387513eaa20852ee816f595c90c5c911","modified":1489110068477},{"_id":"public/page/5/index.html","hash":"3d0e49d6de4b2f1927f38589722d4a5acd73f58b","modified":1489110068477},{"_id":"public/page/6/index.html","hash":"c8880a2ef3c98861bacf34090ff3a412125c9122","modified":1489110068477},{"_id":"public/page/7/index.html","hash":"fa4043f81cb44a1b3d9f20c04369509daae2afd0","modified":1489110068477},{"_id":"public/page/8/index.html","hash":"50fab4e60dda91ae5af4e68097a4cae756a89ee7","modified":1489110068477},{"_id":"public/page/9/index.html","hash":"3d57b89d463342c8222cdc456017bb377b08ea86","modified":1489110068477},{"_id":"public/page/10/index.html","hash":"f047ab52da1e773fa74fed6603bcb4d97b487976","modified":1489110068477},{"_id":"public/page/11/index.html","hash":"8c962d266cbd228e95a5afc8f6d8323e16fdef76","modified":1489110068477},{"_id":"public/page/12/index.html","hash":"d61cf061f7f34caaf1391c2eb3866e8d13917185","modified":1489110068477},{"_id":"public/page/13/index.html","hash":"5b52a286e78ce8115d0726f988d00edabf9d8614","modified":1489110068477},{"_id":"public/page/14/index.html","hash":"c04e8df7684b82079ef4fa6a3f62b05e7e3b6026","modified":1489110068478},{"_id":"public/page/15/index.html","hash":"ba576ef666cbd3718829eb4be74831be2d268066","modified":1489110068478},{"_id":"public/tags/javaScript/index.html","hash":"8dcf25db32d0462e6a489d338a9d3928c836c5a9","modified":1489110068478},{"_id":"public/tags/javaScript/page/2/index.html","hash":"5f98a891dd8c13187e35d86adf38f3be8e8e5e9d","modified":1489110068478},{"_id":"public/tags/javaScript/page/3/index.html","hash":"d4029e0aa1dcb973bf610d3eee12d1da78db65f9","modified":1489110068478},{"_id":"public/tags/javaScript/page/4/index.html","hash":"a01fe18aa558d87991c559d1c0d512e204e4780f","modified":1489110068478},{"_id":"public/tags/javaScript/page/5/index.html","hash":"c452daa6b7f8d99849eb2d200c31142ead0a71ae","modified":1489110068478},{"_id":"public/tags/javaScript/page/6/index.html","hash":"238baa32a61f7b70e58019f72f869b6f2390c385","modified":1489110068478},{"_id":"public/tags/css/index.html","hash":"2d7e905d4fb811d14600d9d70cb2d31abc56849e","modified":1489110068478},{"_id":"public/tags/css/page/2/index.html","hash":"9c6c4adf8766ae08715ee69085345115da32f30f","modified":1489110068478},{"_id":"public/tags/算法/index.html","hash":"e7ea02b8ee4f41ee7b1b44eee2d815414c8131d8","modified":1489110068478},{"_id":"public/CNAME","hash":"8c9d14b6b963ac334a6a1e89ab4badaa4bac47b4","modified":1489110068497},{"_id":"public/favicon.ico","hash":"1d91ae2b3d239d46086041c2f9e34e3808bae750","modified":1489110068497},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1489110068498},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1489110068498},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1489110068498},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1489110068498},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1489110068498},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1489110068498},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1489110068498},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489110068498},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1489110068498},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1489110068498},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1489110068498},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1489110068498},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489110068498},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1489110068498},{"_id":"public/uploads/icon.jpg","hash":"0060e66a71a8ecafffb1dfe797b225cc33694920","modified":1489110068498},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1489110068498},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1489110068498},{"_id":"public/uploads/post/20160329/broswer-caching.jpg","hash":"ff6628eea9ef8aa1d4e11179a8e7dfe6dc033e4b","modified":1489110068498},{"_id":"public/uploads/post/20160428/task3-46.jpg","hash":"325413ae8995720de4828d6f3e5843dfc5b86cb5","modified":1489110068498},{"_id":"public/uploads/post/demo/prototype.jpg","hash":"5641a7364769b07441cb087ba735bd27655bd407","modified":1489110068498},{"_id":"public/uploads/post/demo/scope.jpg","hash":"a317e2c2b219cf0a6e327cf252d7ae3b41e4390f","modified":1489110068498},{"_id":"public/uploads/post/demo/baidu-ife-task1.jpg","hash":"f769bb3c74e6fe7ae354547b1c13b09bcaec3b61","modified":1489110068498},{"_id":"public/uploads/post/demo/float-center.jpg","hash":"2c2f5770d3823d7354b49630ff09bfd7b95aa6fe","modified":1489110068499},{"_id":"public/uploads/post/demo/baidu-ife-task2.jpg","hash":"2dfc96572ca6c348b3a55e36b1c85bb1fa682dcd","modified":1489110068499},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489110068499},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489110068499},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489110068499},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489110068499},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489110068499},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489110068499},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1489110068499},{"_id":"public/uploads/post/demo/collapse/1.jpg","hash":"18ede5fba9b55134df1c649acfdd8c3b54fb1f61","modified":1489110068499},{"_id":"public/uploads/post/demo/collapse/4.jpg","hash":"68671f6b67dc34d38655ef86a59435830434eb67","modified":1489110068499},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489110068499},{"_id":"public/uploads/post/demo/collapse/3.jpg","hash":"34db451c238f5f92060600263f5fa97a201ce1f6","modified":1489110068499},{"_id":"public/uploads/post/demo/collapse/5.jpg","hash":"287c4111800b7365664f475e53e00c65741188b6","modified":1489110068499},{"_id":"public/uploads/post/demo/flex-wrap-reverse.jpg","hash":"f94f3427da9e6a07941db66d655b878d43bd7a4a","modified":1489110069989},{"_id":"public/uploads/post/20160509/async.jpg","hash":"16d264d9698a7d3cca0af89c9e0821ff5f1ae5a2","modified":1489110069994},{"_id":"public/uploads/post/20160329/http-caching.jpg","hash":"0dcbf30a98c2c46919ab3e23e8da2d8527b15105","modified":1489110069998},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"1214ac2c18e406c18d192baf3ec3fcc646bd2b72","modified":1489110069998},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"e18575b6e9b60f713b571c0033facda82d6ebb22","modified":1489110069998},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"ee59197f63a2c4c7b7f2ae135a745202235de8d4","modified":1489110069998},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"3f57f29481d8144a7fad117a891a5d7551a7ec45","modified":1489110069998},{"_id":"public/uploads/post/demo/collapse/2.jpg","hash":"26333286fb4c26f70439d5d2f533aa543f1bd3ab","modified":1489110069998},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1489110070027},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1489110070027},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1489110070027},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1489110070027},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1489110070027},{"_id":"public/vendors/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1489110070027},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1489110070027},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1489110070027},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1489110070027},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1489110070028},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1489110070028},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1489110070028},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1489110070028},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1489110070028},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1489110070028},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1489110070028},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1489110070028},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1489110070028},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1489110070028},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1489110070028},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1489110070028},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1489110070028},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1489110070028},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1489110070028},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489110070028},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1489110070028},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489110070028},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1489110070028},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1489110070028},{"_id":"public/css/main.css","hash":"d42a2a4a85595b71c9a2fc8f95b48002786672af","modified":1489110070028},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1489110070028},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1489110070028},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1489110070028},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1489110070028},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1489110070029},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1489110070029},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"03bf1ac337dfe6f50fb25fd3e254a2bbfab26cc6","modified":1489110070029},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"932e1ffa91a665b0a530a422b6bf0d7ed3187c3f","modified":1489110070029},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1489110070029},{"_id":"public/vendors/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1489110070029},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"596bf3a74878a13e2bf0e572e9467dfc17146b00","modified":1489110070029},{"_id":"public/uploads/post/20160524/node.jpg","hash":"5636ea7cfb577c6f1d0be41c4dccd4c83e21460d","modified":1489110070029},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"a6955d04d00182a80e62fd0b4cef73b686afb858","modified":1489110070058}],"Category":[{"name":"前端笔记","_id":"cj035ocbl0004d5u8uimq59st"},{"name":"搭建博客","_id":"cj035occ8000dd5u8jqx3n1mv"},{"name":"javaScript","_id":"cj035occe000kd5u8jbdafmyt"},{"name":"浏览器","_id":"cj035occk000sd5u8rjuf0hne"},{"name":"性能优化","_id":"cj035occo000zd5u89gp8ta24"},{"name":"工具","_id":"cj035occw0018d5u8ha9awwxk"},{"name":"Demo","_id":"cj035ocd7001od5u8kkkigxeo"},{"name":"算法学习","_id":"cj035ocdm0029d5u8zgpr9ruk"},{"name":"CSS","_id":"cj035ocdu002id5u8rwowq6d8"},{"name":"HTML","_id":"cj035ocen003nd5u8w0y8tj8o"},{"name":"http协议","_id":"cj035ocey0042d5u81g3lqy89"},{"name":"数据库","_id":"cj035och6007ad5u8wia8o05l"},{"name":"nodejs","_id":"cj035ochm007zd5u8s8uq4fog"},{"name":"php","_id":"cj035oci1008hd5u8mx45t0n1"},{"name":"css","_id":"cj035ocjw00bzd5u8m7egh4im"},{"name":"前端框架","_id":"cj035ock100c8d5u8qqzn316m"}],"Data":[],"Page":[{"title":"分类","date":"2016-05-30T02:12:53.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-05-30 10:12:53\ntype: \"categories\"\n---\n","updated":"2016-05-30T02:15:06.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj035ocbe0001d5u8y8xa83rm","content":"","excerpt":"","more":""},{"title":"标签","date":"2016-05-30T02:07:38.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-05-30 10:07:38\ntype: \"tags\"\n---\n","updated":"2016-05-30T02:31:50.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj035ocp400fid5u8t2c9uomp","content":"","excerpt":"","more":""},{"title":"demo","date":"2016-05-30T02:22:46.000Z","type":"demo","_content":"","source":"demo/index.md","raw":"---\ntitle: demo\ndate: 2016-05-30 10:22:46\ntype: \"demo\"\n---\n","updated":"2016-05-30T02:31:56.000Z","path":"demo/index.html","comments":1,"layout":"page","_id":"cj035ocp500fjd5u8tl81nrdx","content":"","excerpt":"","more":""}],"Post":[{"layout":"post","title":"《锋利的jQuery》","date":"2016-02-29T16:00:00.000Z","description":null,"_content":"\njQuery一共有13个模块。\n\n- 核心方法\n- 回调系统\n- 异步队列\n- 数据缓存\n- 队列操作\n- 选择器引\n- 属性操作\n- 节点遍历\n- 文档处理\n- 样式操作\n- 属性操作\n- 事件体系\n- AJAX交互\n- 动画引擎\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-01-《锋利的jQuery》.md","raw":"---\nlayout: post\ntitle: 《锋利的jQuery》\ndate: 2016-03-01\ncategories: 前端笔记 \ntags: [jQuery,Ajax]\ndescription: \n---\n\njQuery一共有13个模块。\n\n- 核心方法\n- 回调系统\n- 异步队列\n- 数据缓存\n- 队列操作\n- 选择器引\n- 属性操作\n- 节点遍历\n- 文档处理\n- 样式操作\n- 属性操作\n- 事件体系\n- AJAX交互\n- 动画引擎\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-01-《锋利的jQuery》","published":1,"updated":"2016-07-08T11:49:46.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocb80000d5u8tln5m5i0","content":"<p>jQuery一共有13个模块。</p>\n<ul>\n<li>核心方法</li>\n<li>回调系统</li>\n<li>异步队列</li>\n<li>数据缓存</li>\n<li>队列操作</li>\n<li>选择器引</li>\n<li>属性操作</li>\n<li>节点遍历</li>\n<li>文档处理</li>\n<li>样式操作</li>\n<li>属性操作</li>\n<li>事件体系</li>\n<li>AJAX交互</li>\n<li>动画引擎</li>\n</ul>\n","excerpt":"","more":"<p>jQuery一共有13个模块。</p>\n<ul>\n<li>核心方法</li>\n<li>回调系统</li>\n<li>异步队列</li>\n<li>数据缓存</li>\n<li>队列操作</li>\n<li>选择器引</li>\n<li>属性操作</li>\n<li>节点遍历</li>\n<li>文档处理</li>\n<li>样式操作</li>\n<li>属性操作</li>\n<li>事件体系</li>\n<li>AJAX交互</li>\n<li>动画引擎</li>\n</ul>\n"},{"layout":"post","title":"编写可维护的javaScript","date":"2016-08-19T16:00:00.000Z","description":null,"_content":"\nJSLint\nJSHint\n### 一. 代码规范\n#### 1. 基本规范\n\n(1). 使用tab空格\n\n(2). 每一行结束使用分号\n\njs有自动分号插入机制，可能会出现错误\n\n(3). 换行\n\n以运算符结尾，第二行追加两个缩进\n\n(4). 命名\n\n以驼峰命名的方式\n\n变量名 前缀为名词\n函数名 前缀为动词\n\ncan has is get set\n\n(5). 常量\n\n大写字母＋下划线\n\nMAX_COUNT\n\n(6). 构造函数\n\n大写字母开头\n一般为名词\n\n因为构造函数一般是创建某种类型的实例\n\n(7). null undefined\n\nnull一般涌来当作对象的占位符\n\n#### 2. 注释\n\n(1). 单行注释 //\n\n注释前空一行，注释与后面一行的缩进相同\n\n(2). 多行注释 /* */\n\n```\n/*\n * abcdefg\n * abcdefg\n */\n```\n\n(3). 文档注释\n\n```\n/**\n\n**/\n```\n\n#### 3. 语句和表达式\n\nif语句\n\nif (condition) {\n\n}\n\n#### 4. 变量、函数\n\n使用合并的var语句来声明变量\n\n函数不允许出现在块级作用域以内\n\n使用 === 和 !== 而不是用 == 和 !=\n\n不要使用eval()、禁止给setTimeout、setInterval传入字符串参数\n\n原始包装类型String、Boolean、Number的作用是让原始值具有对象般的行为\n\n### 二. 编程规范\n\n#### 1. html、css、js之间保持松耦合\n\n**将css从js中抽离出来**\n\n使用修改className的方式来操作样式\n\n**将HTML从js中抽离出来**\n\n方法一：\n\n使用XMLHttprequest从服务器获取外部的标签，然后插入\n\n```\nfunction loadDialog(name, oncomplete) {\n\tvar xhr = new XMLHttpRequest();\n\t\n\txhr.onreadystatechange = function() {\n\t\tif(xhr.readyState == 4) {\n\t\t\tif(xhr.status >= 200 && xhr.status <300 || xhr.status == 304) {\n\t\t\t\tvar div = document.getElementById('dlg-holder');\n\t\t\t\tdiv.innerHTML = xhr.responseText;\n\t\t\t\t\n\t\t\t\t//执行回调函数\n\t\t\t\toncomplete();\n\t\t\t}\n\t\t}\n\t}\n\t\n\txhr.open('get', '/js/dialog/' + name, true);\n\txhr.send(null); \n}\n```\n\n方法二：\n\n使用客户端模版\n\nhandlebar.js\n\n#### 2. 避免使用全局变量\n\n在定义函数时，尽可能地将数据置于局部作用域内，函数外的数据应该用参数的形式传出来\n\n**单全局变量**\n\n很多框架都是采用这种模式\n\n创建一个唯一的全局对象名，并将所有的功能代码都挂载在这个全局对象上。eg: jQuery中的$和jQuery\n\n- 使用命名空间\n- 模块\n\n#### 3. 避免空比较\n\n不要和underfined/null进行比较\n\n**检测基本值：**\n\n typeof\n \n**检测引用值：**\n\ninstanceof \n\nObject.prototype.toString.call([])\n\n检测函数 typeof\n检测数组 Array.isArray()\n\n**检测属性：**\n\n- in\n- object.hasOwnProperty()\n\n#### 4. 将配置数据抽离\n\n#### 5. 错误处理\n\n**抛出错误**\n\nthrow 用来创建自定义错误\n\nthrow new Error('something bad happened')\n\n**捕获错误**\n\ntry {\n\t//可能引发错误的代码\n} catch(error) {\n\t//处理错误的代码\n}\n\n#### 6. 不要修改下列对象\n\n- 原生对象\n- DOM对象\n- BOM对象\n- 类库的对象\n\n#### 7. 使用对浏览器特性检测代替对浏览器的检测\n\n\n\n\n\n\n\n","source":"_posts/2016-03-01-编写可维护的js.md","raw":"---\nlayout: post\ntitle: 编写可维护的javaScript\ndate: 2016-08-20\ncategories: 前端笔记\ntags: [javaScript,代码规范]\ndescription: \n---\n\nJSLint\nJSHint\n### 一. 代码规范\n#### 1. 基本规范\n\n(1). 使用tab空格\n\n(2). 每一行结束使用分号\n\njs有自动分号插入机制，可能会出现错误\n\n(3). 换行\n\n以运算符结尾，第二行追加两个缩进\n\n(4). 命名\n\n以驼峰命名的方式\n\n变量名 前缀为名词\n函数名 前缀为动词\n\ncan has is get set\n\n(5). 常量\n\n大写字母＋下划线\n\nMAX_COUNT\n\n(6). 构造函数\n\n大写字母开头\n一般为名词\n\n因为构造函数一般是创建某种类型的实例\n\n(7). null undefined\n\nnull一般涌来当作对象的占位符\n\n#### 2. 注释\n\n(1). 单行注释 //\n\n注释前空一行，注释与后面一行的缩进相同\n\n(2). 多行注释 /* */\n\n```\n/*\n * abcdefg\n * abcdefg\n */\n```\n\n(3). 文档注释\n\n```\n/**\n\n**/\n```\n\n#### 3. 语句和表达式\n\nif语句\n\nif (condition) {\n\n}\n\n#### 4. 变量、函数\n\n使用合并的var语句来声明变量\n\n函数不允许出现在块级作用域以内\n\n使用 === 和 !== 而不是用 == 和 !=\n\n不要使用eval()、禁止给setTimeout、setInterval传入字符串参数\n\n原始包装类型String、Boolean、Number的作用是让原始值具有对象般的行为\n\n### 二. 编程规范\n\n#### 1. html、css、js之间保持松耦合\n\n**将css从js中抽离出来**\n\n使用修改className的方式来操作样式\n\n**将HTML从js中抽离出来**\n\n方法一：\n\n使用XMLHttprequest从服务器获取外部的标签，然后插入\n\n```\nfunction loadDialog(name, oncomplete) {\n\tvar xhr = new XMLHttpRequest();\n\t\n\txhr.onreadystatechange = function() {\n\t\tif(xhr.readyState == 4) {\n\t\t\tif(xhr.status >= 200 && xhr.status <300 || xhr.status == 304) {\n\t\t\t\tvar div = document.getElementById('dlg-holder');\n\t\t\t\tdiv.innerHTML = xhr.responseText;\n\t\t\t\t\n\t\t\t\t//执行回调函数\n\t\t\t\toncomplete();\n\t\t\t}\n\t\t}\n\t}\n\t\n\txhr.open('get', '/js/dialog/' + name, true);\n\txhr.send(null); \n}\n```\n\n方法二：\n\n使用客户端模版\n\nhandlebar.js\n\n#### 2. 避免使用全局变量\n\n在定义函数时，尽可能地将数据置于局部作用域内，函数外的数据应该用参数的形式传出来\n\n**单全局变量**\n\n很多框架都是采用这种模式\n\n创建一个唯一的全局对象名，并将所有的功能代码都挂载在这个全局对象上。eg: jQuery中的$和jQuery\n\n- 使用命名空间\n- 模块\n\n#### 3. 避免空比较\n\n不要和underfined/null进行比较\n\n**检测基本值：**\n\n typeof\n \n**检测引用值：**\n\ninstanceof \n\nObject.prototype.toString.call([])\n\n检测函数 typeof\n检测数组 Array.isArray()\n\n**检测属性：**\n\n- in\n- object.hasOwnProperty()\n\n#### 4. 将配置数据抽离\n\n#### 5. 错误处理\n\n**抛出错误**\n\nthrow 用来创建自定义错误\n\nthrow new Error('something bad happened')\n\n**捕获错误**\n\ntry {\n\t//可能引发错误的代码\n} catch(error) {\n\t//处理错误的代码\n}\n\n#### 6. 不要修改下列对象\n\n- 原生对象\n- DOM对象\n- BOM对象\n- 类库的对象\n\n#### 7. 使用对浏览器特性检测代替对浏览器的检测\n\n\n\n\n\n\n\n","slug":"2016-03-01-编写可维护的js","published":1,"updated":"2016-09-04T01:37:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocbf0002d5u8ld24uzju","content":"<p>JSLint<br>JSHint</p>\n<h3 id=\"一-代码规范\"><a href=\"#一-代码规范\" class=\"headerlink\" title=\"一. 代码规范\"></a>一. 代码规范</h3><h4 id=\"1-基本规范\"><a href=\"#1-基本规范\" class=\"headerlink\" title=\"1. 基本规范\"></a>1. 基本规范</h4><p>(1). 使用tab空格</p>\n<p>(2). 每一行结束使用分号</p>\n<p>js有自动分号插入机制，可能会出现错误</p>\n<p>(3). 换行</p>\n<p>以运算符结尾，第二行追加两个缩进</p>\n<p>(4). 命名</p>\n<p>以驼峰命名的方式</p>\n<p>变量名 前缀为名词<br>函数名 前缀为动词</p>\n<p>can has is get set</p>\n<p>(5). 常量</p>\n<p>大写字母＋下划线</p>\n<p>MAX_COUNT</p>\n<p>(6). 构造函数</p>\n<p>大写字母开头<br>一般为名词</p>\n<p>因为构造函数一般是创建某种类型的实例</p>\n<p>(7). null undefined</p>\n<p>null一般涌来当作对象的占位符</p>\n<h4 id=\"2-注释\"><a href=\"#2-注释\" class=\"headerlink\" title=\"2. 注释\"></a>2. 注释</h4><p>(1). 单行注释 //</p>\n<p>注释前空一行，注释与后面一行的缩进相同</p>\n<p>(2). 多行注释 /<em> </em>/</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * abcdefg</span><br><span class=\"line\"> * abcdefg</span><br><span class=\"line\"> */</span></span><br></pre></td></tr></table></figure>\n<p>(3). 文档注释</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"></span><br><span class=\"line\">**/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-语句和表达式\"><a href=\"#3-语句和表达式\" class=\"headerlink\" title=\"3. 语句和表达式\"></a>3. 语句和表达式</h4><p>if语句</p>\n<p>if (condition) {</p>\n<p>}</p>\n<h4 id=\"4-变量、函数\"><a href=\"#4-变量、函数\" class=\"headerlink\" title=\"4. 变量、函数\"></a>4. 变量、函数</h4><p>使用合并的var语句来声明变量</p>\n<p>函数不允许出现在块级作用域以内</p>\n<p>使用 === 和 !== 而不是用 == 和 !=</p>\n<p>不要使用eval()、禁止给setTimeout、setInterval传入字符串参数</p>\n<p>原始包装类型String、Boolean、Number的作用是让原始值具有对象般的行为</p>\n<h3 id=\"二-编程规范\"><a href=\"#二-编程规范\" class=\"headerlink\" title=\"二. 编程规范\"></a>二. 编程规范</h3><h4 id=\"1-html、css、js之间保持松耦合\"><a href=\"#1-html、css、js之间保持松耦合\" class=\"headerlink\" title=\"1. html、css、js之间保持松耦合\"></a>1. html、css、js之间保持松耦合</h4><p><strong>将css从js中抽离出来</strong></p>\n<p>使用修改className的方式来操作样式</p>\n<p><strong>将HTML从js中抽离出来</strong></p>\n<p>方法一：</p>\n<p>使用XMLHttprequest从服务器获取外部的标签，然后插入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadDialog</span>(<span class=\"params\">name, oncomplete</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\txhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xhr.readyState == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt;<span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'dlg-holder'</span>);</span><br><span class=\"line\">\t\t\t\tdiv.innerHTML = xhr.responseText;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//执行回调函数</span></span><br><span class=\"line\">\t\t\t\toncomplete();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\txhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/js/dialog/'</span> + name, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\txhr.send(<span class=\"literal\">null</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>使用客户端模版</p>\n<p>handlebar.js</p>\n<h4 id=\"2-避免使用全局变量\"><a href=\"#2-避免使用全局变量\" class=\"headerlink\" title=\"2. 避免使用全局变量\"></a>2. 避免使用全局变量</h4><p>在定义函数时，尽可能地将数据置于局部作用域内，函数外的数据应该用参数的形式传出来</p>\n<p><strong>单全局变量</strong></p>\n<p>很多框架都是采用这种模式</p>\n<p>创建一个唯一的全局对象名，并将所有的功能代码都挂载在这个全局对象上。eg: jQuery中的$和jQuery</p>\n<ul>\n<li>使用命名空间</li>\n<li>模块</li>\n</ul>\n<h4 id=\"3-避免空比较\"><a href=\"#3-避免空比较\" class=\"headerlink\" title=\"3. 避免空比较\"></a>3. 避免空比较</h4><p>不要和underfined/null进行比较</p>\n<p><strong>检测基本值：</strong></p>\n<p> typeof</p>\n<p><strong>检测引用值：</strong></p>\n<p>instanceof </p>\n<p>Object.prototype.toString.call([])</p>\n<p>检测函数 typeof<br>检测数组 Array.isArray()</p>\n<p><strong>检测属性：</strong></p>\n<ul>\n<li>in</li>\n<li>object.hasOwnProperty()</li>\n</ul>\n<h4 id=\"4-将配置数据抽离\"><a href=\"#4-将配置数据抽离\" class=\"headerlink\" title=\"4. 将配置数据抽离\"></a>4. 将配置数据抽离</h4><h4 id=\"5-错误处理\"><a href=\"#5-错误处理\" class=\"headerlink\" title=\"5. 错误处理\"></a>5. 错误处理</h4><p><strong>抛出错误</strong></p>\n<p>throw 用来创建自定义错误</p>\n<p>throw new Error(‘something bad happened’)</p>\n<p><strong>捕获错误</strong></p>\n<p>try {<br>    //可能引发错误的代码<br>} catch(error) {<br>    //处理错误的代码<br>}</p>\n<h4 id=\"6-不要修改下列对象\"><a href=\"#6-不要修改下列对象\" class=\"headerlink\" title=\"6. 不要修改下列对象\"></a>6. 不要修改下列对象</h4><ul>\n<li>原生对象</li>\n<li>DOM对象</li>\n<li>BOM对象</li>\n<li>类库的对象</li>\n</ul>\n<h4 id=\"7-使用对浏览器特性检测代替对浏览器的检测\"><a href=\"#7-使用对浏览器特性检测代替对浏览器的检测\" class=\"headerlink\" title=\"7. 使用对浏览器特性检测代替对浏览器的检测\"></a>7. 使用对浏览器特性检测代替对浏览器的检测</h4>","excerpt":"","more":"<p>JSLint<br>JSHint</p>\n<h3 id=\"一-代码规范\"><a href=\"#一-代码规范\" class=\"headerlink\" title=\"一. 代码规范\"></a>一. 代码规范</h3><h4 id=\"1-基本规范\"><a href=\"#1-基本规范\" class=\"headerlink\" title=\"1. 基本规范\"></a>1. 基本规范</h4><p>(1). 使用tab空格</p>\n<p>(2). 每一行结束使用分号</p>\n<p>js有自动分号插入机制，可能会出现错误</p>\n<p>(3). 换行</p>\n<p>以运算符结尾，第二行追加两个缩进</p>\n<p>(4). 命名</p>\n<p>以驼峰命名的方式</p>\n<p>变量名 前缀为名词<br>函数名 前缀为动词</p>\n<p>can has is get set</p>\n<p>(5). 常量</p>\n<p>大写字母＋下划线</p>\n<p>MAX_COUNT</p>\n<p>(6). 构造函数</p>\n<p>大写字母开头<br>一般为名词</p>\n<p>因为构造函数一般是创建某种类型的实例</p>\n<p>(7). null undefined</p>\n<p>null一般涌来当作对象的占位符</p>\n<h4 id=\"2-注释\"><a href=\"#2-注释\" class=\"headerlink\" title=\"2. 注释\"></a>2. 注释</h4><p>(1). 单行注释 //</p>\n<p>注释前空一行，注释与后面一行的缩进相同</p>\n<p>(2). 多行注释 /<em> </em>/</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * abcdefg</span><br><span class=\"line\"> * abcdefg</span><br><span class=\"line\"> */</span></span><br></pre></td></tr></table></figure>\n<p>(3). 文档注释</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"></span><br><span class=\"line\">**/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-语句和表达式\"><a href=\"#3-语句和表达式\" class=\"headerlink\" title=\"3. 语句和表达式\"></a>3. 语句和表达式</h4><p>if语句</p>\n<p>if (condition) {</p>\n<p>}</p>\n<h4 id=\"4-变量、函数\"><a href=\"#4-变量、函数\" class=\"headerlink\" title=\"4. 变量、函数\"></a>4. 变量、函数</h4><p>使用合并的var语句来声明变量</p>\n<p>函数不允许出现在块级作用域以内</p>\n<p>使用 === 和 !== 而不是用 == 和 !=</p>\n<p>不要使用eval()、禁止给setTimeout、setInterval传入字符串参数</p>\n<p>原始包装类型String、Boolean、Number的作用是让原始值具有对象般的行为</p>\n<h3 id=\"二-编程规范\"><a href=\"#二-编程规范\" class=\"headerlink\" title=\"二. 编程规范\"></a>二. 编程规范</h3><h4 id=\"1-html、css、js之间保持松耦合\"><a href=\"#1-html、css、js之间保持松耦合\" class=\"headerlink\" title=\"1. html、css、js之间保持松耦合\"></a>1. html、css、js之间保持松耦合</h4><p><strong>将css从js中抽离出来</strong></p>\n<p>使用修改className的方式来操作样式</p>\n<p><strong>将HTML从js中抽离出来</strong></p>\n<p>方法一：</p>\n<p>使用XMLHttprequest从服务器获取外部的标签，然后插入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadDialog</span>(<span class=\"params\">name, oncomplete</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\txhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xhr.readyState == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt;<span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'dlg-holder'</span>);</span><br><span class=\"line\">\t\t\t\tdiv.innerHTML = xhr.responseText;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//执行回调函数</span></span><br><span class=\"line\">\t\t\t\toncomplete();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\txhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/js/dialog/'</span> + name, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\txhr.send(<span class=\"literal\">null</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>使用客户端模版</p>\n<p>handlebar.js</p>\n<h4 id=\"2-避免使用全局变量\"><a href=\"#2-避免使用全局变量\" class=\"headerlink\" title=\"2. 避免使用全局变量\"></a>2. 避免使用全局变量</h4><p>在定义函数时，尽可能地将数据置于局部作用域内，函数外的数据应该用参数的形式传出来</p>\n<p><strong>单全局变量</strong></p>\n<p>很多框架都是采用这种模式</p>\n<p>创建一个唯一的全局对象名，并将所有的功能代码都挂载在这个全局对象上。eg: jQuery中的$和jQuery</p>\n<ul>\n<li>使用命名空间</li>\n<li>模块</li>\n</ul>\n<h4 id=\"3-避免空比较\"><a href=\"#3-避免空比较\" class=\"headerlink\" title=\"3. 避免空比较\"></a>3. 避免空比较</h4><p>不要和underfined/null进行比较</p>\n<p><strong>检测基本值：</strong></p>\n<p> typeof</p>\n<p><strong>检测引用值：</strong></p>\n<p>instanceof </p>\n<p>Object.prototype.toString.call([])</p>\n<p>检测函数 typeof<br>检测数组 Array.isArray()</p>\n<p><strong>检测属性：</strong></p>\n<ul>\n<li>in</li>\n<li>object.hasOwnProperty()</li>\n</ul>\n<h4 id=\"4-将配置数据抽离\"><a href=\"#4-将配置数据抽离\" class=\"headerlink\" title=\"4. 将配置数据抽离\"></a>4. 将配置数据抽离</h4><h4 id=\"5-错误处理\"><a href=\"#5-错误处理\" class=\"headerlink\" title=\"5. 错误处理\"></a>5. 错误处理</h4><p><strong>抛出错误</strong></p>\n<p>throw 用来创建自定义错误</p>\n<p>throw new Error(‘something bad happened’)</p>\n<p><strong>捕获错误</strong></p>\n<p>try {<br>    //可能引发错误的代码<br>} catch(error) {<br>    //处理错误的代码<br>}</p>\n<h4 id=\"6-不要修改下列对象\"><a href=\"#6-不要修改下列对象\" class=\"headerlink\" title=\"6. 不要修改下列对象\"></a>6. 不要修改下列对象</h4><ul>\n<li>原生对象</li>\n<li>DOM对象</li>\n<li>BOM对象</li>\n<li>类库的对象</li>\n</ul>\n<h4 id=\"7-使用对浏览器特性检测代替对浏览器的检测\"><a href=\"#7-使用对浏览器特性检测代替对浏览器的检测\" class=\"headerlink\" title=\"7. 使用对浏览器特性检测代替对浏览器的检测\"></a>7. 使用对浏览器特性检测代替对浏览器的检测</h4>"},{"layout":"post","title":"用github pages和jekyll搭建博客","date":"2016-02-29T16:00:00.000Z","description":null,"_content":"\n### 一. 关于一个网站的构成\n一个网站主要由三部分构成：[ 网页 ]、域名、主机空间。\n\n1. 网页：自己写的html、css、js代码以及图片等素材\n\n2. 域名：是一个由字母和数字组成的地址，在浏览器中地址栏输入后就能够访问网站。（域名可以在网上购买）\n\n3. 主机空间：空间就是在网上的一个存储网站内容的地方，也叫虚拟主机。\n\n\t网站空间有一般分为国内空间和国外空间，\n\n\t国内空间对于国内的人来说速度更快，但更贵，且需要备案，\n\n\t国外空间速度不及国内空间，但是不需要备案，且非常便宜。\n\n   本教程搭建的博客的网页部分是用的网上的模板，并自己修改了一部分代码；域名是在GoDaddy上购买的；主机空间用的是github pages给每个个人账号提供的免费空间。\n\n### 二.生成github pages页面\n1.进入自己的github页面，Create a new repository，并将Repository name写成\n（这一部分没写完）\n\n### 三.安装jekyll\njekyll简介：jekyll在启动之后，提供了一个可以在本地调试的功能，并且支持通过添加.md文件来写博客\n\n#### 1. 安装Ruby\n \n下载地址：[http://rubyinstaller.org/downloads/]((http://rubyinstaller.org/downloads/)) \n\n通过 ruby -v 来查看 ruby 是否安装正确\n\n如果出现了版本号，即安装正确\n\n#### 2. 安装DevKit\n\n下载地址：  [http://rubyinstaller.org/downloads/]([http://rubyinstaller.org/downloads/](http://rubyinstaller.org/downloads/))\n\n\tcd C:\\rubydevkit   /*进入安装DevKit的文件夹*/\n\n\truby dk.rb init   \t/*生成config.yml文件*/\n\n\tnotepad config.yml\t/*打开config.yml文件*/\n\n修改 config.yml 文件：在打开的记事本中的最后面添加两行新的代码（如下所示），并保存（注意：每次改动了 config.yml 文件后需要重新启动jekyll才能生效）\n\n\t- C:\\ruby  /*ruby为你安装的ruby的文件夹*/\n  \n\t- C:\\ruby\n\n再输入下一行\n\n\truby dk.rb install\n\n如果在 * ruby dk.rb init 这一步出现问题，可能是安装的 Ruby 和 DevKit 版本不对\n\t\n我选择的是Ruby 2.0.0-p648(x64) 以及对应的 DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe\n\n#### 3.  修改gem镜像到taobao网\n\n\tgem -v     /*查看gem的版本号确保gem正确安装*/\n\t\n\tgem source --remove https://rubygems.org/\n\t\n\tgem source -a https://ruby.taobao.org/\n\t\n\tgem source /*查看gem的source是否为taobao镜像*/\n\t\n\tgem update --system\n\n#### 4. 安装jekyll\n\n\tgem install jekyll\n\n#### 5.启动jekyll\n\n\tjekyll new myblog  /*创建一个jekyll文件夹，名为myblog*/\n\n\tcd myblog\n\n\tjekyll serve       /*在名为myblog的文件夹中启动jekyll*/\n\n#### 6. 将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\n\n#### 7. 在启动jekyll之后，本地调试网址：http://localhost:4000/\n\n通过markdown编辑器写好的.md文件放在_posts文件夹内\n\n#### 8. 将myblog的文件夹push到github上，就可以通过 https://username.github.io/ 访问博客\n\n\n### 四.域名\n\n1. 购买域名\n2. 域名解析\n3. 将域名和github仓库关联起来\n\n将域名和github仓库关联起来：在该项目下创建CNAME，其CNAME内容即是域名（当你迁移博客，或者修改博客模板时，一定要记得把这个文件复制到新博客的文件夹里）\n\n测试你的域名是否和github pages关联上的方法：\n\n在git shell里\n\n```js\nping panpanfish.com(域名)\n\nping panpan040828.github.io\n\n```\n\n看两者所对应的ip地址是否是一样的\n\n\n\n\n\n\n","source":"_posts/2016-03-01-用jekyll搭建博客.md","raw":"---\nlayout: post\ntitle: 用github pages和jekyll搭建博客\ndate: 2016-03-01\ncategories: 搭建博客\ntags: [博客,github]\ndescription: \n---\n\n### 一. 关于一个网站的构成\n一个网站主要由三部分构成：[ 网页 ]、域名、主机空间。\n\n1. 网页：自己写的html、css、js代码以及图片等素材\n\n2. 域名：是一个由字母和数字组成的地址，在浏览器中地址栏输入后就能够访问网站。（域名可以在网上购买）\n\n3. 主机空间：空间就是在网上的一个存储网站内容的地方，也叫虚拟主机。\n\n\t网站空间有一般分为国内空间和国外空间，\n\n\t国内空间对于国内的人来说速度更快，但更贵，且需要备案，\n\n\t国外空间速度不及国内空间，但是不需要备案，且非常便宜。\n\n   本教程搭建的博客的网页部分是用的网上的模板，并自己修改了一部分代码；域名是在GoDaddy上购买的；主机空间用的是github pages给每个个人账号提供的免费空间。\n\n### 二.生成github pages页面\n1.进入自己的github页面，Create a new repository，并将Repository name写成\n（这一部分没写完）\n\n### 三.安装jekyll\njekyll简介：jekyll在启动之后，提供了一个可以在本地调试的功能，并且支持通过添加.md文件来写博客\n\n#### 1. 安装Ruby\n \n下载地址：[http://rubyinstaller.org/downloads/]((http://rubyinstaller.org/downloads/)) \n\n通过 ruby -v 来查看 ruby 是否安装正确\n\n如果出现了版本号，即安装正确\n\n#### 2. 安装DevKit\n\n下载地址：  [http://rubyinstaller.org/downloads/]([http://rubyinstaller.org/downloads/](http://rubyinstaller.org/downloads/))\n\n\tcd C:\\rubydevkit   /*进入安装DevKit的文件夹*/\n\n\truby dk.rb init   \t/*生成config.yml文件*/\n\n\tnotepad config.yml\t/*打开config.yml文件*/\n\n修改 config.yml 文件：在打开的记事本中的最后面添加两行新的代码（如下所示），并保存（注意：每次改动了 config.yml 文件后需要重新启动jekyll才能生效）\n\n\t- C:\\ruby  /*ruby为你安装的ruby的文件夹*/\n  \n\t- C:\\ruby\n\n再输入下一行\n\n\truby dk.rb install\n\n如果在 * ruby dk.rb init 这一步出现问题，可能是安装的 Ruby 和 DevKit 版本不对\n\t\n我选择的是Ruby 2.0.0-p648(x64) 以及对应的 DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe\n\n#### 3.  修改gem镜像到taobao网\n\n\tgem -v     /*查看gem的版本号确保gem正确安装*/\n\t\n\tgem source --remove https://rubygems.org/\n\t\n\tgem source -a https://ruby.taobao.org/\n\t\n\tgem source /*查看gem的source是否为taobao镜像*/\n\t\n\tgem update --system\n\n#### 4. 安装jekyll\n\n\tgem install jekyll\n\n#### 5.启动jekyll\n\n\tjekyll new myblog  /*创建一个jekyll文件夹，名为myblog*/\n\n\tcd myblog\n\n\tjekyll serve       /*在名为myblog的文件夹中启动jekyll*/\n\n#### 6. 将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\n\n#### 7. 在启动jekyll之后，本地调试网址：http://localhost:4000/\n\n通过markdown编辑器写好的.md文件放在_posts文件夹内\n\n#### 8. 将myblog的文件夹push到github上，就可以通过 https://username.github.io/ 访问博客\n\n\n### 四.域名\n\n1. 购买域名\n2. 域名解析\n3. 将域名和github仓库关联起来\n\n将域名和github仓库关联起来：在该项目下创建CNAME，其CNAME内容即是域名（当你迁移博客，或者修改博客模板时，一定要记得把这个文件复制到新博客的文件夹里）\n\n测试你的域名是否和github pages关联上的方法：\n\n在git shell里\n\n```js\nping panpanfish.com(域名)\n\nping panpan040828.github.io\n\n```\n\n看两者所对应的ip地址是否是一样的\n\n\n\n\n\n\n","slug":"2016-03-01-用jekyll搭建博客","published":1,"updated":"2016-05-31T13:51:02.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocbl0005d5u8x79yb7f4","content":"<h3 id=\"一-关于一个网站的构成\"><a href=\"#一-关于一个网站的构成\" class=\"headerlink\" title=\"一. 关于一个网站的构成\"></a>一. 关于一个网站的构成</h3><p>一个网站主要由三部分构成：[ 网页 ]、域名、主机空间。</p>\n<ol>\n<li><p>网页：自己写的html、css、js代码以及图片等素材</p>\n</li>\n<li><p>域名：是一个由字母和数字组成的地址，在浏览器中地址栏输入后就能够访问网站。（域名可以在网上购买）</p>\n</li>\n<li><p>主机空间：空间就是在网上的一个存储网站内容的地方，也叫虚拟主机。</p>\n<p> 网站空间有一般分为国内空间和国外空间，</p>\n<p> 国内空间对于国内的人来说速度更快，但更贵，且需要备案，</p>\n<p> 国外空间速度不及国内空间，但是不需要备案，且非常便宜。</p>\n<p>本教程搭建的博客的网页部分是用的网上的模板，并自己修改了一部分代码；域名是在GoDaddy上购买的；主机空间用的是github pages给每个个人账号提供的免费空间。</p>\n</li>\n</ol>\n<h3 id=\"二-生成github-pages页面\"><a href=\"#二-生成github-pages页面\" class=\"headerlink\" title=\"二.生成github pages页面\"></a>二.生成github pages页面</h3><p>1.进入自己的github页面，Create a new repository，并将Repository name写成<br>（这一部分没写完）</p>\n<h3 id=\"三-安装jekyll\"><a href=\"#三-安装jekyll\" class=\"headerlink\" title=\"三.安装jekyll\"></a>三.安装jekyll</h3><p>jekyll简介：jekyll在启动之后，提供了一个可以在本地调试的功能，并且支持通过添加.md文件来写博客</p>\n<h4 id=\"1-安装Ruby\"><a href=\"#1-安装Ruby\" class=\"headerlink\" title=\"1. 安装Ruby\"></a>1. 安装Ruby</h4><p>下载地址：<a href=\"(http://rubyinstaller.org/downloads/\">http://rubyinstaller.org/downloads/</a>) </p>\n<p>通过 ruby -v 来查看 ruby 是否安装正确</p>\n<p>如果出现了版本号，即安装正确</p>\n<h4 id=\"2-安装DevKit\"><a href=\"#2-安装DevKit\" class=\"headerlink\" title=\"2. 安装DevKit\"></a>2. 安装DevKit</h4><p>下载地址：  <a href=\"[http://rubyinstaller.org/downloads/](http://rubyinstaller.org/downloads/\">http://rubyinstaller.org/downloads/</a>)</p>\n<pre><code>cd C:\\rubydevkit   /*进入安装DevKit的文件夹*/\n\nruby dk.rb init       /*生成config.yml文件*/\n\nnotepad config.yml    /*打开config.yml文件*/\n</code></pre><p>修改 config.yml 文件：在打开的记事本中的最后面添加两行新的代码（如下所示），并保存（注意：每次改动了 config.yml 文件后需要重新启动jekyll才能生效）</p>\n<pre><code>- C:\\ruby  /*ruby为你安装的ruby的文件夹*/\n\n- C:\\ruby\n</code></pre><p>再输入下一行</p>\n<pre><code>ruby dk.rb install\n</code></pre><p>如果在 * ruby dk.rb init 这一步出现问题，可能是安装的 Ruby 和 DevKit 版本不对</p>\n<p>我选择的是Ruby 2.0.0-p648(x64) 以及对应的 DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe</p>\n<h4 id=\"3-修改gem镜像到taobao网\"><a href=\"#3-修改gem镜像到taobao网\" class=\"headerlink\" title=\"3.  修改gem镜像到taobao网\"></a>3.  修改gem镜像到taobao网</h4><pre><code>gem -v     /*查看gem的版本号确保gem正确安装*/\n\ngem source --remove https://rubygems.org/\n\ngem source -a https://ruby.taobao.org/\n\ngem source /*查看gem的source是否为taobao镜像*/\n\ngem update --system\n</code></pre><h4 id=\"4-安装jekyll\"><a href=\"#4-安装jekyll\" class=\"headerlink\" title=\"4. 安装jekyll\"></a>4. 安装jekyll</h4><pre><code>gem install jekyll\n</code></pre><h4 id=\"5-启动jekyll\"><a href=\"#5-启动jekyll\" class=\"headerlink\" title=\"5.启动jekyll\"></a>5.启动jekyll</h4><pre><code>jekyll new myblog  /*创建一个jekyll文件夹，名为myblog*/\n\ncd myblog\n\njekyll serve       /*在名为myblog的文件夹中启动jekyll*/\n</code></pre><h4 id=\"6-将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\"><a href=\"#6-将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\" class=\"headerlink\" title=\"6. 将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\"></a>6. 将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中</h4><h4 id=\"7-在启动jekyll之后，本地调试网址：http-localhost-4000\"><a href=\"#7-在启动jekyll之后，本地调试网址：http-localhost-4000\" class=\"headerlink\" title=\"7. 在启动jekyll之后，本地调试网址：http://localhost:4000/\"></a>7. 在启动jekyll之后，本地调试网址：<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a></h4><p>通过markdown编辑器写好的.md文件放在_posts文件夹内</p>\n<h4 id=\"8-将myblog的文件夹push到github上，就可以通过-https-username-github-io-访问博客\"><a href=\"#8-将myblog的文件夹push到github上，就可以通过-https-username-github-io-访问博客\" class=\"headerlink\" title=\"8. 将myblog的文件夹push到github上，就可以通过 https://username.github.io/ 访问博客\"></a>8. 将myblog的文件夹push到github上，就可以通过 <a href=\"https://username.github.io/\" target=\"_blank\" rel=\"external\">https://username.github.io/</a> 访问博客</h4><h3 id=\"四-域名\"><a href=\"#四-域名\" class=\"headerlink\" title=\"四.域名\"></a>四.域名</h3><ol>\n<li>购买域名</li>\n<li>域名解析</li>\n<li>将域名和github仓库关联起来</li>\n</ol>\n<p>将域名和github仓库关联起来：在该项目下创建CNAME，其CNAME内容即是域名（当你迁移博客，或者修改博客模板时，一定要记得把这个文件复制到新博客的文件夹里）</p>\n<p>测试你的域名是否和github pages关联上的方法：</p>\n<p>在git shell里</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping panpanfish.com(域名)</span><br><span class=\"line\"></span><br><span class=\"line\">ping panpan040828.github.io</span><br></pre></td></tr></table></figure>\n<p>看两者所对应的ip地址是否是一样的</p>\n","excerpt":"","more":"<h3 id=\"一-关于一个网站的构成\"><a href=\"#一-关于一个网站的构成\" class=\"headerlink\" title=\"一. 关于一个网站的构成\"></a>一. 关于一个网站的构成</h3><p>一个网站主要由三部分构成：[ 网页 ]、域名、主机空间。</p>\n<ol>\n<li><p>网页：自己写的html、css、js代码以及图片等素材</p>\n</li>\n<li><p>域名：是一个由字母和数字组成的地址，在浏览器中地址栏输入后就能够访问网站。（域名可以在网上购买）</p>\n</li>\n<li><p>主机空间：空间就是在网上的一个存储网站内容的地方，也叫虚拟主机。</p>\n<p> 网站空间有一般分为国内空间和国外空间，</p>\n<p> 国内空间对于国内的人来说速度更快，但更贵，且需要备案，</p>\n<p> 国外空间速度不及国内空间，但是不需要备案，且非常便宜。</p>\n<p>本教程搭建的博客的网页部分是用的网上的模板，并自己修改了一部分代码；域名是在GoDaddy上购买的；主机空间用的是github pages给每个个人账号提供的免费空间。</p>\n</li>\n</ol>\n<h3 id=\"二-生成github-pages页面\"><a href=\"#二-生成github-pages页面\" class=\"headerlink\" title=\"二.生成github pages页面\"></a>二.生成github pages页面</h3><p>1.进入自己的github页面，Create a new repository，并将Repository name写成<br>（这一部分没写完）</p>\n<h3 id=\"三-安装jekyll\"><a href=\"#三-安装jekyll\" class=\"headerlink\" title=\"三.安装jekyll\"></a>三.安装jekyll</h3><p>jekyll简介：jekyll在启动之后，提供了一个可以在本地调试的功能，并且支持通过添加.md文件来写博客</p>\n<h4 id=\"1-安装Ruby\"><a href=\"#1-安装Ruby\" class=\"headerlink\" title=\"1. 安装Ruby\"></a>1. 安装Ruby</h4><p>下载地址：<a href=\"(http://rubyinstaller.org/downloads/\">http://rubyinstaller.org/downloads/</a>) </p>\n<p>通过 ruby -v 来查看 ruby 是否安装正确</p>\n<p>如果出现了版本号，即安装正确</p>\n<h4 id=\"2-安装DevKit\"><a href=\"#2-安装DevKit\" class=\"headerlink\" title=\"2. 安装DevKit\"></a>2. 安装DevKit</h4><p>下载地址：  <a href=\"[http://rubyinstaller.org/downloads/](http://rubyinstaller.org/downloads/\">http://rubyinstaller.org/downloads/</a>)</p>\n<pre><code>cd C:\\rubydevkit   /*进入安装DevKit的文件夹*/\n\nruby dk.rb init       /*生成config.yml文件*/\n\nnotepad config.yml    /*打开config.yml文件*/\n</code></pre><p>修改 config.yml 文件：在打开的记事本中的最后面添加两行新的代码（如下所示），并保存（注意：每次改动了 config.yml 文件后需要重新启动jekyll才能生效）</p>\n<pre><code>- C:\\ruby  /*ruby为你安装的ruby的文件夹*/\n\n- C:\\ruby\n</code></pre><p>再输入下一行</p>\n<pre><code>ruby dk.rb install\n</code></pre><p>如果在 * ruby dk.rb init 这一步出现问题，可能是安装的 Ruby 和 DevKit 版本不对</p>\n<p>我选择的是Ruby 2.0.0-p648(x64) 以及对应的 DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe</p>\n<h4 id=\"3-修改gem镜像到taobao网\"><a href=\"#3-修改gem镜像到taobao网\" class=\"headerlink\" title=\"3.  修改gem镜像到taobao网\"></a>3.  修改gem镜像到taobao网</h4><pre><code>gem -v     /*查看gem的版本号确保gem正确安装*/\n\ngem source --remove https://rubygems.org/\n\ngem source -a https://ruby.taobao.org/\n\ngem source /*查看gem的source是否为taobao镜像*/\n\ngem update --system\n</code></pre><h4 id=\"4-安装jekyll\"><a href=\"#4-安装jekyll\" class=\"headerlink\" title=\"4. 安装jekyll\"></a>4. 安装jekyll</h4><pre><code>gem install jekyll\n</code></pre><h4 id=\"5-启动jekyll\"><a href=\"#5-启动jekyll\" class=\"headerlink\" title=\"5.启动jekyll\"></a>5.启动jekyll</h4><pre><code>jekyll new myblog  /*创建一个jekyll文件夹，名为myblog*/\n\ncd myblog\n\njekyll serve       /*在名为myblog的文件夹中启动jekyll*/\n</code></pre><h4 id=\"6-将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\"><a href=\"#6-将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\" class=\"headerlink\" title=\"6. 将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中\"></a>6. 将下载的jekyll模板拷贝到创建的博客文件夹（第5步的myblog）中</h4><h4 id=\"7-在启动jekyll之后，本地调试网址：http-localhost-4000\"><a href=\"#7-在启动jekyll之后，本地调试网址：http-localhost-4000\" class=\"headerlink\" title=\"7. 在启动jekyll之后，本地调试网址：http://localhost:4000/\"></a>7. 在启动jekyll之后，本地调试网址：<a href=\"http://localhost:4000/\">http://localhost:4000/</a></h4><p>通过markdown编辑器写好的.md文件放在_posts文件夹内</p>\n<h4 id=\"8-将myblog的文件夹push到github上，就可以通过-https-username-github-io-访问博客\"><a href=\"#8-将myblog的文件夹push到github上，就可以通过-https-username-github-io-访问博客\" class=\"headerlink\" title=\"8. 将myblog的文件夹push到github上，就可以通过 https://username.github.io/ 访问博客\"></a>8. 将myblog的文件夹push到github上，就可以通过 <a href=\"https://username.github.io/\">https://username.github.io/</a> 访问博客</h4><h3 id=\"四-域名\"><a href=\"#四-域名\" class=\"headerlink\" title=\"四.域名\"></a>四.域名</h3><ol>\n<li>购买域名</li>\n<li>域名解析</li>\n<li>将域名和github仓库关联起来</li>\n</ol>\n<p>将域名和github仓库关联起来：在该项目下创建CNAME，其CNAME内容即是域名（当你迁移博客，或者修改博客模板时，一定要记得把这个文件复制到新博客的文件夹里）</p>\n<p>测试你的域名是否和github pages关联上的方法：</p>\n<p>在git shell里</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping panpanfish.com(域名)</span><br><span class=\"line\"></span><br><span class=\"line\">ping panpan040828.github.io</span><br></pre></td></tr></table></figure>\n<p>看两者所对应的ip地址是否是一样的</p>\n"},{"layout":"post","title":"解决兼容性问题记录","date":"2016-02-29T16:00:00.000Z","description":null,"_content":"\n#### 1. 事件监听与解绑\n\n**ie:**\n\n    监听事件：obj.attachEvent(\"on...\",fn);\n    解除事件：obj.detachEvent(\"on...\",fn);\n\n**其他：**\n\n    监听事件：obj.addEventListener(\"type\",fn,false);\n    解除事件：obj.removeEventListener(\"type\",fn,false);\n\n#### 2. 计算非内嵌样式\n\n**ie：**\n\n    obj.currentStyle.attr 或者 obj.currentStyle[attr]\n\n**其他：**\n\n    document.defaultView.getComputedStyle(obj,null).attr\n    或者\n    document.defaultView.getComputedStyle(obj,null)[attr]\n\n#### 3. 获取页面滚动条距离顶端的距离\n\n关于获取**浏览器的滚动条距离顶端的距离**，有下面两种方法，存在兼容性问题：\n\n- document.body.scrollTop\n- document.documentElement.scrollTop\n\n**（1）文档处于混杂模式下：**\n\n所有浏览器使用`document.body.scrollTop`获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。\n\n**（2）文档处于标准模式下：**\n\n- chrome和safari：使用`document.body.scrollTop`获取\n- IE：使用`document.documentElement.scrollTop`获取\n\n考虑浏览器的兼容性：\n```js\nvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n```\n\n#### 4. IE和其他浏览器中的事件对象`event`\n\n封装一个获取当前事件的派生对象的函数`getEventTarget`\n\n    若使用dom0级绑定事件的方式，那么event是作为window对象的属性存在的\n    \n    IE中，既可以使用window.event，也可以使用函数的第一个参数\n    \n    在其他浏览器中，event是事件的参数\n    \n    在IE中，引发事件的对象是由`event.srcElement`获得；在其他浏览器中，引发事件的对象是由`event.target`获得。\n    \n    function getEventTarget(event) {\n    \tvar eve = window.event || event;\n    \treturn eve.srcElement || eve.target;\n    }\n\n#### 5. 取消事件冒泡\n\n    在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n    \n    在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n    \n    function stopPropagation(event) {\n    \tvar eve = window.event || event;\n    \tif(eve.stopPropagation) {\n    \t\teve.stopPropagation();\n    \t} else {\n    \t\teve.cancelBubble = true;\n    \t}\n    }\n\n#### 6. 取消事件的默认行为\n\n    **事件的默认行为：**例如`<a>`的点击事件的默认行为就是跳转链接\n    \n    在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n    \n    在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n    \n    function preventDefault() {\n    \tvar eve = window.event || event;\n    \tif(eve.preventDefault){\n    \t\teve.preventDefault();\n    \t} else {\n    \t\teve.returnValue = false;\n    \t}\n    }\n\n\n\n","source":"_posts/2016-03-01-在做demo过程中遇到解决兼容性问题记录.md","raw":"---\nlayout: post\ntitle: 解决兼容性问题记录\ndate: 2016-03-01\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n#### 1. 事件监听与解绑\n\n**ie:**\n\n    监听事件：obj.attachEvent(\"on...\",fn);\n    解除事件：obj.detachEvent(\"on...\",fn);\n\n**其他：**\n\n    监听事件：obj.addEventListener(\"type\",fn,false);\n    解除事件：obj.removeEventListener(\"type\",fn,false);\n\n#### 2. 计算非内嵌样式\n\n**ie：**\n\n    obj.currentStyle.attr 或者 obj.currentStyle[attr]\n\n**其他：**\n\n    document.defaultView.getComputedStyle(obj,null).attr\n    或者\n    document.defaultView.getComputedStyle(obj,null)[attr]\n\n#### 3. 获取页面滚动条距离顶端的距离\n\n关于获取**浏览器的滚动条距离顶端的距离**，有下面两种方法，存在兼容性问题：\n\n- document.body.scrollTop\n- document.documentElement.scrollTop\n\n**（1）文档处于混杂模式下：**\n\n所有浏览器使用`document.body.scrollTop`获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。\n\n**（2）文档处于标准模式下：**\n\n- chrome和safari：使用`document.body.scrollTop`获取\n- IE：使用`document.documentElement.scrollTop`获取\n\n考虑浏览器的兼容性：\n```js\nvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n```\n\n#### 4. IE和其他浏览器中的事件对象`event`\n\n封装一个获取当前事件的派生对象的函数`getEventTarget`\n\n    若使用dom0级绑定事件的方式，那么event是作为window对象的属性存在的\n    \n    IE中，既可以使用window.event，也可以使用函数的第一个参数\n    \n    在其他浏览器中，event是事件的参数\n    \n    在IE中，引发事件的对象是由`event.srcElement`获得；在其他浏览器中，引发事件的对象是由`event.target`获得。\n    \n    function getEventTarget(event) {\n    \tvar eve = window.event || event;\n    \treturn eve.srcElement || eve.target;\n    }\n\n#### 5. 取消事件冒泡\n\n    在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n    \n    在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n    \n    function stopPropagation(event) {\n    \tvar eve = window.event || event;\n    \tif(eve.stopPropagation) {\n    \t\teve.stopPropagation();\n    \t} else {\n    \t\teve.cancelBubble = true;\n    \t}\n    }\n\n#### 6. 取消事件的默认行为\n\n    **事件的默认行为：**例如`<a>`的点击事件的默认行为就是跳转链接\n    \n    在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n    \n    在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n    \n    function preventDefault() {\n    \tvar eve = window.event || event;\n    \tif(eve.preventDefault){\n    \t\teve.preventDefault();\n    \t} else {\n    \t\teve.returnValue = false;\n    \t}\n    }\n\n\n\n","slug":"2016-03-01-在做demo过程中遇到解决兼容性问题记录","published":1,"updated":"2016-08-11T06:35:32.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocbn0006d5u8pbl5erl9","content":"<h4 id=\"1-事件监听与解绑\"><a href=\"#1-事件监听与解绑\" class=\"headerlink\" title=\"1. 事件监听与解绑\"></a>1. 事件监听与解绑</h4><p><strong>ie:</strong></p>\n<pre><code>监听事件：obj.attachEvent(&quot;on...&quot;,fn);\n解除事件：obj.detachEvent(&quot;on...&quot;,fn);\n</code></pre><p><strong>其他：</strong></p>\n<pre><code>监听事件：obj.addEventListener(&quot;type&quot;,fn,false);\n解除事件：obj.removeEventListener(&quot;type&quot;,fn,false);\n</code></pre><h4 id=\"2-计算非内嵌样式\"><a href=\"#2-计算非内嵌样式\" class=\"headerlink\" title=\"2. 计算非内嵌样式\"></a>2. 计算非内嵌样式</h4><p><strong>ie：</strong></p>\n<pre><code>obj.currentStyle.attr 或者 obj.currentStyle[attr]\n</code></pre><p><strong>其他：</strong></p>\n<pre><code>document.defaultView.getComputedStyle(obj,null).attr\n或者\ndocument.defaultView.getComputedStyle(obj,null)[attr]\n</code></pre><h4 id=\"3-获取页面滚动条距离顶端的距离\"><a href=\"#3-获取页面滚动条距离顶端的距离\" class=\"headerlink\" title=\"3. 获取页面滚动条距离顶端的距离\"></a>3. 获取页面滚动条距离顶端的距离</h4><p>关于获取<strong>浏览器的滚动条距离顶端的距离</strong>，有下面两种方法，存在兼容性问题：</p>\n<ul>\n<li>document.body.scrollTop</li>\n<li>document.documentElement.scrollTop</li>\n</ul>\n<p><strong>（1）文档处于混杂模式下：</strong></p>\n<p>所有浏览器使用<code>document.body.scrollTop</code>获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。</p>\n<p><strong>（2）文档处于标准模式下：</strong></p>\n<ul>\n<li>chrome和safari：使用<code>document.body.scrollTop</code>获取</li>\n<li>IE：使用<code>document.documentElement.scrollTop</code>获取</li>\n</ul>\n<p>考虑浏览器的兼容性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-IE和其他浏览器中的事件对象event\"><a href=\"#4-IE和其他浏览器中的事件对象event\" class=\"headerlink\" title=\"4. IE和其他浏览器中的事件对象event\"></a>4. IE和其他浏览器中的事件对象<code>event</code></h4><p>封装一个获取当前事件的派生对象的函数<code>getEventTarget</code></p>\n<pre><code>若使用dom0级绑定事件的方式，那么event是作为window对象的属性存在的\n\nIE中，既可以使用window.event，也可以使用函数的第一个参数\n\n在其他浏览器中，event是事件的参数\n\n在IE中，引发事件的对象是由`event.srcElement`获得；在其他浏览器中，引发事件的对象是由`event.target`获得。\n\nfunction getEventTarget(event) {\n    var eve = window.event || event;\n    return eve.srcElement || eve.target;\n}\n</code></pre><h4 id=\"5-取消事件冒泡\"><a href=\"#5-取消事件冒泡\" class=\"headerlink\" title=\"5. 取消事件冒泡\"></a>5. 取消事件冒泡</h4><pre><code>在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n\n在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n\nfunction stopPropagation(event) {\n    var eve = window.event || event;\n    if(eve.stopPropagation) {\n        eve.stopPropagation();\n    } else {\n        eve.cancelBubble = true;\n    }\n}\n</code></pre><h4 id=\"6-取消事件的默认行为\"><a href=\"#6-取消事件的默认行为\" class=\"headerlink\" title=\"6. 取消事件的默认行为\"></a>6. 取消事件的默认行为</h4><pre><code>**事件的默认行为：**例如`&lt;a&gt;`的点击事件的默认行为就是跳转链接\n\n在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n\n在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n\nfunction preventDefault() {\n    var eve = window.event || event;\n    if(eve.preventDefault){\n        eve.preventDefault();\n    } else {\n        eve.returnValue = false;\n    }\n}\n</code></pre>","excerpt":"","more":"<h4 id=\"1-事件监听与解绑\"><a href=\"#1-事件监听与解绑\" class=\"headerlink\" title=\"1. 事件监听与解绑\"></a>1. 事件监听与解绑</h4><p><strong>ie:</strong></p>\n<pre><code>监听事件：obj.attachEvent(&quot;on...&quot;,fn);\n解除事件：obj.detachEvent(&quot;on...&quot;,fn);\n</code></pre><p><strong>其他：</strong></p>\n<pre><code>监听事件：obj.addEventListener(&quot;type&quot;,fn,false);\n解除事件：obj.removeEventListener(&quot;type&quot;,fn,false);\n</code></pre><h4 id=\"2-计算非内嵌样式\"><a href=\"#2-计算非内嵌样式\" class=\"headerlink\" title=\"2. 计算非内嵌样式\"></a>2. 计算非内嵌样式</h4><p><strong>ie：</strong></p>\n<pre><code>obj.currentStyle.attr 或者 obj.currentStyle[attr]\n</code></pre><p><strong>其他：</strong></p>\n<pre><code>document.defaultView.getComputedStyle(obj,null).attr\n或者\ndocument.defaultView.getComputedStyle(obj,null)[attr]\n</code></pre><h4 id=\"3-获取页面滚动条距离顶端的距离\"><a href=\"#3-获取页面滚动条距离顶端的距离\" class=\"headerlink\" title=\"3. 获取页面滚动条距离顶端的距离\"></a>3. 获取页面滚动条距离顶端的距离</h4><p>关于获取<strong>浏览器的滚动条距离顶端的距离</strong>，有下面两种方法，存在兼容性问题：</p>\n<ul>\n<li>document.body.scrollTop</li>\n<li>document.documentElement.scrollTop</li>\n</ul>\n<p><strong>（1）文档处于混杂模式下：</strong></p>\n<p>所有浏览器使用<code>document.body.scrollTop</code>获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。</p>\n<p><strong>（2）文档处于标准模式下：</strong></p>\n<ul>\n<li>chrome和safari：使用<code>document.body.scrollTop</code>获取</li>\n<li>IE：使用<code>document.documentElement.scrollTop</code>获取</li>\n</ul>\n<p>考虑浏览器的兼容性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-IE和其他浏览器中的事件对象event\"><a href=\"#4-IE和其他浏览器中的事件对象event\" class=\"headerlink\" title=\"4. IE和其他浏览器中的事件对象event\"></a>4. IE和其他浏览器中的事件对象<code>event</code></h4><p>封装一个获取当前事件的派生对象的函数<code>getEventTarget</code></p>\n<pre><code>若使用dom0级绑定事件的方式，那么event是作为window对象的属性存在的\n\nIE中，既可以使用window.event，也可以使用函数的第一个参数\n\n在其他浏览器中，event是事件的参数\n\n在IE中，引发事件的对象是由`event.srcElement`获得；在其他浏览器中，引发事件的对象是由`event.target`获得。\n\nfunction getEventTarget(event) {\n    var eve = window.event || event;\n    return eve.srcElement || eve.target;\n}\n</code></pre><h4 id=\"5-取消事件冒泡\"><a href=\"#5-取消事件冒泡\" class=\"headerlink\" title=\"5. 取消事件冒泡\"></a>5. 取消事件冒泡</h4><pre><code>在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n\n在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n\nfunction stopPropagation(event) {\n    var eve = window.event || event;\n    if(eve.stopPropagation) {\n        eve.stopPropagation();\n    } else {\n        eve.cancelBubble = true;\n    }\n}\n</code></pre><h4 id=\"6-取消事件的默认行为\"><a href=\"#6-取消事件的默认行为\" class=\"headerlink\" title=\"6. 取消事件的默认行为\"></a>6. 取消事件的默认行为</h4><pre><code>**事件的默认行为：**例如`&lt;a&gt;`的点击事件的默认行为就是跳转链接\n\n在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n\n在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n\nfunction preventDefault() {\n    var eve = window.event || event;\n    if(eve.preventDefault){\n        eve.preventDefault();\n    } else {\n        eve.returnValue = false;\n    }\n}\n</code></pre>"},{"layout":"post","title":"浏览器显示页面","date":"2016-03-02T16:00:00.000Z","description":null,"_content":"\n### 一. 浏览器内核\n\n浏览器的功能：显示在计算机中的网页实际上是位于许多不同的计算机文件中的元素的集合。因此，浏览器的功能首先是检索文件，然后将页面的各个部分组合起来，根据文本中的html命令排列这些部分。\n\n**浏览器内核**分为两部分：渲染引擎 和 JavaScript引擎。其中，**渲染引擎**是浏览器内核中比较重要的部分，现在所说的内核一般指的都是渲染引擎。\n\n常见的浏览器内核：Trident、Gecko、Presto、Webkit\n\n### 二.  浏览器显示页面的步骤\n\n#### 1. 从网络层（networking）获取请求文档的内容，解析HTML/SVG/XHTML，形成一个DOM树(DOM Tree)\n\n默认情况下，**加载**和**执行**javascript都会阻止DOM tree的构建。\n\n内部js脚本会在引入它的位置执行，外联脚本则是加载完毕后执行。\n\n**注意：**因此，不管是内联脚本还是外部脚本，都应该尽量放在<body>标签结束之前（除非某些脚本需要在页面加载完之前调用），这样可以保证在运行脚本之前，页面已经基本加载完成。\n\n#### 2. 解析CSS代码，计算出最终的样式数据，产生一个CSS规则树(CSS Rule Tree)\n\n**解析**CSS的时候的顺序：浏览器默认设置，用户设置，外链样式，内联样式，html中的style\n\n#### 3. 解析JavaScript\n\n- 通过**DOM API**来操作**DOM Tree**\n- 通过**CSSOM API**来操作**CSS Rule Tree**\n\n#### 4. 解析完上述三种代码之后，就构建一个渲染树 (rendering tree)\n\n**渲染树和DOM树有所不同：**\n\n\t渲染树中不包括不需要渲染的节点\n    eg : \n\t    html \n\t    head\n\t    meta\n\t    link\n\t    style\n\t    script\n\t    display : none的元素\n\n渲染树中每一个节点都储存有对应的CSS属性\n\n加载css会阻止render tree的构建\n\n#### 5. 开始渲染\n\n页面初始化时会发生一次回流\n\n### 三. 页面的重绘和回流\n\n#### 1. 什么是页面的重绘和回流\n\n**回流：**当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。（需要改变布局、几何属性）\n\n**重绘：**当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，**而不会影响布局的**，比如background-color。则就叫称为重绘。\n\n**回流必定影响重绘，重绘不一定引起回流。**\n\n**回流比重绘的代价要更高**\n\n#### 2. 回流何时发生\n\n当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：\n\n1、添加或者删除可见的DOM元素；\n\n2、元素位置改变；\n\n3、元素尺寸改变——边距、填充、边框、宽度和高度\n\n4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；\n\n5、页面渲染初始化；\n\n6、浏览器窗口尺寸改变——resize事件发生时；（所以需要函数节流）\n\n#### 3. 浏览器对回流和重绘做的优化工作\n\n浏览器会维护**1个队列**，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会**释放队列**，进行一个批处理。**这样就会让多次的回流、重绘变成一次回流重绘**。\n\n虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前释放队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器释放队列，比如：\n\n1. offsetTop, offsetLeft, offsetWidth, offsetHeight\n\n2. scrollTop/Left/Width/Height\n\n3. clientTop/Left/Width/Height\n\n4. width,height\n\n5. 请求了getComputedStyle(), 或者 IE的 currentStyle\n\n当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要释放队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。\n\n#### 4. 减少回流reflow和重绘repaint\n\n**(1) 不要一条条修改DOM的样式**\n\n**替换方法：**\n\n- 预先定义好css，然后修改DOM的className\n- 修改style的style.cssText\n\n    eg:\n    \n    // bad\n    var left = 10,\n    top = 10;\n    el.style.left = left + \"px\";\n    el.style.top  = top  + \"px\";\n     \n    // Good 预先定义好css，然后修改DOM的className\n    el.className += \" theclassname\";\n     \n    // Good 修改style的style.cssText\n    el.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\";\n\n**(2) 把DOM离线后修改**\n\n- 先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。\n- clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。\n\n**(3) 不要把DOM结点的属性值放在一个循环里当成循环的变量。**\n\n**(4) 尽可能修改层级比较低的DOM**\n\n**(5) 为动画的HTML元素使用fixed或者absolute的position**\n\n修改他们的CSS是不会reflow的，因为使用fixed或者absolute的元素会脱离文档流~~\n\n**(6) 千万不要使用table布局**\n\n<font color=\"red\">注意：CSS匹配DOM Tree主要是从右到左解析CSS的Selector，CSS匹配HTML元素是一个相当复杂和有性能问题的事情。DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。</font>\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-03-浏览器渲染页面.md","raw":"---\nlayout: post\ntitle: 浏览器显示页面\ndate: 2016-03-03\ncategories: 浏览器\ntags: [浏览器]\ndescription: \n---\n\n### 一. 浏览器内核\n\n浏览器的功能：显示在计算机中的网页实际上是位于许多不同的计算机文件中的元素的集合。因此，浏览器的功能首先是检索文件，然后将页面的各个部分组合起来，根据文本中的html命令排列这些部分。\n\n**浏览器内核**分为两部分：渲染引擎 和 JavaScript引擎。其中，**渲染引擎**是浏览器内核中比较重要的部分，现在所说的内核一般指的都是渲染引擎。\n\n常见的浏览器内核：Trident、Gecko、Presto、Webkit\n\n### 二.  浏览器显示页面的步骤\n\n#### 1. 从网络层（networking）获取请求文档的内容，解析HTML/SVG/XHTML，形成一个DOM树(DOM Tree)\n\n默认情况下，**加载**和**执行**javascript都会阻止DOM tree的构建。\n\n内部js脚本会在引入它的位置执行，外联脚本则是加载完毕后执行。\n\n**注意：**因此，不管是内联脚本还是外部脚本，都应该尽量放在<body>标签结束之前（除非某些脚本需要在页面加载完之前调用），这样可以保证在运行脚本之前，页面已经基本加载完成。\n\n#### 2. 解析CSS代码，计算出最终的样式数据，产生一个CSS规则树(CSS Rule Tree)\n\n**解析**CSS的时候的顺序：浏览器默认设置，用户设置，外链样式，内联样式，html中的style\n\n#### 3. 解析JavaScript\n\n- 通过**DOM API**来操作**DOM Tree**\n- 通过**CSSOM API**来操作**CSS Rule Tree**\n\n#### 4. 解析完上述三种代码之后，就构建一个渲染树 (rendering tree)\n\n**渲染树和DOM树有所不同：**\n\n\t渲染树中不包括不需要渲染的节点\n    eg : \n\t    html \n\t    head\n\t    meta\n\t    link\n\t    style\n\t    script\n\t    display : none的元素\n\n渲染树中每一个节点都储存有对应的CSS属性\n\n加载css会阻止render tree的构建\n\n#### 5. 开始渲染\n\n页面初始化时会发生一次回流\n\n### 三. 页面的重绘和回流\n\n#### 1. 什么是页面的重绘和回流\n\n**回流：**当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。（需要改变布局、几何属性）\n\n**重绘：**当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，**而不会影响布局的**，比如background-color。则就叫称为重绘。\n\n**回流必定影响重绘，重绘不一定引起回流。**\n\n**回流比重绘的代价要更高**\n\n#### 2. 回流何时发生\n\n当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：\n\n1、添加或者删除可见的DOM元素；\n\n2、元素位置改变；\n\n3、元素尺寸改变——边距、填充、边框、宽度和高度\n\n4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；\n\n5、页面渲染初始化；\n\n6、浏览器窗口尺寸改变——resize事件发生时；（所以需要函数节流）\n\n#### 3. 浏览器对回流和重绘做的优化工作\n\n浏览器会维护**1个队列**，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会**释放队列**，进行一个批处理。**这样就会让多次的回流、重绘变成一次回流重绘**。\n\n虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前释放队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器释放队列，比如：\n\n1. offsetTop, offsetLeft, offsetWidth, offsetHeight\n\n2. scrollTop/Left/Width/Height\n\n3. clientTop/Left/Width/Height\n\n4. width,height\n\n5. 请求了getComputedStyle(), 或者 IE的 currentStyle\n\n当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要释放队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。\n\n#### 4. 减少回流reflow和重绘repaint\n\n**(1) 不要一条条修改DOM的样式**\n\n**替换方法：**\n\n- 预先定义好css，然后修改DOM的className\n- 修改style的style.cssText\n\n    eg:\n    \n    // bad\n    var left = 10,\n    top = 10;\n    el.style.left = left + \"px\";\n    el.style.top  = top  + \"px\";\n     \n    // Good 预先定义好css，然后修改DOM的className\n    el.className += \" theclassname\";\n     \n    // Good 修改style的style.cssText\n    el.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\";\n\n**(2) 把DOM离线后修改**\n\n- 先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。\n- clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。\n\n**(3) 不要把DOM结点的属性值放在一个循环里当成循环的变量。**\n\n**(4) 尽可能修改层级比较低的DOM**\n\n**(5) 为动画的HTML元素使用fixed或者absolute的position**\n\n修改他们的CSS是不会reflow的，因为使用fixed或者absolute的元素会脱离文档流~~\n\n**(6) 千万不要使用table布局**\n\n<font color=\"red\">注意：CSS匹配DOM Tree主要是从右到左解析CSS的Selector，CSS匹配HTML元素是一个相当复杂和有性能问题的事情。DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。</font>\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-03-浏览器渲染页面","published":1,"updated":"2016-08-20T08:57:10.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocbq0008d5u8qexe4waz","content":"<h3 id=\"一-浏览器内核\"><a href=\"#一-浏览器内核\" class=\"headerlink\" title=\"一. 浏览器内核\"></a>一. 浏览器内核</h3><p>浏览器的功能：显示在计算机中的网页实际上是位于许多不同的计算机文件中的元素的集合。因此，浏览器的功能首先是检索文件，然后将页面的各个部分组合起来，根据文本中的html命令排列这些部分。</p>\n<p><strong>浏览器内核</strong>分为两部分：渲染引擎 和 JavaScript引擎。其中，<strong>渲染引擎</strong>是浏览器内核中比较重要的部分，现在所说的内核一般指的都是渲染引擎。</p>\n<p>常见的浏览器内核：Trident、Gecko、Presto、Webkit</p>\n<h3 id=\"二-浏览器显示页面的步骤\"><a href=\"#二-浏览器显示页面的步骤\" class=\"headerlink\" title=\"二.  浏览器显示页面的步骤\"></a>二.  浏览器显示页面的步骤</h3><h4 id=\"1-从网络层（networking）获取请求文档的内容，解析HTML-SVG-XHTML，形成一个DOM树-DOM-Tree\"><a href=\"#1-从网络层（networking）获取请求文档的内容，解析HTML-SVG-XHTML，形成一个DOM树-DOM-Tree\" class=\"headerlink\" title=\"1. 从网络层（networking）获取请求文档的内容，解析HTML/SVG/XHTML，形成一个DOM树(DOM Tree)\"></a>1. 从网络层（networking）获取请求文档的内容，解析HTML/SVG/XHTML，形成一个DOM树(DOM Tree)</h4><p>默认情况下，<strong>加载</strong>和<strong>执行</strong>javascript都会阻止DOM tree的构建。</p>\n<p>内部js脚本会在引入它的位置执行，外联脚本则是加载完毕后执行。</p>\n<p><strong>注意：</strong>因此，不管是内联脚本还是外部脚本，都应该尽量放在<body>标签结束之前（除非某些脚本需要在页面加载完之前调用），这样可以保证在运行脚本之前，页面已经基本加载完成。</body></p>\n<h4 id=\"2-解析CSS代码，计算出最终的样式数据，产生一个CSS规则树-CSS-Rule-Tree\"><a href=\"#2-解析CSS代码，计算出最终的样式数据，产生一个CSS规则树-CSS-Rule-Tree\" class=\"headerlink\" title=\"2. 解析CSS代码，计算出最终的样式数据，产生一个CSS规则树(CSS Rule Tree)\"></a>2. 解析CSS代码，计算出最终的样式数据，产生一个CSS规则树(CSS Rule Tree)</h4><p><strong>解析</strong>CSS的时候的顺序：浏览器默认设置，用户设置，外链样式，内联样式，html中的style</p>\n<h4 id=\"3-解析JavaScript\"><a href=\"#3-解析JavaScript\" class=\"headerlink\" title=\"3. 解析JavaScript\"></a>3. 解析JavaScript</h4><ul>\n<li>通过<strong>DOM API</strong>来操作<strong>DOM Tree</strong></li>\n<li>通过<strong>CSSOM API</strong>来操作<strong>CSS Rule Tree</strong></li>\n</ul>\n<h4 id=\"4-解析完上述三种代码之后，就构建一个渲染树-rendering-tree\"><a href=\"#4-解析完上述三种代码之后，就构建一个渲染树-rendering-tree\" class=\"headerlink\" title=\"4. 解析完上述三种代码之后，就构建一个渲染树 (rendering tree)\"></a>4. 解析完上述三种代码之后，就构建一个渲染树 (rendering tree)</h4><p><strong>渲染树和DOM树有所不同：</strong></p>\n<pre><code>渲染树中不包括不需要渲染的节点\neg : \n    html \n    head\n    meta\n    link\n    style\n    script\n    display : none的元素\n</code></pre><p>渲染树中每一个节点都储存有对应的CSS属性</p>\n<p>加载css会阻止render tree的构建</p>\n<h4 id=\"5-开始渲染\"><a href=\"#5-开始渲染\" class=\"headerlink\" title=\"5. 开始渲染\"></a>5. 开始渲染</h4><p>页面初始化时会发生一次回流</p>\n<h3 id=\"三-页面的重绘和回流\"><a href=\"#三-页面的重绘和回流\" class=\"headerlink\" title=\"三. 页面的重绘和回流\"></a>三. 页面的重绘和回流</h3><h4 id=\"1-什么是页面的重绘和回流\"><a href=\"#1-什么是页面的重绘和回流\" class=\"headerlink\" title=\"1. 什么是页面的重绘和回流\"></a>1. 什么是页面的重绘和回流</h4><p><strong>回流：</strong>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。（需要改变布局、几何属性）</p>\n<p><strong>重绘：</strong>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，<strong>而不会影响布局的</strong>，比如background-color。则就叫称为重绘。</p>\n<p><strong>回流必定影响重绘，重绘不一定引起回流。</strong></p>\n<p><strong>回流比重绘的代价要更高</strong></p>\n<h4 id=\"2-回流何时发生\"><a href=\"#2-回流何时发生\" class=\"headerlink\" title=\"2. 回流何时发生\"></a>2. 回流何时发生</h4><p>当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：</p>\n<p>1、添加或者删除可见的DOM元素；</p>\n<p>2、元素位置改变；</p>\n<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>\n<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>\n<p>5、页面渲染初始化；</p>\n<p>6、浏览器窗口尺寸改变——resize事件发生时；（所以需要函数节流）</p>\n<h4 id=\"3-浏览器对回流和重绘做的优化工作\"><a href=\"#3-浏览器对回流和重绘做的优化工作\" class=\"headerlink\" title=\"3. 浏览器对回流和重绘做的优化工作\"></a>3. 浏览器对回流和重绘做的优化工作</h4><p>浏览器会维护<strong>1个队列</strong>，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会<strong>释放队列</strong>，进行一个批处理。<strong>这样就会让多次的回流、重绘变成一次回流重绘</strong>。</p>\n<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前释放队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器释放队列，比如：</p>\n<ol>\n<li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p>\n</li>\n<li><p>scrollTop/Left/Width/Height</p>\n</li>\n<li><p>clientTop/Left/Width/Height</p>\n</li>\n<li><p>width,height</p>\n</li>\n<li><p>请求了getComputedStyle(), 或者 IE的 currentStyle</p>\n</li>\n</ol>\n<p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要释放队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。</p>\n<h4 id=\"4-减少回流reflow和重绘repaint\"><a href=\"#4-减少回流reflow和重绘repaint\" class=\"headerlink\" title=\"4. 减少回流reflow和重绘repaint\"></a>4. 减少回流reflow和重绘repaint</h4><p><strong>(1) 不要一条条修改DOM的样式</strong></p>\n<p><strong>替换方法：</strong></p>\n<ul>\n<li>预先定义好css，然后修改DOM的className</li>\n<li><p>修改style的style.cssText</p>\n<p>  eg:</p>\n<p>  // bad<br>  var left = 10,<br>  top = 10;<br>  el.style.left = left + “px”;<br>  el.style.top  = top  + “px”;</p>\n<p>  // Good 预先定义好css，然后修改DOM的className<br>  el.className += “ theclassname”;</p>\n<p>  // Good 修改style的style.cssText<br>  el.style.cssText += “; left: “ + left + “px; top: “ + top + “px;”;</p>\n</li>\n</ul>\n<p><strong>(2) 把DOM离线后修改</strong></p>\n<ul>\n<li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li>\n<li>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>\n</ul>\n<p><strong>(3) 不要把DOM结点的属性值放在一个循环里当成循环的变量。</strong></p>\n<p><strong>(4) 尽可能修改层级比较低的DOM</strong></p>\n<p><strong>(5) 为动画的HTML元素使用fixed或者absolute的position</strong></p>\n<p>修改他们的CSS是不会reflow的，因为使用fixed或者absolute的元素会脱离文档流~~</p>\n<p><strong>(6) 千万不要使用table布局</strong></p>\n<font color=\"red\">注意：CSS匹配DOM Tree主要是从右到左解析CSS的Selector，CSS匹配HTML元素是一个相当复杂和有性能问题的事情。DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。</font>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"","more":"<h3 id=\"一-浏览器内核\"><a href=\"#一-浏览器内核\" class=\"headerlink\" title=\"一. 浏览器内核\"></a>一. 浏览器内核</h3><p>浏览器的功能：显示在计算机中的网页实际上是位于许多不同的计算机文件中的元素的集合。因此，浏览器的功能首先是检索文件，然后将页面的各个部分组合起来，根据文本中的html命令排列这些部分。</p>\n<p><strong>浏览器内核</strong>分为两部分：渲染引擎 和 JavaScript引擎。其中，<strong>渲染引擎</strong>是浏览器内核中比较重要的部分，现在所说的内核一般指的都是渲染引擎。</p>\n<p>常见的浏览器内核：Trident、Gecko、Presto、Webkit</p>\n<h3 id=\"二-浏览器显示页面的步骤\"><a href=\"#二-浏览器显示页面的步骤\" class=\"headerlink\" title=\"二.  浏览器显示页面的步骤\"></a>二.  浏览器显示页面的步骤</h3><h4 id=\"1-从网络层（networking）获取请求文档的内容，解析HTML-SVG-XHTML，形成一个DOM树-DOM-Tree\"><a href=\"#1-从网络层（networking）获取请求文档的内容，解析HTML-SVG-XHTML，形成一个DOM树-DOM-Tree\" class=\"headerlink\" title=\"1. 从网络层（networking）获取请求文档的内容，解析HTML/SVG/XHTML，形成一个DOM树(DOM Tree)\"></a>1. 从网络层（networking）获取请求文档的内容，解析HTML/SVG/XHTML，形成一个DOM树(DOM Tree)</h4><p>默认情况下，<strong>加载</strong>和<strong>执行</strong>javascript都会阻止DOM tree的构建。</p>\n<p>内部js脚本会在引入它的位置执行，外联脚本则是加载完毕后执行。</p>\n<p><strong>注意：</strong>因此，不管是内联脚本还是外部脚本，都应该尽量放在<body>标签结束之前（除非某些脚本需要在页面加载完之前调用），这样可以保证在运行脚本之前，页面已经基本加载完成。</p>\n<h4 id=\"2-解析CSS代码，计算出最终的样式数据，产生一个CSS规则树-CSS-Rule-Tree\"><a href=\"#2-解析CSS代码，计算出最终的样式数据，产生一个CSS规则树-CSS-Rule-Tree\" class=\"headerlink\" title=\"2. 解析CSS代码，计算出最终的样式数据，产生一个CSS规则树(CSS Rule Tree)\"></a>2. 解析CSS代码，计算出最终的样式数据，产生一个CSS规则树(CSS Rule Tree)</h4><p><strong>解析</strong>CSS的时候的顺序：浏览器默认设置，用户设置，外链样式，内联样式，html中的style</p>\n<h4 id=\"3-解析JavaScript\"><a href=\"#3-解析JavaScript\" class=\"headerlink\" title=\"3. 解析JavaScript\"></a>3. 解析JavaScript</h4><ul>\n<li>通过<strong>DOM API</strong>来操作<strong>DOM Tree</strong></li>\n<li>通过<strong>CSSOM API</strong>来操作<strong>CSS Rule Tree</strong></li>\n</ul>\n<h4 id=\"4-解析完上述三种代码之后，就构建一个渲染树-rendering-tree\"><a href=\"#4-解析完上述三种代码之后，就构建一个渲染树-rendering-tree\" class=\"headerlink\" title=\"4. 解析完上述三种代码之后，就构建一个渲染树 (rendering tree)\"></a>4. 解析完上述三种代码之后，就构建一个渲染树 (rendering tree)</h4><p><strong>渲染树和DOM树有所不同：</strong></p>\n<pre><code>渲染树中不包括不需要渲染的节点\neg : \n    html \n    head\n    meta\n    link\n    style\n    script\n    display : none的元素\n</code></pre><p>渲染树中每一个节点都储存有对应的CSS属性</p>\n<p>加载css会阻止render tree的构建</p>\n<h4 id=\"5-开始渲染\"><a href=\"#5-开始渲染\" class=\"headerlink\" title=\"5. 开始渲染\"></a>5. 开始渲染</h4><p>页面初始化时会发生一次回流</p>\n<h3 id=\"三-页面的重绘和回流\"><a href=\"#三-页面的重绘和回流\" class=\"headerlink\" title=\"三. 页面的重绘和回流\"></a>三. 页面的重绘和回流</h3><h4 id=\"1-什么是页面的重绘和回流\"><a href=\"#1-什么是页面的重绘和回流\" class=\"headerlink\" title=\"1. 什么是页面的重绘和回流\"></a>1. 什么是页面的重绘和回流</h4><p><strong>回流：</strong>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。（需要改变布局、几何属性）</p>\n<p><strong>重绘：</strong>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，<strong>而不会影响布局的</strong>，比如background-color。则就叫称为重绘。</p>\n<p><strong>回流必定影响重绘，重绘不一定引起回流。</strong></p>\n<p><strong>回流比重绘的代价要更高</strong></p>\n<h4 id=\"2-回流何时发生\"><a href=\"#2-回流何时发生\" class=\"headerlink\" title=\"2. 回流何时发生\"></a>2. 回流何时发生</h4><p>当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：</p>\n<p>1、添加或者删除可见的DOM元素；</p>\n<p>2、元素位置改变；</p>\n<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>\n<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>\n<p>5、页面渲染初始化；</p>\n<p>6、浏览器窗口尺寸改变——resize事件发生时；（所以需要函数节流）</p>\n<h4 id=\"3-浏览器对回流和重绘做的优化工作\"><a href=\"#3-浏览器对回流和重绘做的优化工作\" class=\"headerlink\" title=\"3. 浏览器对回流和重绘做的优化工作\"></a>3. 浏览器对回流和重绘做的优化工作</h4><p>浏览器会维护<strong>1个队列</strong>，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会<strong>释放队列</strong>，进行一个批处理。<strong>这样就会让多次的回流、重绘变成一次回流重绘</strong>。</p>\n<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前释放队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器释放队列，比如：</p>\n<ol>\n<li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p>\n</li>\n<li><p>scrollTop/Left/Width/Height</p>\n</li>\n<li><p>clientTop/Left/Width/Height</p>\n</li>\n<li><p>width,height</p>\n</li>\n<li><p>请求了getComputedStyle(), 或者 IE的 currentStyle</p>\n</li>\n</ol>\n<p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要释放队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。</p>\n<h4 id=\"4-减少回流reflow和重绘repaint\"><a href=\"#4-减少回流reflow和重绘repaint\" class=\"headerlink\" title=\"4. 减少回流reflow和重绘repaint\"></a>4. 减少回流reflow和重绘repaint</h4><p><strong>(1) 不要一条条修改DOM的样式</strong></p>\n<p><strong>替换方法：</strong></p>\n<ul>\n<li>预先定义好css，然后修改DOM的className</li>\n<li><p>修改style的style.cssText</p>\n<p>  eg:</p>\n<p>  // bad<br>  var left = 10,<br>  top = 10;<br>  el.style.left = left + “px”;<br>  el.style.top  = top  + “px”;</p>\n<p>  // Good 预先定义好css，然后修改DOM的className<br>  el.className += “ theclassname”;</p>\n<p>  // Good 修改style的style.cssText<br>  el.style.cssText += “; left: “ + left + “px; top: “ + top + “px;”;</p>\n</li>\n</ul>\n<p><strong>(2) 把DOM离线后修改</strong></p>\n<ul>\n<li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li>\n<li>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>\n</ul>\n<p><strong>(3) 不要把DOM结点的属性值放在一个循环里当成循环的变量。</strong></p>\n<p><strong>(4) 尽可能修改层级比较低的DOM</strong></p>\n<p><strong>(5) 为动画的HTML元素使用fixed或者absolute的position</strong></p>\n<p>修改他们的CSS是不会reflow的，因为使用fixed或者absolute的元素会脱离文档流~~</p>\n<p><strong>(6) 千万不要使用table布局</strong></p>\n<font color=\"red\">注意：CSS匹配DOM Tree主要是从右到左解析CSS的Selector，CSS匹配HTML元素是一个相当复杂和有性能问题的事情。DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。</font>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"layout":"post","title":"性能优化 资源的非覆盖式发布","date":"2016-03-06T16:00:00.000Z","description":null,"_content":"\n### 一. 大公司的静态资源优化方案\n\n- 配置很长时间的本地缓存 ———— 节省带宽，提高性能\n- 给静态文件添加MD5值 ———— 精确地控制缓存\n- 静态资源CDN部署 ———— 优化网络请求\n- 更新资源发布路径实现非覆盖式发布\n\n**http协议缓存：**\n\n**1. 本地强制缓存**\n\n- expires: 缓存的绝对过期的时间\n- cache-control: 缓存的相对过期时间\n\n也就是说在这个过期日期之前都不会向服务器去请求数据\n\n**2. 304协商缓存**\n\n如果缓存过期了，那么就要进行缓存再验证\n\n请求头里  If-Modified-Since: 表示的是上一次从服务器获取数据的日期\n响应头里  Last-Modified: 表示的是服务器上最近一次修改文件的日期\n\n如果If-Modified-Since中的时间和浏览器最近一次修改的时间一致，那么服务器就会返回304，浏览器就会使用缓存\n\n### 二. 资源的非覆盖式发布\n\n一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。\n\n一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。\n\n#### 使用资源的非覆盖式发布解决的问题：\n\n**1. 缓存问题**\n\n由于一般的公司都会将缓存的过期时间设得很长，那么如果是使用的同名文件\n\n例如：\n\n```\na.html <script src='a.js'></script>\na.js \n```  \n\n即使在服务器上更新了静态资源，那么页面在缓存过期之前就会一直使用缓存的文件（这个就是静态资源的缓存的问题）\n\n<font color='red'>于是可以使用资源的非覆盖式发布，让页面加载新的静态文件(文件名变了，于是也不会使用本地的缓存了)。</font>\n\n```\n更新前\na.html <script src='a.js'></script>\na.js \n\n更新后\na.html <script src='a_0abcde.js'></script>\na_0abcde.js\n```\n\n**2. 更新问题**\n\n在更新了静态资源和页面之后，静态资源发布和页面的**部署顺序**会影响页面的加载\n\n**先发布静态资源，再发布页面**\n\n若是有缓存的浏览器，旧页面 ————> 旧资源，页面没有改变；\n\n**先部署页面，再发布静态资源**\n\n在两者部署的时间间隔内，有用户访问页面，就会在新的页面中加载旧资源，并且把旧静态资源缓存起来，在缓存过期之内，页面一直都会是错误状态。\n\n无论怎么部署，都会出现问题。\n\n<font color='red'>使用资源的非覆盖式发布，先部署静态资源，再部署页面，新的静态资源会被缓存。</font>\n\n**3. 非覆盖式的发布如果线上出bug了方便快速回滚**\n\n### 三. 如何实现资源的非覆盖式发布\n\n解决方式：给文件添加MD5值\n\nMD5：消息摘要算法第五版\n\n\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"a_82244e91.css\">\n\n其中”_82244e91”这串字符是根据a.css的文件内容进行hash运算得到的，只有文件内容发生变化了才会有更改。由于版本序列是与文件名写在一起的，而不是同名文件覆盖，因此不会出现上述说的那些问题。\n\n\n\n\n\n\n\n","source":"_posts/2016-03-07-性能优化资源的非覆盖式发布.md","raw":"---\nlayout: post\ntitle: 性能优化 资源的非覆盖式发布\ndate: 2016-03-07\ncategories: 性能优化\ntags: [性能优化]\ndescription: \n---\n\n### 一. 大公司的静态资源优化方案\n\n- 配置很长时间的本地缓存 ———— 节省带宽，提高性能\n- 给静态文件添加MD5值 ———— 精确地控制缓存\n- 静态资源CDN部署 ———— 优化网络请求\n- 更新资源发布路径实现非覆盖式发布\n\n**http协议缓存：**\n\n**1. 本地强制缓存**\n\n- expires: 缓存的绝对过期的时间\n- cache-control: 缓存的相对过期时间\n\n也就是说在这个过期日期之前都不会向服务器去请求数据\n\n**2. 304协商缓存**\n\n如果缓存过期了，那么就要进行缓存再验证\n\n请求头里  If-Modified-Since: 表示的是上一次从服务器获取数据的日期\n响应头里  Last-Modified: 表示的是服务器上最近一次修改文件的日期\n\n如果If-Modified-Since中的时间和浏览器最近一次修改的时间一致，那么服务器就会返回304，浏览器就会使用缓存\n\n### 二. 资源的非覆盖式发布\n\n一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。\n\n一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。\n\n#### 使用资源的非覆盖式发布解决的问题：\n\n**1. 缓存问题**\n\n由于一般的公司都会将缓存的过期时间设得很长，那么如果是使用的同名文件\n\n例如：\n\n```\na.html <script src='a.js'></script>\na.js \n```  \n\n即使在服务器上更新了静态资源，那么页面在缓存过期之前就会一直使用缓存的文件（这个就是静态资源的缓存的问题）\n\n<font color='red'>于是可以使用资源的非覆盖式发布，让页面加载新的静态文件(文件名变了，于是也不会使用本地的缓存了)。</font>\n\n```\n更新前\na.html <script src='a.js'></script>\na.js \n\n更新后\na.html <script src='a_0abcde.js'></script>\na_0abcde.js\n```\n\n**2. 更新问题**\n\n在更新了静态资源和页面之后，静态资源发布和页面的**部署顺序**会影响页面的加载\n\n**先发布静态资源，再发布页面**\n\n若是有缓存的浏览器，旧页面 ————> 旧资源，页面没有改变；\n\n**先部署页面，再发布静态资源**\n\n在两者部署的时间间隔内，有用户访问页面，就会在新的页面中加载旧资源，并且把旧静态资源缓存起来，在缓存过期之内，页面一直都会是错误状态。\n\n无论怎么部署，都会出现问题。\n\n<font color='red'>使用资源的非覆盖式发布，先部署静态资源，再部署页面，新的静态资源会被缓存。</font>\n\n**3. 非覆盖式的发布如果线上出bug了方便快速回滚**\n\n### 三. 如何实现资源的非覆盖式发布\n\n解决方式：给文件添加MD5值\n\nMD5：消息摘要算法第五版\n\n\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"a_82244e91.css\">\n\n其中”_82244e91”这串字符是根据a.css的文件内容进行hash运算得到的，只有文件内容发生变化了才会有更改。由于版本序列是与文件名写在一起的，而不是同名文件覆盖，因此不会出现上述说的那些问题。\n\n\n\n\n\n\n\n","slug":"2016-03-07-性能优化资源的非覆盖式发布","published":1,"updated":"2016-09-09T03:30:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035occ0000ad5u8w2u8paru","content":"<h3 id=\"一-大公司的静态资源优化方案\"><a href=\"#一-大公司的静态资源优化方案\" class=\"headerlink\" title=\"一. 大公司的静态资源优化方案\"></a>一. 大公司的静态资源优化方案</h3><ul>\n<li>配置很长时间的本地缓存 ———— 节省带宽，提高性能</li>\n<li>给静态文件添加MD5值 ———— 精确地控制缓存</li>\n<li>静态资源CDN部署 ———— 优化网络请求</li>\n<li>更新资源发布路径实现非覆盖式发布</li>\n</ul>\n<p><strong>http协议缓存：</strong></p>\n<p><strong>1. 本地强制缓存</strong></p>\n<ul>\n<li>expires: 缓存的绝对过期的时间</li>\n<li>cache-control: 缓存的相对过期时间</li>\n</ul>\n<p>也就是说在这个过期日期之前都不会向服务器去请求数据</p>\n<p><strong>2. 304协商缓存</strong></p>\n<p>如果缓存过期了，那么就要进行缓存再验证</p>\n<p>请求头里  If-Modified-Since: 表示的是上一次从服务器获取数据的日期<br>响应头里  Last-Modified: 表示的是服务器上最近一次修改文件的日期</p>\n<p>如果If-Modified-Since中的时间和浏览器最近一次修改的时间一致，那么服务器就会返回304，浏览器就会使用缓存</p>\n<h3 id=\"二-资源的非覆盖式发布\"><a href=\"#二-资源的非覆盖式发布\" class=\"headerlink\" title=\"二. 资源的非覆盖式发布\"></a>二. 资源的非覆盖式发布</h3><p>一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。</p>\n<p>一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。</p>\n<h4 id=\"使用资源的非覆盖式发布解决的问题：\"><a href=\"#使用资源的非覆盖式发布解决的问题：\" class=\"headerlink\" title=\"使用资源的非覆盖式发布解决的问题：\"></a>使用资源的非覆盖式发布解决的问题：</h4><p><strong>1. 缓存问题</strong></p>\n<p>由于一般的公司都会将缓存的过期时间设得很长，那么如果是使用的同名文件</p>\n<p>例如：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-class\">.html</span> &lt;script src=<span class=\"string\">'a.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-class\">.js</span> </span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">即使在服务器上更新了静态资源，那么页面在缓存过期之前就会一直使用缓存的文件（这个就是静态资源的缓存的问题）</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"attribute\">font</span> color=<span class=\"string\">'red'</span>&gt;于是可以使用资源的非覆盖式发布，让页面加载新的静态文件(文件名变了，于是也不会使用本地的缓存了)。&lt;/font&gt;</span><br></pre></td></tr></table></figure>\n<p>更新前<br>a.html <script src=\"a.js\"></script><br>a.js </p>\n<p>更新后<br>a.html <script src=\"a_0abcde.js\"></script><br>a_0abcde.js<br>```</p>\n<p><strong>2. 更新问题</strong></p>\n<p>在更新了静态资源和页面之后，静态资源发布和页面的<strong>部署顺序</strong>会影响页面的加载</p>\n<p><strong>先发布静态资源，再发布页面</strong></p>\n<p>若是有缓存的浏览器，旧页面 ————&gt; 旧资源，页面没有改变；</p>\n<p><strong>先部署页面，再发布静态资源</strong></p>\n<p>在两者部署的时间间隔内，有用户访问页面，就会在新的页面中加载旧资源，并且把旧静态资源缓存起来，在缓存过期之内，页面一直都会是错误状态。</p>\n<p>无论怎么部署，都会出现问题。</p>\n<font color=\"red\">使用资源的非覆盖式发布，先部署静态资源，再部署页面，新的静态资源会被缓存。</font>\n\n<p><strong>3. 非覆盖式的发布如果线上出bug了方便快速回滚</strong></p>\n<h3 id=\"三-如何实现资源的非覆盖式发布\"><a href=\"#三-如何实现资源的非覆盖式发布\" class=\"headerlink\" title=\"三. 如何实现资源的非覆盖式发布\"></a>三. 如何实现资源的非覆盖式发布</h3><p>解决方式：给文件添加MD5值</p>\n<p>MD5：消息摘要算法第五版</p>\n<pre><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;a_82244e91.css&quot;&gt;\n</code></pre><p>其中”_82244e91”这串字符是根据a.css的文件内容进行hash运算得到的，只有文件内容发生变化了才会有更改。由于版本序列是与文件名写在一起的，而不是同名文件覆盖，因此不会出现上述说的那些问题。</p>\n","excerpt":"","more":"<h3 id=\"一-大公司的静态资源优化方案\"><a href=\"#一-大公司的静态资源优化方案\" class=\"headerlink\" title=\"一. 大公司的静态资源优化方案\"></a>一. 大公司的静态资源优化方案</h3><ul>\n<li>配置很长时间的本地缓存 ———— 节省带宽，提高性能</li>\n<li>给静态文件添加MD5值 ———— 精确地控制缓存</li>\n<li>静态资源CDN部署 ———— 优化网络请求</li>\n<li>更新资源发布路径实现非覆盖式发布</li>\n</ul>\n<p><strong>http协议缓存：</strong></p>\n<p><strong>1. 本地强制缓存</strong></p>\n<ul>\n<li>expires: 缓存的绝对过期的时间</li>\n<li>cache-control: 缓存的相对过期时间</li>\n</ul>\n<p>也就是说在这个过期日期之前都不会向服务器去请求数据</p>\n<p><strong>2. 304协商缓存</strong></p>\n<p>如果缓存过期了，那么就要进行缓存再验证</p>\n<p>请求头里  If-Modified-Since: 表示的是上一次从服务器获取数据的日期<br>响应头里  Last-Modified: 表示的是服务器上最近一次修改文件的日期</p>\n<p>如果If-Modified-Since中的时间和浏览器最近一次修改的时间一致，那么服务器就会返回304，浏览器就会使用缓存</p>\n<h3 id=\"二-资源的非覆盖式发布\"><a href=\"#二-资源的非覆盖式发布\" class=\"headerlink\" title=\"二. 资源的非覆盖式发布\"></a>二. 资源的非覆盖式发布</h3><p>一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。</p>\n<p>一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。</p>\n<h4 id=\"使用资源的非覆盖式发布解决的问题：\"><a href=\"#使用资源的非覆盖式发布解决的问题：\" class=\"headerlink\" title=\"使用资源的非覆盖式发布解决的问题：\"></a>使用资源的非覆盖式发布解决的问题：</h4><p><strong>1. 缓存问题</strong></p>\n<p>由于一般的公司都会将缓存的过期时间设得很长，那么如果是使用的同名文件</p>\n<p>例如：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-class\">.html</span> &lt;script src=<span class=\"string\">'a.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-class\">.js</span> </span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">即使在服务器上更新了静态资源，那么页面在缓存过期之前就会一直使用缓存的文件（这个就是静态资源的缓存的问题）</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"attribute\">font</span> color=<span class=\"string\">'red'</span>&gt;于是可以使用资源的非覆盖式发布，让页面加载新的静态文件(文件名变了，于是也不会使用本地的缓存了)。&lt;/font&gt;</span><br></pre></td></tr></table></figure>\n<p>更新前<br>a.html <script src='a.js'></script><br>a.js </p>\n<p>更新后<br>a.html <script src='a_0abcde.js'></script><br>a_0abcde.js<br>```</p>\n<p><strong>2. 更新问题</strong></p>\n<p>在更新了静态资源和页面之后，静态资源发布和页面的<strong>部署顺序</strong>会影响页面的加载</p>\n<p><strong>先发布静态资源，再发布页面</strong></p>\n<p>若是有缓存的浏览器，旧页面 ————&gt; 旧资源，页面没有改变；</p>\n<p><strong>先部署页面，再发布静态资源</strong></p>\n<p>在两者部署的时间间隔内，有用户访问页面，就会在新的页面中加载旧资源，并且把旧静态资源缓存起来，在缓存过期之内，页面一直都会是错误状态。</p>\n<p>无论怎么部署，都会出现问题。</p>\n<font color='red'>使用资源的非覆盖式发布，先部署静态资源，再部署页面，新的静态资源会被缓存。</font>\n\n<p><strong>3. 非覆盖式的发布如果线上出bug了方便快速回滚</strong></p>\n<h3 id=\"三-如何实现资源的非覆盖式发布\"><a href=\"#三-如何实现资源的非覆盖式发布\" class=\"headerlink\" title=\"三. 如何实现资源的非覆盖式发布\"></a>三. 如何实现资源的非覆盖式发布</h3><p>解决方式：给文件添加MD5值</p>\n<p>MD5：消息摘要算法第五版</p>\n<pre><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;a_82244e91.css&quot;&gt;\n</code></pre><p>其中”_82244e91”这串字符是根据a.css的文件内容进行hash运算得到的，只有文件内容发生变化了才会有更改。由于版本序列是与文件名写在一起的，而不是同名文件覆盖，因此不会出现上述说的那些问题。</p>\n"},{"layout":"post","title":"jQuery Ajax","date":"2016-03-03T16:00:00.000Z","description":null,"_content":"\n### 一. Ajax方法\n\n**jquery**：JavaScript代码包装成拿过来就能实现特定功能的代码库\n\n**json**：简单说就是javascript中的对象和数组\n\n**Ajax**：异步的JavaScript和XML，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示\n\n##### 1. $(selector). load(url,[data],[callback]) 获取网页\n\n**url**：服务器的地址\n\n可选项**data**参数为请求时发送的数据\n    \n**callback**参数为数据请求成功后，执行的回调函数\n    \neg: \n` .load(\"http://www.imooc.com/data/fruit_part.html\"  ,function(){`\n                        `$this.attr(\"disabled\", \"true\");`\n                   ` });`\n\n##### 2.    jQuery.getJSON(url,[data],[callback]) 或者 $.getJSON(url,[data],[callback])  获取数组\n\n使用<font color=\"red\">getJSON()</font>方法可以通过<font color=\"red\">Ajax异步请求</font>的方式，获取服务器中的数组，并对获取的数据进行解析\n\n##### 3. jQuery.getScript(url,[callback])  或 $.getScript(url,[callback])\n\n异步加载并执行js文件  获取JS文件内容\n\n##### 4. $.get(url,[callback])     向服务器请求数据\n\n 采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据\n \n##### 5. $.post(url,[data],[callback])   向服务器发送数据\n\n用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面\n\neg:    ` $.post(\"http://www.imooc.com/data/check_f.php\",{num:$(\"#txtNumber\").val()},`\n                    `function (data) {});`\n                    \n <font color=\"red\">注意：Ajax里面的post、get都是以用户为主体，所以get指的是向服务器请求数据，post是指向服务器发送数据</font>\n\n##### 6.  $(selector).serialize()        将元素进行序列化\n\n将表单中有name属性的元素值进行序列化，生成标准URL编码文本字符串???，直接可用于ajax请求\n\n##### 7. jQuery.ajax([settings])   或$.ajax([settings])\n\n获取服务器数据，同时向服务器发送请求\n  \n使用**$.ajax()**方法是最底层、功能最强大的请求服务器数据的方法，\n它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值\n\nsettings为一个**对象**：该对象包括：\n\nurl  表示服务器请求的路径，\n\n data为请求时传递的数据，\n                                               \n dataType为服务器返回的数据类型\n                                               \n success为请求成功的执行的回调函数\n                                               \ntype为发送数据请求的方式，**默认为get**\n                                               \neg:          \t`$.ajax({`\n                         `\turl:\"http://www.imooc.com/data/check.php\",`\n                         \t`data: { num: $(\"#txtNumber\").val() },`\n                         `\tdataType:\"text\",`\n                         `\tsuccess: function (data) {`\n                        ` \t$(\"ul\").append( \"<li> 你输入的<b>  \"  + $(\"#txtNumber\").val() + \" </b>是<b> \"  + data + \" </b></li>\");`\n                       \t `}`\n                   \t `});`\n\n##### 8. jQuery.ajaxSetup([options])     或$.ajaxSetup([options])         \n\n设置Ajax的全局性选项值\n   \n设置Ajax请求的一些全局性选项值，设置完成后，后面的Ajax请求将不需要再添加这些选项值，options为一个对象\n\n##### 9.  $(selector).ajaxStart(function())  ajax请求执行前执行\n\n$(selector).ajaxStop(function())    ajax请求执行后执行\n\n当发送Ajax请求前，执行ajaxStart()方法绑定的函数；请求成功后，执行ajaxStop ()方法绑定的函数\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-04-jQuery Ajax.md","raw":"---\nlayout: post\ntitle: jQuery Ajax\ndate: 2016-03-04\ncategories: 前端笔记 \ntags: [jQuery,Ajax]\ndescription: \n---\n\n### 一. Ajax方法\n\n**jquery**：JavaScript代码包装成拿过来就能实现特定功能的代码库\n\n**json**：简单说就是javascript中的对象和数组\n\n**Ajax**：异步的JavaScript和XML，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示\n\n##### 1. $(selector). load(url,[data],[callback]) 获取网页\n\n**url**：服务器的地址\n\n可选项**data**参数为请求时发送的数据\n    \n**callback**参数为数据请求成功后，执行的回调函数\n    \neg: \n` .load(\"http://www.imooc.com/data/fruit_part.html\"  ,function(){`\n                        `$this.attr(\"disabled\", \"true\");`\n                   ` });`\n\n##### 2.    jQuery.getJSON(url,[data],[callback]) 或者 $.getJSON(url,[data],[callback])  获取数组\n\n使用<font color=\"red\">getJSON()</font>方法可以通过<font color=\"red\">Ajax异步请求</font>的方式，获取服务器中的数组，并对获取的数据进行解析\n\n##### 3. jQuery.getScript(url,[callback])  或 $.getScript(url,[callback])\n\n异步加载并执行js文件  获取JS文件内容\n\n##### 4. $.get(url,[callback])     向服务器请求数据\n\n 采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据\n \n##### 5. $.post(url,[data],[callback])   向服务器发送数据\n\n用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面\n\neg:    ` $.post(\"http://www.imooc.com/data/check_f.php\",{num:$(\"#txtNumber\").val()},`\n                    `function (data) {});`\n                    \n <font color=\"red\">注意：Ajax里面的post、get都是以用户为主体，所以get指的是向服务器请求数据，post是指向服务器发送数据</font>\n\n##### 6.  $(selector).serialize()        将元素进行序列化\n\n将表单中有name属性的元素值进行序列化，生成标准URL编码文本字符串???，直接可用于ajax请求\n\n##### 7. jQuery.ajax([settings])   或$.ajax([settings])\n\n获取服务器数据，同时向服务器发送请求\n  \n使用**$.ajax()**方法是最底层、功能最强大的请求服务器数据的方法，\n它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值\n\nsettings为一个**对象**：该对象包括：\n\nurl  表示服务器请求的路径，\n\n data为请求时传递的数据，\n                                               \n dataType为服务器返回的数据类型\n                                               \n success为请求成功的执行的回调函数\n                                               \ntype为发送数据请求的方式，**默认为get**\n                                               \neg:          \t`$.ajax({`\n                         `\turl:\"http://www.imooc.com/data/check.php\",`\n                         \t`data: { num: $(\"#txtNumber\").val() },`\n                         `\tdataType:\"text\",`\n                         `\tsuccess: function (data) {`\n                        ` \t$(\"ul\").append( \"<li> 你输入的<b>  \"  + $(\"#txtNumber\").val() + \" </b>是<b> \"  + data + \" </b></li>\");`\n                       \t `}`\n                   \t `});`\n\n##### 8. jQuery.ajaxSetup([options])     或$.ajaxSetup([options])         \n\n设置Ajax的全局性选项值\n   \n设置Ajax请求的一些全局性选项值，设置完成后，后面的Ajax请求将不需要再添加这些选项值，options为一个对象\n\n##### 9.  $(selector).ajaxStart(function())  ajax请求执行前执行\n\n$(selector).ajaxStop(function())    ajax请求执行后执行\n\n当发送Ajax请求前，执行ajaxStart()方法绑定的函数；请求成功后，执行ajaxStop ()方法绑定的函数\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-04-jQuery Ajax","published":1,"updated":"2016-05-27T03:16:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035occ3000cd5u8ysayrqr9","content":"<h3 id=\"一-Ajax方法\"><a href=\"#一-Ajax方法\" class=\"headerlink\" title=\"一. Ajax方法\"></a>一. Ajax方法</h3><p><strong>jquery</strong>：JavaScript代码包装成拿过来就能实现特定功能的代码库</p>\n<p><strong>json</strong>：简单说就是javascript中的对象和数组</p>\n<p><strong>Ajax</strong>：异步的JavaScript和XML，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示</p>\n<h5 id=\"1-selector-load-url-data-callback-获取网页\"><a href=\"#1-selector-load-url-data-callback-获取网页\" class=\"headerlink\" title=\"1. $(selector). load(url,[data],[callback]) 获取网页\"></a>1. $(selector). load(url,[data],[callback]) 获取网页</h5><p><strong>url</strong>：服务器的地址</p>\n<p>可选项<strong>data</strong>参数为请求时发送的数据</p>\n<p><strong>callback</strong>参数为数据请求成功后，执行的回调函数</p>\n<p>eg:<br><code>.load(&quot;http://www.imooc.com/data/fruit_part.html&quot;  ,function(){</code><br>                        <code>$this.attr(&quot;disabled&quot;, &quot;true&quot;);</code><br>                   <code>});</code></p>\n<h5 id=\"2-jQuery-getJSON-url-data-callback-或者-getJSON-url-data-callback-获取数组\"><a href=\"#2-jQuery-getJSON-url-data-callback-或者-getJSON-url-data-callback-获取数组\" class=\"headerlink\" title=\"2.    jQuery.getJSON(url,[data],[callback]) 或者 $.getJSON(url,[data],[callback])  获取数组\"></a>2.    jQuery.getJSON(url,[data],[callback]) 或者 $.getJSON(url,[data],[callback])  获取数组</h5><p>使用<font color=\"red\">getJSON()</font>方法可以通过<font color=\"red\">Ajax异步请求</font>的方式，获取服务器中的数组，并对获取的数据进行解析</p>\n<h5 id=\"3-jQuery-getScript-url-callback-或-getScript-url-callback\"><a href=\"#3-jQuery-getScript-url-callback-或-getScript-url-callback\" class=\"headerlink\" title=\"3. jQuery.getScript(url,[callback])  或 $.getScript(url,[callback])\"></a>3. jQuery.getScript(url,[callback])  或 $.getScript(url,[callback])</h5><p>异步加载并执行js文件  获取JS文件内容</p>\n<h5 id=\"4-get-url-callback-向服务器请求数据\"><a href=\"#4-get-url-callback-向服务器请求数据\" class=\"headerlink\" title=\"4. $.get(url,[callback])     向服务器请求数据\"></a>4. $.get(url,[callback])     向服务器请求数据</h5><p> 采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据</p>\n<h5 id=\"5-post-url-data-callback-向服务器发送数据\"><a href=\"#5-post-url-data-callback-向服务器发送数据\" class=\"headerlink\" title=\"5. $.post(url,[data],[callback])   向服务器发送数据\"></a>5. $.post(url,[data],[callback])   向服务器发送数据</h5><p>用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面</p>\n<p>eg:    <code>$.post(&quot;http://www.imooc.com/data/check_f.php&quot;,{num:$(&quot;#txtNumber&quot;).val()},</code><br>                    <code>function (data) {});</code></p>\n <font color=\"red\">注意：Ajax里面的post、get都是以用户为主体，所以get指的是向服务器请求数据，post是指向服务器发送数据</font>\n\n<h5 id=\"6-selector-serialize-将元素进行序列化\"><a href=\"#6-selector-serialize-将元素进行序列化\" class=\"headerlink\" title=\"6.  $(selector).serialize()        将元素进行序列化\"></a>6.  $(selector).serialize()        将元素进行序列化</h5><p>将表单中有name属性的元素值进行序列化，生成标准URL编码文本字符串???，直接可用于ajax请求</p>\n<h5 id=\"7-jQuery-ajax-settings-或-ajax-settings\"><a href=\"#7-jQuery-ajax-settings-或-ajax-settings\" class=\"headerlink\" title=\"7. jQuery.ajax([settings])   或$.ajax([settings])\"></a>7. jQuery.ajax([settings])   或$.ajax([settings])</h5><p>获取服务器数据，同时向服务器发送请求</p>\n<p>使用<strong>$.ajax()</strong>方法是最底层、功能最强大的请求服务器数据的方法，<br>它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值</p>\n<p>settings为一个<strong>对象</strong>：该对象包括：</p>\n<p>url  表示服务器请求的路径，</p>\n<p> data为请求时传递的数据，</p>\n<p> dataType为服务器返回的数据类型</p>\n<p> success为请求成功的执行的回调函数</p>\n<p>type为发送数据请求的方式，<strong>默认为get</strong></p>\n<p>eg:              <code>$.ajax({</code><br>                         <code>url:&quot;http://www.imooc.com/data/check.php&quot;,</code><br>                             <code>data: { num: $(&quot;#txtNumber&quot;).val() },</code><br>                         <code>dataType:&quot;text&quot;,</code><br>                         <code>success: function (data) {</code><br>                        <code>$(&quot;ul&quot;).append( &quot;&lt;li&gt; 你输入的&lt;b&gt;  &quot;  + $(&quot;#txtNumber&quot;).val() + &quot; &lt;/b&gt;是&lt;b&gt; &quot;  + data + &quot; &lt;/b&gt;&lt;/li&gt;&quot;);</code><br>                            <code>}</code><br>                        <code>});</code></p>\n<h5 id=\"8-jQuery-ajaxSetup-options-或-ajaxSetup-options\"><a href=\"#8-jQuery-ajaxSetup-options-或-ajaxSetup-options\" class=\"headerlink\" title=\"8. jQuery.ajaxSetup([options])     或$.ajaxSetup([options])\"></a>8. jQuery.ajaxSetup([options])     或$.ajaxSetup([options])</h5><p>设置Ajax的全局性选项值</p>\n<p>设置Ajax请求的一些全局性选项值，设置完成后，后面的Ajax请求将不需要再添加这些选项值，options为一个对象</p>\n<h5 id=\"9-selector-ajaxStart-function-ajax请求执行前执行\"><a href=\"#9-selector-ajaxStart-function-ajax请求执行前执行\" class=\"headerlink\" title=\"9.  $(selector).ajaxStart(function())  ajax请求执行前执行\"></a>9.  $(selector).ajaxStart(function())  ajax请求执行前执行</h5><p>$(selector).ajaxStop(function())    ajax请求执行后执行</p>\n<p>当发送Ajax请求前，执行ajaxStart()方法绑定的函数；请求成功后，执行ajaxStop ()方法绑定的函数</p>\n","excerpt":"","more":"<h3 id=\"一-Ajax方法\"><a href=\"#一-Ajax方法\" class=\"headerlink\" title=\"一. Ajax方法\"></a>一. Ajax方法</h3><p><strong>jquery</strong>：JavaScript代码包装成拿过来就能实现特定功能的代码库</p>\n<p><strong>json</strong>：简单说就是javascript中的对象和数组</p>\n<p><strong>Ajax</strong>：异步的JavaScript和XML，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示</p>\n<h5 id=\"1-selector-load-url-data-callback-获取网页\"><a href=\"#1-selector-load-url-data-callback-获取网页\" class=\"headerlink\" title=\"1. $(selector). load(url,[data],[callback]) 获取网页\"></a>1. $(selector). load(url,[data],[callback]) 获取网页</h5><p><strong>url</strong>：服务器的地址</p>\n<p>可选项<strong>data</strong>参数为请求时发送的数据</p>\n<p><strong>callback</strong>参数为数据请求成功后，执行的回调函数</p>\n<p>eg:<br><code>.load(&quot;http://www.imooc.com/data/fruit_part.html&quot;  ,function(){</code><br>                        <code>$this.attr(&quot;disabled&quot;, &quot;true&quot;);</code><br>                   <code>});</code></p>\n<h5 id=\"2-jQuery-getJSON-url-data-callback-或者-getJSON-url-data-callback-获取数组\"><a href=\"#2-jQuery-getJSON-url-data-callback-或者-getJSON-url-data-callback-获取数组\" class=\"headerlink\" title=\"2.    jQuery.getJSON(url,[data],[callback]) 或者 $.getJSON(url,[data],[callback])  获取数组\"></a>2.    jQuery.getJSON(url,[data],[callback]) 或者 $.getJSON(url,[data],[callback])  获取数组</h5><p>使用<font color=\"red\">getJSON()</font>方法可以通过<font color=\"red\">Ajax异步请求</font>的方式，获取服务器中的数组，并对获取的数据进行解析</p>\n<h5 id=\"3-jQuery-getScript-url-callback-或-getScript-url-callback\"><a href=\"#3-jQuery-getScript-url-callback-或-getScript-url-callback\" class=\"headerlink\" title=\"3. jQuery.getScript(url,[callback])  或 $.getScript(url,[callback])\"></a>3. jQuery.getScript(url,[callback])  或 $.getScript(url,[callback])</h5><p>异步加载并执行js文件  获取JS文件内容</p>\n<h5 id=\"4-get-url-callback-向服务器请求数据\"><a href=\"#4-get-url-callback-向服务器请求数据\" class=\"headerlink\" title=\"4. $.get(url,[callback])     向服务器请求数据\"></a>4. $.get(url,[callback])     向服务器请求数据</h5><p> 采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据</p>\n<h5 id=\"5-post-url-data-callback-向服务器发送数据\"><a href=\"#5-post-url-data-callback-向服务器发送数据\" class=\"headerlink\" title=\"5. $.post(url,[data],[callback])   向服务器发送数据\"></a>5. $.post(url,[data],[callback])   向服务器发送数据</h5><p>用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面</p>\n<p>eg:    <code>$.post(&quot;http://www.imooc.com/data/check_f.php&quot;,{num:$(&quot;#txtNumber&quot;).val()},</code><br>                    <code>function (data) {});</code></p>\n <font color=\"red\">注意：Ajax里面的post、get都是以用户为主体，所以get指的是向服务器请求数据，post是指向服务器发送数据</font>\n\n<h5 id=\"6-selector-serialize-将元素进行序列化\"><a href=\"#6-selector-serialize-将元素进行序列化\" class=\"headerlink\" title=\"6.  $(selector).serialize()        将元素进行序列化\"></a>6.  $(selector).serialize()        将元素进行序列化</h5><p>将表单中有name属性的元素值进行序列化，生成标准URL编码文本字符串???，直接可用于ajax请求</p>\n<h5 id=\"7-jQuery-ajax-settings-或-ajax-settings\"><a href=\"#7-jQuery-ajax-settings-或-ajax-settings\" class=\"headerlink\" title=\"7. jQuery.ajax([settings])   或$.ajax([settings])\"></a>7. jQuery.ajax([settings])   或$.ajax([settings])</h5><p>获取服务器数据，同时向服务器发送请求</p>\n<p>使用<strong>$.ajax()</strong>方法是最底层、功能最强大的请求服务器数据的方法，<br>它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值</p>\n<p>settings为一个<strong>对象</strong>：该对象包括：</p>\n<p>url  表示服务器请求的路径，</p>\n<p> data为请求时传递的数据，</p>\n<p> dataType为服务器返回的数据类型</p>\n<p> success为请求成功的执行的回调函数</p>\n<p>type为发送数据请求的方式，<strong>默认为get</strong></p>\n<p>eg:              <code>$.ajax({</code><br>                         <code>url:&quot;http://www.imooc.com/data/check.php&quot;,</code><br>                             <code>data: { num: $(&quot;#txtNumber&quot;).val() },</code><br>                         <code>dataType:&quot;text&quot;,</code><br>                         <code>success: function (data) {</code><br>                        <code>$(&quot;ul&quot;).append( &quot;&lt;li&gt; 你输入的&lt;b&gt;  &quot;  + $(&quot;#txtNumber&quot;).val() + &quot; &lt;/b&gt;是&lt;b&gt; &quot;  + data + &quot; &lt;/b&gt;&lt;/li&gt;&quot;);</code><br>                            <code>}</code><br>                        <code>});</code></p>\n<h5 id=\"8-jQuery-ajaxSetup-options-或-ajaxSetup-options\"><a href=\"#8-jQuery-ajaxSetup-options-或-ajaxSetup-options\" class=\"headerlink\" title=\"8. jQuery.ajaxSetup([options])     或$.ajaxSetup([options])\"></a>8. jQuery.ajaxSetup([options])     或$.ajaxSetup([options])</h5><p>设置Ajax的全局性选项值</p>\n<p>设置Ajax请求的一些全局性选项值，设置完成后，后面的Ajax请求将不需要再添加这些选项值，options为一个对象</p>\n<h5 id=\"9-selector-ajaxStart-function-ajax请求执行前执行\"><a href=\"#9-selector-ajaxStart-function-ajax请求执行前执行\" class=\"headerlink\" title=\"9.  $(selector).ajaxStart(function())  ajax请求执行前执行\"></a>9.  $(selector).ajaxStart(function())  ajax请求执行前执行</h5><p>$(selector).ajaxStop(function())    ajax请求执行后执行</p>\n<p>当发送Ajax请求前，执行ajaxStart()方法绑定的函数；请求成功后，执行ajaxStop ()方法绑定的函数</p>\n"},{"layout":"post","title":"gulp 前端代码构建工具","date":"2016-03-04T16:00:00.000Z","description":null,"_content":"\n### 一. gulp简介\n\n**gulp**是一种任务自动处理工具，简单地说，gulp是一个工具框架，有很多插件扩展它的功能。\n\n**gulp**能够自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。\n\n**gulp的优点：**\n\n1. 基于流的构建工具，利用流的方式进行文件的处理\n1. 代码优于配置，通过简单的配置能够完成很多重复的功能\n1. 简单明了，目的明确，一般一个插件只完成一个任务\n1. gulp的gulpfile.js的写法更加通俗易懂，易上手\n\n### 二.  使用gulp的步骤：\n\n由于gulp是基于node.js的，因此在安装gulp之前需要安装node.js\n\n**node.js**是一个后端的js运行环境，也就是说：你写一个服务器端的js代码，可以交给node.js来解释执行。\n\n<font color=\"red\">安装nodejs -> 全局安装gulp -> 项目安装gulp以及gulp插件 -> 配置gulpfile.js -> 运行任务</font>\n\n#### 1. 安装nodejs\n\n从官网上直接下载安装（路径随意）\n\n打开cmd：\n\n\t输入 node -v       /* 查看nodejs版本号*/\n\t输入npm -v         /* 查看npm版本号 */\n\t输入D:             /*定位到D盘*/\n\t输入cd  nodejs \t  /* 定位到安装目录*/\n\t输入dir           /*查看当前定位目录下的文件*/\n\t输入cls           /* 清空内容*/\n\n#### 2. 全局安装gulp  \n**目的**：通过全局安装的gulp执行gulp任务，全局安装完gulp之后，就可以使用gulp命令行\n\n\t输入 npm install gulp -g   /*全局安装gulp*/\n\t输入 gulp -v               /*查看安装的gulp的版本号，出现版本号即为正确安装*/\n\n#### 3. 新建package.json文件\npackage.json是nodejs项目必不可少的配置文件，存放在项目的根目录下\n\n\t输入 npm init          /*创建 package.json文件*/\n\n前三项（项目名称，项目版本，项目描述）必须输入，后几项可留空\n\t\n\t输入 npm help package.json   /*查看package.json帮助文档*/\n\n#### 4. 项目安装gulp依赖\n\n\t输入 npm install gulp --save-dev     /*本地安装gulp*/\n\t输入 npm install 插件名 --save-dev   /*安装gulp插件*/\n\t\n--save : 将配置信息保存至 **package.json**\n\n-dev：将配置信息保存至**package.json** 的 **devDependencies**节点\n\n#### 5. 在项目的根目录下创建gulpfile.js文件\n\n\t//导入工具包 require('node_modules里对应模块')\n\tvar gulp = require('gulp'), //本地安装gulp所用到的地方\n \t less = require('gulp-less');\n \n\t//定义一个testLess任务（自定义任务名称）\n\tgulp.task('testLess', function () {\n   \t\t gulp.src('src/less/index.less') //该任务针对的文件\n       \t\t .pipe(less()) //该任务调用的模块\n       \t\t .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css\n\t});\n \n\tgulp.task('default',['testLess', 'elseTask']); //定义默认任务\n \n\t//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数\n\t//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组)\n\t//gulp.dest(path[, options]) 处理完后文件生成路径\n\n#### 6. 运行gulp\n\t输入$gulp                 /*运行gulp*/\n\t输入gulp default     \t /*运行gulpfile.js中一个名为default的函数*/\n\n### 二. gulp的API（在gulpfile.js里面会用到）\n\n#### 1. task  用于定义一个gulp的任务\n\tgulp.task(name, [deps] , fn)\n\n**name**为任务名称** ‘default’**\n\n**deps**为任务依赖的任务，可有多个，按照顺序执行 ['task', 'task2']\n\n**fn** 该任务调用的插件操作\n\n#### 2. src  指定需要处理的源文件的路径\n\tgulp.src(文件路径的模式匹配globs, {options})\n\nglobs为需要处理的源文件匹配符路径（字符串或者字符串数组）\n\n\n\teg：\"src/a.js\"                                             匹配具体文件\n\t\n\t\t\"src/*.js\"                                             匹配src目录下的所有js文件\n\t\n\t\t\"src/**/*.js\"                                         匹配src目录下的 0个或多个子文件夹 下的所有js文件\n\t\n\t\t\"src/{a,b}.js\" 或者\"src/*.{jpg,png}\"     同时匹配多个文件\n\n**options：有3个属性buffer  read  base**\n\n**buffer：**默认true        设置为false时，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；\n\n**read：** 默认为true      设置为false，将不执行读取文件操作，返回null；\n\n**base：**为string类型    设置输出路径以某个路径的某个组成部分为基础向后拼接。\n\n#### 3. dest 指定处理完之后文件的输出路径\n\tgulp.dest(path,{option})\n\t\npath为文件的输出路径\n\n**options：有2个属性cwd mode**\n\ncwd：类型string  默认：process.cwd()：前脚本的工作目录的路径当文件输出路径为相对路径将会用到；\n\nmode：类型：String  默认：0777 指定被创建文件夹的权限；\n\n#### 4. watch 监听文件的变化\n\tgulp.watch(文件路径, [, opts ] , tasks ) \n\ntasks为当任务为多个时，执行的任务的名称的数组\n```\neg：\n\tgulp.task('uglify',function(){\n \t\t//do something\n\t});\n\t\n\tgulp.task('reload',function(){\n \t//do something\n\t});\n\t\n\tgulp.watch('js/**/*.js', ['uglify','reload']);\n\twatcher.on('change', function(event) {\n\t\tconsole.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n\t});\n\n\tgulp.watch(glob, [,opts], cb(event))\n\tcb(event)为每个变化执行的回调函数\n```\n```\neg：\n\n\tgulp.watch('js/**/*.js', function(event){\n \t\t//变化类型 added为新增,deleted为删除，changed为改变\n\tconsole.log(event.type);\n\t\t //变化的文件的路径\n\tconsole.log(event.path);\n\t});\n```\n\n### 三. gulp常见插件的使用\n\n#### 1. gulp-uglify  压缩javascript文件，减小文件大小\n\n##### (1) 输入 npm install gulp-uglify --save-dev  安装插件\n\n##### (2) 在gulpfile.js中引入\n\tvar gulp = require('gulp'),\n\tuglify = require(\"gulp-uglify\");\n\tgulp.task('minify-js', function () {\n\tgulp.src('js/*.js') // 要压缩的js文件\n\t .pipe(uglify())\n\t.pipe(gulp.dest('dist/js')); //压缩后的路径\n\t});\n\t\n  \t//压缩多个文件\n   \tvar gulp = require('gulp'),\n \t uglify = require('gulp-uglify');\n  \tgulp.task('jsmin', function () {\n \t//多个文件以数组形式传入\n \tgulp.src(['src/js/index.js','src/js/detail.js'])\n\t\t .pipe(uglify())\n \t\t.pipe(gulp.dest('dist/js'));\n\t});\n\t\n\tvar gulp = require('gulp'),\n\tuglify= require('gulp-uglify');\n\t\n\t匹配符“!”，“*”，“**”，“{}”\n\tgulp.task('jsmin', function () {\n\t //压缩src/js目录下的所有js文件\n \t//除了test1.js和test2.js（**匹配src/js的0个或多个子文件夹）\n\tgulp.src(['src/js/*.js', '!src/js/**/{test1,test2}.js'])\n \t.pipe(uglify())\n\t .pipe(gulp.dest('dist/js'));\n\t});\n\n详细介绍：[https://www.npmjs.com/package/gulp-uglify]([https://www.npmjs.com/package/gulp-uglify](https://www.npmjs.com/package/gulp-uglify))\n\n#### 2. gulp-rename 重命名文件流中的文件\n\n用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用 gulp-rename 插件来改变文件流中的文件名。\n##### (1) 安装gulp-rename\n\tnpm install gulp-rename --save-dev\n##### (2) 运用\n\tvar gulp = require('gulp'),\n\trename = require('gulp-rename'),\n\tuglify = require(\"gulp-uglify\");\n\tgulp.task('rename', function () {\n\tgulp.src('js/jquery.js')\n\t .pipe(uglify()) //压缩\n \t//会将jquery.js重命名为jquery.min.js\n \t.pipe(rename('jquery.min.js'))        //给所有文件加min后缀  .pipe(rename({ suffix: '.min' }))\n\t .pipe(gulp.dest('js'));\n\t});\n\n详细介绍：(https://www.npmjs.com/package/gulp-rename)[https://www.npmjs.com/package/gulp-rename](https://www.npmjs.com/package/gulp-rename)\n\n#### 3. gulp-minify-css 压缩css文件时并给引用url添加版本号避免缓存\n\n##### (1) 安装\n\tnpm install gulp-minify-css --save-dev\n\n##### (2) 运用\n\tvar gulp = require('gulp'),\n\tcssmin = require('gulp-minify-css');\n \t//确保已本地安装gulp-make-css-url-version [npm install gulp-make-css-url-version --save-dev]\n\tcssver = require('gulp-make-css-url-version');\n\tgulp.task('testCssmin', function () {\n\tgulp.src('src/css/*.css')\n\t .pipe(cssver()) //给css文件里引用文件加版本号（文件MD5）\n\t .pipe(cssmin())\n\t .pipe(gulp.dest('dist/css'));\n\t});\n\n详细介绍：[https://www.npmjs.com/package/gulp-minify-css/](https://www.npmjs.com/package/gulp-minify-css/)\n\n#### 4. gulp-htmlmin \n\n压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作。\n\n##### (1) 安装\n\tnpm install gulp-htmlmin --save-dev\n\t\n##### (2) 运用\n\n\tvar gulp = require('gulp'),\n\thtmlmin = require('gulp-htmlmin');\n\tgulp.task('testHtmlmin', function () {\n \tvar options = {\n\tremoveComments: true,//清除HTML注释\n\tcollapseWhitespace: true,//压缩HTML\n\t //省略布尔属性的值 <input checked=\"true\"/> ==> <input />\n\tcollapseBooleanAttributes: true,\n\t //删除所有空格作属性值 <input id=\"\" /> ==> <input />\n\tremoveEmptyAttributes: true,\n\t //删除<script>的type=\"text/javascript\"\n\tremoveScriptTypeAttributes: true,\n\t //删除<style>和<link>的type=\"text/css\"\n\tremoveStyleLinkTypeAttributes: true,\n\tminifyJS: true,//压缩页面JS\n\tminifyCSS: true//压缩页面CSS\n \t};\n\tgulp.src('src/html/*.html')\n\t .pipe(htmlmin(options))\n\t .pipe(gulp.dest('dist/html'));\n\t});\n\n详细介绍：[https://github.com/kangax/html-minifier#user-content-options-quick-reference](https://github.com/kangax/html-minifier#user-content-options-quick-reference)\n\n#### 5. gulp-concat \n\n用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了。\n\n##### (1)安装\n\n\tnpm install gulp-concat --save-dev\n\t\n##### (2) 运用\n\n\tvar gulp = require('gulp'),\n\tconcat = require(\"gulp-concat\");\n\tgulp.task('concat', function () {\n\tgulp.src('js/*.js') //要合并的文件\n\t .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 \"all.js\"\n \t.pipe(gulp.dest('dist/js'));\n\t});\n\n详细介绍：[https://www.npmjs.com/package/gulp-concat/](https://www.npmjs.com/package/gulp-concat/)\n\n#### 6. gulp-imagemin 压缩图片文件\n\n详细介绍：[https://github.com/sindresorhus/gulp-imagemin]( https://github.com/sindresorhus/gulp-imagemin)\n\n#### 7. gulp-jshint 检测JavaScript代码中错误和潜在问题\n\n详细介绍：[https://www.npmjs.com/package/gulp-jshint](https://www.npmjs.com/package/gulp-jshint)\n\n#### 8.gulp-rev 给文件增加MD5值\n\n结果如下：\n\n\"css/unicorn.css\": \"css/unicorn-d41d8cd98f.css\",\n\"js/unicorn.js\": \"js/unicorn-273c2cin3f.js\"\n\n##### (1) 安装：\n\t\n\tnpm install gulp-rev --save-rev\n\n##### (2) 运用\n\n\tvar gulp = require('gulp');\n\tvar rev = require('gulp-rev');\n \n\tgulp.task('default', function () {\n\treturn gulp.src('assets/css/*.css')\n   \t\t .pipe(rev())\n   \t\t .pipe(gulp.dest('dist/css'))  \n    \t\t.pipe(rev.manifest())//生成一个json文件，记录添加MD5值前后文件名的对应关系\n    \t\t.pipe(gulp.dest('dist/rev'));\n\t});\n\t\n#### 9. gulp-rev-recollector  替换掉html文件中的引用路径\n\n本插件必须在gulp-rev安装成功后，用.pipe(rev.manifest())生成了对应的json文件才能替换html文件中的引用路径\n\n##### (1) 安装\n\t\n\tnpm install gulp-rev-recollector --save-dev\n\t\n##### (2) 运用 \n\n\tvar revCollector = require('gulp-rev-collector'); \n\tgulp.task('rev', ['使用gulp-rev的函数名'] , function () {\n    \treturn gulp.src(['rev/**/*.json', 'templates/**/*.html'])\n   \t .pipe( revCollector({\n              \t replaceReved: true,\n              \t dirReplacements: {\n                                            \t 'css': '/dist/css',\n                                            \t '/js/': '/dist/js/',\n                                             \t 'cdn/': function(manifest_value) {\n                                              \t return '//cdn' + (Math.floor(Math.random() * 9) + 1) + '.' + 'exsample.dot' + '/img/' +     \n                                               \t manifest_value;\n                \t }\n  \t }\n\t }) )\n \t.pipe( gulp.dest('dist') );\n\t});\n\t\n<font color=\"red\"> 注意：由于gulp完成各个task是异步的，因此执行gulp-rev-recollector之前需要执行gulo-rev，解决方法：见代码第二行红色部分 </font>\n\n#### 10.gulp-autoprefixer 针对不同的浏览器，给CSS文件添加相应的前缀\n\n##### (1) 安装 \n\n\tnpm install gulp-autoprefixer --save-dev\n\t\n##### (2) 运用\n\n\t//引入插件\n\tvar gulp = require('gulp');\n\tvar autoprefixer = require('gulp-autoprefixer');\n\t//默认执行任务\n\tgulp.task('default', function () {\n\t//找到src目录下app.css，为其补全浏览器兼容的css\n\treturn gulp.src('src/app.css')\n       \t .pipe(autoprefixer({\n            \tbrowsers: ['last 2 versions'],\n            \tcascade: false\n        \t}))\n\t//输出到dist文件夹\n       \t .pipe(gulp.dest('dist'));\n\t});\n\n#### 11. gulp-watch-path   若文件有改动，针对改动的文件进行压缩\n\n##### (1) 安装  \n\tnpm install gulp-watch-path --save-dev\n\t\n##### (2) 运用\n\n\tvar watchPath=require('gulp-watch-path');\n\tgulp.task('auto-css',function(){ \n     \tgulp.watch('static/css/**/*.css', function (event) { \n        \tvar paths = watchPath(event, 'static/', 'dist/') \n       \t /* \n       \t paths \n          \t  { srcPath: 'src/js/log.js', \n            \t  srcDir: 'src/js/', \n             \t distPath: 'dist/js/log.js', \n             \t distDir: 'dist/js/', \n             \t srcFilename: 'log.js', \n             \t distFilename: 'log.js' } \n       \t */ \n       \t //gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) \n        \t//gutil.log('Dist ' + paths.distPath) \n       \t gulp.src(paths.srcPath)\n       \t .pipe(minifycss()) \n       \t .pipe(gulp.dest(paths.distDir)) \n  \t  }) \n\t});\n\n#### 12. 压缩图片gulp-imagemin\n\n可以压缩gif，png和jpg。\n\n用这个插件压缩jpg图片，体积压缩得越小，图片就越不清晰，所以不建议把jpg图片压缩质量设置得过低，60%-80%为宜。\n\n而把png24压缩成png8，提及一般可以减少50%以上。\n\n图片质量，优化等级进行设置\n\nhttp://www.ydcss.com/archives/26\n\n### 三. 在使用时应注意\n\n安装的插件和gulp不需要上传到代码托管工具上，只需要上传package.json 这个文件即可， package.json 这个文件记录了项目中依赖的 glup 插件。将代码下载下来之后，只需要在这个项目文件夹下面，输入命令 npm install，NPM 会自动读取 package.json 文件，将 gulp 和有关插件下载下来。\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-05-gulp.md","raw":"---\nlayout: post\ntitle: gulp 前端代码构建工具\ndate: 2016-03-05\ncategories: 工具\ntags: [工具,优化]\ndescription: \n---\n\n### 一. gulp简介\n\n**gulp**是一种任务自动处理工具，简单地说，gulp是一个工具框架，有很多插件扩展它的功能。\n\n**gulp**能够自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。\n\n**gulp的优点：**\n\n1. 基于流的构建工具，利用流的方式进行文件的处理\n1. 代码优于配置，通过简单的配置能够完成很多重复的功能\n1. 简单明了，目的明确，一般一个插件只完成一个任务\n1. gulp的gulpfile.js的写法更加通俗易懂，易上手\n\n### 二.  使用gulp的步骤：\n\n由于gulp是基于node.js的，因此在安装gulp之前需要安装node.js\n\n**node.js**是一个后端的js运行环境，也就是说：你写一个服务器端的js代码，可以交给node.js来解释执行。\n\n<font color=\"red\">安装nodejs -> 全局安装gulp -> 项目安装gulp以及gulp插件 -> 配置gulpfile.js -> 运行任务</font>\n\n#### 1. 安装nodejs\n\n从官网上直接下载安装（路径随意）\n\n打开cmd：\n\n\t输入 node -v       /* 查看nodejs版本号*/\n\t输入npm -v         /* 查看npm版本号 */\n\t输入D:             /*定位到D盘*/\n\t输入cd  nodejs \t  /* 定位到安装目录*/\n\t输入dir           /*查看当前定位目录下的文件*/\n\t输入cls           /* 清空内容*/\n\n#### 2. 全局安装gulp  \n**目的**：通过全局安装的gulp执行gulp任务，全局安装完gulp之后，就可以使用gulp命令行\n\n\t输入 npm install gulp -g   /*全局安装gulp*/\n\t输入 gulp -v               /*查看安装的gulp的版本号，出现版本号即为正确安装*/\n\n#### 3. 新建package.json文件\npackage.json是nodejs项目必不可少的配置文件，存放在项目的根目录下\n\n\t输入 npm init          /*创建 package.json文件*/\n\n前三项（项目名称，项目版本，项目描述）必须输入，后几项可留空\n\t\n\t输入 npm help package.json   /*查看package.json帮助文档*/\n\n#### 4. 项目安装gulp依赖\n\n\t输入 npm install gulp --save-dev     /*本地安装gulp*/\n\t输入 npm install 插件名 --save-dev   /*安装gulp插件*/\n\t\n--save : 将配置信息保存至 **package.json**\n\n-dev：将配置信息保存至**package.json** 的 **devDependencies**节点\n\n#### 5. 在项目的根目录下创建gulpfile.js文件\n\n\t//导入工具包 require('node_modules里对应模块')\n\tvar gulp = require('gulp'), //本地安装gulp所用到的地方\n \t less = require('gulp-less');\n \n\t//定义一个testLess任务（自定义任务名称）\n\tgulp.task('testLess', function () {\n   \t\t gulp.src('src/less/index.less') //该任务针对的文件\n       \t\t .pipe(less()) //该任务调用的模块\n       \t\t .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css\n\t});\n \n\tgulp.task('default',['testLess', 'elseTask']); //定义默认任务\n \n\t//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数\n\t//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组)\n\t//gulp.dest(path[, options]) 处理完后文件生成路径\n\n#### 6. 运行gulp\n\t输入$gulp                 /*运行gulp*/\n\t输入gulp default     \t /*运行gulpfile.js中一个名为default的函数*/\n\n### 二. gulp的API（在gulpfile.js里面会用到）\n\n#### 1. task  用于定义一个gulp的任务\n\tgulp.task(name, [deps] , fn)\n\n**name**为任务名称** ‘default’**\n\n**deps**为任务依赖的任务，可有多个，按照顺序执行 ['task', 'task2']\n\n**fn** 该任务调用的插件操作\n\n#### 2. src  指定需要处理的源文件的路径\n\tgulp.src(文件路径的模式匹配globs, {options})\n\nglobs为需要处理的源文件匹配符路径（字符串或者字符串数组）\n\n\n\teg：\"src/a.js\"                                             匹配具体文件\n\t\n\t\t\"src/*.js\"                                             匹配src目录下的所有js文件\n\t\n\t\t\"src/**/*.js\"                                         匹配src目录下的 0个或多个子文件夹 下的所有js文件\n\t\n\t\t\"src/{a,b}.js\" 或者\"src/*.{jpg,png}\"     同时匹配多个文件\n\n**options：有3个属性buffer  read  base**\n\n**buffer：**默认true        设置为false时，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；\n\n**read：** 默认为true      设置为false，将不执行读取文件操作，返回null；\n\n**base：**为string类型    设置输出路径以某个路径的某个组成部分为基础向后拼接。\n\n#### 3. dest 指定处理完之后文件的输出路径\n\tgulp.dest(path,{option})\n\t\npath为文件的输出路径\n\n**options：有2个属性cwd mode**\n\ncwd：类型string  默认：process.cwd()：前脚本的工作目录的路径当文件输出路径为相对路径将会用到；\n\nmode：类型：String  默认：0777 指定被创建文件夹的权限；\n\n#### 4. watch 监听文件的变化\n\tgulp.watch(文件路径, [, opts ] , tasks ) \n\ntasks为当任务为多个时，执行的任务的名称的数组\n```\neg：\n\tgulp.task('uglify',function(){\n \t\t//do something\n\t});\n\t\n\tgulp.task('reload',function(){\n \t//do something\n\t});\n\t\n\tgulp.watch('js/**/*.js', ['uglify','reload']);\n\twatcher.on('change', function(event) {\n\t\tconsole.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n\t});\n\n\tgulp.watch(glob, [,opts], cb(event))\n\tcb(event)为每个变化执行的回调函数\n```\n```\neg：\n\n\tgulp.watch('js/**/*.js', function(event){\n \t\t//变化类型 added为新增,deleted为删除，changed为改变\n\tconsole.log(event.type);\n\t\t //变化的文件的路径\n\tconsole.log(event.path);\n\t});\n```\n\n### 三. gulp常见插件的使用\n\n#### 1. gulp-uglify  压缩javascript文件，减小文件大小\n\n##### (1) 输入 npm install gulp-uglify --save-dev  安装插件\n\n##### (2) 在gulpfile.js中引入\n\tvar gulp = require('gulp'),\n\tuglify = require(\"gulp-uglify\");\n\tgulp.task('minify-js', function () {\n\tgulp.src('js/*.js') // 要压缩的js文件\n\t .pipe(uglify())\n\t.pipe(gulp.dest('dist/js')); //压缩后的路径\n\t});\n\t\n  \t//压缩多个文件\n   \tvar gulp = require('gulp'),\n \t uglify = require('gulp-uglify');\n  \tgulp.task('jsmin', function () {\n \t//多个文件以数组形式传入\n \tgulp.src(['src/js/index.js','src/js/detail.js'])\n\t\t .pipe(uglify())\n \t\t.pipe(gulp.dest('dist/js'));\n\t});\n\t\n\tvar gulp = require('gulp'),\n\tuglify= require('gulp-uglify');\n\t\n\t匹配符“!”，“*”，“**”，“{}”\n\tgulp.task('jsmin', function () {\n\t //压缩src/js目录下的所有js文件\n \t//除了test1.js和test2.js（**匹配src/js的0个或多个子文件夹）\n\tgulp.src(['src/js/*.js', '!src/js/**/{test1,test2}.js'])\n \t.pipe(uglify())\n\t .pipe(gulp.dest('dist/js'));\n\t});\n\n详细介绍：[https://www.npmjs.com/package/gulp-uglify]([https://www.npmjs.com/package/gulp-uglify](https://www.npmjs.com/package/gulp-uglify))\n\n#### 2. gulp-rename 重命名文件流中的文件\n\n用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用 gulp-rename 插件来改变文件流中的文件名。\n##### (1) 安装gulp-rename\n\tnpm install gulp-rename --save-dev\n##### (2) 运用\n\tvar gulp = require('gulp'),\n\trename = require('gulp-rename'),\n\tuglify = require(\"gulp-uglify\");\n\tgulp.task('rename', function () {\n\tgulp.src('js/jquery.js')\n\t .pipe(uglify()) //压缩\n \t//会将jquery.js重命名为jquery.min.js\n \t.pipe(rename('jquery.min.js'))        //给所有文件加min后缀  .pipe(rename({ suffix: '.min' }))\n\t .pipe(gulp.dest('js'));\n\t});\n\n详细介绍：(https://www.npmjs.com/package/gulp-rename)[https://www.npmjs.com/package/gulp-rename](https://www.npmjs.com/package/gulp-rename)\n\n#### 3. gulp-minify-css 压缩css文件时并给引用url添加版本号避免缓存\n\n##### (1) 安装\n\tnpm install gulp-minify-css --save-dev\n\n##### (2) 运用\n\tvar gulp = require('gulp'),\n\tcssmin = require('gulp-minify-css');\n \t//确保已本地安装gulp-make-css-url-version [npm install gulp-make-css-url-version --save-dev]\n\tcssver = require('gulp-make-css-url-version');\n\tgulp.task('testCssmin', function () {\n\tgulp.src('src/css/*.css')\n\t .pipe(cssver()) //给css文件里引用文件加版本号（文件MD5）\n\t .pipe(cssmin())\n\t .pipe(gulp.dest('dist/css'));\n\t});\n\n详细介绍：[https://www.npmjs.com/package/gulp-minify-css/](https://www.npmjs.com/package/gulp-minify-css/)\n\n#### 4. gulp-htmlmin \n\n压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作。\n\n##### (1) 安装\n\tnpm install gulp-htmlmin --save-dev\n\t\n##### (2) 运用\n\n\tvar gulp = require('gulp'),\n\thtmlmin = require('gulp-htmlmin');\n\tgulp.task('testHtmlmin', function () {\n \tvar options = {\n\tremoveComments: true,//清除HTML注释\n\tcollapseWhitespace: true,//压缩HTML\n\t //省略布尔属性的值 <input checked=\"true\"/> ==> <input />\n\tcollapseBooleanAttributes: true,\n\t //删除所有空格作属性值 <input id=\"\" /> ==> <input />\n\tremoveEmptyAttributes: true,\n\t //删除<script>的type=\"text/javascript\"\n\tremoveScriptTypeAttributes: true,\n\t //删除<style>和<link>的type=\"text/css\"\n\tremoveStyleLinkTypeAttributes: true,\n\tminifyJS: true,//压缩页面JS\n\tminifyCSS: true//压缩页面CSS\n \t};\n\tgulp.src('src/html/*.html')\n\t .pipe(htmlmin(options))\n\t .pipe(gulp.dest('dist/html'));\n\t});\n\n详细介绍：[https://github.com/kangax/html-minifier#user-content-options-quick-reference](https://github.com/kangax/html-minifier#user-content-options-quick-reference)\n\n#### 5. gulp-concat \n\n用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了。\n\n##### (1)安装\n\n\tnpm install gulp-concat --save-dev\n\t\n##### (2) 运用\n\n\tvar gulp = require('gulp'),\n\tconcat = require(\"gulp-concat\");\n\tgulp.task('concat', function () {\n\tgulp.src('js/*.js') //要合并的文件\n\t .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 \"all.js\"\n \t.pipe(gulp.dest('dist/js'));\n\t});\n\n详细介绍：[https://www.npmjs.com/package/gulp-concat/](https://www.npmjs.com/package/gulp-concat/)\n\n#### 6. gulp-imagemin 压缩图片文件\n\n详细介绍：[https://github.com/sindresorhus/gulp-imagemin]( https://github.com/sindresorhus/gulp-imagemin)\n\n#### 7. gulp-jshint 检测JavaScript代码中错误和潜在问题\n\n详细介绍：[https://www.npmjs.com/package/gulp-jshint](https://www.npmjs.com/package/gulp-jshint)\n\n#### 8.gulp-rev 给文件增加MD5值\n\n结果如下：\n\n\"css/unicorn.css\": \"css/unicorn-d41d8cd98f.css\",\n\"js/unicorn.js\": \"js/unicorn-273c2cin3f.js\"\n\n##### (1) 安装：\n\t\n\tnpm install gulp-rev --save-rev\n\n##### (2) 运用\n\n\tvar gulp = require('gulp');\n\tvar rev = require('gulp-rev');\n \n\tgulp.task('default', function () {\n\treturn gulp.src('assets/css/*.css')\n   \t\t .pipe(rev())\n   \t\t .pipe(gulp.dest('dist/css'))  \n    \t\t.pipe(rev.manifest())//生成一个json文件，记录添加MD5值前后文件名的对应关系\n    \t\t.pipe(gulp.dest('dist/rev'));\n\t});\n\t\n#### 9. gulp-rev-recollector  替换掉html文件中的引用路径\n\n本插件必须在gulp-rev安装成功后，用.pipe(rev.manifest())生成了对应的json文件才能替换html文件中的引用路径\n\n##### (1) 安装\n\t\n\tnpm install gulp-rev-recollector --save-dev\n\t\n##### (2) 运用 \n\n\tvar revCollector = require('gulp-rev-collector'); \n\tgulp.task('rev', ['使用gulp-rev的函数名'] , function () {\n    \treturn gulp.src(['rev/**/*.json', 'templates/**/*.html'])\n   \t .pipe( revCollector({\n              \t replaceReved: true,\n              \t dirReplacements: {\n                                            \t 'css': '/dist/css',\n                                            \t '/js/': '/dist/js/',\n                                             \t 'cdn/': function(manifest_value) {\n                                              \t return '//cdn' + (Math.floor(Math.random() * 9) + 1) + '.' + 'exsample.dot' + '/img/' +     \n                                               \t manifest_value;\n                \t }\n  \t }\n\t }) )\n \t.pipe( gulp.dest('dist') );\n\t});\n\t\n<font color=\"red\"> 注意：由于gulp完成各个task是异步的，因此执行gulp-rev-recollector之前需要执行gulo-rev，解决方法：见代码第二行红色部分 </font>\n\n#### 10.gulp-autoprefixer 针对不同的浏览器，给CSS文件添加相应的前缀\n\n##### (1) 安装 \n\n\tnpm install gulp-autoprefixer --save-dev\n\t\n##### (2) 运用\n\n\t//引入插件\n\tvar gulp = require('gulp');\n\tvar autoprefixer = require('gulp-autoprefixer');\n\t//默认执行任务\n\tgulp.task('default', function () {\n\t//找到src目录下app.css，为其补全浏览器兼容的css\n\treturn gulp.src('src/app.css')\n       \t .pipe(autoprefixer({\n            \tbrowsers: ['last 2 versions'],\n            \tcascade: false\n        \t}))\n\t//输出到dist文件夹\n       \t .pipe(gulp.dest('dist'));\n\t});\n\n#### 11. gulp-watch-path   若文件有改动，针对改动的文件进行压缩\n\n##### (1) 安装  \n\tnpm install gulp-watch-path --save-dev\n\t\n##### (2) 运用\n\n\tvar watchPath=require('gulp-watch-path');\n\tgulp.task('auto-css',function(){ \n     \tgulp.watch('static/css/**/*.css', function (event) { \n        \tvar paths = watchPath(event, 'static/', 'dist/') \n       \t /* \n       \t paths \n          \t  { srcPath: 'src/js/log.js', \n            \t  srcDir: 'src/js/', \n             \t distPath: 'dist/js/log.js', \n             \t distDir: 'dist/js/', \n             \t srcFilename: 'log.js', \n             \t distFilename: 'log.js' } \n       \t */ \n       \t //gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) \n        \t//gutil.log('Dist ' + paths.distPath) \n       \t gulp.src(paths.srcPath)\n       \t .pipe(minifycss()) \n       \t .pipe(gulp.dest(paths.distDir)) \n  \t  }) \n\t});\n\n#### 12. 压缩图片gulp-imagemin\n\n可以压缩gif，png和jpg。\n\n用这个插件压缩jpg图片，体积压缩得越小，图片就越不清晰，所以不建议把jpg图片压缩质量设置得过低，60%-80%为宜。\n\n而把png24压缩成png8，提及一般可以减少50%以上。\n\n图片质量，优化等级进行设置\n\nhttp://www.ydcss.com/archives/26\n\n### 三. 在使用时应注意\n\n安装的插件和gulp不需要上传到代码托管工具上，只需要上传package.json 这个文件即可， package.json 这个文件记录了项目中依赖的 glup 插件。将代码下载下来之后，只需要在这个项目文件夹下面，输入命令 npm install，NPM 会自动读取 package.json 文件，将 gulp 和有关插件下载下来。\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-05-gulp","published":1,"updated":"2016-08-24T09:49:50.000Z","comments":1,"photos":[],"link":"","_id":"cj035occa000gd5u81zxg2aji","content":"<h3 id=\"一-gulp简介\"><a href=\"#一-gulp简介\" class=\"headerlink\" title=\"一. gulp简介\"></a>一. gulp简介</h3><p><strong>gulp</strong>是一种任务自动处理工具，简单地说，gulp是一个工具框架，有很多插件扩展它的功能。</p>\n<p><strong>gulp</strong>能够自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。</p>\n<p><strong>gulp的优点：</strong></p>\n<ol>\n<li>基于流的构建工具，利用流的方式进行文件的处理</li>\n<li>代码优于配置，通过简单的配置能够完成很多重复的功能</li>\n<li>简单明了，目的明确，一般一个插件只完成一个任务</li>\n<li>gulp的gulpfile.js的写法更加通俗易懂，易上手</li>\n</ol>\n<h3 id=\"二-使用gulp的步骤：\"><a href=\"#二-使用gulp的步骤：\" class=\"headerlink\" title=\"二.  使用gulp的步骤：\"></a>二.  使用gulp的步骤：</h3><p>由于gulp是基于node.js的，因此在安装gulp之前需要安装node.js</p>\n<p><strong>node.js</strong>是一个后端的js运行环境，也就是说：你写一个服务器端的js代码，可以交给node.js来解释执行。</p>\n<font color=\"red\">安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务</font>\n\n<h4 id=\"1-安装nodejs\"><a href=\"#1-安装nodejs\" class=\"headerlink\" title=\"1. 安装nodejs\"></a>1. 安装nodejs</h4><p>从官网上直接下载安装（路径随意）</p>\n<p>打开cmd：</p>\n<pre><code>输入 node -v       /* 查看nodejs版本号*/\n输入npm -v         /* 查看npm版本号 */\n输入D:             /*定位到D盘*/\n输入cd  nodejs       /* 定位到安装目录*/\n输入dir           /*查看当前定位目录下的文件*/\n输入cls           /* 清空内容*/\n</code></pre><h4 id=\"2-全局安装gulp\"><a href=\"#2-全局安装gulp\" class=\"headerlink\" title=\"2. 全局安装gulp\"></a>2. 全局安装gulp</h4><p><strong>目的</strong>：通过全局安装的gulp执行gulp任务，全局安装完gulp之后，就可以使用gulp命令行</p>\n<pre><code>输入 npm install gulp -g   /*全局安装gulp*/\n输入 gulp -v               /*查看安装的gulp的版本号，出现版本号即为正确安装*/\n</code></pre><h4 id=\"3-新建package-json文件\"><a href=\"#3-新建package-json文件\" class=\"headerlink\" title=\"3. 新建package.json文件\"></a>3. 新建package.json文件</h4><p>package.json是nodejs项目必不可少的配置文件，存放在项目的根目录下</p>\n<pre><code>输入 npm init          /*创建 package.json文件*/\n</code></pre><p>前三项（项目名称，项目版本，项目描述）必须输入，后几项可留空</p>\n<pre><code>输入 npm help package.json   /*查看package.json帮助文档*/\n</code></pre><h4 id=\"4-项目安装gulp依赖\"><a href=\"#4-项目安装gulp依赖\" class=\"headerlink\" title=\"4. 项目安装gulp依赖\"></a>4. 项目安装gulp依赖</h4><pre><code>输入 npm install gulp --save-dev     /*本地安装gulp*/\n输入 npm install 插件名 --save-dev   /*安装gulp插件*/\n</code></pre><p>–save : 将配置信息保存至 <strong>package.json</strong></p>\n<p>-dev：将配置信息保存至<strong>package.json</strong> 的 <strong>devDependencies</strong>节点</p>\n<h4 id=\"5-在项目的根目录下创建gulpfile-js文件\"><a href=\"#5-在项目的根目录下创建gulpfile-js文件\" class=\"headerlink\" title=\"5. 在项目的根目录下创建gulpfile.js文件\"></a>5. 在项目的根目录下创建gulpfile.js文件</h4><pre><code>//导入工具包 require(&apos;node_modules里对应模块&apos;)\nvar gulp = require(&apos;gulp&apos;), //本地安装gulp所用到的地方\n  less = require(&apos;gulp-less&apos;);\n\n//定义一个testLess任务（自定义任务名称）\ngulp.task(&apos;testLess&apos;, function () {\n        gulp.src(&apos;src/less/index.less&apos;) //该任务针对的文件\n            .pipe(less()) //该任务调用的模块\n            .pipe(gulp.dest(&apos;src/css&apos;)); //将会在src/css下生成index.css\n});\n\ngulp.task(&apos;default&apos;,[&apos;testLess&apos;, &apos;elseTask&apos;]); //定义默认任务\n\n//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数\n//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组)\n//gulp.dest(path[, options]) 处理完后文件生成路径\n</code></pre><h4 id=\"6-运行gulp\"><a href=\"#6-运行gulp\" class=\"headerlink\" title=\"6. 运行gulp\"></a>6. 运行gulp</h4><pre><code>输入$gulp                 /*运行gulp*/\n输入gulp default          /*运行gulpfile.js中一个名为default的函数*/\n</code></pre><h3 id=\"二-gulp的API（在gulpfile-js里面会用到）\"><a href=\"#二-gulp的API（在gulpfile-js里面会用到）\" class=\"headerlink\" title=\"二. gulp的API（在gulpfile.js里面会用到）\"></a>二. gulp的API（在gulpfile.js里面会用到）</h3><h4 id=\"1-task-用于定义一个gulp的任务\"><a href=\"#1-task-用于定义一个gulp的任务\" class=\"headerlink\" title=\"1. task  用于定义一个gulp的任务\"></a>1. task  用于定义一个gulp的任务</h4><pre><code>gulp.task(name, [deps] , fn)\n</code></pre><p><strong>name</strong>为任务名称<strong> ‘default’</strong></p>\n<p><strong>deps</strong>为任务依赖的任务，可有多个，按照顺序执行 [‘task’, ‘task2’]</p>\n<p><strong>fn</strong> 该任务调用的插件操作</p>\n<h4 id=\"2-src-指定需要处理的源文件的路径\"><a href=\"#2-src-指定需要处理的源文件的路径\" class=\"headerlink\" title=\"2. src  指定需要处理的源文件的路径\"></a>2. src  指定需要处理的源文件的路径</h4><pre><code>gulp.src(文件路径的模式匹配globs, {options})\n</code></pre><p>globs为需要处理的源文件匹配符路径（字符串或者字符串数组）</p>\n<pre><code>eg：&quot;src/a.js&quot;                                             匹配具体文件\n\n    &quot;src/*.js&quot;                                             匹配src目录下的所有js文件\n\n    &quot;src/**/*.js&quot;                                         匹配src目录下的 0个或多个子文件夹 下的所有js文件\n\n    &quot;src/{a,b}.js&quot; 或者&quot;src/*.{jpg,png}&quot;     同时匹配多个文件\n</code></pre><p><strong>options：有3个属性buffer  read  base</strong></p>\n<p><strong>buffer：</strong>默认true        设置为false时，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；</p>\n<p><strong>read：</strong> 默认为true      设置为false，将不执行读取文件操作，返回null；</p>\n<p><strong>base：</strong>为string类型    设置输出路径以某个路径的某个组成部分为基础向后拼接。</p>\n<h4 id=\"3-dest-指定处理完之后文件的输出路径\"><a href=\"#3-dest-指定处理完之后文件的输出路径\" class=\"headerlink\" title=\"3. dest 指定处理完之后文件的输出路径\"></a>3. dest 指定处理完之后文件的输出路径</h4><pre><code>gulp.dest(path,{option})\n</code></pre><p>path为文件的输出路径</p>\n<p><strong>options：有2个属性cwd mode</strong></p>\n<p>cwd：类型string  默认：process.cwd()：前脚本的工作目录的路径当文件输出路径为相对路径将会用到；</p>\n<p>mode：类型：String  默认：0777 指定被创建文件夹的权限；</p>\n<h4 id=\"4-watch-监听文件的变化\"><a href=\"#4-watch-监听文件的变化\" class=\"headerlink\" title=\"4. watch 监听文件的变化\"></a>4. watch 监听文件的变化</h4><pre><code>gulp.watch(文件路径, [, opts ] , tasks ) \n</code></pre><p>tasks为当任务为多个时，执行的任务的名称的数组<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">eg</span>：</span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.task</span>(<span class=\"string\">'uglify'</span>,function()&#123;</span><br><span class=\"line\"> \t\t<span class=\"comment\">//do something</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.task</span>(<span class=\"string\">'reload'</span>,function()&#123;</span><br><span class=\"line\"> \t<span class=\"comment\">//do something</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.watch</span>(<span class=\"string\">'js/**/*.js'</span>, [<span class=\"string\">'uglify'</span>,<span class=\"string\">'reload'</span>]);</span><br><span class=\"line\">\t<span class=\"selector-tag\">watcher</span><span class=\"selector-class\">.on</span>(<span class=\"string\">'change'</span>, function(event) &#123;</span><br><span class=\"line\">\t\tconsole<span class=\"selector-class\">.log</span>(<span class=\"string\">'File '</span> + event.path + <span class=\"string\">' was '</span> + event.type + <span class=\"string\">', running tasks...'</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.watch</span>(glob, [,opts], cb(event))</span><br><span class=\"line\">\t<span class=\"selector-tag\">cb</span>(event)为每个变化执行的回调函数</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">eg</span>：</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.watch</span>(<span class=\"string\">'js/**/*.js'</span>, function(event)&#123;</span><br><span class=\"line\"> \t\t<span class=\"comment\">//变化类型 added为新增,deleted为删除，changed为改变</span></span><br><span class=\"line\">\tconsole<span class=\"selector-class\">.log</span>(event.type);</span><br><span class=\"line\">\t\t <span class=\"comment\">//变化的文件的路径</span></span><br><span class=\"line\">\tconsole<span class=\"selector-class\">.log</span>(event.path);</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-gulp常见插件的使用\"><a href=\"#三-gulp常见插件的使用\" class=\"headerlink\" title=\"三. gulp常见插件的使用\"></a>三. gulp常见插件的使用</h3><h4 id=\"1-gulp-uglify-压缩javascript文件，减小文件大小\"><a href=\"#1-gulp-uglify-压缩javascript文件，减小文件大小\" class=\"headerlink\" title=\"1. gulp-uglify  压缩javascript文件，减小文件大小\"></a>1. gulp-uglify  压缩javascript文件，减小文件大小</h4><h5 id=\"1-输入-npm-install-gulp-uglify-–save-dev-安装插件\"><a href=\"#1-输入-npm-install-gulp-uglify-–save-dev-安装插件\" class=\"headerlink\" title=\"(1) 输入 npm install gulp-uglify –save-dev  安装插件\"></a>(1) 输入 npm install gulp-uglify –save-dev  安装插件</h5><h5 id=\"2-在gulpfile-js中引入\"><a href=\"#2-在gulpfile-js中引入\" class=\"headerlink\" title=\"(2) 在gulpfile.js中引入\"></a>(2) 在gulpfile.js中引入</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nuglify = require(&quot;gulp-uglify&quot;);\ngulp.task(&apos;minify-js&apos;, function () {\ngulp.src(&apos;js/*.js&apos;) // 要压缩的js文件\n .pipe(uglify())\n.pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径\n});\n\n  //压缩多个文件\n   var gulp = require(&apos;gulp&apos;),\n  uglify = require(&apos;gulp-uglify&apos;);\n  gulp.task(&apos;jsmin&apos;, function () {\n //多个文件以数组形式传入\n gulp.src([&apos;src/js/index.js&apos;,&apos;src/js/detail.js&apos;])\n     .pipe(uglify())\n     .pipe(gulp.dest(&apos;dist/js&apos;));\n});\n\nvar gulp = require(&apos;gulp&apos;),\nuglify= require(&apos;gulp-uglify&apos;);\n\n匹配符“!”，“*”，“**”，“{}”\ngulp.task(&apos;jsmin&apos;, function () {\n //压缩src/js目录下的所有js文件\n //除了test1.js和test2.js（**匹配src/js的0个或多个子文件夹）\ngulp.src([&apos;src/js/*.js&apos;, &apos;!src/js/**/{test1,test2}.js&apos;])\n .pipe(uglify())\n .pipe(gulp.dest(&apos;dist/js&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"[https://www.npmjs.com/package/gulp-uglify](https://www.npmjs.com/package/gulp-uglify\">https://www.npmjs.com/package/gulp-uglify</a>)</p>\n<h4 id=\"2-gulp-rename-重命名文件流中的文件\"><a href=\"#2-gulp-rename-重命名文件流中的文件\" class=\"headerlink\" title=\"2. gulp-rename 重命名文件流中的文件\"></a>2. gulp-rename 重命名文件流中的文件</h4><p>用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用 gulp-rename 插件来改变文件流中的文件名。</p>\n<h5 id=\"1-安装gulp-rename\"><a href=\"#1-安装gulp-rename\" class=\"headerlink\" title=\"(1) 安装gulp-rename\"></a>(1) 安装gulp-rename</h5><pre><code>npm install gulp-rename --save-dev\n</code></pre><h5 id=\"2-运用\"><a href=\"#2-运用\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nrename = require(&apos;gulp-rename&apos;),\nuglify = require(&quot;gulp-uglify&quot;);\ngulp.task(&apos;rename&apos;, function () {\ngulp.src(&apos;js/jquery.js&apos;)\n .pipe(uglify()) //压缩\n //会将jquery.js重命名为jquery.min.js\n .pipe(rename(&apos;jquery.min.js&apos;))        //给所有文件加min后缀  .pipe(rename({ suffix: &apos;.min&apos; }))\n .pipe(gulp.dest(&apos;js&apos;));\n});\n</code></pre><p>详细介绍：(<a href=\"https://www.npmjs.com/package/gulp-rename)[https://www.npmjs.com/package/gulp-rename](https://www.npmjs.com/package/gulp-rename\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/gulp-rename)[https://www.npmjs.com/package/gulp-rename](https://www.npmjs.com/package/gulp-rename</a>)</p>\n<h4 id=\"3-gulp-minify-css-压缩css文件时并给引用url添加版本号避免缓存\"><a href=\"#3-gulp-minify-css-压缩css文件时并给引用url添加版本号避免缓存\" class=\"headerlink\" title=\"3. gulp-minify-css 压缩css文件时并给引用url添加版本号避免缓存\"></a>3. gulp-minify-css 压缩css文件时并给引用url添加版本号避免缓存</h4><h5 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-minify-css --save-dev\n</code></pre><h5 id=\"2-运用-1\"><a href=\"#2-运用-1\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\ncssmin = require(&apos;gulp-minify-css&apos;);\n //确保已本地安装gulp-make-css-url-version [npm install gulp-make-css-url-version --save-dev]\ncssver = require(&apos;gulp-make-css-url-version&apos;);\ngulp.task(&apos;testCssmin&apos;, function () {\ngulp.src(&apos;src/css/*.css&apos;)\n .pipe(cssver()) //给css文件里引用文件加版本号（文件MD5）\n .pipe(cssmin())\n .pipe(gulp.dest(&apos;dist/css&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"https://www.npmjs.com/package/gulp-minify-css/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/gulp-minify-css/</a></p>\n<h4 id=\"4-gulp-htmlmin\"><a href=\"#4-gulp-htmlmin\" class=\"headerlink\" title=\"4. gulp-htmlmin\"></a>4. gulp-htmlmin</h4><p>压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作。</p>\n<h5 id=\"1-安装-1\"><a href=\"#1-安装-1\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-htmlmin --save-dev\n</code></pre><h5 id=\"2-运用-2\"><a href=\"#2-运用-2\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nhtmlmin = require(&apos;gulp-htmlmin&apos;);\ngulp.task(&apos;testHtmlmin&apos;, function () {\n var options = {\nremoveComments: true,//清除HTML注释\ncollapseWhitespace: true,//压缩HTML\n //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;\ncollapseBooleanAttributes: true,\n //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;\nremoveEmptyAttributes: true,\n //删除&lt;script&gt;的type=&quot;text/javascript&quot;\nremoveScriptTypeAttributes: true,\n //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;\nremoveStyleLinkTypeAttributes: true,\nminifyJS: true,//压缩页面JS\nminifyCSS: true//压缩页面CSS\n };\ngulp.src(&apos;src/html/*.html&apos;)\n .pipe(htmlmin(options))\n .pipe(gulp.dest(&apos;dist/html&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"https://github.com/kangax/html-minifier#user-content-options-quick-reference\" target=\"_blank\" rel=\"external\">https://github.com/kangax/html-minifier#user-content-options-quick-reference</a></p>\n<h4 id=\"5-gulp-concat\"><a href=\"#5-gulp-concat\" class=\"headerlink\" title=\"5. gulp-concat\"></a>5. gulp-concat</h4><p>用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了。</p>\n<h5 id=\"1-安装-2\"><a href=\"#1-安装-2\" class=\"headerlink\" title=\"(1)安装\"></a>(1)安装</h5><pre><code>npm install gulp-concat --save-dev\n</code></pre><h5 id=\"2-运用-3\"><a href=\"#2-运用-3\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nconcat = require(&quot;gulp-concat&quot;);\ngulp.task(&apos;concat&apos;, function () {\ngulp.src(&apos;js/*.js&apos;) //要合并的文件\n .pipe(concat(&apos;all.js&apos;)) // 合并匹配到的js文件并命名为 &quot;all.js&quot;\n .pipe(gulp.dest(&apos;dist/js&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"https://www.npmjs.com/package/gulp-concat/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/gulp-concat/</a></p>\n<h4 id=\"6-gulp-imagemin-压缩图片文件\"><a href=\"#6-gulp-imagemin-压缩图片文件\" class=\"headerlink\" title=\"6. gulp-imagemin 压缩图片文件\"></a>6. gulp-imagemin 压缩图片文件</h4><p>详细介绍：<a href=\"https://github.com/sindresorhus/gulp-imagemin\" target=\"_blank\" rel=\"external\">https://github.com/sindresorhus/gulp-imagemin</a></p>\n<h4 id=\"7-gulp-jshint-检测JavaScript代码中错误和潜在问题\"><a href=\"#7-gulp-jshint-检测JavaScript代码中错误和潜在问题\" class=\"headerlink\" title=\"7. gulp-jshint 检测JavaScript代码中错误和潜在问题\"></a>7. gulp-jshint 检测JavaScript代码中错误和潜在问题</h4><p>详细介绍：<a href=\"https://www.npmjs.com/package/gulp-jshint\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/gulp-jshint</a></p>\n<h4 id=\"8-gulp-rev-给文件增加MD5值\"><a href=\"#8-gulp-rev-给文件增加MD5值\" class=\"headerlink\" title=\"8.gulp-rev 给文件增加MD5值\"></a>8.gulp-rev 给文件增加MD5值</h4><p>结果如下：</p>\n<p>“css/unicorn.css”: “css/unicorn-d41d8cd98f.css”,<br>“js/unicorn.js”: “js/unicorn-273c2cin3f.js”</p>\n<h5 id=\"1-安装：\"><a href=\"#1-安装：\" class=\"headerlink\" title=\"(1) 安装：\"></a>(1) 安装：</h5><pre><code>npm install gulp-rev --save-rev\n</code></pre><h5 id=\"2-运用-4\"><a href=\"#2-运用-4\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;);\nvar rev = require(&apos;gulp-rev&apos;);\n\ngulp.task(&apos;default&apos;, function () {\nreturn gulp.src(&apos;assets/css/*.css&apos;)\n        .pipe(rev())\n        .pipe(gulp.dest(&apos;dist/css&apos;))  \n        .pipe(rev.manifest())//生成一个json文件，记录添加MD5值前后文件名的对应关系\n        .pipe(gulp.dest(&apos;dist/rev&apos;));\n});\n</code></pre><h4 id=\"9-gulp-rev-recollector-替换掉html文件中的引用路径\"><a href=\"#9-gulp-rev-recollector-替换掉html文件中的引用路径\" class=\"headerlink\" title=\"9. gulp-rev-recollector  替换掉html文件中的引用路径\"></a>9. gulp-rev-recollector  替换掉html文件中的引用路径</h4><p>本插件必须在gulp-rev安装成功后，用.pipe(rev.manifest())生成了对应的json文件才能替换html文件中的引用路径</p>\n<h5 id=\"1-安装-3\"><a href=\"#1-安装-3\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-rev-recollector --save-dev\n</code></pre><h5 id=\"2-运用-5\"><a href=\"#2-运用-5\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var revCollector = require(&apos;gulp-rev-collector&apos;); \ngulp.task(&apos;rev&apos;, [&apos;使用gulp-rev的函数名&apos;] , function () {\n    return gulp.src([&apos;rev/**/*.json&apos;, &apos;templates/**/*.html&apos;])\n    .pipe( revCollector({\n               replaceReved: true,\n               dirReplacements: {\n                                             &apos;css&apos;: &apos;/dist/css&apos;,\n                                             &apos;/js/&apos;: &apos;/dist/js/&apos;,\n                                              &apos;cdn/&apos;: function(manifest_value) {\n                                               return &apos;//cdn&apos; + (Math.floor(Math.random() * 9) + 1) + &apos;.&apos; + &apos;exsample.dot&apos; + &apos;/img/&apos; +     \n                                                manifest_value;\n                 }\n   }\n }) )\n .pipe( gulp.dest(&apos;dist&apos;) );\n});\n</code></pre><font color=\"red\"> 注意：由于gulp完成各个task是异步的，因此执行gulp-rev-recollector之前需要执行gulo-rev，解决方法：见代码第二行红色部分 </font>\n\n<h4 id=\"10-gulp-autoprefixer-针对不同的浏览器，给CSS文件添加相应的前缀\"><a href=\"#10-gulp-autoprefixer-针对不同的浏览器，给CSS文件添加相应的前缀\" class=\"headerlink\" title=\"10.gulp-autoprefixer 针对不同的浏览器，给CSS文件添加相应的前缀\"></a>10.gulp-autoprefixer 针对不同的浏览器，给CSS文件添加相应的前缀</h4><h5 id=\"1-安装-4\"><a href=\"#1-安装-4\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-autoprefixer --save-dev\n</code></pre><h5 id=\"2-运用-6\"><a href=\"#2-运用-6\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>//引入插件\nvar gulp = require(&apos;gulp&apos;);\nvar autoprefixer = require(&apos;gulp-autoprefixer&apos;);\n//默认执行任务\ngulp.task(&apos;default&apos;, function () {\n//找到src目录下app.css，为其补全浏览器兼容的css\nreturn gulp.src(&apos;src/app.css&apos;)\n        .pipe(autoprefixer({\n            browsers: [&apos;last 2 versions&apos;],\n            cascade: false\n        }))\n//输出到dist文件夹\n        .pipe(gulp.dest(&apos;dist&apos;));\n});\n</code></pre><h4 id=\"11-gulp-watch-path-若文件有改动，针对改动的文件进行压缩\"><a href=\"#11-gulp-watch-path-若文件有改动，针对改动的文件进行压缩\" class=\"headerlink\" title=\"11. gulp-watch-path   若文件有改动，针对改动的文件进行压缩\"></a>11. gulp-watch-path   若文件有改动，针对改动的文件进行压缩</h4><h5 id=\"1-安装-5\"><a href=\"#1-安装-5\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-watch-path --save-dev\n</code></pre><h5 id=\"2-运用-7\"><a href=\"#2-运用-7\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var watchPath=require(&apos;gulp-watch-path&apos;);\ngulp.task(&apos;auto-css&apos;,function(){ \n     gulp.watch(&apos;static/css/**/*.css&apos;, function (event) { \n        var paths = watchPath(event, &apos;static/&apos;, &apos;dist/&apos;) \n        /* \n        paths \n            { srcPath: &apos;src/js/log.js&apos;, \n              srcDir: &apos;src/js/&apos;, \n              distPath: &apos;dist/js/log.js&apos;, \n              distDir: &apos;dist/js/&apos;, \n              srcFilename: &apos;log.js&apos;, \n              distFilename: &apos;log.js&apos; } \n        */ \n        //gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath) \n        //gutil.log(&apos;Dist &apos; + paths.distPath) \n        gulp.src(paths.srcPath)\n        .pipe(minifycss()) \n        .pipe(gulp.dest(paths.distDir)) \n    }) \n});\n</code></pre><h4 id=\"12-压缩图片gulp-imagemin\"><a href=\"#12-压缩图片gulp-imagemin\" class=\"headerlink\" title=\"12. 压缩图片gulp-imagemin\"></a>12. 压缩图片gulp-imagemin</h4><p>可以压缩gif，png和jpg。</p>\n<p>用这个插件压缩jpg图片，体积压缩得越小，图片就越不清晰，所以不建议把jpg图片压缩质量设置得过低，60%-80%为宜。</p>\n<p>而把png24压缩成png8，提及一般可以减少50%以上。</p>\n<p>图片质量，优化等级进行设置</p>\n<p><a href=\"http://www.ydcss.com/archives/26\" target=\"_blank\" rel=\"external\">http://www.ydcss.com/archives/26</a></p>\n<h3 id=\"三-在使用时应注意\"><a href=\"#三-在使用时应注意\" class=\"headerlink\" title=\"三. 在使用时应注意\"></a>三. 在使用时应注意</h3><p>安装的插件和gulp不需要上传到代码托管工具上，只需要上传package.json 这个文件即可， package.json 这个文件记录了项目中依赖的 glup 插件。将代码下载下来之后，只需要在这个项目文件夹下面，输入命令 npm install，NPM 会自动读取 package.json 文件，将 gulp 和有关插件下载下来。</p>\n","excerpt":"","more":"<h3 id=\"一-gulp简介\"><a href=\"#一-gulp简介\" class=\"headerlink\" title=\"一. gulp简介\"></a>一. gulp简介</h3><p><strong>gulp</strong>是一种任务自动处理工具，简单地说，gulp是一个工具框架，有很多插件扩展它的功能。</p>\n<p><strong>gulp</strong>能够自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。</p>\n<p><strong>gulp的优点：</strong></p>\n<ol>\n<li>基于流的构建工具，利用流的方式进行文件的处理</li>\n<li>代码优于配置，通过简单的配置能够完成很多重复的功能</li>\n<li>简单明了，目的明确，一般一个插件只完成一个任务</li>\n<li>gulp的gulpfile.js的写法更加通俗易懂，易上手</li>\n</ol>\n<h3 id=\"二-使用gulp的步骤：\"><a href=\"#二-使用gulp的步骤：\" class=\"headerlink\" title=\"二.  使用gulp的步骤：\"></a>二.  使用gulp的步骤：</h3><p>由于gulp是基于node.js的，因此在安装gulp之前需要安装node.js</p>\n<p><strong>node.js</strong>是一个后端的js运行环境，也就是说：你写一个服务器端的js代码，可以交给node.js来解释执行。</p>\n<font color=\"red\">安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务</font>\n\n<h4 id=\"1-安装nodejs\"><a href=\"#1-安装nodejs\" class=\"headerlink\" title=\"1. 安装nodejs\"></a>1. 安装nodejs</h4><p>从官网上直接下载安装（路径随意）</p>\n<p>打开cmd：</p>\n<pre><code>输入 node -v       /* 查看nodejs版本号*/\n输入npm -v         /* 查看npm版本号 */\n输入D:             /*定位到D盘*/\n输入cd  nodejs       /* 定位到安装目录*/\n输入dir           /*查看当前定位目录下的文件*/\n输入cls           /* 清空内容*/\n</code></pre><h4 id=\"2-全局安装gulp\"><a href=\"#2-全局安装gulp\" class=\"headerlink\" title=\"2. 全局安装gulp\"></a>2. 全局安装gulp</h4><p><strong>目的</strong>：通过全局安装的gulp执行gulp任务，全局安装完gulp之后，就可以使用gulp命令行</p>\n<pre><code>输入 npm install gulp -g   /*全局安装gulp*/\n输入 gulp -v               /*查看安装的gulp的版本号，出现版本号即为正确安装*/\n</code></pre><h4 id=\"3-新建package-json文件\"><a href=\"#3-新建package-json文件\" class=\"headerlink\" title=\"3. 新建package.json文件\"></a>3. 新建package.json文件</h4><p>package.json是nodejs项目必不可少的配置文件，存放在项目的根目录下</p>\n<pre><code>输入 npm init          /*创建 package.json文件*/\n</code></pre><p>前三项（项目名称，项目版本，项目描述）必须输入，后几项可留空</p>\n<pre><code>输入 npm help package.json   /*查看package.json帮助文档*/\n</code></pre><h4 id=\"4-项目安装gulp依赖\"><a href=\"#4-项目安装gulp依赖\" class=\"headerlink\" title=\"4. 项目安装gulp依赖\"></a>4. 项目安装gulp依赖</h4><pre><code>输入 npm install gulp --save-dev     /*本地安装gulp*/\n输入 npm install 插件名 --save-dev   /*安装gulp插件*/\n</code></pre><p>–save : 将配置信息保存至 <strong>package.json</strong></p>\n<p>-dev：将配置信息保存至<strong>package.json</strong> 的 <strong>devDependencies</strong>节点</p>\n<h4 id=\"5-在项目的根目录下创建gulpfile-js文件\"><a href=\"#5-在项目的根目录下创建gulpfile-js文件\" class=\"headerlink\" title=\"5. 在项目的根目录下创建gulpfile.js文件\"></a>5. 在项目的根目录下创建gulpfile.js文件</h4><pre><code>//导入工具包 require(&apos;node_modules里对应模块&apos;)\nvar gulp = require(&apos;gulp&apos;), //本地安装gulp所用到的地方\n  less = require(&apos;gulp-less&apos;);\n\n//定义一个testLess任务（自定义任务名称）\ngulp.task(&apos;testLess&apos;, function () {\n        gulp.src(&apos;src/less/index.less&apos;) //该任务针对的文件\n            .pipe(less()) //该任务调用的模块\n            .pipe(gulp.dest(&apos;src/css&apos;)); //将会在src/css下生成index.css\n});\n\ngulp.task(&apos;default&apos;,[&apos;testLess&apos;, &apos;elseTask&apos;]); //定义默认任务\n\n//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数\n//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组)\n//gulp.dest(path[, options]) 处理完后文件生成路径\n</code></pre><h4 id=\"6-运行gulp\"><a href=\"#6-运行gulp\" class=\"headerlink\" title=\"6. 运行gulp\"></a>6. 运行gulp</h4><pre><code>输入$gulp                 /*运行gulp*/\n输入gulp default          /*运行gulpfile.js中一个名为default的函数*/\n</code></pre><h3 id=\"二-gulp的API（在gulpfile-js里面会用到）\"><a href=\"#二-gulp的API（在gulpfile-js里面会用到）\" class=\"headerlink\" title=\"二. gulp的API（在gulpfile.js里面会用到）\"></a>二. gulp的API（在gulpfile.js里面会用到）</h3><h4 id=\"1-task-用于定义一个gulp的任务\"><a href=\"#1-task-用于定义一个gulp的任务\" class=\"headerlink\" title=\"1. task  用于定义一个gulp的任务\"></a>1. task  用于定义一个gulp的任务</h4><pre><code>gulp.task(name, [deps] , fn)\n</code></pre><p><strong>name</strong>为任务名称<strong> ‘default’</strong></p>\n<p><strong>deps</strong>为任务依赖的任务，可有多个，按照顺序执行 [‘task’, ‘task2’]</p>\n<p><strong>fn</strong> 该任务调用的插件操作</p>\n<h4 id=\"2-src-指定需要处理的源文件的路径\"><a href=\"#2-src-指定需要处理的源文件的路径\" class=\"headerlink\" title=\"2. src  指定需要处理的源文件的路径\"></a>2. src  指定需要处理的源文件的路径</h4><pre><code>gulp.src(文件路径的模式匹配globs, {options})\n</code></pre><p>globs为需要处理的源文件匹配符路径（字符串或者字符串数组）</p>\n<pre><code>eg：&quot;src/a.js&quot;                                             匹配具体文件\n\n    &quot;src/*.js&quot;                                             匹配src目录下的所有js文件\n\n    &quot;src/**/*.js&quot;                                         匹配src目录下的 0个或多个子文件夹 下的所有js文件\n\n    &quot;src/{a,b}.js&quot; 或者&quot;src/*.{jpg,png}&quot;     同时匹配多个文件\n</code></pre><p><strong>options：有3个属性buffer  read  base</strong></p>\n<p><strong>buffer：</strong>默认true        设置为false时，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；</p>\n<p><strong>read：</strong> 默认为true      设置为false，将不执行读取文件操作，返回null；</p>\n<p><strong>base：</strong>为string类型    设置输出路径以某个路径的某个组成部分为基础向后拼接。</p>\n<h4 id=\"3-dest-指定处理完之后文件的输出路径\"><a href=\"#3-dest-指定处理完之后文件的输出路径\" class=\"headerlink\" title=\"3. dest 指定处理完之后文件的输出路径\"></a>3. dest 指定处理完之后文件的输出路径</h4><pre><code>gulp.dest(path,{option})\n</code></pre><p>path为文件的输出路径</p>\n<p><strong>options：有2个属性cwd mode</strong></p>\n<p>cwd：类型string  默认：process.cwd()：前脚本的工作目录的路径当文件输出路径为相对路径将会用到；</p>\n<p>mode：类型：String  默认：0777 指定被创建文件夹的权限；</p>\n<h4 id=\"4-watch-监听文件的变化\"><a href=\"#4-watch-监听文件的变化\" class=\"headerlink\" title=\"4. watch 监听文件的变化\"></a>4. watch 监听文件的变化</h4><pre><code>gulp.watch(文件路径, [, opts ] , tasks ) \n</code></pre><p>tasks为当任务为多个时，执行的任务的名称的数组<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">eg</span>：</span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.task</span>(<span class=\"string\">'uglify'</span>,function()&#123;</span><br><span class=\"line\"> \t\t<span class=\"comment\">//do something</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.task</span>(<span class=\"string\">'reload'</span>,function()&#123;</span><br><span class=\"line\"> \t<span class=\"comment\">//do something</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.watch</span>(<span class=\"string\">'js/**/*.js'</span>, [<span class=\"string\">'uglify'</span>,<span class=\"string\">'reload'</span>]);</span><br><span class=\"line\">\t<span class=\"selector-tag\">watcher</span><span class=\"selector-class\">.on</span>(<span class=\"string\">'change'</span>, function(event) &#123;</span><br><span class=\"line\">\t\tconsole<span class=\"selector-class\">.log</span>(<span class=\"string\">'File '</span> + event.path + <span class=\"string\">' was '</span> + event.type + <span class=\"string\">', running tasks...'</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.watch</span>(glob, [,opts], cb(event))</span><br><span class=\"line\">\t<span class=\"selector-tag\">cb</span>(event)为每个变化执行的回调函数</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">eg</span>：</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-tag\">gulp</span><span class=\"selector-class\">.watch</span>(<span class=\"string\">'js/**/*.js'</span>, function(event)&#123;</span><br><span class=\"line\"> \t\t<span class=\"comment\">//变化类型 added为新增,deleted为删除，changed为改变</span></span><br><span class=\"line\">\tconsole<span class=\"selector-class\">.log</span>(event.type);</span><br><span class=\"line\">\t\t <span class=\"comment\">//变化的文件的路径</span></span><br><span class=\"line\">\tconsole<span class=\"selector-class\">.log</span>(event.path);</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-gulp常见插件的使用\"><a href=\"#三-gulp常见插件的使用\" class=\"headerlink\" title=\"三. gulp常见插件的使用\"></a>三. gulp常见插件的使用</h3><h4 id=\"1-gulp-uglify-压缩javascript文件，减小文件大小\"><a href=\"#1-gulp-uglify-压缩javascript文件，减小文件大小\" class=\"headerlink\" title=\"1. gulp-uglify  压缩javascript文件，减小文件大小\"></a>1. gulp-uglify  压缩javascript文件，减小文件大小</h4><h5 id=\"1-输入-npm-install-gulp-uglify-–save-dev-安装插件\"><a href=\"#1-输入-npm-install-gulp-uglify-–save-dev-安装插件\" class=\"headerlink\" title=\"(1) 输入 npm install gulp-uglify –save-dev  安装插件\"></a>(1) 输入 npm install gulp-uglify –save-dev  安装插件</h5><h5 id=\"2-在gulpfile-js中引入\"><a href=\"#2-在gulpfile-js中引入\" class=\"headerlink\" title=\"(2) 在gulpfile.js中引入\"></a>(2) 在gulpfile.js中引入</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nuglify = require(&quot;gulp-uglify&quot;);\ngulp.task(&apos;minify-js&apos;, function () {\ngulp.src(&apos;js/*.js&apos;) // 要压缩的js文件\n .pipe(uglify())\n.pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径\n});\n\n  //压缩多个文件\n   var gulp = require(&apos;gulp&apos;),\n  uglify = require(&apos;gulp-uglify&apos;);\n  gulp.task(&apos;jsmin&apos;, function () {\n //多个文件以数组形式传入\n gulp.src([&apos;src/js/index.js&apos;,&apos;src/js/detail.js&apos;])\n     .pipe(uglify())\n     .pipe(gulp.dest(&apos;dist/js&apos;));\n});\n\nvar gulp = require(&apos;gulp&apos;),\nuglify= require(&apos;gulp-uglify&apos;);\n\n匹配符“!”，“*”，“**”，“{}”\ngulp.task(&apos;jsmin&apos;, function () {\n //压缩src/js目录下的所有js文件\n //除了test1.js和test2.js（**匹配src/js的0个或多个子文件夹）\ngulp.src([&apos;src/js/*.js&apos;, &apos;!src/js/**/{test1,test2}.js&apos;])\n .pipe(uglify())\n .pipe(gulp.dest(&apos;dist/js&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"[https://www.npmjs.com/package/gulp-uglify](https://www.npmjs.com/package/gulp-uglify\">https://www.npmjs.com/package/gulp-uglify</a>)</p>\n<h4 id=\"2-gulp-rename-重命名文件流中的文件\"><a href=\"#2-gulp-rename-重命名文件流中的文件\" class=\"headerlink\" title=\"2. gulp-rename 重命名文件流中的文件\"></a>2. gulp-rename 重命名文件流中的文件</h4><p>用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用 gulp-rename 插件来改变文件流中的文件名。</p>\n<h5 id=\"1-安装gulp-rename\"><a href=\"#1-安装gulp-rename\" class=\"headerlink\" title=\"(1) 安装gulp-rename\"></a>(1) 安装gulp-rename</h5><pre><code>npm install gulp-rename --save-dev\n</code></pre><h5 id=\"2-运用\"><a href=\"#2-运用\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nrename = require(&apos;gulp-rename&apos;),\nuglify = require(&quot;gulp-uglify&quot;);\ngulp.task(&apos;rename&apos;, function () {\ngulp.src(&apos;js/jquery.js&apos;)\n .pipe(uglify()) //压缩\n //会将jquery.js重命名为jquery.min.js\n .pipe(rename(&apos;jquery.min.js&apos;))        //给所有文件加min后缀  .pipe(rename({ suffix: &apos;.min&apos; }))\n .pipe(gulp.dest(&apos;js&apos;));\n});\n</code></pre><p>详细介绍：(<a href=\"https://www.npmjs.com/package/gulp-rename)[https://www.npmjs.com/package/gulp-rename](https://www.npmjs.com/package/gulp-rename\">https://www.npmjs.com/package/gulp-rename)[https://www.npmjs.com/package/gulp-rename](https://www.npmjs.com/package/gulp-rename</a>)</p>\n<h4 id=\"3-gulp-minify-css-压缩css文件时并给引用url添加版本号避免缓存\"><a href=\"#3-gulp-minify-css-压缩css文件时并给引用url添加版本号避免缓存\" class=\"headerlink\" title=\"3. gulp-minify-css 压缩css文件时并给引用url添加版本号避免缓存\"></a>3. gulp-minify-css 压缩css文件时并给引用url添加版本号避免缓存</h4><h5 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-minify-css --save-dev\n</code></pre><h5 id=\"2-运用-1\"><a href=\"#2-运用-1\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\ncssmin = require(&apos;gulp-minify-css&apos;);\n //确保已本地安装gulp-make-css-url-version [npm install gulp-make-css-url-version --save-dev]\ncssver = require(&apos;gulp-make-css-url-version&apos;);\ngulp.task(&apos;testCssmin&apos;, function () {\ngulp.src(&apos;src/css/*.css&apos;)\n .pipe(cssver()) //给css文件里引用文件加版本号（文件MD5）\n .pipe(cssmin())\n .pipe(gulp.dest(&apos;dist/css&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"https://www.npmjs.com/package/gulp-minify-css/\">https://www.npmjs.com/package/gulp-minify-css/</a></p>\n<h4 id=\"4-gulp-htmlmin\"><a href=\"#4-gulp-htmlmin\" class=\"headerlink\" title=\"4. gulp-htmlmin\"></a>4. gulp-htmlmin</h4><p>压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作。</p>\n<h5 id=\"1-安装-1\"><a href=\"#1-安装-1\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-htmlmin --save-dev\n</code></pre><h5 id=\"2-运用-2\"><a href=\"#2-运用-2\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nhtmlmin = require(&apos;gulp-htmlmin&apos;);\ngulp.task(&apos;testHtmlmin&apos;, function () {\n var options = {\nremoveComments: true,//清除HTML注释\ncollapseWhitespace: true,//压缩HTML\n //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;\ncollapseBooleanAttributes: true,\n //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;\nremoveEmptyAttributes: true,\n //删除&lt;script&gt;的type=&quot;text/javascript&quot;\nremoveScriptTypeAttributes: true,\n //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;\nremoveStyleLinkTypeAttributes: true,\nminifyJS: true,//压缩页面JS\nminifyCSS: true//压缩页面CSS\n };\ngulp.src(&apos;src/html/*.html&apos;)\n .pipe(htmlmin(options))\n .pipe(gulp.dest(&apos;dist/html&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"https://github.com/kangax/html-minifier#user-content-options-quick-reference\">https://github.com/kangax/html-minifier#user-content-options-quick-reference</a></p>\n<h4 id=\"5-gulp-concat\"><a href=\"#5-gulp-concat\" class=\"headerlink\" title=\"5. gulp-concat\"></a>5. gulp-concat</h4><p>用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了。</p>\n<h5 id=\"1-安装-2\"><a href=\"#1-安装-2\" class=\"headerlink\" title=\"(1)安装\"></a>(1)安装</h5><pre><code>npm install gulp-concat --save-dev\n</code></pre><h5 id=\"2-运用-3\"><a href=\"#2-运用-3\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;),\nconcat = require(&quot;gulp-concat&quot;);\ngulp.task(&apos;concat&apos;, function () {\ngulp.src(&apos;js/*.js&apos;) //要合并的文件\n .pipe(concat(&apos;all.js&apos;)) // 合并匹配到的js文件并命名为 &quot;all.js&quot;\n .pipe(gulp.dest(&apos;dist/js&apos;));\n});\n</code></pre><p>详细介绍：<a href=\"https://www.npmjs.com/package/gulp-concat/\">https://www.npmjs.com/package/gulp-concat/</a></p>\n<h4 id=\"6-gulp-imagemin-压缩图片文件\"><a href=\"#6-gulp-imagemin-压缩图片文件\" class=\"headerlink\" title=\"6. gulp-imagemin 压缩图片文件\"></a>6. gulp-imagemin 压缩图片文件</h4><p>详细介绍：<a href=\"https://github.com/sindresorhus/gulp-imagemin\">https://github.com/sindresorhus/gulp-imagemin</a></p>\n<h4 id=\"7-gulp-jshint-检测JavaScript代码中错误和潜在问题\"><a href=\"#7-gulp-jshint-检测JavaScript代码中错误和潜在问题\" class=\"headerlink\" title=\"7. gulp-jshint 检测JavaScript代码中错误和潜在问题\"></a>7. gulp-jshint 检测JavaScript代码中错误和潜在问题</h4><p>详细介绍：<a href=\"https://www.npmjs.com/package/gulp-jshint\">https://www.npmjs.com/package/gulp-jshint</a></p>\n<h4 id=\"8-gulp-rev-给文件增加MD5值\"><a href=\"#8-gulp-rev-给文件增加MD5值\" class=\"headerlink\" title=\"8.gulp-rev 给文件增加MD5值\"></a>8.gulp-rev 给文件增加MD5值</h4><p>结果如下：</p>\n<p>“css/unicorn.css”: “css/unicorn-d41d8cd98f.css”,<br>“js/unicorn.js”: “js/unicorn-273c2cin3f.js”</p>\n<h5 id=\"1-安装：\"><a href=\"#1-安装：\" class=\"headerlink\" title=\"(1) 安装：\"></a>(1) 安装：</h5><pre><code>npm install gulp-rev --save-rev\n</code></pre><h5 id=\"2-运用-4\"><a href=\"#2-运用-4\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var gulp = require(&apos;gulp&apos;);\nvar rev = require(&apos;gulp-rev&apos;);\n\ngulp.task(&apos;default&apos;, function () {\nreturn gulp.src(&apos;assets/css/*.css&apos;)\n        .pipe(rev())\n        .pipe(gulp.dest(&apos;dist/css&apos;))  \n        .pipe(rev.manifest())//生成一个json文件，记录添加MD5值前后文件名的对应关系\n        .pipe(gulp.dest(&apos;dist/rev&apos;));\n});\n</code></pre><h4 id=\"9-gulp-rev-recollector-替换掉html文件中的引用路径\"><a href=\"#9-gulp-rev-recollector-替换掉html文件中的引用路径\" class=\"headerlink\" title=\"9. gulp-rev-recollector  替换掉html文件中的引用路径\"></a>9. gulp-rev-recollector  替换掉html文件中的引用路径</h4><p>本插件必须在gulp-rev安装成功后，用.pipe(rev.manifest())生成了对应的json文件才能替换html文件中的引用路径</p>\n<h5 id=\"1-安装-3\"><a href=\"#1-安装-3\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-rev-recollector --save-dev\n</code></pre><h5 id=\"2-运用-5\"><a href=\"#2-运用-5\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var revCollector = require(&apos;gulp-rev-collector&apos;); \ngulp.task(&apos;rev&apos;, [&apos;使用gulp-rev的函数名&apos;] , function () {\n    return gulp.src([&apos;rev/**/*.json&apos;, &apos;templates/**/*.html&apos;])\n    .pipe( revCollector({\n               replaceReved: true,\n               dirReplacements: {\n                                             &apos;css&apos;: &apos;/dist/css&apos;,\n                                             &apos;/js/&apos;: &apos;/dist/js/&apos;,\n                                              &apos;cdn/&apos;: function(manifest_value) {\n                                               return &apos;//cdn&apos; + (Math.floor(Math.random() * 9) + 1) + &apos;.&apos; + &apos;exsample.dot&apos; + &apos;/img/&apos; +     \n                                                manifest_value;\n                 }\n   }\n }) )\n .pipe( gulp.dest(&apos;dist&apos;) );\n});\n</code></pre><font color=\"red\"> 注意：由于gulp完成各个task是异步的，因此执行gulp-rev-recollector之前需要执行gulo-rev，解决方法：见代码第二行红色部分 </font>\n\n<h4 id=\"10-gulp-autoprefixer-针对不同的浏览器，给CSS文件添加相应的前缀\"><a href=\"#10-gulp-autoprefixer-针对不同的浏览器，给CSS文件添加相应的前缀\" class=\"headerlink\" title=\"10.gulp-autoprefixer 针对不同的浏览器，给CSS文件添加相应的前缀\"></a>10.gulp-autoprefixer 针对不同的浏览器，给CSS文件添加相应的前缀</h4><h5 id=\"1-安装-4\"><a href=\"#1-安装-4\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-autoprefixer --save-dev\n</code></pre><h5 id=\"2-运用-6\"><a href=\"#2-运用-6\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>//引入插件\nvar gulp = require(&apos;gulp&apos;);\nvar autoprefixer = require(&apos;gulp-autoprefixer&apos;);\n//默认执行任务\ngulp.task(&apos;default&apos;, function () {\n//找到src目录下app.css，为其补全浏览器兼容的css\nreturn gulp.src(&apos;src/app.css&apos;)\n        .pipe(autoprefixer({\n            browsers: [&apos;last 2 versions&apos;],\n            cascade: false\n        }))\n//输出到dist文件夹\n        .pipe(gulp.dest(&apos;dist&apos;));\n});\n</code></pre><h4 id=\"11-gulp-watch-path-若文件有改动，针对改动的文件进行压缩\"><a href=\"#11-gulp-watch-path-若文件有改动，针对改动的文件进行压缩\" class=\"headerlink\" title=\"11. gulp-watch-path   若文件有改动，针对改动的文件进行压缩\"></a>11. gulp-watch-path   若文件有改动，针对改动的文件进行压缩</h4><h5 id=\"1-安装-5\"><a href=\"#1-安装-5\" class=\"headerlink\" title=\"(1) 安装\"></a>(1) 安装</h5><pre><code>npm install gulp-watch-path --save-dev\n</code></pre><h5 id=\"2-运用-7\"><a href=\"#2-运用-7\" class=\"headerlink\" title=\"(2) 运用\"></a>(2) 运用</h5><pre><code>var watchPath=require(&apos;gulp-watch-path&apos;);\ngulp.task(&apos;auto-css&apos;,function(){ \n     gulp.watch(&apos;static/css/**/*.css&apos;, function (event) { \n        var paths = watchPath(event, &apos;static/&apos;, &apos;dist/&apos;) \n        /* \n        paths \n            { srcPath: &apos;src/js/log.js&apos;, \n              srcDir: &apos;src/js/&apos;, \n              distPath: &apos;dist/js/log.js&apos;, \n              distDir: &apos;dist/js/&apos;, \n              srcFilename: &apos;log.js&apos;, \n              distFilename: &apos;log.js&apos; } \n        */ \n        //gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath) \n        //gutil.log(&apos;Dist &apos; + paths.distPath) \n        gulp.src(paths.srcPath)\n        .pipe(minifycss()) \n        .pipe(gulp.dest(paths.distDir)) \n    }) \n});\n</code></pre><h4 id=\"12-压缩图片gulp-imagemin\"><a href=\"#12-压缩图片gulp-imagemin\" class=\"headerlink\" title=\"12. 压缩图片gulp-imagemin\"></a>12. 压缩图片gulp-imagemin</h4><p>可以压缩gif，png和jpg。</p>\n<p>用这个插件压缩jpg图片，体积压缩得越小，图片就越不清晰，所以不建议把jpg图片压缩质量设置得过低，60%-80%为宜。</p>\n<p>而把png24压缩成png8，提及一般可以减少50%以上。</p>\n<p>图片质量，优化等级进行设置</p>\n<p><a href=\"http://www.ydcss.com/archives/26\">http://www.ydcss.com/archives/26</a></p>\n<h3 id=\"三-在使用时应注意\"><a href=\"#三-在使用时应注意\" class=\"headerlink\" title=\"三. 在使用时应注意\"></a>三. 在使用时应注意</h3><p>安装的插件和gulp不需要上传到代码托管工具上，只需要上传package.json 这个文件即可， package.json 这个文件记录了项目中依赖的 glup 插件。将代码下载下来之后，只需要在这个项目文件夹下面，输入命令 npm install，NPM 会自动读取 package.json 文件，将 gulp 和有关插件下载下来。</p>\n"},{"layout":"post","title":"js中的垃圾回收","date":"2016-08-15T16:00:00.000Z","description":null,"_content":"\n### 一. js中的垃圾回收机制\n\njs具有自动垃圾收集机制\n\n其原理如下：找出不再适用的变量，然后释放其中的内存\n\n垃圾收集器会周期性地执行这个操作。\n\n### 二. 手动解除引用，释放内存\n\nvar globalVar = [];\n\n//手动解除引用，释放内存\nglobalVar = null;\n\n\n### 三. 闭包中的变量\n\n局部变量只在函数执行的过程中存在，但是闭包有所不同，如果返回了对闭包函数的引用，在外部也使用了该变量，那么闭包里面的变量不会被垃圾回收机制回收。\n\n#### 什么是内存泄漏？\n\n内存泄漏指由于疏忽或错误造成**程序未能释放已经不再使用的内存**。\n\n在IE中使用闭包会导致内存泄漏\n\n如果闭包的作用域内保存着一个HTML元素，那么意味着该元素无法销毁。\n\n循环引用会造成内存泄漏。\n\n```\n//下面的代码就是循环引用，function里面的element引用了匿名函数，匿名函数里面又引用了element；因此element永远不会被回收\nfunction assignHandler() {\n\tvar element = document.getElementById('id');\n\t\n\telement.onclick = function() {\n\t\talert(element.id);\n\t}\n}\n\n//手动释放内存\nfunction assignHandler() {\n\tvar element = document.getElementById('id');\n\tvar id = element.id;\n\t\n\telement.onclick = function() {\n\t\talert(id);\n\t}\n\t\n\telement = null;\n}\n```\n\n","source":"_posts/2016-03-12-js中的垃圾回收.md","raw":"---\nlayout: post\ntitle: js中的垃圾回收\ndate: 2016-08-16\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. js中的垃圾回收机制\n\njs具有自动垃圾收集机制\n\n其原理如下：找出不再适用的变量，然后释放其中的内存\n\n垃圾收集器会周期性地执行这个操作。\n\n### 二. 手动解除引用，释放内存\n\nvar globalVar = [];\n\n//手动解除引用，释放内存\nglobalVar = null;\n\n\n### 三. 闭包中的变量\n\n局部变量只在函数执行的过程中存在，但是闭包有所不同，如果返回了对闭包函数的引用，在外部也使用了该变量，那么闭包里面的变量不会被垃圾回收机制回收。\n\n#### 什么是内存泄漏？\n\n内存泄漏指由于疏忽或错误造成**程序未能释放已经不再使用的内存**。\n\n在IE中使用闭包会导致内存泄漏\n\n如果闭包的作用域内保存着一个HTML元素，那么意味着该元素无法销毁。\n\n循环引用会造成内存泄漏。\n\n```\n//下面的代码就是循环引用，function里面的element引用了匿名函数，匿名函数里面又引用了element；因此element永远不会被回收\nfunction assignHandler() {\n\tvar element = document.getElementById('id');\n\t\n\telement.onclick = function() {\n\t\talert(element.id);\n\t}\n}\n\n//手动释放内存\nfunction assignHandler() {\n\tvar element = document.getElementById('id');\n\tvar id = element.id;\n\t\n\telement.onclick = function() {\n\t\talert(id);\n\t}\n\t\n\telement = null;\n}\n```\n\n","slug":"2016-03-12-js中的垃圾回收","published":1,"updated":"2016-08-28T06:45:12.000Z","comments":1,"photos":[],"link":"","_id":"cj035occd000jd5u8y74jd3cj","content":"<h3 id=\"一-js中的垃圾回收机制\"><a href=\"#一-js中的垃圾回收机制\" class=\"headerlink\" title=\"一. js中的垃圾回收机制\"></a>一. js中的垃圾回收机制</h3><p>js具有自动垃圾收集机制</p>\n<p>其原理如下：找出不再适用的变量，然后释放其中的内存</p>\n<p>垃圾收集器会周期性地执行这个操作。</p>\n<h3 id=\"二-手动解除引用，释放内存\"><a href=\"#二-手动解除引用，释放内存\" class=\"headerlink\" title=\"二. 手动解除引用，释放内存\"></a>二. 手动解除引用，释放内存</h3><p>var globalVar = [];</p>\n<p>//手动解除引用，释放内存<br>globalVar = null;</p>\n<h3 id=\"三-闭包中的变量\"><a href=\"#三-闭包中的变量\" class=\"headerlink\" title=\"三. 闭包中的变量\"></a>三. 闭包中的变量</h3><p>局部变量只在函数执行的过程中存在，但是闭包有所不同，如果返回了对闭包函数的引用，在外部也使用了该变量，那么闭包里面的变量不会被垃圾回收机制回收。</p>\n<h4 id=\"什么是内存泄漏？\"><a href=\"#什么是内存泄漏？\" class=\"headerlink\" title=\"什么是内存泄漏？\"></a>什么是内存泄漏？</h4><p>内存泄漏指由于疏忽或错误造成<strong>程序未能释放已经不再使用的内存</strong>。</p>\n<p>在IE中使用闭包会导致内存泄漏</p>\n<p>如果闭包的作用域内保存着一个HTML元素，那么意味着该元素无法销毁。</p>\n<p>循环引用会造成内存泄漏。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面的代码就是循环引用，function里面的element引用了匿名函数，匿名函数里面又引用了element；因此element永远不会被回收</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assignHandler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\telement.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(element.id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//手动释放内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assignHandler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> id = element.id;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\telement.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\telement = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-js中的垃圾回收机制\"><a href=\"#一-js中的垃圾回收机制\" class=\"headerlink\" title=\"一. js中的垃圾回收机制\"></a>一. js中的垃圾回收机制</h3><p>js具有自动垃圾收集机制</p>\n<p>其原理如下：找出不再适用的变量，然后释放其中的内存</p>\n<p>垃圾收集器会周期性地执行这个操作。</p>\n<h3 id=\"二-手动解除引用，释放内存\"><a href=\"#二-手动解除引用，释放内存\" class=\"headerlink\" title=\"二. 手动解除引用，释放内存\"></a>二. 手动解除引用，释放内存</h3><p>var globalVar = [];</p>\n<p>//手动解除引用，释放内存<br>globalVar = null;</p>\n<h3 id=\"三-闭包中的变量\"><a href=\"#三-闭包中的变量\" class=\"headerlink\" title=\"三. 闭包中的变量\"></a>三. 闭包中的变量</h3><p>局部变量只在函数执行的过程中存在，但是闭包有所不同，如果返回了对闭包函数的引用，在外部也使用了该变量，那么闭包里面的变量不会被垃圾回收机制回收。</p>\n<h4 id=\"什么是内存泄漏？\"><a href=\"#什么是内存泄漏？\" class=\"headerlink\" title=\"什么是内存泄漏？\"></a>什么是内存泄漏？</h4><p>内存泄漏指由于疏忽或错误造成<strong>程序未能释放已经不再使用的内存</strong>。</p>\n<p>在IE中使用闭包会导致内存泄漏</p>\n<p>如果闭包的作用域内保存着一个HTML元素，那么意味着该元素无法销毁。</p>\n<p>循环引用会造成内存泄漏。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面的代码就是循环引用，function里面的element引用了匿名函数，匿名函数里面又引用了element；因此element永远不会被回收</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assignHandler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\telement.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(element.id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//手动释放内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assignHandler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> id = element.id;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\telement.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\telement = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Baidu IFE 第一阶段任务1~6","date":"2016-03-14T16:00:00.000Z","description":"参加百度前端公开课的第一阶段任务","_content":"\n### 一. 百度前端技术学院简介\n\n百度前端技术学院诞生于2014年，由百度最大规模的前端技术组织 EFE 团队发起成立。\n\n目前学院是由百度校园品牌部、百度多模交互搜索部以及百度校园招聘组联合组织的，面向大学生人群，免费的一个技术学习、交流与分享平台。\n\n### 二.  第一阶段任务\n\n![第一阶段任务](/uploads/post/demo/baidu-ife-task1.jpg)\n\n### 三.  我的任务\n\n我的任务列表[http://panpanfish.com/baiduIFE/](http://panpanfish.com/baiduIFE/)\n\n在写这个任务列表时遇到的问题：\n\n**子元素浮动之后如何撑开父元素**\n\n由于子元素添加float属性之后就脱离了文档流，给父元素设定一个overflow:hidden;属性，便可使子元素float之后撑开父元素。\n\n**float的元素如何居中显示**\n\n如下图所示：\n\n![浮动元素居中显示](/uploads/post/demo/float-center.jpg)\n\n#### 1. 任务一\n\n#### (1). 任务一需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg)\n\n\n**任务要求：**\n\n- 只需要完成HTML代码编写，不需要写CSS\n- 示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定\n- 尽可能多地尝试更多的HTML标签\n\n#### (2). 任务一demo\n\n[http://panpanfish.com/baiduIFE/task1-1.html](http://panpanfish.com/baiduIFE/task1-1.html)\n\n#### (3). 任务一代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html)\n\n#### (4). 任务一笔记\n\n1.  html5里面添加了很多语义化更好的内容标签：\n\n\tarticle、footer、header、nav、section\n\n\t使用这些标签会使代码结构更加清晰\n \n1. div、section、article三者的相同点和不同\n\n\t**相同点：**都是块元素，可以对某一块内容添加样式\n\n\t**不同点：**div没有语义，仅仅用作样式化或者脚本化；section适用于一段主题内容；article适用于一段完整的独立存在的内容（判断方式：此段内容可不可以脱离上下文）\n\n#### 2. 任务二\n\n#### (1). 任务二需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_2_1.jpg)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定\n- 尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性\n- HTML 及 CSS 代码结构清晰、规范\n\n#### (2). 任务二demo\n\n[http://panpanfish.com/baiduIFE/task1-2.html](http://panpanfish.com/baiduIFE/task1-2.html)\n\n#### (3). 任务二代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html)\n\n#### (4). 任务二笔记\n\n主要是记录一些之前没用到的css样式\n\n1. 让一段文字的首行缩进2个字符\n\n    text-indent:2em;\n\n2. 让一行文字垂直居中于一个div\n\n    line-height = div的height\n\n3. 使用到的css3新增加的特性\n\n    实现阴影 box-shadow\n    \n    实现圆角 border-radius\n\n\n4. verticle-align 设置元素垂直对齐方式\n\n    verticle-align: 百分比 （这个百分比是相对于line-height属性值）\n\n\t若为正值，则升高；若为负值，则降低；0%等同于baseline。\n\n#### 3. 任务三\n\n#### (1). 任务三需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_3_1.png)\n\n**任务要求：**\n\n- 左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。\n- 调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。\n- 改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。\n- 其他效果图中给出的标识均被正确地实现。\n\n#### (2). 任务三demo\n\n[http://panpanfish.com/baiduIFE/task1-3.html](http://panpanfish.com/baiduIFE/task1-3.html)\n\n#### (3). 任务三代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html)\n\n#### (4). 任务三笔记\n\n1. 上传的这个demo是利用左右float，中间设定margin来实现的\n\t\n左右固定宽度，中间自适应\n\n    <!DOCTYPE HTML>\n    <html>\n    \t<head>\n    \t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> \n    \t\t<title>左右固定宽度，中间自适应</title>\n    \t\t<style type=\"text/css\">\n    \t\t\t.leftside-bar{float:left;width:200px;height:100px;background: red;}\n    \t\t\t.rightside-bar{float:right;width:200px;height:100px;background: black;}\n    \t\t\t.content{margin-left:210px;margin-right:210px;height:100px;background: grey;}\n    \t\t</style>\n    \t\t<script type=\"text/javascript\">\n    \t\t\t\n    \t\t</script>\n    \t</head>\n    \t<body>\n    \t\t<div class=\"leftside-bar\"></div>\n    \t\t<div class=\"rightside-bar\"></div>\n    \t\t<div class=\"content\"></div>\n    \t\t\n    \t</body>\n    </html>\n\n2. 脱离文档流\n\n\t**什么叫元素脱离文档流？**\n\n\t元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。\n\n\t**什么情况下元素会脱离文档流？**\n\n\t元素设置了float属性 或者 元素的position定义为absolute\n\n    **float脱离文档流 和 absolute脱离文档流的不同之处？**\n\n\tfloat脱离文档流：其他盒子会无视这个元素，但文字会为其让出位置，环绕周围\n\n\tabsolute脱离文档流：其他盒子和文字均会无视这个元素\n\n3. box-sizing的几种取值\n\n\tbox-sizing可以理解为选择定义盒子尺寸的模式\n\n\tbox-sizing的取值有 content-box、border-box、padding-box\n\n\t适用于一切有width、height属性的元素\n\n\tcontent-box：width和height均指的是 **内容** 的宽度和高度（默认值）\n\n\tborder-box：width和height指的是 **内容+padding+border**的宽度和高度\n\n\tpadding-box：width和height值的是 **内容+padding**的宽度和高度\n\n#### 4. 任务四\n\n#### (1). 任务四需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_4_1.png)\n\n**任务要求：**\n\n- 左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。\n- 调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。\n- 改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。\n- 其他效果图中给出的标识均被正确地实现。\n\n#### (2). 任务四demo\n\n[http://panpanfish.com/baiduIFE/task1-4.html](http://panpanfish.com/baiduIFE/task1-4.html)\n\n#### (3). 任务四代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html)\n\n#### (4). 任务四笔记\n\n这个任务中需要实现的效果有四个：灰色块水平居中、灰色块垂直居中、黄色四分之一圆的实现、黄色四分之一圆的位置固定\n\n1. 灰色块水平居中\n\n\t设置灰色块的 `margin-left:auto; margin-right:auto;`\n\n2. 灰色块的垂直居中\n\n\t关于垂直居中的问题，网上有很多人提出了很多种实现方式\n\n\t在这里我只用了一种我感觉最好理解，并且适用于所有浏览器的方式\n\n\t    <div class=\"floater\"></div>\n    \t<div class=\"content\">\n       \t\tContent here\n    \t</div>\n    \n    \thtml,body{margin:0px;height:100%} /*高度自适应的关键*/\n    \t\n    \t.floater {float:left;\n      \t\t\t height:50%;/*指的是这个悬浮在左边的div的高度为浏览器高度的一半*/\n      \t\t\tmargin-bottom:-120px;/*将此div向上移动内容div高度的一半*/\n      \t}\n    \t.content {clear:both; height:240px; position:relative;}\n\n3. 关于height:50%\n\n\t需要注意一个对象的高度是否可以使用百分比显示，取决于对象的父级元素，在浏览器默认状态下，是没有给body、html一个高度属性的。\n\n\t因此我们需要设置 html,body{height:100%}\n\n\t**很奇怪的一点：若在html文件的开头没有声明<!DOCTYPE HTML>，不设置也不会有问题，这个问题还没搞懂。**\n\n4. border-radius属性\n\n\t如何画四分之一圆？\n\n    div的宽和高相等，并且等于border-radius的某一个角的弧度\n\n#### 5. 任务五\n\n见博客《常见的两栏式布局》\n\n#### 6. 任务六\n\n见博客《模拟报纸排版》","source":"_posts/2016-03-15-Baidu-IFE-task1-1-6.md","raw":"---\nlayout: post\ntitle: Baidu IFE 第一阶段任务1~6\ndate: 2016-03-15\ncategories: Demo\ntags: [BaiduIFE]\ndescription: 参加百度前端公开课的第一阶段任务\n---\n\n### 一. 百度前端技术学院简介\n\n百度前端技术学院诞生于2014年，由百度最大规模的前端技术组织 EFE 团队发起成立。\n\n目前学院是由百度校园品牌部、百度多模交互搜索部以及百度校园招聘组联合组织的，面向大学生人群，免费的一个技术学习、交流与分享平台。\n\n### 二.  第一阶段任务\n\n![第一阶段任务](/uploads/post/demo/baidu-ife-task1.jpg)\n\n### 三.  我的任务\n\n我的任务列表[http://panpanfish.com/baiduIFE/](http://panpanfish.com/baiduIFE/)\n\n在写这个任务列表时遇到的问题：\n\n**子元素浮动之后如何撑开父元素**\n\n由于子元素添加float属性之后就脱离了文档流，给父元素设定一个overflow:hidden;属性，便可使子元素float之后撑开父元素。\n\n**float的元素如何居中显示**\n\n如下图所示：\n\n![浮动元素居中显示](/uploads/post/demo/float-center.jpg)\n\n#### 1. 任务一\n\n#### (1). 任务一需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg)\n\n\n**任务要求：**\n\n- 只需要完成HTML代码编写，不需要写CSS\n- 示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定\n- 尽可能多地尝试更多的HTML标签\n\n#### (2). 任务一demo\n\n[http://panpanfish.com/baiduIFE/task1-1.html](http://panpanfish.com/baiduIFE/task1-1.html)\n\n#### (3). 任务一代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html)\n\n#### (4). 任务一笔记\n\n1.  html5里面添加了很多语义化更好的内容标签：\n\n\tarticle、footer、header、nav、section\n\n\t使用这些标签会使代码结构更加清晰\n \n1. div、section、article三者的相同点和不同\n\n\t**相同点：**都是块元素，可以对某一块内容添加样式\n\n\t**不同点：**div没有语义，仅仅用作样式化或者脚本化；section适用于一段主题内容；article适用于一段完整的独立存在的内容（判断方式：此段内容可不可以脱离上下文）\n\n#### 2. 任务二\n\n#### (1). 任务二需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_2_1.jpg)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定\n- 尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性\n- HTML 及 CSS 代码结构清晰、规范\n\n#### (2). 任务二demo\n\n[http://panpanfish.com/baiduIFE/task1-2.html](http://panpanfish.com/baiduIFE/task1-2.html)\n\n#### (3). 任务二代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html)\n\n#### (4). 任务二笔记\n\n主要是记录一些之前没用到的css样式\n\n1. 让一段文字的首行缩进2个字符\n\n    text-indent:2em;\n\n2. 让一行文字垂直居中于一个div\n\n    line-height = div的height\n\n3. 使用到的css3新增加的特性\n\n    实现阴影 box-shadow\n    \n    实现圆角 border-radius\n\n\n4. verticle-align 设置元素垂直对齐方式\n\n    verticle-align: 百分比 （这个百分比是相对于line-height属性值）\n\n\t若为正值，则升高；若为负值，则降低；0%等同于baseline。\n\n#### 3. 任务三\n\n#### (1). 任务三需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_3_1.png)\n\n**任务要求：**\n\n- 左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。\n- 调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。\n- 改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。\n- 其他效果图中给出的标识均被正确地实现。\n\n#### (2). 任务三demo\n\n[http://panpanfish.com/baiduIFE/task1-3.html](http://panpanfish.com/baiduIFE/task1-3.html)\n\n#### (3). 任务三代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html)\n\n#### (4). 任务三笔记\n\n1. 上传的这个demo是利用左右float，中间设定margin来实现的\n\t\n左右固定宽度，中间自适应\n\n    <!DOCTYPE HTML>\n    <html>\n    \t<head>\n    \t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> \n    \t\t<title>左右固定宽度，中间自适应</title>\n    \t\t<style type=\"text/css\">\n    \t\t\t.leftside-bar{float:left;width:200px;height:100px;background: red;}\n    \t\t\t.rightside-bar{float:right;width:200px;height:100px;background: black;}\n    \t\t\t.content{margin-left:210px;margin-right:210px;height:100px;background: grey;}\n    \t\t</style>\n    \t\t<script type=\"text/javascript\">\n    \t\t\t\n    \t\t</script>\n    \t</head>\n    \t<body>\n    \t\t<div class=\"leftside-bar\"></div>\n    \t\t<div class=\"rightside-bar\"></div>\n    \t\t<div class=\"content\"></div>\n    \t\t\n    \t</body>\n    </html>\n\n2. 脱离文档流\n\n\t**什么叫元素脱离文档流？**\n\n\t元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。\n\n\t**什么情况下元素会脱离文档流？**\n\n\t元素设置了float属性 或者 元素的position定义为absolute\n\n    **float脱离文档流 和 absolute脱离文档流的不同之处？**\n\n\tfloat脱离文档流：其他盒子会无视这个元素，但文字会为其让出位置，环绕周围\n\n\tabsolute脱离文档流：其他盒子和文字均会无视这个元素\n\n3. box-sizing的几种取值\n\n\tbox-sizing可以理解为选择定义盒子尺寸的模式\n\n\tbox-sizing的取值有 content-box、border-box、padding-box\n\n\t适用于一切有width、height属性的元素\n\n\tcontent-box：width和height均指的是 **内容** 的宽度和高度（默认值）\n\n\tborder-box：width和height指的是 **内容+padding+border**的宽度和高度\n\n\tpadding-box：width和height值的是 **内容+padding**的宽度和高度\n\n#### 4. 任务四\n\n#### (1). 任务四需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_4_1.png)\n\n**任务要求：**\n\n- 左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。\n- 调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。\n- 改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。\n- 其他效果图中给出的标识均被正确地实现。\n\n#### (2). 任务四demo\n\n[http://panpanfish.com/baiduIFE/task1-4.html](http://panpanfish.com/baiduIFE/task1-4.html)\n\n#### (3). 任务四代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html)\n\n#### (4). 任务四笔记\n\n这个任务中需要实现的效果有四个：灰色块水平居中、灰色块垂直居中、黄色四分之一圆的实现、黄色四分之一圆的位置固定\n\n1. 灰色块水平居中\n\n\t设置灰色块的 `margin-left:auto; margin-right:auto;`\n\n2. 灰色块的垂直居中\n\n\t关于垂直居中的问题，网上有很多人提出了很多种实现方式\n\n\t在这里我只用了一种我感觉最好理解，并且适用于所有浏览器的方式\n\n\t    <div class=\"floater\"></div>\n    \t<div class=\"content\">\n       \t\tContent here\n    \t</div>\n    \n    \thtml,body{margin:0px;height:100%} /*高度自适应的关键*/\n    \t\n    \t.floater {float:left;\n      \t\t\t height:50%;/*指的是这个悬浮在左边的div的高度为浏览器高度的一半*/\n      \t\t\tmargin-bottom:-120px;/*将此div向上移动内容div高度的一半*/\n      \t}\n    \t.content {clear:both; height:240px; position:relative;}\n\n3. 关于height:50%\n\n\t需要注意一个对象的高度是否可以使用百分比显示，取决于对象的父级元素，在浏览器默认状态下，是没有给body、html一个高度属性的。\n\n\t因此我们需要设置 html,body{height:100%}\n\n\t**很奇怪的一点：若在html文件的开头没有声明<!DOCTYPE HTML>，不设置也不会有问题，这个问题还没搞懂。**\n\n4. border-radius属性\n\n\t如何画四分之一圆？\n\n    div的宽和高相等，并且等于border-radius的某一个角的弧度\n\n#### 5. 任务五\n\n见博客《常见的两栏式布局》\n\n#### 6. 任务六\n\n见博客《模拟报纸排版》","slug":"2016-03-15-Baidu-IFE-task1-1-6","published":1,"updated":"2016-06-13T07:13:54.000Z","comments":1,"photos":[],"link":"","_id":"cj035occh000od5u8m8qpudu5","content":"<h3 id=\"一-百度前端技术学院简介\"><a href=\"#一-百度前端技术学院简介\" class=\"headerlink\" title=\"一. 百度前端技术学院简介\"></a>一. 百度前端技术学院简介</h3><p>百度前端技术学院诞生于2014年，由百度最大规模的前端技术组织 EFE 团队发起成立。</p>\n<p>目前学院是由百度校园品牌部、百度多模交互搜索部以及百度校园招聘组联合组织的，面向大学生人群，免费的一个技术学习、交流与分享平台。</p>\n<h3 id=\"二-第一阶段任务\"><a href=\"#二-第一阶段任务\" class=\"headerlink\" title=\"二.  第一阶段任务\"></a>二.  第一阶段任务</h3><p><img src=\"/uploads/post/demo/baidu-ife-task1.jpg\" alt=\"第一阶段任务\"></p>\n<h3 id=\"三-我的任务\"><a href=\"#三-我的任务\" class=\"headerlink\" title=\"三.  我的任务\"></a>三.  我的任务</h3><p>我的任务列表<a href=\"http://panpanfish.com/baiduIFE/\">http://panpanfish.com/baiduIFE/</a></p>\n<p>在写这个任务列表时遇到的问题：</p>\n<p><strong>子元素浮动之后如何撑开父元素</strong></p>\n<p>由于子元素添加float属性之后就脱离了文档流，给父元素设定一个overflow:hidden;属性，便可使子元素float之后撑开父元素。</p>\n<p><strong>float的元素如何居中显示</strong></p>\n<p>如下图所示：</p>\n<p><img src=\"/uploads/post/demo/float-center.jpg\" alt=\"浮动元素居中显示\"></p>\n<h4 id=\"1-任务一\"><a href=\"#1-任务一\" class=\"headerlink\" title=\"1. 任务一\"></a>1. 任务一</h4><h4 id=\"1-任务一需要完成的示意图\"><a href=\"#1-任务一需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务一需要完成的示意图\"></a>(1). 任务一需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML代码编写，不需要写CSS</li>\n<li>示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定</li>\n<li>尽可能多地尝试更多的HTML标签</li>\n</ul>\n<h4 id=\"2-任务一demo\"><a href=\"#2-任务一demo\" class=\"headerlink\" title=\"(2). 任务一demo\"></a>(2). 任务一demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-1.html\">http://panpanfish.com/baiduIFE/task1-1.html</a></p>\n<h4 id=\"3-任务一代码\"><a href=\"#3-任务一代码\" class=\"headerlink\" title=\"(3). 任务一代码\"></a>(3). 任务一代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html</a></p>\n<h4 id=\"4-任务一笔记\"><a href=\"#4-任务一笔记\" class=\"headerlink\" title=\"(4). 任务一笔记\"></a>(4). 任务一笔记</h4><ol>\n<li><p>html5里面添加了很多语义化更好的内容标签：</p>\n<p>article、footer、header、nav、section</p>\n<p>使用这些标签会使代码结构更加清晰</p>\n</li>\n<li><p>div、section、article三者的相同点和不同</p>\n<p> <strong>相同点：</strong>都是块元素，可以对某一块内容添加样式</p>\n<p> <strong>不同点：</strong>div没有语义，仅仅用作样式化或者脚本化；section适用于一段主题内容；article适用于一段完整的独立存在的内容（判断方式：此段内容可不可以脱离上下文）</p>\n</li>\n</ol>\n<h4 id=\"2-任务二\"><a href=\"#2-任务二\" class=\"headerlink\" title=\"2. 任务二\"></a>2. 任务二</h4><h4 id=\"1-任务二需要完成的示意图\"><a href=\"#1-任务二需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务二需要完成的示意图\"></a>(1). 任务二需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_2_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定</li>\n<li>尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性</li>\n<li>HTML 及 CSS 代码结构清晰、规范</li>\n</ul>\n<h4 id=\"2-任务二demo\"><a href=\"#2-任务二demo\" class=\"headerlink\" title=\"(2). 任务二demo\"></a>(2). 任务二demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-2.html\">http://panpanfish.com/baiduIFE/task1-2.html</a></p>\n<h4 id=\"3-任务二代码\"><a href=\"#3-任务二代码\" class=\"headerlink\" title=\"(3). 任务二代码\"></a>(3). 任务二代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html</a></p>\n<h4 id=\"4-任务二笔记\"><a href=\"#4-任务二笔记\" class=\"headerlink\" title=\"(4). 任务二笔记\"></a>(4). 任务二笔记</h4><p>主要是记录一些之前没用到的css样式</p>\n<ol>\n<li><p>让一段文字的首行缩进2个字符</p>\n<p> text-indent:2em;</p>\n</li>\n<li><p>让一行文字垂直居中于一个div</p>\n<p> line-height = div的height</p>\n</li>\n<li><p>使用到的css3新增加的特性</p>\n<p> 实现阴影 box-shadow</p>\n<p> 实现圆角 border-radius</p>\n</li>\n</ol>\n<ol>\n<li><p>verticle-align 设置元素垂直对齐方式</p>\n<p> verticle-align: 百分比 （这个百分比是相对于line-height属性值）</p>\n<p> 若为正值，则升高；若为负值，则降低；0%等同于baseline。</p>\n</li>\n</ol>\n<h4 id=\"3-任务三\"><a href=\"#3-任务三\" class=\"headerlink\" title=\"3. 任务三\"></a>3. 任务三</h4><h4 id=\"1-任务三需要完成的示意图\"><a href=\"#1-任务三需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务三需要完成的示意图\"></a>(1). 任务三需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_3_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。</li>\n<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>\n<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。</li>\n<li>其他效果图中给出的标识均被正确地实现。</li>\n</ul>\n<h4 id=\"2-任务三demo\"><a href=\"#2-任务三demo\" class=\"headerlink\" title=\"(2). 任务三demo\"></a>(2). 任务三demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-3.html\">http://panpanfish.com/baiduIFE/task1-3.html</a></p>\n<h4 id=\"3-任务三代码\"><a href=\"#3-任务三代码\" class=\"headerlink\" title=\"(3). 任务三代码\"></a>(3). 任务三代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html</a></p>\n<h4 id=\"4-任务三笔记\"><a href=\"#4-任务三笔记\" class=\"headerlink\" title=\"(4). 任务三笔记\"></a>(4). 任务三笔记</h4><ol>\n<li>上传的这个demo是利用左右float，中间设定margin来实现的</li>\n</ol>\n<p>左右固定宽度，中间自适应</p>\n<pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n    &lt;head&gt;\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; \n        &lt;title&gt;左右固定宽度，中间自适应&lt;/title&gt;\n        &lt;style type=&quot;text/css&quot;&gt;\n            .leftside-bar{float:left;width:200px;height:100px;background: red;}\n            .rightside-bar{float:right;width:200px;height:100px;background: black;}\n            .content{margin-left:210px;margin-right:210px;height:100px;background: grey;}\n        &lt;/style&gt;\n        &lt;script type=&quot;text/javascript&quot;&gt;\n\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=&quot;leftside-bar&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;rightside-bar&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>脱离文档流</p>\n<p> <strong>什么叫元素脱离文档流？</strong></p>\n<p> 元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。</p>\n<p> <strong>什么情况下元素会脱离文档流？</strong></p>\n<p> 元素设置了float属性 或者 元素的position定义为absolute</p>\n<p> <strong>float脱离文档流 和 absolute脱离文档流的不同之处？</strong></p>\n<p> float脱离文档流：其他盒子会无视这个元素，但文字会为其让出位置，环绕周围</p>\n<p> absolute脱离文档流：其他盒子和文字均会无视这个元素</p>\n</li>\n<li><p>box-sizing的几种取值</p>\n<p> box-sizing可以理解为选择定义盒子尺寸的模式</p>\n<p> box-sizing的取值有 content-box、border-box、padding-box</p>\n<p> 适用于一切有width、height属性的元素</p>\n<p> content-box：width和height均指的是 <strong>内容</strong> 的宽度和高度（默认值）</p>\n<p> border-box：width和height指的是 <strong>内容+padding+border</strong>的宽度和高度</p>\n<p> padding-box：width和height值的是 <strong>内容+padding</strong>的宽度和高度</p>\n</li>\n</ol>\n<h4 id=\"4-任务四\"><a href=\"#4-任务四\" class=\"headerlink\" title=\"4. 任务四\"></a>4. 任务四</h4><h4 id=\"1-任务四需要完成的示意图\"><a href=\"#1-任务四需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务四需要完成的示意图\"></a>(1). 任务四需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_4_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。</li>\n<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>\n<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。</li>\n<li>其他效果图中给出的标识均被正确地实现。</li>\n</ul>\n<h4 id=\"2-任务四demo\"><a href=\"#2-任务四demo\" class=\"headerlink\" title=\"(2). 任务四demo\"></a>(2). 任务四demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-4.html\">http://panpanfish.com/baiduIFE/task1-4.html</a></p>\n<h4 id=\"3-任务四代码\"><a href=\"#3-任务四代码\" class=\"headerlink\" title=\"(3). 任务四代码\"></a>(3). 任务四代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html</a></p>\n<h4 id=\"4-任务四笔记\"><a href=\"#4-任务四笔记\" class=\"headerlink\" title=\"(4). 任务四笔记\"></a>(4). 任务四笔记</h4><p>这个任务中需要实现的效果有四个：灰色块水平居中、灰色块垂直居中、黄色四分之一圆的实现、黄色四分之一圆的位置固定</p>\n<ol>\n<li><p>灰色块水平居中</p>\n<p> 设置灰色块的 <code>margin-left:auto; margin-right:auto;</code></p>\n</li>\n<li><p>灰色块的垂直居中</p>\n<p> 关于垂直居中的问题，网上有很多人提出了很多种实现方式</p>\n<p> 在这里我只用了一种我感觉最好理解，并且适用于所有浏览器的方式</p>\n<pre><code>&lt;div class=&quot;floater&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;content&quot;&gt;\n       Content here\n&lt;/div&gt;\n\nhtml,body{margin:0px;height:100%} /*高度自适应的关键*/\n\n.floater {float:left;\n           height:50%;/*指的是这个悬浮在左边的div的高度为浏览器高度的一半*/\n          margin-bottom:-120px;/*将此div向上移动内容div高度的一半*/\n  }\n.content {clear:both; height:240px; position:relative;}\n</code></pre></li>\n<li><p>关于height:50%</p>\n<p> 需要注意一个对象的高度是否可以使用百分比显示，取决于对象的父级元素，在浏览器默认状态下，是没有给body、html一个高度属性的。</p>\n<p> 因此我们需要设置 html,body{height:100%}</p>\n<p> <strong>很奇怪的一点：若在html文件的开头没有声明&lt;!DOCTYPE HTML&gt;，不设置也不会有问题，这个问题还没搞懂。</strong></p>\n</li>\n<li><p>border-radius属性</p>\n<p> 如何画四分之一圆？</p>\n<p> div的宽和高相等，并且等于border-radius的某一个角的弧度</p>\n</li>\n</ol>\n<h4 id=\"5-任务五\"><a href=\"#5-任务五\" class=\"headerlink\" title=\"5. 任务五\"></a>5. 任务五</h4><p>见博客《常见的两栏式布局》</p>\n<h4 id=\"6-任务六\"><a href=\"#6-任务六\" class=\"headerlink\" title=\"6. 任务六\"></a>6. 任务六</h4><p>见博客《模拟报纸排版》</p>\n","excerpt":"","more":"<h3 id=\"一-百度前端技术学院简介\"><a href=\"#一-百度前端技术学院简介\" class=\"headerlink\" title=\"一. 百度前端技术学院简介\"></a>一. 百度前端技术学院简介</h3><p>百度前端技术学院诞生于2014年，由百度最大规模的前端技术组织 EFE 团队发起成立。</p>\n<p>目前学院是由百度校园品牌部、百度多模交互搜索部以及百度校园招聘组联合组织的，面向大学生人群，免费的一个技术学习、交流与分享平台。</p>\n<h3 id=\"二-第一阶段任务\"><a href=\"#二-第一阶段任务\" class=\"headerlink\" title=\"二.  第一阶段任务\"></a>二.  第一阶段任务</h3><p><img src=\"/uploads/post/demo/baidu-ife-task1.jpg\" alt=\"第一阶段任务\"></p>\n<h3 id=\"三-我的任务\"><a href=\"#三-我的任务\" class=\"headerlink\" title=\"三.  我的任务\"></a>三.  我的任务</h3><p>我的任务列表<a href=\"http://panpanfish.com/baiduIFE/\">http://panpanfish.com/baiduIFE/</a></p>\n<p>在写这个任务列表时遇到的问题：</p>\n<p><strong>子元素浮动之后如何撑开父元素</strong></p>\n<p>由于子元素添加float属性之后就脱离了文档流，给父元素设定一个overflow:hidden;属性，便可使子元素float之后撑开父元素。</p>\n<p><strong>float的元素如何居中显示</strong></p>\n<p>如下图所示：</p>\n<p><img src=\"/uploads/post/demo/float-center.jpg\" alt=\"浮动元素居中显示\"></p>\n<h4 id=\"1-任务一\"><a href=\"#1-任务一\" class=\"headerlink\" title=\"1. 任务一\"></a>1. 任务一</h4><h4 id=\"1-任务一需要完成的示意图\"><a href=\"#1-任务一需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务一需要完成的示意图\"></a>(1). 任务一需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML代码编写，不需要写CSS</li>\n<li>示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定</li>\n<li>尽可能多地尝试更多的HTML标签</li>\n</ul>\n<h4 id=\"2-任务一demo\"><a href=\"#2-任务一demo\" class=\"headerlink\" title=\"(2). 任务一demo\"></a>(2). 任务一demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-1.html\">http://panpanfish.com/baiduIFE/task1-1.html</a></p>\n<h4 id=\"3-任务一代码\"><a href=\"#3-任务一代码\" class=\"headerlink\" title=\"(3). 任务一代码\"></a>(3). 任务一代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-1.html</a></p>\n<h4 id=\"4-任务一笔记\"><a href=\"#4-任务一笔记\" class=\"headerlink\" title=\"(4). 任务一笔记\"></a>(4). 任务一笔记</h4><ol>\n<li><p>html5里面添加了很多语义化更好的内容标签：</p>\n<p>article、footer、header、nav、section</p>\n<p>使用这些标签会使代码结构更加清晰</p>\n</li>\n<li><p>div、section、article三者的相同点和不同</p>\n<p> <strong>相同点：</strong>都是块元素，可以对某一块内容添加样式</p>\n<p> <strong>不同点：</strong>div没有语义，仅仅用作样式化或者脚本化；section适用于一段主题内容；article适用于一段完整的独立存在的内容（判断方式：此段内容可不可以脱离上下文）</p>\n</li>\n</ol>\n<h4 id=\"2-任务二\"><a href=\"#2-任务二\" class=\"headerlink\" title=\"2. 任务二\"></a>2. 任务二</h4><h4 id=\"1-任务二需要完成的示意图\"><a href=\"#1-任务二需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务二需要完成的示意图\"></a>(1). 任务二需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_2_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定</li>\n<li>尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性</li>\n<li>HTML 及 CSS 代码结构清晰、规范</li>\n</ul>\n<h4 id=\"2-任务二demo\"><a href=\"#2-任务二demo\" class=\"headerlink\" title=\"(2). 任务二demo\"></a>(2). 任务二demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-2.html\">http://panpanfish.com/baiduIFE/task1-2.html</a></p>\n<h4 id=\"3-任务二代码\"><a href=\"#3-任务二代码\" class=\"headerlink\" title=\"(3). 任务二代码\"></a>(3). 任务二代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-2.html</a></p>\n<h4 id=\"4-任务二笔记\"><a href=\"#4-任务二笔记\" class=\"headerlink\" title=\"(4). 任务二笔记\"></a>(4). 任务二笔记</h4><p>主要是记录一些之前没用到的css样式</p>\n<ol>\n<li><p>让一段文字的首行缩进2个字符</p>\n<p> text-indent:2em;</p>\n</li>\n<li><p>让一行文字垂直居中于一个div</p>\n<p> line-height = div的height</p>\n</li>\n<li><p>使用到的css3新增加的特性</p>\n<p> 实现阴影 box-shadow</p>\n<p> 实现圆角 border-radius</p>\n</li>\n</ol>\n<ol>\n<li><p>verticle-align 设置元素垂直对齐方式</p>\n<p> verticle-align: 百分比 （这个百分比是相对于line-height属性值）</p>\n<p> 若为正值，则升高；若为负值，则降低；0%等同于baseline。</p>\n</li>\n</ol>\n<h4 id=\"3-任务三\"><a href=\"#3-任务三\" class=\"headerlink\" title=\"3. 任务三\"></a>3. 任务三</h4><h4 id=\"1-任务三需要完成的示意图\"><a href=\"#1-任务三需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务三需要完成的示意图\"></a>(1). 任务三需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_3_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。</li>\n<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>\n<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。</li>\n<li>其他效果图中给出的标识均被正确地实现。</li>\n</ul>\n<h4 id=\"2-任务三demo\"><a href=\"#2-任务三demo\" class=\"headerlink\" title=\"(2). 任务三demo\"></a>(2). 任务三demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-3.html\">http://panpanfish.com/baiduIFE/task1-3.html</a></p>\n<h4 id=\"3-任务三代码\"><a href=\"#3-任务三代码\" class=\"headerlink\" title=\"(3). 任务三代码\"></a>(3). 任务三代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-3.html</a></p>\n<h4 id=\"4-任务三笔记\"><a href=\"#4-任务三笔记\" class=\"headerlink\" title=\"(4). 任务三笔记\"></a>(4). 任务三笔记</h4><ol>\n<li>上传的这个demo是利用左右float，中间设定margin来实现的</li>\n</ol>\n<p>左右固定宽度，中间自适应</p>\n<pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n    &lt;head&gt;\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; \n        &lt;title&gt;左右固定宽度，中间自适应&lt;/title&gt;\n        &lt;style type=&quot;text/css&quot;&gt;\n            .leftside-bar{float:left;width:200px;height:100px;background: red;}\n            .rightside-bar{float:right;width:200px;height:100px;background: black;}\n            .content{margin-left:210px;margin-right:210px;height:100px;background: grey;}\n        &lt;/style&gt;\n        &lt;script type=&quot;text/javascript&quot;&gt;\n\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=&quot;leftside-bar&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;rightside-bar&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>脱离文档流</p>\n<p> <strong>什么叫元素脱离文档流？</strong></p>\n<p> 元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。</p>\n<p> <strong>什么情况下元素会脱离文档流？</strong></p>\n<p> 元素设置了float属性 或者 元素的position定义为absolute</p>\n<p> <strong>float脱离文档流 和 absolute脱离文档流的不同之处？</strong></p>\n<p> float脱离文档流：其他盒子会无视这个元素，但文字会为其让出位置，环绕周围</p>\n<p> absolute脱离文档流：其他盒子和文字均会无视这个元素</p>\n</li>\n<li><p>box-sizing的几种取值</p>\n<p> box-sizing可以理解为选择定义盒子尺寸的模式</p>\n<p> box-sizing的取值有 content-box、border-box、padding-box</p>\n<p> 适用于一切有width、height属性的元素</p>\n<p> content-box：width和height均指的是 <strong>内容</strong> 的宽度和高度（默认值）</p>\n<p> border-box：width和height指的是 <strong>内容+padding+border</strong>的宽度和高度</p>\n<p> padding-box：width和height值的是 <strong>内容+padding</strong>的宽度和高度</p>\n</li>\n</ol>\n<h4 id=\"4-任务四\"><a href=\"#4-任务四\" class=\"headerlink\" title=\"4. 任务四\"></a>4. 任务四</h4><h4 id=\"1-任务四需要完成的示意图\"><a href=\"#1-任务四需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务四需要完成的示意图\"></a>(1). 任务四需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_4_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。</li>\n<li>调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。</li>\n<li>改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。</li>\n<li>其他效果图中给出的标识均被正确地实现。</li>\n</ul>\n<h4 id=\"2-任务四demo\"><a href=\"#2-任务四demo\" class=\"headerlink\" title=\"(2). 任务四demo\"></a>(2). 任务四demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-4.html\">http://panpanfish.com/baiduIFE/task1-4.html</a></p>\n<h4 id=\"3-任务四代码\"><a href=\"#3-任务四代码\" class=\"headerlink\" title=\"(3). 任务四代码\"></a>(3). 任务四代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-4.html</a></p>\n<h4 id=\"4-任务四笔记\"><a href=\"#4-任务四笔记\" class=\"headerlink\" title=\"(4). 任务四笔记\"></a>(4). 任务四笔记</h4><p>这个任务中需要实现的效果有四个：灰色块水平居中、灰色块垂直居中、黄色四分之一圆的实现、黄色四分之一圆的位置固定</p>\n<ol>\n<li><p>灰色块水平居中</p>\n<p> 设置灰色块的 <code>margin-left:auto; margin-right:auto;</code></p>\n</li>\n<li><p>灰色块的垂直居中</p>\n<p> 关于垂直居中的问题，网上有很多人提出了很多种实现方式</p>\n<p> 在这里我只用了一种我感觉最好理解，并且适用于所有浏览器的方式</p>\n<pre><code>&lt;div class=&quot;floater&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;content&quot;&gt;\n       Content here\n&lt;/div&gt;\n\nhtml,body{margin:0px;height:100%} /*高度自适应的关键*/\n\n.floater {float:left;\n           height:50%;/*指的是这个悬浮在左边的div的高度为浏览器高度的一半*/\n          margin-bottom:-120px;/*将此div向上移动内容div高度的一半*/\n  }\n.content {clear:both; height:240px; position:relative;}\n</code></pre></li>\n<li><p>关于height:50%</p>\n<p> 需要注意一个对象的高度是否可以使用百分比显示，取决于对象的父级元素，在浏览器默认状态下，是没有给body、html一个高度属性的。</p>\n<p> 因此我们需要设置 html,body{height:100%}</p>\n<p> <strong>很奇怪的一点：若在html文件的开头没有声明&lt;!DOCTYPE HTML&gt;，不设置也不会有问题，这个问题还没搞懂。</strong></p>\n</li>\n<li><p>border-radius属性</p>\n<p> 如何画四分之一圆？</p>\n<p> div的宽和高相等，并且等于border-radius的某一个角的弧度</p>\n</li>\n</ol>\n<h4 id=\"5-任务五\"><a href=\"#5-任务五\" class=\"headerlink\" title=\"5. 任务五\"></a>5. 任务五</h4><p>见博客《常见的两栏式布局》</p>\n<h4 id=\"6-任务六\"><a href=\"#6-任务六\" class=\"headerlink\" title=\"6. 任务六\"></a>6. 任务六</h4><p>见博客《模拟报纸排版》</p>\n"},{"layout":"post","title":"模拟报纸排版","date":"2016-03-14T16:00:00.000Z","description":null,"_content":"\n### 一. 需要完成的示意图\n\n![模拟报纸排版](/uploads/post/demo/newspaper.jpg)\n\n**任务要求：**\n\n- 页面宽度固定（定宽）\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 有能力的同学可以在实现一遍后尝试用less, sass或者stylus等再实现一次\n\n### 二. 模拟报纸排版demo\n\n[http://panpanfish.com/myDemo/newspaper.html](http://panpanfish.com/myDemo/newspaper.html \"报纸排版\")\n\n### 三. 模拟报纸排版代码\n\n[https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html](https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html)\n\n### 四. 实现过程中的笔记\n\n任务六是做一个模拟报纸排版的固定宽度的网页\n\n我在做这个任务时遇到的问题有：\n\n1. `<img>` 标签行后有空格问题\n\n可能是编辑器换行产生的空格，把font-size设置成0px即可\n\n2. 用CSS画三角形\n\n    <div class=\"triangle-up\"></div>\n    \n    .triangle-up{ width: 0;\n    height: 0;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-bottom: 10px solid #31539E;\n    display: inline-block;}\n\n可以抽象地想象一下：一个宽和高均为0px的div\n\n3. CSS3高级选择器——伪元素选择器\n\n所谓伪元素，也就是并不是html里面的元素\n\n**CSS中有4个伪元素选择器：**\n\n**（1）first-line**\n\n对某个元素中的第一行文字使用样式\n\n例子：   p:first-line{ }\n\n**(2) first-letter**\n\n对某个元素中的第一个字母使用样式\n\n例子：   p:first-letter{ }\n\n**（3）before**\n\n在元素之前添加内容\n\n例子：   li:before{ }\n\n**（4）after**\n\n在元素之后添加内容\n\n例子：   li:after{ }\n","source":"_posts/2016-03-15-模拟报纸排版.md","raw":"---\nlayout: post\ntitle: 模拟报纸排版\ndate: 2016-03-15\ncategories: Demo\ntags: [javaScript,css]\ndescription: \n---\n\n### 一. 需要完成的示意图\n\n![模拟报纸排版](/uploads/post/demo/newspaper.jpg)\n\n**任务要求：**\n\n- 页面宽度固定（定宽）\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 有能力的同学可以在实现一遍后尝试用less, sass或者stylus等再实现一次\n\n### 二. 模拟报纸排版demo\n\n[http://panpanfish.com/myDemo/newspaper.html](http://panpanfish.com/myDemo/newspaper.html \"报纸排版\")\n\n### 三. 模拟报纸排版代码\n\n[https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html](https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html)\n\n### 四. 实现过程中的笔记\n\n任务六是做一个模拟报纸排版的固定宽度的网页\n\n我在做这个任务时遇到的问题有：\n\n1. `<img>` 标签行后有空格问题\n\n可能是编辑器换行产生的空格，把font-size设置成0px即可\n\n2. 用CSS画三角形\n\n    <div class=\"triangle-up\"></div>\n    \n    .triangle-up{ width: 0;\n    height: 0;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-bottom: 10px solid #31539E;\n    display: inline-block;}\n\n可以抽象地想象一下：一个宽和高均为0px的div\n\n3. CSS3高级选择器——伪元素选择器\n\n所谓伪元素，也就是并不是html里面的元素\n\n**CSS中有4个伪元素选择器：**\n\n**（1）first-line**\n\n对某个元素中的第一行文字使用样式\n\n例子：   p:first-line{ }\n\n**(2) first-letter**\n\n对某个元素中的第一个字母使用样式\n\n例子：   p:first-letter{ }\n\n**（3）before**\n\n在元素之前添加内容\n\n例子：   li:before{ }\n\n**（4）after**\n\n在元素之后添加内容\n\n例子：   li:after{ }\n","slug":"2016-03-15-模拟报纸排版","published":1,"updated":"2016-07-03T13:52:20.000Z","comments":1,"photos":[],"link":"","_id":"cj035occi000qd5u8whpg3nbq","content":"<h3 id=\"一-需要完成的示意图\"><a href=\"#一-需要完成的示意图\" class=\"headerlink\" title=\"一. 需要完成的示意图\"></a>一. 需要完成的示意图</h3><p><img src=\"/uploads/post/demo/newspaper.jpg\" alt=\"模拟报纸排版\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>页面宽度固定（定宽）</li>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>有能力的同学可以在实现一遍后尝试用less, sass或者stylus等再实现一次</li>\n</ul>\n<h3 id=\"二-模拟报纸排版demo\"><a href=\"#二-模拟报纸排版demo\" class=\"headerlink\" title=\"二. 模拟报纸排版demo\"></a>二. 模拟报纸排版demo</h3><p><a href=\"http://panpanfish.com/myDemo/newspaper.html\" title=\"报纸排版\">http://panpanfish.com/myDemo/newspaper.html</a></p>\n<h3 id=\"三-模拟报纸排版代码\"><a href=\"#三-模拟报纸排版代码\" class=\"headerlink\" title=\"三. 模拟报纸排版代码\"></a>三. 模拟报纸排版代码</h3><p><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html</a></p>\n<h3 id=\"四-实现过程中的笔记\"><a href=\"#四-实现过程中的笔记\" class=\"headerlink\" title=\"四. 实现过程中的笔记\"></a>四. 实现过程中的笔记</h3><p>任务六是做一个模拟报纸排版的固定宽度的网页</p>\n<p>我在做这个任务时遇到的问题有：</p>\n<ol>\n<li><code>&lt;img&gt;</code> 标签行后有空格问题</li>\n</ol>\n<p>可能是编辑器换行产生的空格，把font-size设置成0px即可</p>\n<ol>\n<li><p>用CSS画三角形</p>\n <div class=\"triangle-up\"></div>\n\n<p> .triangle-up{ width: 0;<br> height: 0;<br> border-left: 5px solid transparent;<br> border-right: 5px solid transparent;<br> border-bottom: 10px solid #31539E;<br> display: inline-block;}</p>\n</li>\n</ol>\n<p>可以抽象地想象一下：一个宽和高均为0px的div</p>\n<ol>\n<li>CSS3高级选择器——伪元素选择器</li>\n</ol>\n<p>所谓伪元素，也就是并不是html里面的元素</p>\n<p><strong>CSS中有4个伪元素选择器：</strong></p>\n<p><strong>（1）first-line</strong></p>\n<p>对某个元素中的第一行文字使用样式</p>\n<p>例子：   p:first-line{ }</p>\n<p><strong>(2) first-letter</strong></p>\n<p>对某个元素中的第一个字母使用样式</p>\n<p>例子：   p:first-letter{ }</p>\n<p><strong>（3）before</strong></p>\n<p>在元素之前添加内容</p>\n<p>例子：   li:before{ }</p>\n<p><strong>（4）after</strong></p>\n<p>在元素之后添加内容</p>\n<p>例子：   li:after{ }</p>\n","excerpt":"","more":"<h3 id=\"一-需要完成的示意图\"><a href=\"#一-需要完成的示意图\" class=\"headerlink\" title=\"一. 需要完成的示意图\"></a>一. 需要完成的示意图</h3><p><img src=\"/uploads/post/demo/newspaper.jpg\" alt=\"模拟报纸排版\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>页面宽度固定（定宽）</li>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>有能力的同学可以在实现一遍后尝试用less, sass或者stylus等再实现一次</li>\n</ul>\n<h3 id=\"二-模拟报纸排版demo\"><a href=\"#二-模拟报纸排版demo\" class=\"headerlink\" title=\"二. 模拟报纸排版demo\"></a>二. 模拟报纸排版demo</h3><p><a href=\"http://panpanfish.com/myDemo/newspaper.html\" title=\"报纸排版\">http://panpanfish.com/myDemo/newspaper.html</a></p>\n<h3 id=\"三-模拟报纸排版代码\"><a href=\"#三-模拟报纸排版代码\" class=\"headerlink\" title=\"三. 模拟报纸排版代码\"></a>三. 模拟报纸排版代码</h3><p><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html\">https://github.com/panpan040828/myDemo/blob/gh-pages/newspaper.html</a></p>\n<h3 id=\"四-实现过程中的笔记\"><a href=\"#四-实现过程中的笔记\" class=\"headerlink\" title=\"四. 实现过程中的笔记\"></a>四. 实现过程中的笔记</h3><p>任务六是做一个模拟报纸排版的固定宽度的网页</p>\n<p>我在做这个任务时遇到的问题有：</p>\n<ol>\n<li><code>&lt;img&gt;</code> 标签行后有空格问题</li>\n</ol>\n<p>可能是编辑器换行产生的空格，把font-size设置成0px即可</p>\n<ol>\n<li><p>用CSS画三角形</p>\n <div class=\"triangle-up\"></div>\n\n<p> .triangle-up{ width: 0;<br> height: 0;<br> border-left: 5px solid transparent;<br> border-right: 5px solid transparent;<br> border-bottom: 10px solid #31539E;<br> display: inline-block;}</p>\n</li>\n</ol>\n<p>可以抽象地想象一下：一个宽和高均为0px的div</p>\n<ol>\n<li>CSS3高级选择器——伪元素选择器</li>\n</ol>\n<p>所谓伪元素，也就是并不是html里面的元素</p>\n<p><strong>CSS中有4个伪元素选择器：</strong></p>\n<p><strong>（1）first-line</strong></p>\n<p>对某个元素中的第一行文字使用样式</p>\n<p>例子：   p:first-line{ }</p>\n<p><strong>(2) first-letter</strong></p>\n<p>对某个元素中的第一个字母使用样式</p>\n<p>例子：   p:first-letter{ }</p>\n<p><strong>（3）before</strong></p>\n<p>在元素之前添加内容</p>\n<p>例子：   li:before{ }</p>\n<p><strong>（4）after</strong></p>\n<p>在元素之后添加内容</p>\n<p>例子：   li:after{ }</p>\n"},{"layout":"post","title":"常见的两栏式布局","date":"2016-03-14T16:00:00.000Z","description":null,"_content":"\n### 一. 需要完成的示意图\n\n![模拟报纸排版](/uploads/post/demo/two-column.jpg)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定\n- 尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性\n- HTML 及 CSS 代码结构清晰、规范\n- 头部和底部的黑色区域始终是100%宽\n- 页面右侧部分为固定宽度，左侧保持与浏览器窗口变化同步自适应变化\n- 左侧的各个模块里面的内容宽度跟随左侧整体宽度同步自适应变化\n- 10张图片需要永远都完整展现，所以会随着宽度变窄，从两行变成三行甚至更多，也有可能随着宽度变宽，变成一行\n \n### 二. 两栏式布局demo\n\n[http://panpanfish.com/myDemo/two-column.html](http://panpanfish.com/myDemo/two-column.html \"常见的两栏式布局\")\n\n### 三. 两栏式布局代码\n\n[https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html](https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html)\n\n### 四. 实现过程中的笔记\n\n任务五要实现的效果有两个：\n\n#### 1. 左边自适应，右边固定宽度的布局\n \n  关于这个布局的实现，网上也有好几种方法，我还是选取了我觉得比较好的一种：固定宽度区域float，设置自适应宽度区域的margin\n\n代码如下：\n\n    <div id=\"wrap\">\n      <div id=\"sidebar\" style=\"height:240px;\">固定宽度区</div>\n      <div id=\"content\" style=\"height:340px;\">自适应区</div>\n    </div>\n    \n    \n      #sidebar {\n    float: right; width: 300px;\n      }\n      #content {\n    margin-right: 310px;\n      }\n\n\n#### 2. 使用CSS3的弹性盒布局flexbox\n\n这一部分见我写的《CSS3弹性盒布局flexbox》那篇博客\n","source":"_posts/2016-03-15-常见的两栏式布局.md","raw":"---\nlayout: post\ntitle: 常见的两栏式布局\ndate: 2016-03-15\ncategories: Demo\ntags: [css]\ndescription: \n---\n\n### 一. 需要完成的示意图\n\n![模拟报纸排版](/uploads/post/demo/two-column.jpg)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定\n- 尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性\n- HTML 及 CSS 代码结构清晰、规范\n- 头部和底部的黑色区域始终是100%宽\n- 页面右侧部分为固定宽度，左侧保持与浏览器窗口变化同步自适应变化\n- 左侧的各个模块里面的内容宽度跟随左侧整体宽度同步自适应变化\n- 10张图片需要永远都完整展现，所以会随着宽度变窄，从两行变成三行甚至更多，也有可能随着宽度变宽，变成一行\n \n### 二. 两栏式布局demo\n\n[http://panpanfish.com/myDemo/two-column.html](http://panpanfish.com/myDemo/two-column.html \"常见的两栏式布局\")\n\n### 三. 两栏式布局代码\n\n[https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html](https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html)\n\n### 四. 实现过程中的笔记\n\n任务五要实现的效果有两个：\n\n#### 1. 左边自适应，右边固定宽度的布局\n \n  关于这个布局的实现，网上也有好几种方法，我还是选取了我觉得比较好的一种：固定宽度区域float，设置自适应宽度区域的margin\n\n代码如下：\n\n    <div id=\"wrap\">\n      <div id=\"sidebar\" style=\"height:240px;\">固定宽度区</div>\n      <div id=\"content\" style=\"height:340px;\">自适应区</div>\n    </div>\n    \n    \n      #sidebar {\n    float: right; width: 300px;\n      }\n      #content {\n    margin-right: 310px;\n      }\n\n\n#### 2. 使用CSS3的弹性盒布局flexbox\n\n这一部分见我写的《CSS3弹性盒布局flexbox》那篇博客\n","slug":"2016-03-15-常见的两栏式布局","published":1,"updated":"2016-07-03T13:52:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035occk000vd5u86bvihjnx","content":"<h3 id=\"一-需要完成的示意图\"><a href=\"#一-需要完成的示意图\" class=\"headerlink\" title=\"一. 需要完成的示意图\"></a>一. 需要完成的示意图</h3><p><img src=\"/uploads/post/demo/two-column.jpg\" alt=\"模拟报纸排版\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定</li>\n<li>尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性</li>\n<li>HTML 及 CSS 代码结构清晰、规范</li>\n<li>头部和底部的黑色区域始终是100%宽</li>\n<li>页面右侧部分为固定宽度，左侧保持与浏览器窗口变化同步自适应变化</li>\n<li>左侧的各个模块里面的内容宽度跟随左侧整体宽度同步自适应变化</li>\n<li>10张图片需要永远都完整展现，所以会随着宽度变窄，从两行变成三行甚至更多，也有可能随着宽度变宽，变成一行</li>\n</ul>\n<h3 id=\"二-两栏式布局demo\"><a href=\"#二-两栏式布局demo\" class=\"headerlink\" title=\"二. 两栏式布局demo\"></a>二. 两栏式布局demo</h3><p><a href=\"http://panpanfish.com/myDemo/two-column.html\" title=\"常见的两栏式布局\">http://panpanfish.com/myDemo/two-column.html</a></p>\n<h3 id=\"三-两栏式布局代码\"><a href=\"#三-两栏式布局代码\" class=\"headerlink\" title=\"三. 两栏式布局代码\"></a>三. 两栏式布局代码</h3><p><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html</a></p>\n<h3 id=\"四-实现过程中的笔记\"><a href=\"#四-实现过程中的笔记\" class=\"headerlink\" title=\"四. 实现过程中的笔记\"></a>四. 实现过程中的笔记</h3><p>任务五要实现的效果有两个：</p>\n<h4 id=\"1-左边自适应，右边固定宽度的布局\"><a href=\"#1-左边自适应，右边固定宽度的布局\" class=\"headerlink\" title=\"1. 左边自适应，右边固定宽度的布局\"></a>1. 左边自适应，右边固定宽度的布局</h4><p>  关于这个布局的实现，网上也有好几种方法，我还是选取了我觉得比较好的一种：固定宽度区域float，设置自适应宽度区域的margin</p>\n<p>代码如下：</p>\n<pre><code>&lt;div id=&quot;wrap&quot;&gt;\n  &lt;div id=&quot;sidebar&quot; style=&quot;height:240px;&quot;&gt;固定宽度区&lt;/div&gt;\n  &lt;div id=&quot;content&quot; style=&quot;height:340px;&quot;&gt;自适应区&lt;/div&gt;\n&lt;/div&gt;\n\n\n  #sidebar {\nfloat: right; width: 300px;\n  }\n  #content {\nmargin-right: 310px;\n  }\n</code></pre><h4 id=\"2-使用CSS3的弹性盒布局flexbox\"><a href=\"#2-使用CSS3的弹性盒布局flexbox\" class=\"headerlink\" title=\"2. 使用CSS3的弹性盒布局flexbox\"></a>2. 使用CSS3的弹性盒布局flexbox</h4><p>这一部分见我写的《CSS3弹性盒布局flexbox》那篇博客</p>\n","excerpt":"","more":"<h3 id=\"一-需要完成的示意图\"><a href=\"#一-需要完成的示意图\" class=\"headerlink\" title=\"一. 需要完成的示意图\"></a>一. 需要完成的示意图</h3><p><img src=\"/uploads/post/demo/two-column.jpg\" alt=\"模拟报纸排版\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>示例图仅为参考，不需要完全实现一致，其中的图片、文案均可自行设定</li>\n<li>尽可能多地尝试不同的、更多的样式设定来实践各种CSS属性</li>\n<li>HTML 及 CSS 代码结构清晰、规范</li>\n<li>头部和底部的黑色区域始终是100%宽</li>\n<li>页面右侧部分为固定宽度，左侧保持与浏览器窗口变化同步自适应变化</li>\n<li>左侧的各个模块里面的内容宽度跟随左侧整体宽度同步自适应变化</li>\n<li>10张图片需要永远都完整展现，所以会随着宽度变窄，从两行变成三行甚至更多，也有可能随着宽度变宽，变成一行</li>\n</ul>\n<h3 id=\"二-两栏式布局demo\"><a href=\"#二-两栏式布局demo\" class=\"headerlink\" title=\"二. 两栏式布局demo\"></a>二. 两栏式布局demo</h3><p><a href=\"http://panpanfish.com/myDemo/two-column.html\" title=\"常见的两栏式布局\">http://panpanfish.com/myDemo/two-column.html</a></p>\n<h3 id=\"三-两栏式布局代码\"><a href=\"#三-两栏式布局代码\" class=\"headerlink\" title=\"三. 两栏式布局代码\"></a>三. 两栏式布局代码</h3><p><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html\">https://github.com/panpan040828/myDemo/blob/gh-pages/two-column.html</a></p>\n<h3 id=\"四-实现过程中的笔记\"><a href=\"#四-实现过程中的笔记\" class=\"headerlink\" title=\"四. 实现过程中的笔记\"></a>四. 实现过程中的笔记</h3><p>任务五要实现的效果有两个：</p>\n<h4 id=\"1-左边自适应，右边固定宽度的布局\"><a href=\"#1-左边自适应，右边固定宽度的布局\" class=\"headerlink\" title=\"1. 左边自适应，右边固定宽度的布局\"></a>1. 左边自适应，右边固定宽度的布局</h4><p>  关于这个布局的实现，网上也有好几种方法，我还是选取了我觉得比较好的一种：固定宽度区域float，设置自适应宽度区域的margin</p>\n<p>代码如下：</p>\n<pre><code>&lt;div id=&quot;wrap&quot;&gt;\n  &lt;div id=&quot;sidebar&quot; style=&quot;height:240px;&quot;&gt;固定宽度区&lt;/div&gt;\n  &lt;div id=&quot;content&quot; style=&quot;height:340px;&quot;&gt;自适应区&lt;/div&gt;\n&lt;/div&gt;\n\n\n  #sidebar {\nfloat: right; width: 300px;\n  }\n  #content {\nmargin-right: 310px;\n  }\n</code></pre><h4 id=\"2-使用CSS3的弹性盒布局flexbox\"><a href=\"#2-使用CSS3的弹性盒布局flexbox\" class=\"headerlink\" title=\"2. 使用CSS3的弹性盒布局flexbox\"></a>2. 使用CSS3的弹性盒布局flexbox</h4><p>这一部分见我写的《CSS3弹性盒布局flexbox》那篇博客</p>\n"},{"layout":"post","title":"break、continue、true","date":"2016-03-15T16:00:00.000Z","description":null,"_content":"\n### break\n\nbreak有两种用法：用在switch语句中、用在循环语句中\n\n**用在switch语句中：**跳出switch语句\n\n**用在循环语句中：**跳出**最内层**的循环，遇见break，这循环就停止，就执行循环后面的代码。\n\n### continue\n\ncontinue是用来退出本次循环，执行下一次循环\n\n只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内\n\n### return\n\nreturn语句只能用在函数中，用来为函数指定返回值\n\n当执行return语句时，函数执行会停止，即使函数主体中还有其他语句。\n\n\n\n","source":"_posts/2016-03-16-break、continue、return.md","raw":"---\nlayout: post\ntitle: break、continue、true\ndate: 2016-03-16\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### break\n\nbreak有两种用法：用在switch语句中、用在循环语句中\n\n**用在switch语句中：**跳出switch语句\n\n**用在循环语句中：**跳出**最内层**的循环，遇见break，这循环就停止，就执行循环后面的代码。\n\n### continue\n\ncontinue是用来退出本次循环，执行下一次循环\n\n只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内\n\n### return\n\nreturn语句只能用在函数中，用来为函数指定返回值\n\n当执行return语句时，函数执行会停止，即使函数主体中还有其他语句。\n\n\n\n","slug":"2016-03-16-break、continue、return","published":1,"updated":"2016-08-18T07:43:00.000Z","comments":1,"photos":[],"link":"","_id":"cj035occl000xd5u8m1hkt6va","content":"<h3 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h3><p>break有两种用法：用在switch语句中、用在循环语句中</p>\n<p><strong>用在switch语句中：</strong>跳出switch语句</p>\n<p><strong>用在循环语句中：</strong>跳出<strong>最内层</strong>的循环，遇见break，这循环就停止，就执行循环后面的代码。</p>\n<h3 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h3><p>continue是用来退出本次循环，执行下一次循环</p>\n<p>只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内</p>\n<h3 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h3><p>return语句只能用在函数中，用来为函数指定返回值</p>\n<p>当执行return语句时，函数执行会停止，即使函数主体中还有其他语句。</p>\n","excerpt":"","more":"<h3 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h3><p>break有两种用法：用在switch语句中、用在循环语句中</p>\n<p><strong>用在switch语句中：</strong>跳出switch语句</p>\n<p><strong>用在循环语句中：</strong>跳出<strong>最内层</strong>的循环，遇见break，这循环就停止，就执行循环后面的代码。</p>\n<h3 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h3><p>continue是用来退出本次循环，执行下一次循环</p>\n<p>只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内</p>\n<h3 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h3><p>return语句只能用在函数中，用来为函数指定返回值</p>\n<p>当执行return语句时，函数执行会停止，即使函数主体中还有其他语句。</p>\n"},{"layout":"post","title":"__proto__和prototype","date":"2016-03-21T16:00:00.000Z","description":null,"_content":"\n### 一. 原型指针__proto__\n\n原型指针是**对象才有**的\n\n每一个对象都有一个原型指针，指向的是它的原型。\n\n举例：\n\n```\n\t//对象\n\tvar a = new Object();\n\tconsole.log(a.__proto__); // Object.prototype\n\tconsole.log(a.__proto__.__proto__) // null\n\t原型链：\n\ta => Object.prototype => null\n\n\t//数组\n\tvar a = ['1', '2', '3'];\n\tconsole.log(a.__proto__); // [] = Array.prototype\n\tconsole.log(a.__proto__.__proto__) // Object.prototype\n\tconsole.log(a.__proto__.__proto__.__proto__) // null\n\t原型链：\n\ta => Array.prototype => Object.prototype => null\n\n\t//函数\n\tfunction foo() {}\n\tconsole.log(foo.__proto__); // Function.prototype\n\tconsole.log(foo.__proto__.__proto__); // Object.prototype\n\tconsole.log(foo.__proto__.__proto__.__proto__); // null\n\t原型链：\n\tfoo => Function.prototype => Object.prototype => null\n```\n\n### 二. 原型对象prototype\n\n原型对象是只有**函数才有**的属性。\n\n原型对象是javaScript中的**基因链接**。\n\njavaScript中的函数也是对象，因此一个函数既有__proto__指针，也有prototype属性。\n\n\n**原型、构造函数、实例之间的关系：**\n\n```\n\tfunction Person() {\t\t\n\t}\n\n\tPerson.prototype \n\n\tvar p = new Person();\n\n\t构造函数：Person            属性：prototype => 指向原型对象\n\t原型对象：Person.prototype  属性：constructor => 指向构造函数\n\t\t\t\t\t\t\t\t\t__proto__ (原型指针) => 指向原型链上一层的原型对象 \n\t实例：p                     属性：__proto__(原型指针) => 指向原型对象\n```\n\n\n\n\n","source":"_posts/2016-03-22-原型指针__proto__和原型对象.md","raw":"---\nlayout: post\ntitle: __proto__和prototype\ndate: 2016-03-22\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 原型指针__proto__\n\n原型指针是**对象才有**的\n\n每一个对象都有一个原型指针，指向的是它的原型。\n\n举例：\n\n```\n\t//对象\n\tvar a = new Object();\n\tconsole.log(a.__proto__); // Object.prototype\n\tconsole.log(a.__proto__.__proto__) // null\n\t原型链：\n\ta => Object.prototype => null\n\n\t//数组\n\tvar a = ['1', '2', '3'];\n\tconsole.log(a.__proto__); // [] = Array.prototype\n\tconsole.log(a.__proto__.__proto__) // Object.prototype\n\tconsole.log(a.__proto__.__proto__.__proto__) // null\n\t原型链：\n\ta => Array.prototype => Object.prototype => null\n\n\t//函数\n\tfunction foo() {}\n\tconsole.log(foo.__proto__); // Function.prototype\n\tconsole.log(foo.__proto__.__proto__); // Object.prototype\n\tconsole.log(foo.__proto__.__proto__.__proto__); // null\n\t原型链：\n\tfoo => Function.prototype => Object.prototype => null\n```\n\n### 二. 原型对象prototype\n\n原型对象是只有**函数才有**的属性。\n\n原型对象是javaScript中的**基因链接**。\n\njavaScript中的函数也是对象，因此一个函数既有__proto__指针，也有prototype属性。\n\n\n**原型、构造函数、实例之间的关系：**\n\n```\n\tfunction Person() {\t\t\n\t}\n\n\tPerson.prototype \n\n\tvar p = new Person();\n\n\t构造函数：Person            属性：prototype => 指向原型对象\n\t原型对象：Person.prototype  属性：constructor => 指向构造函数\n\t\t\t\t\t\t\t\t\t__proto__ (原型指针) => 指向原型链上一层的原型对象 \n\t实例：p                     属性：__proto__(原型指针) => 指向原型对象\n```\n\n\n\n\n","slug":"2016-03-22-原型指针__proto__和原型对象","published":1,"updated":"2016-10-15T11:44:48.000Z","comments":1,"photos":[],"link":"","_id":"cj035occp0012d5u8funvffr7","content":"<h3 id=\"一-原型指针proto\"><a href=\"#一-原型指针proto\" class=\"headerlink\" title=\"一. 原型指针proto\"></a>一. 原型指针<strong>proto</strong></h3><p>原型指针是<strong>对象才有</strong>的</p>\n<p>每一个对象都有一个原型指针，指向的是它的原型。</p>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__); <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__.__proto__) <span class=\"comment\">// null</span></span><br><span class=\"line\">原型链：</span><br><span class=\"line\">a =&gt; <span class=\"built_in\">Object</span>.prototype =&gt; <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__); <span class=\"comment\">// [] = Array.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__.__proto__) <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__.__proto__.__proto__) <span class=\"comment\">// null</span></span><br><span class=\"line\">原型链：</span><br><span class=\"line\">a =&gt; <span class=\"built_in\">Array</span>.prototype =&gt; <span class=\"built_in\">Object</span>.prototype =&gt; <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__); <span class=\"comment\">// Function.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__.__proto__); <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__.__proto__.__proto__); <span class=\"comment\">// null</span></span><br><span class=\"line\">原型链：</span><br><span class=\"line\">foo =&gt; <span class=\"built_in\">Function</span>.prototype =&gt; <span class=\"built_in\">Object</span>.prototype =&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-原型对象prototype\"><a href=\"#二-原型对象prototype\" class=\"headerlink\" title=\"二. 原型对象prototype\"></a>二. 原型对象prototype</h3><p>原型对象是只有<strong>函数才有</strong>的属性。</p>\n<p>原型对象是javaScript中的<strong>基因链接</strong>。</p>\n<p>javaScript中的函数也是对象，因此一个函数既有<strong>proto</strong>指针，也有prototype属性。</p>\n<p><strong>原型、构造函数、实例之间的关系：</strong></p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">()</span> <span class=\"comment\">&#123;\t\t</span><br><span class=\"line\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">Person</span>.<span class=\"title\">prototype</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">var</span> <span class=\"title\">p</span> = <span class=\"title\">new</span> <span class=\"title\">Person</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">构造函数：Person            属性：prototype =&gt; 指向原型对象</span><br><span class=\"line\">原型对象：Person.prototype  属性：<span class=\"function\"><span class=\"keyword\">constructor</span> =&gt; 指向构造函数</span><br><span class=\"line\">\t\t\t\t\t\t\t\t__<span class=\"title\">proto__</span> <span class=\"params\">(原型指针)</span> =&gt; 指向原型链上一层的原型对象 </span><br><span class=\"line\">实例：<span class=\"title\">p</span>                     属性：__<span class=\"title\">proto__</span><span class=\"params\">(原型指针)</span> =&gt; 指向原型对象</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-原型指针proto\"><a href=\"#一-原型指针proto\" class=\"headerlink\" title=\"一. 原型指针proto\"></a>一. 原型指针<strong>proto</strong></h3><p>原型指针是<strong>对象才有</strong>的</p>\n<p>每一个对象都有一个原型指针，指向的是它的原型。</p>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__); <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__.__proto__) <span class=\"comment\">// null</span></span><br><span class=\"line\">原型链：</span><br><span class=\"line\">a =&gt; <span class=\"built_in\">Object</span>.prototype =&gt; <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__); <span class=\"comment\">// [] = Array.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__.__proto__) <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.__proto__.__proto__.__proto__) <span class=\"comment\">// null</span></span><br><span class=\"line\">原型链：</span><br><span class=\"line\">a =&gt; <span class=\"built_in\">Array</span>.prototype =&gt; <span class=\"built_in\">Object</span>.prototype =&gt; <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__); <span class=\"comment\">// Function.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__.__proto__); <span class=\"comment\">// Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__.__proto__.__proto__); <span class=\"comment\">// null</span></span><br><span class=\"line\">原型链：</span><br><span class=\"line\">foo =&gt; <span class=\"built_in\">Function</span>.prototype =&gt; <span class=\"built_in\">Object</span>.prototype =&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-原型对象prototype\"><a href=\"#二-原型对象prototype\" class=\"headerlink\" title=\"二. 原型对象prototype\"></a>二. 原型对象prototype</h3><p>原型对象是只有<strong>函数才有</strong>的属性。</p>\n<p>原型对象是javaScript中的<strong>基因链接</strong>。</p>\n<p>javaScript中的函数也是对象，因此一个函数既有<strong>proto</strong>指针，也有prototype属性。</p>\n<p><strong>原型、构造函数、实例之间的关系：</strong></p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">()</span> <span class=\"comment\">&#123;\t\t</span><br><span class=\"line\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">Person</span>.<span class=\"title\">prototype</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">var</span> <span class=\"title\">p</span> = <span class=\"title\">new</span> <span class=\"title\">Person</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">构造函数：Person            属性：prototype =&gt; 指向原型对象</span><br><span class=\"line\">原型对象：Person.prototype  属性：<span class=\"function\"><span class=\"keyword\">constructor</span> =&gt; 指向构造函数</span><br><span class=\"line\">\t\t\t\t\t\t\t\t__<span class=\"title\">proto__</span> <span class=\"params\">(原型指针)</span> =&gt; 指向原型链上一层的原型对象 </span><br><span class=\"line\">实例：<span class=\"title\">p</span>                     属性：__<span class=\"title\">proto__</span><span class=\"params\">(原型指针)</span> =&gt; 指向原型对象</span></span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"javaScript 继承问题","date":"2016-03-21T16:00:00.000Z","description":null,"_content":"\n最近在看《javaScript高级程序设计》，就其中的继承写一下自己的理解。\n\n### 一. 什么是继承\n\n继承是指一个对象直接使用另一对象的属性和方法。\n\njs中继承的方法有：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承\n\n#### 1. 原型链继承\n\n#### （1）. 原型、构造函数和实例的关系\n\n```\n\tfunction Person() {\t\t\n\t}\n\n\tPerson.prototype \n\n\tvar p = new Person();\n\n\t构造函数：Person            属性：prototype => 指向原型对象\n\t原型对象：Person.prototype  属性：constructor => 指向构造函数\n\t\t\t\t\t\t\t\t\t__proto__ (原型指针) => 指向原型链上一层的原型对象 \n\t实例：p                     属性：__proto__(原型指针) => 指向原型对象\n```\n\n具体如下图所示：\n\n![原型、构造函数和实例的关系](/uploads/post/demo/prototype.jpg)\n\n一个问题：\n\n```\n\t  function Person(name,age) {\n\t  \tthis.name = name;\n\t  \tthis.age = age;\n\t  }\n\n\t  Person.prototype = {\n\t  \tgetAge: function() {\n\t  \t\talert(this.age);\n\t  \t}\n\t  }\n\n\t  var p = new Person('lucy',12);\n\t  console.log(p.constructor === Person);//false\n\t  console.log(p.constructor);//Object\n```\n\n出现上面那个结果的原因是，实例是没有constructor这个属性的，p.constructor其实是访问的p.prototype.constructor，但是由于我们用对象字面量的方式，重写了Person.prototype，所以会顺着原型链往上找，找到Object.prototype.constructor\n\n\n#### （2）. 原型链\n\n如（1）中所示，如果让（1）中的原型对象成为另外一个类型的实例，以此类推，便构成了原型链。\n\n<font color=\"red\">注意：所有构造函数的默认原型都是Object的实例，因此默认原型会有一个prototype指针指向object.prototype。</font>\n\n#### （3）. 原型链继承\n\n主要思想是：通过设定一种类型的原型是另一种类型的实例来继承另外一种类型。\n\n    例如：B要继承A\n    \n    创建A的实例：new A();\n    让其等于B的原型：B.prototype = new A();//B则继承了A里面所有的属性和方法\n\n**原型搜索机制：**以读取方式访问一个实例属性时，若在该实例中搜索该属性，没有找到再搜索实例的原型，顺着原型链往上找。\n\n代码示例如下：\n\n     function Parent(){\n    \tthis.colors = [\"red\"];\n    }\n\n    function Child() {\n\t\n\t}\n\n    Child.prototype = new Parent();/*child的原型是parent的实例*/\n    /*实现了child继承parent*/\n    var A = new Child();\n    console.log(A.colors); //['red']\n\n原型继承的缺点：\n\n（1）.超类型中有引用类型的属性时，子类型继承超类型，一个子类型中对该引用类型修改，会反应到所有的子类型上。所有子类型共享超类型的引用类型\n\n例如：\n```\n\t\tfunction A() {\n\t    \tthis.colors = ['red'];\n\t    }\n\t    function B() {\n\n\t    }\n\t\t\n\t\t//B继承了A\n\t    B.prototype = new A();\t\n\n\t\t//B的两个实例    \n\t    var example1 = new B();\n\t    var example2 = new B();\n\n\t\t//第一个实例修改了colors属性\n\t    example1.colors.push('blue');\n\n\t    console.log(example2.colors); //['red','blue']\n\t    console.log(example1.colors); //['red','blue']\n```\n\n（2）.创建子类型实例时无法向超类型的构造函数中传递参数\n\n\n#### 2. 构造函数继承\n\n利用call()和apply()方法在新的对象上执行超类型的构造函数。\n\n超类型：指的是被继承的类型。\n\n    a.func.call(b)  /*指的是a对象的方法应用到b对象上*/\n    a.func.apply(b)\n\n代码示例：\n\n    function parent(){\n    \tthis.colors = [\"red\"];\n    }\n    \n    function child(){\n    \tparent.call(this); /*或者 parent.apply(this);*/\n\t\t/*实现了child继承parent*/\n    }\n    \n    var one = new child();\n\n**构造函数继承的优点：**\n\n使子类child在创建对象的同时传递参数到父类parent\n\n**构造函数继承的缺点：**\n\n无法进行函数的复用，a的原型中定义的方法也无法继承。\n\n#### 3. 组合继承(将原型链继承和借用构造函数继承组合起来)\n\n主要思想是：使用原型链实现对a原型属性和方法的继承，通过构造函数实现对a实例属性的继承。\n\n代码示例如下：\n\n    function Parent() {       \n\t    this.sayAge=function() {  \n\t    \tconsole.log(this.age);  \n\t    }  \n    }  \n      \n    Parent.prototype = {\n\t\tsayParent: function() {  \n       \t\talert(\"this is parentmethod!!!\");  \n    \t}  \n\t}\n\n      \n    function Child(firstname) {  \n\t    Parent.call(this);//构造函数继承  \n\t    this.fname=firstname;  \n\t    this.age=40;  \n\t    this.saySomeThing = function() {  \n\t\t    console.log(this.fname);  \n\t\t    this.sayAge();  \n\t    }  \n    }  \n      \n    Child.prototype = new Parent();//原型链继承\n    var child = new Child(\"张\");  \n    child.saySomeThing();  \n    child.sayParent();\n\n缺点：要调用两次超类型的构造函数  \n\n#### 4. 原型式继承\n\n主要思想是：实现对父类的**浅复制**，产生一个副本\n\nObject.create()函数实现的就是原型式继承\n\n代码示例如下：\n\t\n    function object(object) {\n    \tfunction F(){} //一个构造函数F\n    \tF.prototype = object; //将对象赋值给构造函数F的原型，引用类型赋值\n    \treturn new F(); //返回一个F的实例\n    }\n\n    var parent = {\n    \tcolors: [\"red\"]\n    }\n    \n    var child = object(parent); /*实现了child继承parent*/\n\tchild.colors.push(\"blue\");\n\tconsole.log(parent.colors); //[\"red\", \"blue\"]\n\tconsole.log(child.colors); //[\"red\", \"blue\"]\n\t\n这种继承方式是将child的原型设为parent，通过child可以访问parent的属性和方法，而不需要将同名属性和方法在child里面再重新定义一遍。\n\n**Object.create()**\n\n可接收两个参数，第一个参数是需要继承的对象，第二个参数是新生成的对象中新增加的属性和方法。\n\n```\n\n\tvar parent = {\n\t\tname: 'a',\n\t\tsayName: function() {\n\t\t\tconsole.log(this.name)\n\t\t}\n\t}\n\n\tvar child = Object.create(parent,{\n\t\tname: {writable:true, configurable:true, value: 'b'}\n\t});\n\n\tparent.sayName(); // 'a'\n\tchild.sayName(); // 'b'\n```\n\n#### 5. 寄生式继承\n\n主要思想：寄生式继承是基于原型式继承，创建一个仅用于封装继承的函数\n\n代码示例如下：\n\t\n    function object(object) {\n    \tfunction F(){}//一个构造函数F\n    \tF.prototype = object;//将对象赋值给构造函数F的原型，引用类型赋值\n    \treturn new F();//返回一个F的实例\n    }\n\n\tfunction createAnother(original) {\n\t\tvar clone = object(original);\n\t\tclone.sayHi = function() {\n\t\t\talert(\"Hi!\");\n\t\t};\n\t\treturn clone;\n\t}\n\n    var parent = {\n    \tcolors: [\"red\"];\n    }\n    \n    var child = createAnother(parent);/*实现了child继承parent*/\n\tchild.colors.push(\"blue\");\n\tconsole.log(parent.colors);//[\"red\", \"blue\"]\n\tconsole.log(child.colors);//[\"red\", \"blue\"]\n\n#### 6. 寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\n\n**组合式继承的缺点：**会调用两次超类型的构造函数，会在子类型的原型和实例中创建2次超类型构造函数中的属性（实例中的同名属性会覆盖原型中的）\n\nYUI框架的`extend`函数就是使用的`寄生组合式继承`。\n\n    //Sub是子类型的构造函数，Super是超类型的构造函数\n    function extend(Sub,Super) {\n    \n\t    //引入空函数,避免创建父类的新实例（效率比较高）\n\t    var F = function() {};\n\t    F.prototype = Super.prototype;\n\t    \n\t    //使用新函数创建实例而不是父类型创建\n\t    Sub.prototype = new F();\n\t       \n\t    Sub.prototype.constructor = Sub;\n\t    \n\t    //提供Super属性,弱化父子类间耦合\n\t    Sub.super=Super.prototype;\n\n\t    if(Super.prototype.constructor == Object.prototype.constructor) {\n\t    \tSuper.prototype.constructor = Super;\n\t    }\n    }\n\n\t//父类型\n\tfunction Parent(name) {\n\t\tthis.name = name;\n\t\tthis.colors = [\"red\",\"blue\",\"green\"];\n\t}\n\n\tParent.prototype = {\n\t\tsayName: function() {\n\t\t\talert(this.name);\n\t\t}\n\t}\n\n\t//子类型\n\tfunction Child(name,age) {\n\t\t//调用超类型的构造函数\n\t\tParent.call(this,name);\n\t\tthis.age = age;\n\t}\n\t\n\t//使用extend函数来代替组合继承里面的创建父类型的实例\n\textend(Child,Parent);\n\n\n### 二. 如何判断一个属性在实例中还是在原型中\n\ninstance.hasOwnProperty('属性名')\n\n```\nfunction hasPrototypeProperty(object,name){\n\treturn (name in object) && !object.hasOwnProperty(name)\n }\n```","source":"_posts/2016-03-22-javaScript继承问题.md","raw":"---\nlayout: post\ntitle: javaScript 继承问题\ndate: 2016-03-22\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n最近在看《javaScript高级程序设计》，就其中的继承写一下自己的理解。\n\n### 一. 什么是继承\n\n继承是指一个对象直接使用另一对象的属性和方法。\n\njs中继承的方法有：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承\n\n#### 1. 原型链继承\n\n#### （1）. 原型、构造函数和实例的关系\n\n```\n\tfunction Person() {\t\t\n\t}\n\n\tPerson.prototype \n\n\tvar p = new Person();\n\n\t构造函数：Person            属性：prototype => 指向原型对象\n\t原型对象：Person.prototype  属性：constructor => 指向构造函数\n\t\t\t\t\t\t\t\t\t__proto__ (原型指针) => 指向原型链上一层的原型对象 \n\t实例：p                     属性：__proto__(原型指针) => 指向原型对象\n```\n\n具体如下图所示：\n\n![原型、构造函数和实例的关系](/uploads/post/demo/prototype.jpg)\n\n一个问题：\n\n```\n\t  function Person(name,age) {\n\t  \tthis.name = name;\n\t  \tthis.age = age;\n\t  }\n\n\t  Person.prototype = {\n\t  \tgetAge: function() {\n\t  \t\talert(this.age);\n\t  \t}\n\t  }\n\n\t  var p = new Person('lucy',12);\n\t  console.log(p.constructor === Person);//false\n\t  console.log(p.constructor);//Object\n```\n\n出现上面那个结果的原因是，实例是没有constructor这个属性的，p.constructor其实是访问的p.prototype.constructor，但是由于我们用对象字面量的方式，重写了Person.prototype，所以会顺着原型链往上找，找到Object.prototype.constructor\n\n\n#### （2）. 原型链\n\n如（1）中所示，如果让（1）中的原型对象成为另外一个类型的实例，以此类推，便构成了原型链。\n\n<font color=\"red\">注意：所有构造函数的默认原型都是Object的实例，因此默认原型会有一个prototype指针指向object.prototype。</font>\n\n#### （3）. 原型链继承\n\n主要思想是：通过设定一种类型的原型是另一种类型的实例来继承另外一种类型。\n\n    例如：B要继承A\n    \n    创建A的实例：new A();\n    让其等于B的原型：B.prototype = new A();//B则继承了A里面所有的属性和方法\n\n**原型搜索机制：**以读取方式访问一个实例属性时，若在该实例中搜索该属性，没有找到再搜索实例的原型，顺着原型链往上找。\n\n代码示例如下：\n\n     function Parent(){\n    \tthis.colors = [\"red\"];\n    }\n\n    function Child() {\n\t\n\t}\n\n    Child.prototype = new Parent();/*child的原型是parent的实例*/\n    /*实现了child继承parent*/\n    var A = new Child();\n    console.log(A.colors); //['red']\n\n原型继承的缺点：\n\n（1）.超类型中有引用类型的属性时，子类型继承超类型，一个子类型中对该引用类型修改，会反应到所有的子类型上。所有子类型共享超类型的引用类型\n\n例如：\n```\n\t\tfunction A() {\n\t    \tthis.colors = ['red'];\n\t    }\n\t    function B() {\n\n\t    }\n\t\t\n\t\t//B继承了A\n\t    B.prototype = new A();\t\n\n\t\t//B的两个实例    \n\t    var example1 = new B();\n\t    var example2 = new B();\n\n\t\t//第一个实例修改了colors属性\n\t    example1.colors.push('blue');\n\n\t    console.log(example2.colors); //['red','blue']\n\t    console.log(example1.colors); //['red','blue']\n```\n\n（2）.创建子类型实例时无法向超类型的构造函数中传递参数\n\n\n#### 2. 构造函数继承\n\n利用call()和apply()方法在新的对象上执行超类型的构造函数。\n\n超类型：指的是被继承的类型。\n\n    a.func.call(b)  /*指的是a对象的方法应用到b对象上*/\n    a.func.apply(b)\n\n代码示例：\n\n    function parent(){\n    \tthis.colors = [\"red\"];\n    }\n    \n    function child(){\n    \tparent.call(this); /*或者 parent.apply(this);*/\n\t\t/*实现了child继承parent*/\n    }\n    \n    var one = new child();\n\n**构造函数继承的优点：**\n\n使子类child在创建对象的同时传递参数到父类parent\n\n**构造函数继承的缺点：**\n\n无法进行函数的复用，a的原型中定义的方法也无法继承。\n\n#### 3. 组合继承(将原型链继承和借用构造函数继承组合起来)\n\n主要思想是：使用原型链实现对a原型属性和方法的继承，通过构造函数实现对a实例属性的继承。\n\n代码示例如下：\n\n    function Parent() {       \n\t    this.sayAge=function() {  \n\t    \tconsole.log(this.age);  \n\t    }  \n    }  \n      \n    Parent.prototype = {\n\t\tsayParent: function() {  \n       \t\talert(\"this is parentmethod!!!\");  \n    \t}  \n\t}\n\n      \n    function Child(firstname) {  \n\t    Parent.call(this);//构造函数继承  \n\t    this.fname=firstname;  \n\t    this.age=40;  \n\t    this.saySomeThing = function() {  \n\t\t    console.log(this.fname);  \n\t\t    this.sayAge();  \n\t    }  \n    }  \n      \n    Child.prototype = new Parent();//原型链继承\n    var child = new Child(\"张\");  \n    child.saySomeThing();  \n    child.sayParent();\n\n缺点：要调用两次超类型的构造函数  \n\n#### 4. 原型式继承\n\n主要思想是：实现对父类的**浅复制**，产生一个副本\n\nObject.create()函数实现的就是原型式继承\n\n代码示例如下：\n\t\n    function object(object) {\n    \tfunction F(){} //一个构造函数F\n    \tF.prototype = object; //将对象赋值给构造函数F的原型，引用类型赋值\n    \treturn new F(); //返回一个F的实例\n    }\n\n    var parent = {\n    \tcolors: [\"red\"]\n    }\n    \n    var child = object(parent); /*实现了child继承parent*/\n\tchild.colors.push(\"blue\");\n\tconsole.log(parent.colors); //[\"red\", \"blue\"]\n\tconsole.log(child.colors); //[\"red\", \"blue\"]\n\t\n这种继承方式是将child的原型设为parent，通过child可以访问parent的属性和方法，而不需要将同名属性和方法在child里面再重新定义一遍。\n\n**Object.create()**\n\n可接收两个参数，第一个参数是需要继承的对象，第二个参数是新生成的对象中新增加的属性和方法。\n\n```\n\n\tvar parent = {\n\t\tname: 'a',\n\t\tsayName: function() {\n\t\t\tconsole.log(this.name)\n\t\t}\n\t}\n\n\tvar child = Object.create(parent,{\n\t\tname: {writable:true, configurable:true, value: 'b'}\n\t});\n\n\tparent.sayName(); // 'a'\n\tchild.sayName(); // 'b'\n```\n\n#### 5. 寄生式继承\n\n主要思想：寄生式继承是基于原型式继承，创建一个仅用于封装继承的函数\n\n代码示例如下：\n\t\n    function object(object) {\n    \tfunction F(){}//一个构造函数F\n    \tF.prototype = object;//将对象赋值给构造函数F的原型，引用类型赋值\n    \treturn new F();//返回一个F的实例\n    }\n\n\tfunction createAnother(original) {\n\t\tvar clone = object(original);\n\t\tclone.sayHi = function() {\n\t\t\talert(\"Hi!\");\n\t\t};\n\t\treturn clone;\n\t}\n\n    var parent = {\n    \tcolors: [\"red\"];\n    }\n    \n    var child = createAnother(parent);/*实现了child继承parent*/\n\tchild.colors.push(\"blue\");\n\tconsole.log(parent.colors);//[\"red\", \"blue\"]\n\tconsole.log(child.colors);//[\"red\", \"blue\"]\n\n#### 6. 寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\n\n**组合式继承的缺点：**会调用两次超类型的构造函数，会在子类型的原型和实例中创建2次超类型构造函数中的属性（实例中的同名属性会覆盖原型中的）\n\nYUI框架的`extend`函数就是使用的`寄生组合式继承`。\n\n    //Sub是子类型的构造函数，Super是超类型的构造函数\n    function extend(Sub,Super) {\n    \n\t    //引入空函数,避免创建父类的新实例（效率比较高）\n\t    var F = function() {};\n\t    F.prototype = Super.prototype;\n\t    \n\t    //使用新函数创建实例而不是父类型创建\n\t    Sub.prototype = new F();\n\t       \n\t    Sub.prototype.constructor = Sub;\n\t    \n\t    //提供Super属性,弱化父子类间耦合\n\t    Sub.super=Super.prototype;\n\n\t    if(Super.prototype.constructor == Object.prototype.constructor) {\n\t    \tSuper.prototype.constructor = Super;\n\t    }\n    }\n\n\t//父类型\n\tfunction Parent(name) {\n\t\tthis.name = name;\n\t\tthis.colors = [\"red\",\"blue\",\"green\"];\n\t}\n\n\tParent.prototype = {\n\t\tsayName: function() {\n\t\t\talert(this.name);\n\t\t}\n\t}\n\n\t//子类型\n\tfunction Child(name,age) {\n\t\t//调用超类型的构造函数\n\t\tParent.call(this,name);\n\t\tthis.age = age;\n\t}\n\t\n\t//使用extend函数来代替组合继承里面的创建父类型的实例\n\textend(Child,Parent);\n\n\n### 二. 如何判断一个属性在实例中还是在原型中\n\ninstance.hasOwnProperty('属性名')\n\n```\nfunction hasPrototypeProperty(object,name){\n\treturn (name in object) && !object.hasOwnProperty(name)\n }\n```","slug":"2016-03-22-javaScript继承问题","published":1,"updated":"2016-10-15T12:15:58.000Z","comments":1,"photos":[],"link":"","_id":"cj035occq0014d5u8vo58k4sm","content":"<p>最近在看《javaScript高级程序设计》，就其中的继承写一下自己的理解。</p>\n<h3 id=\"一-什么是继承\"><a href=\"#一-什么是继承\" class=\"headerlink\" title=\"一. 什么是继承\"></a>一. 什么是继承</h3><p>继承是指一个对象直接使用另一对象的属性和方法。</p>\n<p>js中继承的方法有：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承</p>\n<h4 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h4><h4 id=\"（1）-原型、构造函数和实例的关系\"><a href=\"#（1）-原型、构造函数和实例的关系\" class=\"headerlink\" title=\"（1）. 原型、构造函数和实例的关系\"></a>（1）. 原型、构造函数和实例的关系</h4><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">()</span> <span class=\"comment\">&#123;\t\t</span><br><span class=\"line\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">Person</span>.<span class=\"title\">prototype</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">var</span> <span class=\"title\">p</span> = <span class=\"title\">new</span> <span class=\"title\">Person</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">构造函数：Person            属性：prototype =&gt; 指向原型对象</span><br><span class=\"line\">原型对象：Person.prototype  属性：<span class=\"function\"><span class=\"keyword\">constructor</span> =&gt; 指向构造函数</span><br><span class=\"line\">\t\t\t\t\t\t\t\t__<span class=\"title\">proto__</span> <span class=\"params\">(原型指针)</span> =&gt; 指向原型链上一层的原型对象 </span><br><span class=\"line\">实例：<span class=\"title\">p</span>                     属性：__<span class=\"title\">proto__</span><span class=\"params\">(原型指针)</span> =&gt; 指向原型对象</span></span><br></pre></td></tr></table></figure>\n<p>具体如下图所示：</p>\n<p><img src=\"/uploads/post/demo/prototype.jpg\" alt=\"原型、构造函数和实例的关系\"></p>\n<p>一个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\tgetAge: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person(<span class=\"string\">'lucy'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.constructor === Person);<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.constructor);<span class=\"comment\">//Object</span></span><br></pre></td></tr></table></figure>\n<p>出现上面那个结果的原因是，实例是没有constructor这个属性的，p.constructor其实是访问的p.prototype.constructor，但是由于我们用对象字面量的方式，重写了Person.prototype，所以会顺着原型链往上找，找到Object.prototype.constructor</p>\n<h4 id=\"（2）-原型链\"><a href=\"#（2）-原型链\" class=\"headerlink\" title=\"（2）. 原型链\"></a>（2）. 原型链</h4><p>如（1）中所示，如果让（1）中的原型对象成为另外一个类型的实例，以此类推，便构成了原型链。</p>\n<font color=\"red\">注意：所有构造函数的默认原型都是Object的实例，因此默认原型会有一个prototype指针指向object.prototype。</font>\n\n<h4 id=\"（3）-原型链继承\"><a href=\"#（3）-原型链继承\" class=\"headerlink\" title=\"（3）. 原型链继承\"></a>（3）. 原型链继承</h4><p>主要思想是：通过设定一种类型的原型是另一种类型的实例来继承另外一种类型。</p>\n<pre><code>例如：B要继承A\n\n创建A的实例：new A();\n让其等于B的原型：B.prototype = new A();//B则继承了A里面所有的属性和方法\n</code></pre><p><strong>原型搜索机制：</strong>以读取方式访问一个实例属性时，若在该实例中搜索该属性，没有找到再搜索实例的原型，顺着原型链往上找。</p>\n<p>代码示例如下：</p>\n<pre><code> function Parent(){\n    this.colors = [&quot;red&quot;];\n}\n\nfunction Child() {\n\n}\n\nChild.prototype = new Parent();/*child的原型是parent的实例*/\n/*实现了child继承parent*/\nvar A = new Child();\nconsole.log(A.colors); //[&apos;red&apos;]\n</code></pre><p>原型继承的缺点：</p>\n<p>（1）.超类型中有引用类型的属性时，子类型继承超类型，一个子类型中对该引用类型修改，会反应到所有的子类型上。所有子类型共享超类型的引用类型</p>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//B继承了A</span></span><br><span class=\"line\">   B.prototype = <span class=\"keyword\">new</span> A();\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//B的两个实例    </span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">   <span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个实例修改了colors属性</span></span><br><span class=\"line\">   example1.colors.push(<span class=\"string\">'blue'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(example2.colors); <span class=\"comment\">//['red','blue']</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(example1.colors); <span class=\"comment\">//['red','blue']</span></span><br></pre></td></tr></table></figure></p>\n<p>（2）.创建子类型实例时无法向超类型的构造函数中传递参数</p>\n<h4 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2. 构造函数继承\"></a>2. 构造函数继承</h4><p>利用call()和apply()方法在新的对象上执行超类型的构造函数。</p>\n<p>超类型：指的是被继承的类型。</p>\n<pre><code>a.func.call(b)  /*指的是a对象的方法应用到b对象上*/\na.func.apply(b)\n</code></pre><p>代码示例：</p>\n<pre><code>function parent(){\n    this.colors = [&quot;red&quot;];\n}\n\nfunction child(){\n    parent.call(this); /*或者 parent.apply(this);*/\n    /*实现了child继承parent*/\n}\n\nvar one = new child();\n</code></pre><p><strong>构造函数继承的优点：</strong></p>\n<p>使子类child在创建对象的同时传递参数到父类parent</p>\n<p><strong>构造函数继承的缺点：</strong></p>\n<p>无法进行函数的复用，a的原型中定义的方法也无法继承。</p>\n<h4 id=\"3-组合继承-将原型链继承和借用构造函数继承组合起来\"><a href=\"#3-组合继承-将原型链继承和借用构造函数继承组合起来\" class=\"headerlink\" title=\"3. 组合继承(将原型链继承和借用构造函数继承组合起来)\"></a>3. 组合继承(将原型链继承和借用构造函数继承组合起来)</h4><p>主要思想是：使用原型链实现对a原型属性和方法的继承，通过构造函数实现对a实例属性的继承。</p>\n<p>代码示例如下：</p>\n<pre><code>function Parent() {       \n    this.sayAge=function() {  \n        console.log(this.age);  \n    }  \n}  \n\nParent.prototype = {\n    sayParent: function() {  \n           alert(&quot;this is parentmethod!!!&quot;);  \n    }  \n}\n\n\nfunction Child(firstname) {  \n    Parent.call(this);//构造函数继承  \n    this.fname=firstname;  \n    this.age=40;  \n    this.saySomeThing = function() {  \n        console.log(this.fname);  \n        this.sayAge();  \n    }  \n}  \n\nChild.prototype = new Parent();//原型链继承\nvar child = new Child(&quot;张&quot;);  \nchild.saySomeThing();  \nchild.sayParent();\n</code></pre><p>缺点：要调用两次超类型的构造函数  </p>\n<h4 id=\"4-原型式继承\"><a href=\"#4-原型式继承\" class=\"headerlink\" title=\"4. 原型式继承\"></a>4. 原型式继承</h4><p>主要思想是：实现对父类的<strong>浅复制</strong>，产生一个副本</p>\n<p>Object.create()函数实现的就是原型式继承</p>\n<p>代码示例如下：</p>\n<pre><code>function object(object) {\n    function F(){} //一个构造函数F\n    F.prototype = object; //将对象赋值给构造函数F的原型，引用类型赋值\n    return new F(); //返回一个F的实例\n}\n\nvar parent = {\n    colors: [&quot;red&quot;]\n}\n\nvar child = object(parent); /*实现了child继承parent*/\nchild.colors.push(&quot;blue&quot;);\nconsole.log(parent.colors); //[&quot;red&quot;, &quot;blue&quot;]\nconsole.log(child.colors); //[&quot;red&quot;, &quot;blue&quot;]\n</code></pre><p>这种继承方式是将child的原型设为parent，通过child可以访问parent的属性和方法，而不需要将同名属性和方法在child里面再重新定义一遍。</p>\n<p><strong>Object.create()</strong></p>\n<p>可接收两个参数，第一个参数是需要继承的对象，第二个参数是新生成的对象中新增加的属性和方法。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">parent</span> = &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">name</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">\t<span class=\"attribute\">sayName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> child = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">parent</span>,&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">name</span>: &#123;<span class=\"attribute\">writable</span>:<span class=\"attribute\">true, configurable</span>:<span class=\"attribute\">true, value</span>: <span class=\"string\">'b'</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parent</span>.sayName(); <span class=\"comment\">// 'a'</span></span><br><span class=\"line\">child.sayName(); <span class=\"comment\">// 'b'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-寄生式继承\"><a href=\"#5-寄生式继承\" class=\"headerlink\" title=\"5. 寄生式继承\"></a>5. 寄生式继承</h4><p>主要思想：寄生式继承是基于原型式继承，创建一个仅用于封装继承的函数</p>\n<p>代码示例如下：</p>\n<pre><code>function object(object) {\n    function F(){}//一个构造函数F\n    F.prototype = object;//将对象赋值给构造函数F的原型，引用类型赋值\n    return new F();//返回一个F的实例\n}\n\nfunction createAnother(original) {\n    var clone = object(original);\n    clone.sayHi = function() {\n        alert(&quot;Hi!&quot;);\n    };\n    return clone;\n}\n\nvar parent = {\n    colors: [&quot;red&quot;];\n}\n\nvar child = createAnother(parent);/*实现了child继承parent*/\nchild.colors.push(&quot;blue&quot;);\nconsole.log(parent.colors);//[&quot;red&quot;, &quot;blue&quot;]\nconsole.log(child.colors);//[&quot;red&quot;, &quot;blue&quot;]\n</code></pre><h4 id=\"6-寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\"><a href=\"#6-寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\" class=\"headerlink\" title=\"6. 寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\"></a>6. 寄生组合式继承（将寄生式继承和组合继承的方式结合起来）</h4><p><strong>组合式继承的缺点：</strong>会调用两次超类型的构造函数，会在子类型的原型和实例中创建2次超类型构造函数中的属性（实例中的同名属性会覆盖原型中的）</p>\n<p>YUI框架的<code>extend</code>函数就是使用的<code>寄生组合式继承</code>。</p>\n<pre><code>//Sub是子类型的构造函数，Super是超类型的构造函数\nfunction extend(Sub,Super) {\n\n    //引入空函数,避免创建父类的新实例（效率比较高）\n    var F = function() {};\n    F.prototype = Super.prototype;\n\n    //使用新函数创建实例而不是父类型创建\n    Sub.prototype = new F();\n\n    Sub.prototype.constructor = Sub;\n\n    //提供Super属性,弱化父子类间耦合\n    Sub.super=Super.prototype;\n\n    if(Super.prototype.constructor == Object.prototype.constructor) {\n        Super.prototype.constructor = Super;\n    }\n}\n\n//父类型\nfunction Parent(name) {\n    this.name = name;\n    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];\n}\n\nParent.prototype = {\n    sayName: function() {\n        alert(this.name);\n    }\n}\n\n//子类型\nfunction Child(name,age) {\n    //调用超类型的构造函数\n    Parent.call(this,name);\n    this.age = age;\n}\n\n//使用extend函数来代替组合继承里面的创建父类型的实例\nextend(Child,Parent);\n</code></pre><h3 id=\"二-如何判断一个属性在实例中还是在原型中\"><a href=\"#二-如何判断一个属性在实例中还是在原型中\" class=\"headerlink\" title=\"二. 如何判断一个属性在实例中还是在原型中\"></a>二. 如何判断一个属性在实例中还是在原型中</h3><p>instance.hasOwnProperty(‘属性名’)</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">hasPrototypeProperty</span>(object,name)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">(name</span> <span class=\"keyword\">in</span> object) &amp;&amp; !object.hasOwnProperty(name)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>最近在看《javaScript高级程序设计》，就其中的继承写一下自己的理解。</p>\n<h3 id=\"一-什么是继承\"><a href=\"#一-什么是继承\" class=\"headerlink\" title=\"一. 什么是继承\"></a>一. 什么是继承</h3><p>继承是指一个对象直接使用另一对象的属性和方法。</p>\n<p>js中继承的方法有：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承</p>\n<h4 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h4><h4 id=\"（1）-原型、构造函数和实例的关系\"><a href=\"#（1）-原型、构造函数和实例的关系\" class=\"headerlink\" title=\"（1）. 原型、构造函数和实例的关系\"></a>（1）. 原型、构造函数和实例的关系</h4><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">()</span> <span class=\"comment\">&#123;\t\t</span><br><span class=\"line\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">Person</span>.<span class=\"title\">prototype</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">var</span> <span class=\"title\">p</span> = <span class=\"title\">new</span> <span class=\"title\">Person</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">构造函数：Person            属性：prototype =&gt; 指向原型对象</span><br><span class=\"line\">原型对象：Person.prototype  属性：<span class=\"function\"><span class=\"keyword\">constructor</span> =&gt; 指向构造函数</span><br><span class=\"line\">\t\t\t\t\t\t\t\t__<span class=\"title\">proto__</span> <span class=\"params\">(原型指针)</span> =&gt; 指向原型链上一层的原型对象 </span><br><span class=\"line\">实例：<span class=\"title\">p</span>                     属性：__<span class=\"title\">proto__</span><span class=\"params\">(原型指针)</span> =&gt; 指向原型对象</span></span><br></pre></td></tr></table></figure>\n<p>具体如下图所示：</p>\n<p><img src=\"/uploads/post/demo/prototype.jpg\" alt=\"原型、构造函数和实例的关系\"></p>\n<p>一个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\tgetAge: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person(<span class=\"string\">'lucy'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.constructor === Person);<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.constructor);<span class=\"comment\">//Object</span></span><br></pre></td></tr></table></figure>\n<p>出现上面那个结果的原因是，实例是没有constructor这个属性的，p.constructor其实是访问的p.prototype.constructor，但是由于我们用对象字面量的方式，重写了Person.prototype，所以会顺着原型链往上找，找到Object.prototype.constructor</p>\n<h4 id=\"（2）-原型链\"><a href=\"#（2）-原型链\" class=\"headerlink\" title=\"（2）. 原型链\"></a>（2）. 原型链</h4><p>如（1）中所示，如果让（1）中的原型对象成为另外一个类型的实例，以此类推，便构成了原型链。</p>\n<font color=\"red\">注意：所有构造函数的默认原型都是Object的实例，因此默认原型会有一个prototype指针指向object.prototype。</font>\n\n<h4 id=\"（3）-原型链继承\"><a href=\"#（3）-原型链继承\" class=\"headerlink\" title=\"（3）. 原型链继承\"></a>（3）. 原型链继承</h4><p>主要思想是：通过设定一种类型的原型是另一种类型的实例来继承另外一种类型。</p>\n<pre><code>例如：B要继承A\n\n创建A的实例：new A();\n让其等于B的原型：B.prototype = new A();//B则继承了A里面所有的属性和方法\n</code></pre><p><strong>原型搜索机制：</strong>以读取方式访问一个实例属性时，若在该实例中搜索该属性，没有找到再搜索实例的原型，顺着原型链往上找。</p>\n<p>代码示例如下：</p>\n<pre><code> function Parent(){\n    this.colors = [&quot;red&quot;];\n}\n\nfunction Child() {\n\n}\n\nChild.prototype = new Parent();/*child的原型是parent的实例*/\n/*实现了child继承parent*/\nvar A = new Child();\nconsole.log(A.colors); //[&apos;red&apos;]\n</code></pre><p>原型继承的缺点：</p>\n<p>（1）.超类型中有引用类型的属性时，子类型继承超类型，一个子类型中对该引用类型修改，会反应到所有的子类型上。所有子类型共享超类型的引用类型</p>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//B继承了A</span></span><br><span class=\"line\">   B.prototype = <span class=\"keyword\">new</span> A();\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//B的两个实例    </span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">   <span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个实例修改了colors属性</span></span><br><span class=\"line\">   example1.colors.push(<span class=\"string\">'blue'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(example2.colors); <span class=\"comment\">//['red','blue']</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(example1.colors); <span class=\"comment\">//['red','blue']</span></span><br></pre></td></tr></table></figure></p>\n<p>（2）.创建子类型实例时无法向超类型的构造函数中传递参数</p>\n<h4 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2. 构造函数继承\"></a>2. 构造函数继承</h4><p>利用call()和apply()方法在新的对象上执行超类型的构造函数。</p>\n<p>超类型：指的是被继承的类型。</p>\n<pre><code>a.func.call(b)  /*指的是a对象的方法应用到b对象上*/\na.func.apply(b)\n</code></pre><p>代码示例：</p>\n<pre><code>function parent(){\n    this.colors = [&quot;red&quot;];\n}\n\nfunction child(){\n    parent.call(this); /*或者 parent.apply(this);*/\n    /*实现了child继承parent*/\n}\n\nvar one = new child();\n</code></pre><p><strong>构造函数继承的优点：</strong></p>\n<p>使子类child在创建对象的同时传递参数到父类parent</p>\n<p><strong>构造函数继承的缺点：</strong></p>\n<p>无法进行函数的复用，a的原型中定义的方法也无法继承。</p>\n<h4 id=\"3-组合继承-将原型链继承和借用构造函数继承组合起来\"><a href=\"#3-组合继承-将原型链继承和借用构造函数继承组合起来\" class=\"headerlink\" title=\"3. 组合继承(将原型链继承和借用构造函数继承组合起来)\"></a>3. 组合继承(将原型链继承和借用构造函数继承组合起来)</h4><p>主要思想是：使用原型链实现对a原型属性和方法的继承，通过构造函数实现对a实例属性的继承。</p>\n<p>代码示例如下：</p>\n<pre><code>function Parent() {       \n    this.sayAge=function() {  \n        console.log(this.age);  \n    }  \n}  \n\nParent.prototype = {\n    sayParent: function() {  \n           alert(&quot;this is parentmethod!!!&quot;);  \n    }  \n}\n\n\nfunction Child(firstname) {  \n    Parent.call(this);//构造函数继承  \n    this.fname=firstname;  \n    this.age=40;  \n    this.saySomeThing = function() {  \n        console.log(this.fname);  \n        this.sayAge();  \n    }  \n}  \n\nChild.prototype = new Parent();//原型链继承\nvar child = new Child(&quot;张&quot;);  \nchild.saySomeThing();  \nchild.sayParent();\n</code></pre><p>缺点：要调用两次超类型的构造函数  </p>\n<h4 id=\"4-原型式继承\"><a href=\"#4-原型式继承\" class=\"headerlink\" title=\"4. 原型式继承\"></a>4. 原型式继承</h4><p>主要思想是：实现对父类的<strong>浅复制</strong>，产生一个副本</p>\n<p>Object.create()函数实现的就是原型式继承</p>\n<p>代码示例如下：</p>\n<pre><code>function object(object) {\n    function F(){} //一个构造函数F\n    F.prototype = object; //将对象赋值给构造函数F的原型，引用类型赋值\n    return new F(); //返回一个F的实例\n}\n\nvar parent = {\n    colors: [&quot;red&quot;]\n}\n\nvar child = object(parent); /*实现了child继承parent*/\nchild.colors.push(&quot;blue&quot;);\nconsole.log(parent.colors); //[&quot;red&quot;, &quot;blue&quot;]\nconsole.log(child.colors); //[&quot;red&quot;, &quot;blue&quot;]\n</code></pre><p>这种继承方式是将child的原型设为parent，通过child可以访问parent的属性和方法，而不需要将同名属性和方法在child里面再重新定义一遍。</p>\n<p><strong>Object.create()</strong></p>\n<p>可接收两个参数，第一个参数是需要继承的对象，第二个参数是新生成的对象中新增加的属性和方法。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">parent</span> = &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">name</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">\t<span class=\"attribute\">sayName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> child = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">parent</span>,&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">name</span>: &#123;<span class=\"attribute\">writable</span>:<span class=\"attribute\">true, configurable</span>:<span class=\"attribute\">true, value</span>: <span class=\"string\">'b'</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parent</span>.sayName(); <span class=\"comment\">// 'a'</span></span><br><span class=\"line\">child.sayName(); <span class=\"comment\">// 'b'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-寄生式继承\"><a href=\"#5-寄生式继承\" class=\"headerlink\" title=\"5. 寄生式继承\"></a>5. 寄生式继承</h4><p>主要思想：寄生式继承是基于原型式继承，创建一个仅用于封装继承的函数</p>\n<p>代码示例如下：</p>\n<pre><code>function object(object) {\n    function F(){}//一个构造函数F\n    F.prototype = object;//将对象赋值给构造函数F的原型，引用类型赋值\n    return new F();//返回一个F的实例\n}\n\nfunction createAnother(original) {\n    var clone = object(original);\n    clone.sayHi = function() {\n        alert(&quot;Hi!&quot;);\n    };\n    return clone;\n}\n\nvar parent = {\n    colors: [&quot;red&quot;];\n}\n\nvar child = createAnother(parent);/*实现了child继承parent*/\nchild.colors.push(&quot;blue&quot;);\nconsole.log(parent.colors);//[&quot;red&quot;, &quot;blue&quot;]\nconsole.log(child.colors);//[&quot;red&quot;, &quot;blue&quot;]\n</code></pre><h4 id=\"6-寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\"><a href=\"#6-寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\" class=\"headerlink\" title=\"6. 寄生组合式继承（将寄生式继承和组合继承的方式结合起来）\"></a>6. 寄生组合式继承（将寄生式继承和组合继承的方式结合起来）</h4><p><strong>组合式继承的缺点：</strong>会调用两次超类型的构造函数，会在子类型的原型和实例中创建2次超类型构造函数中的属性（实例中的同名属性会覆盖原型中的）</p>\n<p>YUI框架的<code>extend</code>函数就是使用的<code>寄生组合式继承</code>。</p>\n<pre><code>//Sub是子类型的构造函数，Super是超类型的构造函数\nfunction extend(Sub,Super) {\n\n    //引入空函数,避免创建父类的新实例（效率比较高）\n    var F = function() {};\n    F.prototype = Super.prototype;\n\n    //使用新函数创建实例而不是父类型创建\n    Sub.prototype = new F();\n\n    Sub.prototype.constructor = Sub;\n\n    //提供Super属性,弱化父子类间耦合\n    Sub.super=Super.prototype;\n\n    if(Super.prototype.constructor == Object.prototype.constructor) {\n        Super.prototype.constructor = Super;\n    }\n}\n\n//父类型\nfunction Parent(name) {\n    this.name = name;\n    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];\n}\n\nParent.prototype = {\n    sayName: function() {\n        alert(this.name);\n    }\n}\n\n//子类型\nfunction Child(name,age) {\n    //调用超类型的构造函数\n    Parent.call(this,name);\n    this.age = age;\n}\n\n//使用extend函数来代替组合继承里面的创建父类型的实例\nextend(Child,Parent);\n</code></pre><h3 id=\"二-如何判断一个属性在实例中还是在原型中\"><a href=\"#二-如何判断一个属性在实例中还是在原型中\" class=\"headerlink\" title=\"二. 如何判断一个属性在实例中还是在原型中\"></a>二. 如何判断一个属性在实例中还是在原型中</h3><p>instance.hasOwnProperty(‘属性名’)</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">hasPrototypeProperty</span>(object,name)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">(name</span> <span class=\"keyword\">in</span> object) &amp;&amp; !object.hasOwnProperty(name)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"原生js里的DOM操作","date":"2016-03-24T16:00:00.000Z","description":null,"_content":"\n### 一. 获取节点的方法\n\n####  1. 顶层API\n\n- documment.getElementById() 返回一个元素\n- document.getElementByName()  返回一个dom数组，具有相同name值的dom\n- document.getElementByTagName() 返回一个dom数组，具有相同的标签名\n\n#### 2. 通过父节点获取\n\n- parent.firstChild\n- parent.lastChild\n- parent.childNodes\n- parent.children\n- parent.getElementsByTagName\n\n#### 3. 通过子节点获取\n\n- childNode.parentNode\n\n#### 4. 通过临近节点获取\n\n- neighbour.previousSibling\n- neighbour.nextSibling\n\n### 二. 插入节点的方法\n\n- appendChild()\n- insertBefore()\n\n### 三. 删除节点的方法\n\n- replaceChild(替换节点, 被替换的节点)\n- removeChild(被移除的节点)\n\n### 四. 复制节点\n\n\tcloneNode(bool)\n    bool为true时，深复制，复制节点以及节点的所有子节点\n    bool为false时，浅复制，只复制节点本身\n\n","source":"_posts/2016-03-25-js里获取dom节点的方法.md","raw":"---\nlayout: post\ntitle: 原生js里的DOM操作\ndate: 2016-03-25\ncategories: javaScript\ntags: [javaScript,DOM]\ndescription: \n---\n\n### 一. 获取节点的方法\n\n####  1. 顶层API\n\n- documment.getElementById() 返回一个元素\n- document.getElementByName()  返回一个dom数组，具有相同name值的dom\n- document.getElementByTagName() 返回一个dom数组，具有相同的标签名\n\n#### 2. 通过父节点获取\n\n- parent.firstChild\n- parent.lastChild\n- parent.childNodes\n- parent.children\n- parent.getElementsByTagName\n\n#### 3. 通过子节点获取\n\n- childNode.parentNode\n\n#### 4. 通过临近节点获取\n\n- neighbour.previousSibling\n- neighbour.nextSibling\n\n### 二. 插入节点的方法\n\n- appendChild()\n- insertBefore()\n\n### 三. 删除节点的方法\n\n- replaceChild(替换节点, 被替换的节点)\n- removeChild(被移除的节点)\n\n### 四. 复制节点\n\n\tcloneNode(bool)\n    bool为true时，深复制，复制节点以及节点的所有子节点\n    bool为false时，浅复制，只复制节点本身\n\n","slug":"2016-03-25-js里获取dom节点的方法","published":1,"updated":"2016-08-18T06:34:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035occv0017d5u8o42lxpb7","content":"<h3 id=\"一-获取节点的方法\"><a href=\"#一-获取节点的方法\" class=\"headerlink\" title=\"一. 获取节点的方法\"></a>一. 获取节点的方法</h3><h4 id=\"1-顶层API\"><a href=\"#1-顶层API\" class=\"headerlink\" title=\"1. 顶层API\"></a>1. 顶层API</h4><ul>\n<li>documment.getElementById() 返回一个元素</li>\n<li>document.getElementByName()  返回一个dom数组，具有相同name值的dom</li>\n<li>document.getElementByTagName() 返回一个dom数组，具有相同的标签名</li>\n</ul>\n<h4 id=\"2-通过父节点获取\"><a href=\"#2-通过父节点获取\" class=\"headerlink\" title=\"2. 通过父节点获取\"></a>2. 通过父节点获取</h4><ul>\n<li>parent.firstChild</li>\n<li>parent.lastChild</li>\n<li>parent.childNodes</li>\n<li>parent.children</li>\n<li>parent.getElementsByTagName</li>\n</ul>\n<h4 id=\"3-通过子节点获取\"><a href=\"#3-通过子节点获取\" class=\"headerlink\" title=\"3. 通过子节点获取\"></a>3. 通过子节点获取</h4><ul>\n<li>childNode.parentNode</li>\n</ul>\n<h4 id=\"4-通过临近节点获取\"><a href=\"#4-通过临近节点获取\" class=\"headerlink\" title=\"4. 通过临近节点获取\"></a>4. 通过临近节点获取</h4><ul>\n<li>neighbour.previousSibling</li>\n<li>neighbour.nextSibling</li>\n</ul>\n<h3 id=\"二-插入节点的方法\"><a href=\"#二-插入节点的方法\" class=\"headerlink\" title=\"二. 插入节点的方法\"></a>二. 插入节点的方法</h3><ul>\n<li>appendChild()</li>\n<li>insertBefore()</li>\n</ul>\n<h3 id=\"三-删除节点的方法\"><a href=\"#三-删除节点的方法\" class=\"headerlink\" title=\"三. 删除节点的方法\"></a>三. 删除节点的方法</h3><ul>\n<li>replaceChild(替换节点, 被替换的节点)</li>\n<li>removeChild(被移除的节点)</li>\n</ul>\n<h3 id=\"四-复制节点\"><a href=\"#四-复制节点\" class=\"headerlink\" title=\"四. 复制节点\"></a>四. 复制节点</h3><pre><code>cloneNode(bool)\nbool为true时，深复制，复制节点以及节点的所有子节点\nbool为false时，浅复制，只复制节点本身\n</code></pre>","excerpt":"","more":"<h3 id=\"一-获取节点的方法\"><a href=\"#一-获取节点的方法\" class=\"headerlink\" title=\"一. 获取节点的方法\"></a>一. 获取节点的方法</h3><h4 id=\"1-顶层API\"><a href=\"#1-顶层API\" class=\"headerlink\" title=\"1. 顶层API\"></a>1. 顶层API</h4><ul>\n<li>documment.getElementById() 返回一个元素</li>\n<li>document.getElementByName()  返回一个dom数组，具有相同name值的dom</li>\n<li>document.getElementByTagName() 返回一个dom数组，具有相同的标签名</li>\n</ul>\n<h4 id=\"2-通过父节点获取\"><a href=\"#2-通过父节点获取\" class=\"headerlink\" title=\"2. 通过父节点获取\"></a>2. 通过父节点获取</h4><ul>\n<li>parent.firstChild</li>\n<li>parent.lastChild</li>\n<li>parent.childNodes</li>\n<li>parent.children</li>\n<li>parent.getElementsByTagName</li>\n</ul>\n<h4 id=\"3-通过子节点获取\"><a href=\"#3-通过子节点获取\" class=\"headerlink\" title=\"3. 通过子节点获取\"></a>3. 通过子节点获取</h4><ul>\n<li>childNode.parentNode</li>\n</ul>\n<h4 id=\"4-通过临近节点获取\"><a href=\"#4-通过临近节点获取\" class=\"headerlink\" title=\"4. 通过临近节点获取\"></a>4. 通过临近节点获取</h4><ul>\n<li>neighbour.previousSibling</li>\n<li>neighbour.nextSibling</li>\n</ul>\n<h3 id=\"二-插入节点的方法\"><a href=\"#二-插入节点的方法\" class=\"headerlink\" title=\"二. 插入节点的方法\"></a>二. 插入节点的方法</h3><ul>\n<li>appendChild()</li>\n<li>insertBefore()</li>\n</ul>\n<h3 id=\"三-删除节点的方法\"><a href=\"#三-删除节点的方法\" class=\"headerlink\" title=\"三. 删除节点的方法\"></a>三. 删除节点的方法</h3><ul>\n<li>replaceChild(替换节点, 被替换的节点)</li>\n<li>removeChild(被移除的节点)</li>\n</ul>\n<h3 id=\"四-复制节点\"><a href=\"#四-复制节点\" class=\"headerlink\" title=\"四. 复制节点\"></a>四. 复制节点</h3><pre><code>cloneNode(bool)\nbool为true时，深复制，复制节点以及节点的所有子节点\nbool为false时，浅复制，只复制节点本身\n</code></pre>"},{"layout":"post","title":"CSS3 flexbox弹性布局","date":"2016-03-24T16:00:00.000Z","description":null,"_content":"\n使用过bootstrap框架之后，觉得它最大的一个优点就是它的栅格布局，使用栅格布局使得布局变得简单了很多，不用去考虑一些float、position属性。\n\nflexbox是一种与栅格布局类似的方式。\n\n是2009年w3c提出的一种布局方式，也叫做弹性布局，弹性布局的出现给盒模型提供了很大的便利性。\n\n### 一. 如何让容器变成flexbox布局\n\n#### 1. 父元素的设置\n    .parent{\n      display: -webkit-flex; /* Safari */\n      display: flex;\n    }\n    \n\t或者成为行内flex布局\n\n    .parent{\n      display: inline-flex;\n    }\n\n<font color=\"red\">注意：设为flexbox布局之后，子元素的**float**、**clear**、**vertical-align**属性都会失效。</font>\n\n#### 2. 子元素的设置\n    \n    .child{\n    \tflex:[number];\n    }\n    \n给其中的每一个孩子设置 `flex: [number]` 来让他们按比例分配容器的宽度。\n\n比如三个child分别设置了 `flex: 1` `flex: 2` `flex: 1` 则他们是按照 1-2-1 的比例来分配宽度的。\n\n如果有child没有设置 `flex` 而是设置了固定的宽度，比如 `width: 100px` 那么它的宽度就不受flex容器的影响，但是其他的设置了 `flex: [number]` 的容器会按比例平分剩下的部分。\n\n\n### 二. flex布局的属性\n\n#### 1 . 针对父元素的属性\n\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n#### (1). flex-direction\n\n决定项目的排列方向（主轴的方向）\n\n     flex-direction: row | row-reverse | column | column-reverse;\n\n按照字面意思也挺好理解的。\n\n#### (2). flex-wrap\n\n决定项目的换行方向\n\n     flex-wrap: nowrap | wrap | wrap-reverse;\n\n- nowrap:不换行\n- \n- wrap:正常换行\n- \n- wrap-reverse:换行，但是第一行在下方，如下图所示：\n\n![flexbox反方向换行](/img/post/demo/flex-wrap-reverse.jpg)\n\n#### (3). flex-flow\n\n是 flex-direction 和 flex-wrap 组合形式\n\n#### (4). justify-content\n\n定义项目在**主轴**的对齐方式\n\n `justify-content: flex-start | flex-end | center | space-between | space-around;`\n\n- flex-start（默认值）：在项目开始的地方对齐\n- flex-end：在项目结束的地方对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n#### (5). align-items\n\n定义项目在**交叉轴**的对齐方式\n\n     align-items: flex-start | flex-end | center | baseline | stretch;\n\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#### (6). align-content\n\n同时定义项目在**主轴**和**交叉轴**（水平线上）的对齐方式\n\n     align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n\n- flex-start：主轴方向与起点对齐，交叉轴方向也与起点对齐。\n- flex-end：主轴方向与终点对齐，交叉轴方向也与终点对齐。\n- center：主轴和交叉轴方向均为居中。\n- <font color=\"red\">space-between：主轴和交叉轴方向均两端对齐，轴线之间的间隔平均分布。</font>这个有待考证\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- <font color=\"red\">stretch（默认值）：轴线占满整个交叉轴</font>这个有待考证\n\n#### 2 . 针对子元素的属性\n\n- order\n- flex-grow\n- flex-shrink\n- flex-basis\n- flex\n- align-self\n\n#### (1). order\n\n定义项目的排列顺序，数值越小，排列越靠前。\n\n    order:<number>; /* default:0 */\n\n#### (2). flex-grow\n\n定义项目的放大比例。\n\n    flex-grow:<number>; /* default:0 */\n\n#### (3). flex-shrink\n\n定义项目的缩小比例。\n\n    flex-shrink:<number>; /* default:0 */\n\n#### (4). flex-basis\n\n定义项目占据主轴的空间。\n\n    flex-basis:<length>; /* default:auto */\n\n#### (5). flex\n\nflex是flex-grow、flex-shrink、flex-basis的缩写形式\n\n    flex:flex-grow flex-shrink flex-basis; /* default: 0 0 auto */\n\n#### (5). align-self\n\n允许单个子元素与其他子元素在交叉轴上的对齐方式不一样\n\n    align-self:\n\n- auto:保持元素本身的对齐方式\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。","source":"_posts/2016-03-25-CSS3 flexbox弹性布局.md","raw":"---\nlayout: post\ntitle: CSS3 flexbox弹性布局\ndate: 2016-03-25\ncategories: 前端笔记\ntags: [css]\ndescription: \n---\n\n使用过bootstrap框架之后，觉得它最大的一个优点就是它的栅格布局，使用栅格布局使得布局变得简单了很多，不用去考虑一些float、position属性。\n\nflexbox是一种与栅格布局类似的方式。\n\n是2009年w3c提出的一种布局方式，也叫做弹性布局，弹性布局的出现给盒模型提供了很大的便利性。\n\n### 一. 如何让容器变成flexbox布局\n\n#### 1. 父元素的设置\n    .parent{\n      display: -webkit-flex; /* Safari */\n      display: flex;\n    }\n    \n\t或者成为行内flex布局\n\n    .parent{\n      display: inline-flex;\n    }\n\n<font color=\"red\">注意：设为flexbox布局之后，子元素的**float**、**clear**、**vertical-align**属性都会失效。</font>\n\n#### 2. 子元素的设置\n    \n    .child{\n    \tflex:[number];\n    }\n    \n给其中的每一个孩子设置 `flex: [number]` 来让他们按比例分配容器的宽度。\n\n比如三个child分别设置了 `flex: 1` `flex: 2` `flex: 1` 则他们是按照 1-2-1 的比例来分配宽度的。\n\n如果有child没有设置 `flex` 而是设置了固定的宽度，比如 `width: 100px` 那么它的宽度就不受flex容器的影响，但是其他的设置了 `flex: [number]` 的容器会按比例平分剩下的部分。\n\n\n### 二. flex布局的属性\n\n#### 1 . 针对父元素的属性\n\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n#### (1). flex-direction\n\n决定项目的排列方向（主轴的方向）\n\n     flex-direction: row | row-reverse | column | column-reverse;\n\n按照字面意思也挺好理解的。\n\n#### (2). flex-wrap\n\n决定项目的换行方向\n\n     flex-wrap: nowrap | wrap | wrap-reverse;\n\n- nowrap:不换行\n- \n- wrap:正常换行\n- \n- wrap-reverse:换行，但是第一行在下方，如下图所示：\n\n![flexbox反方向换行](/img/post/demo/flex-wrap-reverse.jpg)\n\n#### (3). flex-flow\n\n是 flex-direction 和 flex-wrap 组合形式\n\n#### (4). justify-content\n\n定义项目在**主轴**的对齐方式\n\n `justify-content: flex-start | flex-end | center | space-between | space-around;`\n\n- flex-start（默认值）：在项目开始的地方对齐\n- flex-end：在项目结束的地方对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n#### (5). align-items\n\n定义项目在**交叉轴**的对齐方式\n\n     align-items: flex-start | flex-end | center | baseline | stretch;\n\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#### (6). align-content\n\n同时定义项目在**主轴**和**交叉轴**（水平线上）的对齐方式\n\n     align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n\n- flex-start：主轴方向与起点对齐，交叉轴方向也与起点对齐。\n- flex-end：主轴方向与终点对齐，交叉轴方向也与终点对齐。\n- center：主轴和交叉轴方向均为居中。\n- <font color=\"red\">space-between：主轴和交叉轴方向均两端对齐，轴线之间的间隔平均分布。</font>这个有待考证\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- <font color=\"red\">stretch（默认值）：轴线占满整个交叉轴</font>这个有待考证\n\n#### 2 . 针对子元素的属性\n\n- order\n- flex-grow\n- flex-shrink\n- flex-basis\n- flex\n- align-self\n\n#### (1). order\n\n定义项目的排列顺序，数值越小，排列越靠前。\n\n    order:<number>; /* default:0 */\n\n#### (2). flex-grow\n\n定义项目的放大比例。\n\n    flex-grow:<number>; /* default:0 */\n\n#### (3). flex-shrink\n\n定义项目的缩小比例。\n\n    flex-shrink:<number>; /* default:0 */\n\n#### (4). flex-basis\n\n定义项目占据主轴的空间。\n\n    flex-basis:<length>; /* default:auto */\n\n#### (5). flex\n\nflex是flex-grow、flex-shrink、flex-basis的缩写形式\n\n    flex:flex-grow flex-shrink flex-basis; /* default: 0 0 auto */\n\n#### (5). align-self\n\n允许单个子元素与其他子元素在交叉轴上的对齐方式不一样\n\n    align-self:\n\n- auto:保持元素本身的对齐方式\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。","slug":"2016-03-25-CSS3 flexbox弹性布局","published":1,"updated":"2016-08-11T03:19:12.000Z","comments":1,"photos":[],"link":"","_id":"cj035occx001cd5u8vet4u5pq","content":"<p>使用过bootstrap框架之后，觉得它最大的一个优点就是它的栅格布局，使用栅格布局使得布局变得简单了很多，不用去考虑一些float、position属性。</p>\n<p>flexbox是一种与栅格布局类似的方式。</p>\n<p>是2009年w3c提出的一种布局方式，也叫做弹性布局，弹性布局的出现给盒模型提供了很大的便利性。</p>\n<h3 id=\"一-如何让容器变成flexbox布局\"><a href=\"#一-如何让容器变成flexbox布局\" class=\"headerlink\" title=\"一. 如何让容器变成flexbox布局\"></a>一. 如何让容器变成flexbox布局</h3><h4 id=\"1-父元素的设置\"><a href=\"#1-父元素的设置\" class=\"headerlink\" title=\"1. 父元素的设置\"></a>1. 父元素的设置</h4><pre><code>.parent{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n\n或者成为行内flex布局\n\n.parent{\n  display: inline-flex;\n}\n</code></pre><font color=\"red\">注意：设为flexbox布局之后，子元素的<strong>float</strong>、<strong>clear</strong>、<strong>vertical-align</strong>属性都会失效。</font>\n\n<h4 id=\"2-子元素的设置\"><a href=\"#2-子元素的设置\" class=\"headerlink\" title=\"2. 子元素的设置\"></a>2. 子元素的设置</h4><pre><code>.child{\n    flex:[number];\n}\n</code></pre><p>给其中的每一个孩子设置 <code>flex: [number]</code> 来让他们按比例分配容器的宽度。</p>\n<p>比如三个child分别设置了 <code>flex: 1</code> <code>flex: 2</code> <code>flex: 1</code> 则他们是按照 1-2-1 的比例来分配宽度的。</p>\n<p>如果有child没有设置 <code>flex</code> 而是设置了固定的宽度，比如 <code>width: 100px</code> 那么它的宽度就不受flex容器的影响，但是其他的设置了 <code>flex: [number]</code> 的容器会按比例平分剩下的部分。</p>\n<h3 id=\"二-flex布局的属性\"><a href=\"#二-flex布局的属性\" class=\"headerlink\" title=\"二. flex布局的属性\"></a>二. flex布局的属性</h3><h4 id=\"1-针对父元素的属性\"><a href=\"#1-针对父元素的属性\" class=\"headerlink\" title=\"1 . 针对父元素的属性\"></a>1 . 针对父元素的属性</h4><ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h4 id=\"1-flex-direction\"><a href=\"#1-flex-direction\" class=\"headerlink\" title=\"(1). flex-direction\"></a>(1). flex-direction</h4><p>决定项目的排列方向（主轴的方向）</p>\n<pre><code>flex-direction: row | row-reverse | column | column-reverse;\n</code></pre><p>按照字面意思也挺好理解的。</p>\n<h4 id=\"2-flex-wrap\"><a href=\"#2-flex-wrap\" class=\"headerlink\" title=\"(2). flex-wrap\"></a>(2). flex-wrap</h4><p>决定项目的换行方向</p>\n<pre><code>flex-wrap: nowrap | wrap | wrap-reverse;\n</code></pre><ul>\n<li>nowrap:不换行</li>\n<li></li>\n<li>wrap:正常换行</li>\n<li></li>\n<li>wrap-reverse:换行，但是第一行在下方，如下图所示：</li>\n</ul>\n<p><img src=\"/img/post/demo/flex-wrap-reverse.jpg\" alt=\"flexbox反方向换行\"></p>\n<h4 id=\"3-flex-flow\"><a href=\"#3-flex-flow\" class=\"headerlink\" title=\"(3). flex-flow\"></a>(3). flex-flow</h4><p>是 flex-direction 和 flex-wrap 组合形式</p>\n<h4 id=\"4-justify-content\"><a href=\"#4-justify-content\" class=\"headerlink\" title=\"(4). justify-content\"></a>(4). justify-content</h4><p>定义项目在<strong>主轴</strong>的对齐方式</p>\n<p> <code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></p>\n<ul>\n<li>flex-start（默认值）：在项目开始的地方对齐</li>\n<li>flex-end：在项目结束的地方对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<h4 id=\"5-align-items\"><a href=\"#5-align-items\" class=\"headerlink\" title=\"(5). align-items\"></a>(5). align-items</h4><p>定义项目在<strong>交叉轴</strong>的对齐方式</p>\n<pre><code>align-items: flex-start | flex-end | center | baseline | stretch;\n</code></pre><ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h4 id=\"6-align-content\"><a href=\"#6-align-content\" class=\"headerlink\" title=\"(6). align-content\"></a>(6). align-content</h4><p>同时定义项目在<strong>主轴</strong>和<strong>交叉轴</strong>（水平线上）的对齐方式</p>\n<pre><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n</code></pre><ul>\n<li>flex-start：主轴方向与起点对齐，交叉轴方向也与起点对齐。</li>\n<li>flex-end：主轴方向与终点对齐，交叉轴方向也与终点对齐。</li>\n<li>center：主轴和交叉轴方向均为居中。</li>\n<li><font color=\"red\">space-between：主轴和交叉轴方向均两端对齐，轴线之间的间隔平均分布。</font>这个有待考证</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li><font color=\"red\">stretch（默认值）：轴线占满整个交叉轴</font>这个有待考证</li>\n</ul>\n<h4 id=\"2-针对子元素的属性\"><a href=\"#2-针对子元素的属性\" class=\"headerlink\" title=\"2 . 针对子元素的属性\"></a>2 . 针对子元素的属性</h4><ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"1-order\"><a href=\"#1-order\" class=\"headerlink\" title=\"(1). order\"></a>(1). order</h4><p>定义项目的排列顺序，数值越小，排列越靠前。</p>\n<pre><code>order:&lt;number&gt;; /* default:0 */\n</code></pre><h4 id=\"2-flex-grow\"><a href=\"#2-flex-grow\" class=\"headerlink\" title=\"(2). flex-grow\"></a>(2). flex-grow</h4><p>定义项目的放大比例。</p>\n<pre><code>flex-grow:&lt;number&gt;; /* default:0 */\n</code></pre><h4 id=\"3-flex-shrink\"><a href=\"#3-flex-shrink\" class=\"headerlink\" title=\"(3). flex-shrink\"></a>(3). flex-shrink</h4><p>定义项目的缩小比例。</p>\n<pre><code>flex-shrink:&lt;number&gt;; /* default:0 */\n</code></pre><h4 id=\"4-flex-basis\"><a href=\"#4-flex-basis\" class=\"headerlink\" title=\"(4). flex-basis\"></a>(4). flex-basis</h4><p>定义项目占据主轴的空间。</p>\n<pre><code>flex-basis:&lt;length&gt;; /* default:auto */\n</code></pre><h4 id=\"5-flex\"><a href=\"#5-flex\" class=\"headerlink\" title=\"(5). flex\"></a>(5). flex</h4><p>flex是flex-grow、flex-shrink、flex-basis的缩写形式</p>\n<pre><code>flex:flex-grow flex-shrink flex-basis; /* default: 0 0 auto */\n</code></pre><h4 id=\"5-align-self\"><a href=\"#5-align-self\" class=\"headerlink\" title=\"(5). align-self\"></a>(5). align-self</h4><p>允许单个子元素与其他子元素在交叉轴上的对齐方式不一样</p>\n<pre><code>align-self:\n</code></pre><ul>\n<li>auto:保持元素本身的对齐方式</li>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n","excerpt":"","more":"<p>使用过bootstrap框架之后，觉得它最大的一个优点就是它的栅格布局，使用栅格布局使得布局变得简单了很多，不用去考虑一些float、position属性。</p>\n<p>flexbox是一种与栅格布局类似的方式。</p>\n<p>是2009年w3c提出的一种布局方式，也叫做弹性布局，弹性布局的出现给盒模型提供了很大的便利性。</p>\n<h3 id=\"一-如何让容器变成flexbox布局\"><a href=\"#一-如何让容器变成flexbox布局\" class=\"headerlink\" title=\"一. 如何让容器变成flexbox布局\"></a>一. 如何让容器变成flexbox布局</h3><h4 id=\"1-父元素的设置\"><a href=\"#1-父元素的设置\" class=\"headerlink\" title=\"1. 父元素的设置\"></a>1. 父元素的设置</h4><pre><code>.parent{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n\n或者成为行内flex布局\n\n.parent{\n  display: inline-flex;\n}\n</code></pre><font color=\"red\">注意：设为flexbox布局之后，子元素的<strong>float</strong>、<strong>clear</strong>、<strong>vertical-align</strong>属性都会失效。</font>\n\n<h4 id=\"2-子元素的设置\"><a href=\"#2-子元素的设置\" class=\"headerlink\" title=\"2. 子元素的设置\"></a>2. 子元素的设置</h4><pre><code>.child{\n    flex:[number];\n}\n</code></pre><p>给其中的每一个孩子设置 <code>flex: [number]</code> 来让他们按比例分配容器的宽度。</p>\n<p>比如三个child分别设置了 <code>flex: 1</code> <code>flex: 2</code> <code>flex: 1</code> 则他们是按照 1-2-1 的比例来分配宽度的。</p>\n<p>如果有child没有设置 <code>flex</code> 而是设置了固定的宽度，比如 <code>width: 100px</code> 那么它的宽度就不受flex容器的影响，但是其他的设置了 <code>flex: [number]</code> 的容器会按比例平分剩下的部分。</p>\n<h3 id=\"二-flex布局的属性\"><a href=\"#二-flex布局的属性\" class=\"headerlink\" title=\"二. flex布局的属性\"></a>二. flex布局的属性</h3><h4 id=\"1-针对父元素的属性\"><a href=\"#1-针对父元素的属性\" class=\"headerlink\" title=\"1 . 针对父元素的属性\"></a>1 . 针对父元素的属性</h4><ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h4 id=\"1-flex-direction\"><a href=\"#1-flex-direction\" class=\"headerlink\" title=\"(1). flex-direction\"></a>(1). flex-direction</h4><p>决定项目的排列方向（主轴的方向）</p>\n<pre><code>flex-direction: row | row-reverse | column | column-reverse;\n</code></pre><p>按照字面意思也挺好理解的。</p>\n<h4 id=\"2-flex-wrap\"><a href=\"#2-flex-wrap\" class=\"headerlink\" title=\"(2). flex-wrap\"></a>(2). flex-wrap</h4><p>决定项目的换行方向</p>\n<pre><code>flex-wrap: nowrap | wrap | wrap-reverse;\n</code></pre><ul>\n<li>nowrap:不换行</li>\n<li></li>\n<li>wrap:正常换行</li>\n<li></li>\n<li>wrap-reverse:换行，但是第一行在下方，如下图所示：</li>\n</ul>\n<p><img src=\"/img/post/demo/flex-wrap-reverse.jpg\" alt=\"flexbox反方向换行\"></p>\n<h4 id=\"3-flex-flow\"><a href=\"#3-flex-flow\" class=\"headerlink\" title=\"(3). flex-flow\"></a>(3). flex-flow</h4><p>是 flex-direction 和 flex-wrap 组合形式</p>\n<h4 id=\"4-justify-content\"><a href=\"#4-justify-content\" class=\"headerlink\" title=\"(4). justify-content\"></a>(4). justify-content</h4><p>定义项目在<strong>主轴</strong>的对齐方式</p>\n<p> <code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></p>\n<ul>\n<li>flex-start（默认值）：在项目开始的地方对齐</li>\n<li>flex-end：在项目结束的地方对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<h4 id=\"5-align-items\"><a href=\"#5-align-items\" class=\"headerlink\" title=\"(5). align-items\"></a>(5). align-items</h4><p>定义项目在<strong>交叉轴</strong>的对齐方式</p>\n<pre><code>align-items: flex-start | flex-end | center | baseline | stretch;\n</code></pre><ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<h4 id=\"6-align-content\"><a href=\"#6-align-content\" class=\"headerlink\" title=\"(6). align-content\"></a>(6). align-content</h4><p>同时定义项目在<strong>主轴</strong>和<strong>交叉轴</strong>（水平线上）的对齐方式</p>\n<pre><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n</code></pre><ul>\n<li>flex-start：主轴方向与起点对齐，交叉轴方向也与起点对齐。</li>\n<li>flex-end：主轴方向与终点对齐，交叉轴方向也与终点对齐。</li>\n<li>center：主轴和交叉轴方向均为居中。</li>\n<li><font color=\"red\">space-between：主轴和交叉轴方向均两端对齐，轴线之间的间隔平均分布。</font>这个有待考证</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li><font color=\"red\">stretch（默认值）：轴线占满整个交叉轴</font>这个有待考证</li>\n</ul>\n<h4 id=\"2-针对子元素的属性\"><a href=\"#2-针对子元素的属性\" class=\"headerlink\" title=\"2 . 针对子元素的属性\"></a>2 . 针对子元素的属性</h4><ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"1-order\"><a href=\"#1-order\" class=\"headerlink\" title=\"(1). order\"></a>(1). order</h4><p>定义项目的排列顺序，数值越小，排列越靠前。</p>\n<pre><code>order:&lt;number&gt;; /* default:0 */\n</code></pre><h4 id=\"2-flex-grow\"><a href=\"#2-flex-grow\" class=\"headerlink\" title=\"(2). flex-grow\"></a>(2). flex-grow</h4><p>定义项目的放大比例。</p>\n<pre><code>flex-grow:&lt;number&gt;; /* default:0 */\n</code></pre><h4 id=\"3-flex-shrink\"><a href=\"#3-flex-shrink\" class=\"headerlink\" title=\"(3). flex-shrink\"></a>(3). flex-shrink</h4><p>定义项目的缩小比例。</p>\n<pre><code>flex-shrink:&lt;number&gt;; /* default:0 */\n</code></pre><h4 id=\"4-flex-basis\"><a href=\"#4-flex-basis\" class=\"headerlink\" title=\"(4). flex-basis\"></a>(4). flex-basis</h4><p>定义项目占据主轴的空间。</p>\n<pre><code>flex-basis:&lt;length&gt;; /* default:auto */\n</code></pre><h4 id=\"5-flex\"><a href=\"#5-flex\" class=\"headerlink\" title=\"(5). flex\"></a>(5). flex</h4><p>flex是flex-grow、flex-shrink、flex-basis的缩写形式</p>\n<pre><code>flex:flex-grow flex-shrink flex-basis; /* default: 0 0 auto */\n</code></pre><h4 id=\"5-align-self\"><a href=\"#5-align-self\" class=\"headerlink\" title=\"(5). align-self\"></a>(5). align-self</h4><p>允许单个子元素与其他子元素在交叉轴上的对齐方式不一样</p>\n<pre><code>align-self:\n</code></pre><ul>\n<li>auto:保持元素本身的对齐方式</li>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n"},{"layout":"post","title":"异步加载脚本的几种方式","date":"2016-03-24T16:00:00.000Z","description":null,"_content":"\n<font color='red'>**为什么要异步加载脚本？**</font>\n\n**加载脚本会阻塞其他资源和文件的加载**，当浏览器解析器遇到`<script>`时，会立即加载，浏览器对其他资源和文档的加载会停止。\n\n其他文件（图片，样式表）可以并行下载。\n\n为了提高页面的加载速度，需要让JS不阻塞其他资源的加载。\n\n![ansyc](/uploads/post/20160509/async.jpg)\n\n绿线是HTML解析，蓝线是js脚本加载，红线是js脚本执行\n\n### 1. 方案一：`<script>`标签的async=\"async\"属性\n\n**HTML5**中新增的async属性，脚本会**异步加载**(注意是加载而不是执行！！！)，加载时不会阻塞页面，加载完马上执行，执行时仍然会阻塞页面的解析。\n\n由于async脚本何时加载完是不确定的，所以async脚本执行的时机是不确定的。\n\n因此，若有多个脚本，这种方法不能保证脚本按顺序执行。\n\n注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。\n\n**特点：可以跨域，多个脚本不能按顺序执行。**\n\n### 2. 方案二：`<script>`标签的defer=\"defer\"属性\n\ndefer的作用是：阻止脚本在下载完成后立即执行，会让脚本延迟到所有脚本加载执行完成后顺序执行。\n\n设置了defer属性之后，脚本会**异步加载**，加载完之后不会马上执行，等到页面解析完毕之后再按顺序执行。\n\n因此，设置了defer属性的脚本不会阻塞页面的执行。\n\n此外，这种方法可以确保所有设置defer属性的脚本按顺序执行。\n\n**特点：可以跨域，多个脚本可以按顺序执行。**\n\n**defer和async这两个特性的初衷也是希望能够解决或者缓解阻塞对于页面体验的影响**\n\ndefer和async优先级的问题：\n\n- 如果`<script>`元素同时定义了defer和async特性，则按async来处理（注意：对于不支持async的浏览器会直接忽略async特性）\n- 如果`<script>`元素只定义了defer，则按延迟脚本的方式处理\n- 如果`<script>`元素没有定义defer也没有定义async，则按正常情况处理，即：脚本立即加载和执行\n\n### 3. 方案三：动态创建`<script>`标签\n\n示例：\n    \t```js\n\t\t<!DOCTYPE html>\n    \t<html>\n\t    \t<head>\n\t\t    \t<script type=\"text/javascript\">\n\t\t\t    \t(function(){\n\t\t\t\t    \tvar s = document.createElement('script');\n\t\t\t\t    \ts.type = 'text/javascript';\n\t\t\t\t    \ts.src = \"http://code.jquery.com/jquery-1.7.2.min.js\";\n\t\t\t\t    \tvar tmp = document.getElementsByTagName('script')[0];\n\t\t\t\t    \ttmp.parentNode.insertBefore(s, tmp);//在这个script标签前再加一个script标签\n\t\t\t    \t})();\n\t\t    \t</script>\n\t    \t</head>\n\t    \t<body>\n\t    \t\t<img src=\"http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg\" />\n\t    \t</body>\n    \t</html>\n\t\t```\n\n在执行最后一行代码之前，是不会加载外部文件的。\n\n此文件元素添加到页面后立即开始下载。此技术的重点在于：无论在何处启动下载，脚本的下载和运行都不会阻塞页面的处理过程。\n\n**优点：允许跨域，多个脚本可以按顺序执行。**\n\n### 4. AJAX \n\n使用XHR对象加载js代码并注入页面\n\n**思路1：XHR 注入**\n\n先创建一个XMLHttpRequest对象，加载js文件，最后通过**动态添加`<script>`元素**将代码注入页面。\n    ```js\n    eg:\n    \n    var xhr = new XMLHttpRequest();\n    xhr.open(\"get\",\"file.js\",true);//发送GET请求file.js文件\n    xhr.onreadystatechange = function(){\n    \tif(xhr.readyState == 4){\n    \t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304){\n    \t\t\tvar myScript = document.createElement(\"script\");\n    \t\t\tmyScript.type = \"text/javascript\";\n    \t\t\tmyScript.text = xhr.responseText;\n    \t\t\tdocument.body.appendChild(myScript);\n    \t\t}\n    \t}\n    }\n\t```\n\n**思路2：XHR eval**\n\n先创建一个XMLHttpRequest对象，加载js文件，然后将加载得到的js代码放到eval()函数内\n\neval() 它是一个动态执行函数,可以把脚本语句写成字符串,然后用它来执行，eval() 函数可计算某个字符串，并执行其中的 JavaScript 代码。\n\n```\nvar xhr = new XMLHttpRequest();\nxhr.open('get','file.js',true);\nxhr.onreadystatechange = function() {\n\tif(xhr.readystate == 4) {\n\t\tif(xhr.status >= 200 && xhr.status <= 300 || xhr.status == 304) {\n\t\t\teval(xhr.responseText);\n\t\t}\n\t}\n}\n```\n**特点：这两种方法都不允许跨域，不能确保多个脚本按顺序执行。**\n\n### 5. iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）\n\n不允许跨域访问。\n\n使用iframe是因为它可以和主页面并行加载，不会阻塞主页面。\n\niframe会阻塞主页面的onload事件\n\n主页面和iframe共享同一个连接池","source":"_posts/2016-03-27-异步加载脚本的几种方式.md","raw":"---\nlayout: post\ntitle: 异步加载脚本的几种方式\ndate: 2016-03-25\ncategories: 前端笔记\ntags: [浏览器]\ndescription: \n---\n\n<font color='red'>**为什么要异步加载脚本？**</font>\n\n**加载脚本会阻塞其他资源和文件的加载**，当浏览器解析器遇到`<script>`时，会立即加载，浏览器对其他资源和文档的加载会停止。\n\n其他文件（图片，样式表）可以并行下载。\n\n为了提高页面的加载速度，需要让JS不阻塞其他资源的加载。\n\n![ansyc](/uploads/post/20160509/async.jpg)\n\n绿线是HTML解析，蓝线是js脚本加载，红线是js脚本执行\n\n### 1. 方案一：`<script>`标签的async=\"async\"属性\n\n**HTML5**中新增的async属性，脚本会**异步加载**(注意是加载而不是执行！！！)，加载时不会阻塞页面，加载完马上执行，执行时仍然会阻塞页面的解析。\n\n由于async脚本何时加载完是不确定的，所以async脚本执行的时机是不确定的。\n\n因此，若有多个脚本，这种方法不能保证脚本按顺序执行。\n\n注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。\n\n**特点：可以跨域，多个脚本不能按顺序执行。**\n\n### 2. 方案二：`<script>`标签的defer=\"defer\"属性\n\ndefer的作用是：阻止脚本在下载完成后立即执行，会让脚本延迟到所有脚本加载执行完成后顺序执行。\n\n设置了defer属性之后，脚本会**异步加载**，加载完之后不会马上执行，等到页面解析完毕之后再按顺序执行。\n\n因此，设置了defer属性的脚本不会阻塞页面的执行。\n\n此外，这种方法可以确保所有设置defer属性的脚本按顺序执行。\n\n**特点：可以跨域，多个脚本可以按顺序执行。**\n\n**defer和async这两个特性的初衷也是希望能够解决或者缓解阻塞对于页面体验的影响**\n\ndefer和async优先级的问题：\n\n- 如果`<script>`元素同时定义了defer和async特性，则按async来处理（注意：对于不支持async的浏览器会直接忽略async特性）\n- 如果`<script>`元素只定义了defer，则按延迟脚本的方式处理\n- 如果`<script>`元素没有定义defer也没有定义async，则按正常情况处理，即：脚本立即加载和执行\n\n### 3. 方案三：动态创建`<script>`标签\n\n示例：\n    \t```js\n\t\t<!DOCTYPE html>\n    \t<html>\n\t    \t<head>\n\t\t    \t<script type=\"text/javascript\">\n\t\t\t    \t(function(){\n\t\t\t\t    \tvar s = document.createElement('script');\n\t\t\t\t    \ts.type = 'text/javascript';\n\t\t\t\t    \ts.src = \"http://code.jquery.com/jquery-1.7.2.min.js\";\n\t\t\t\t    \tvar tmp = document.getElementsByTagName('script')[0];\n\t\t\t\t    \ttmp.parentNode.insertBefore(s, tmp);//在这个script标签前再加一个script标签\n\t\t\t    \t})();\n\t\t    \t</script>\n\t    \t</head>\n\t    \t<body>\n\t    \t\t<img src=\"http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg\" />\n\t    \t</body>\n    \t</html>\n\t\t```\n\n在执行最后一行代码之前，是不会加载外部文件的。\n\n此文件元素添加到页面后立即开始下载。此技术的重点在于：无论在何处启动下载，脚本的下载和运行都不会阻塞页面的处理过程。\n\n**优点：允许跨域，多个脚本可以按顺序执行。**\n\n### 4. AJAX \n\n使用XHR对象加载js代码并注入页面\n\n**思路1：XHR 注入**\n\n先创建一个XMLHttpRequest对象，加载js文件，最后通过**动态添加`<script>`元素**将代码注入页面。\n    ```js\n    eg:\n    \n    var xhr = new XMLHttpRequest();\n    xhr.open(\"get\",\"file.js\",true);//发送GET请求file.js文件\n    xhr.onreadystatechange = function(){\n    \tif(xhr.readyState == 4){\n    \t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304){\n    \t\t\tvar myScript = document.createElement(\"script\");\n    \t\t\tmyScript.type = \"text/javascript\";\n    \t\t\tmyScript.text = xhr.responseText;\n    \t\t\tdocument.body.appendChild(myScript);\n    \t\t}\n    \t}\n    }\n\t```\n\n**思路2：XHR eval**\n\n先创建一个XMLHttpRequest对象，加载js文件，然后将加载得到的js代码放到eval()函数内\n\neval() 它是一个动态执行函数,可以把脚本语句写成字符串,然后用它来执行，eval() 函数可计算某个字符串，并执行其中的 JavaScript 代码。\n\n```\nvar xhr = new XMLHttpRequest();\nxhr.open('get','file.js',true);\nxhr.onreadystatechange = function() {\n\tif(xhr.readystate == 4) {\n\t\tif(xhr.status >= 200 && xhr.status <= 300 || xhr.status == 304) {\n\t\t\teval(xhr.responseText);\n\t\t}\n\t}\n}\n```\n**特点：这两种方法都不允许跨域，不能确保多个脚本按顺序执行。**\n\n### 5. iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）\n\n不允许跨域访问。\n\n使用iframe是因为它可以和主页面并行加载，不会阻塞主页面。\n\niframe会阻塞主页面的onload事件\n\n主页面和iframe共享同一个连接池","slug":"2016-03-27-异步加载脚本的几种方式","published":1,"updated":"2016-09-12T12:02:18.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocd1001fd5u8t53eo374","content":"<font color=\"red\"><strong>为什么要异步加载脚本？</strong></font>\n\n<p><strong>加载脚本会阻塞其他资源和文件的加载</strong>，当浏览器解析器遇到<code>&lt;script&gt;</code>时，会立即加载，浏览器对其他资源和文档的加载会停止。</p>\n<p>其他文件（图片，样式表）可以并行下载。</p>\n<p>为了提高页面的加载速度，需要让JS不阻塞其他资源的加载。</p>\n<p><img src=\"/uploads/post/20160509/async.jpg\" alt=\"ansyc\"></p>\n<p>绿线是HTML解析，蓝线是js脚本加载，红线是js脚本执行</p>\n<h3 id=\"1-方案一：-lt-script-gt-标签的async-”async”属性\"><a href=\"#1-方案一：-lt-script-gt-标签的async-”async”属性\" class=\"headerlink\" title=\"1. 方案一：&lt;script&gt;标签的async=”async”属性\"></a>1. 方案一：<code>&lt;script&gt;</code>标签的async=”async”属性</h3><p><strong>HTML5</strong>中新增的async属性，脚本会<strong>异步加载</strong>(注意是加载而不是执行！！！)，加载时不会阻塞页面，加载完马上执行，执行时仍然会阻塞页面的解析。</p>\n<p>由于async脚本何时加载完是不确定的，所以async脚本执行的时机是不确定的。</p>\n<p>因此，若有多个脚本，这种方法不能保证脚本按顺序执行。</p>\n<p>注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。</p>\n<p><strong>特点：可以跨域，多个脚本不能按顺序执行。</strong></p>\n<h3 id=\"2-方案二：-lt-script-gt-标签的defer-”defer”属性\"><a href=\"#2-方案二：-lt-script-gt-标签的defer-”defer”属性\" class=\"headerlink\" title=\"2. 方案二：&lt;script&gt;标签的defer=”defer”属性\"></a>2. 方案二：<code>&lt;script&gt;</code>标签的defer=”defer”属性</h3><p>defer的作用是：阻止脚本在下载完成后立即执行，会让脚本延迟到所有脚本加载执行完成后顺序执行。</p>\n<p>设置了defer属性之后，脚本会<strong>异步加载</strong>，加载完之后不会马上执行，等到页面解析完毕之后再按顺序执行。</p>\n<p>因此，设置了defer属性的脚本不会阻塞页面的执行。</p>\n<p>此外，这种方法可以确保所有设置defer属性的脚本按顺序执行。</p>\n<p><strong>特点：可以跨域，多个脚本可以按顺序执行。</strong></p>\n<p><strong>defer和async这两个特性的初衷也是希望能够解决或者缓解阻塞对于页面体验的影响</strong></p>\n<p>defer和async优先级的问题：</p>\n<ul>\n<li>如果<code>&lt;script&gt;</code>元素同时定义了defer和async特性，则按async来处理（注意：对于不支持async的浏览器会直接忽略async特性）</li>\n<li>如果<code>&lt;script&gt;</code>元素只定义了defer，则按延迟脚本的方式处理</li>\n<li>如果<code>&lt;script&gt;</code>元素没有定义defer也没有定义async，则按正常情况处理，即：脚本立即加载和执行</li>\n</ul>\n<h3 id=\"3-方案三：动态创建-lt-script-gt-标签\"><a href=\"#3-方案三：动态创建-lt-script-gt-标签\" class=\"headerlink\" title=\"3. 方案三：动态创建&lt;script&gt;标签\"></a>3. 方案三：动态创建<code>&lt;script&gt;</code>标签</h3><p>示例：<br>        <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">  \t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">\t    \t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t    \t<span class=\"keyword\">var</span> s = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">\t\t    \ts.type = <span class=\"string\">'text/javascript'</span>;</span><br><span class=\"line\">\t\t    \ts.src = <span class=\"string\">\"http://code.jquery.com/jquery-1.7.2.min.js\"</span>;</span><br><span class=\"line\">\t\t    \t<span class=\"keyword\">var</span> tmp = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'script'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t    \ttmp.parentNode.insertBefore(s, tmp);<span class=\"comment\">//在这个script标签前再加一个script标签</span></span><br><span class=\"line\">\t    \t&#125;)();</span><br><span class=\"line\">    \t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg\"</span> /&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>在执行最后一行代码之前，是不会加载外部文件的。</p>\n<p>此文件元素添加到页面后立即开始下载。此技术的重点在于：无论在何处启动下载，脚本的下载和运行都不会阻塞页面的处理过程。</p>\n<p><strong>优点：允许跨域，多个脚本可以按顺序执行。</strong></p>\n<h3 id=\"4-AJAX\"><a href=\"#4-AJAX\" class=\"headerlink\" title=\"4. AJAX\"></a>4. AJAX</h3><p>使用XHR对象加载js代码并注入页面</p>\n<p><strong>思路1：XHR 注入</strong></p>\n<p>先创建一个XMLHttpRequest对象，加载js文件，最后通过<strong>动态添加<code>&lt;script&gt;</code>元素</strong>将代码注入页面。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"get\"</span>,<span class=\"string\">\"file.js\"</span>,<span class=\"literal\">true</span>);<span class=\"comment\">//发送GET请求file.js文件</span></span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(xhr.readyState == <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> myScript = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">\t\t\tmyScript.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">\t\t\tmyScript.text = xhr.responseText;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">document</span>.body.appendChild(myScript);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>思路2：XHR eval</strong></p>\n<p>先创建一个XMLHttpRequest对象，加载js文件，然后将加载得到的js代码放到eval()函数内</p>\n<p>eval() 它是一个动态执行函数,可以把脚本语句写成字符串,然后用它来执行，eval() 函数可计算某个字符串，并执行其中的 JavaScript 代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>,<span class=\"string\">'file.js'</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(xhr.readystate == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt;= <span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">eval</span>(xhr.responseText);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>特点：这两种方法都不允许跨域，不能确保多个脚本按顺序执行。</strong></p>\n<h3 id=\"5-iframe方式（这里可以参照：iframe异步加载技术及性能-中关于Meboo的部分）\"><a href=\"#5-iframe方式（这里可以参照：iframe异步加载技术及性能-中关于Meboo的部分）\" class=\"headerlink\" title=\"5. iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）\"></a>5. iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）</h3><p>不允许跨域访问。</p>\n<p>使用iframe是因为它可以和主页面并行加载，不会阻塞主页面。</p>\n<p>iframe会阻塞主页面的onload事件</p>\n<p>主页面和iframe共享同一个连接池</p>\n","excerpt":"","more":"<font color='red'><strong>为什么要异步加载脚本？</strong></font>\n\n<p><strong>加载脚本会阻塞其他资源和文件的加载</strong>，当浏览器解析器遇到<code>&lt;script&gt;</code>时，会立即加载，浏览器对其他资源和文档的加载会停止。</p>\n<p>其他文件（图片，样式表）可以并行下载。</p>\n<p>为了提高页面的加载速度，需要让JS不阻塞其他资源的加载。</p>\n<p><img src=\"/uploads/post/20160509/async.jpg\" alt=\"ansyc\"></p>\n<p>绿线是HTML解析，蓝线是js脚本加载，红线是js脚本执行</p>\n<h3 id=\"1-方案一：-lt-script-gt-标签的async-”async”属性\"><a href=\"#1-方案一：-lt-script-gt-标签的async-”async”属性\" class=\"headerlink\" title=\"1. 方案一：&lt;script&gt;标签的async=”async”属性\"></a>1. 方案一：<code>&lt;script&gt;</code>标签的async=”async”属性</h3><p><strong>HTML5</strong>中新增的async属性，脚本会<strong>异步加载</strong>(注意是加载而不是执行！！！)，加载时不会阻塞页面，加载完马上执行，执行时仍然会阻塞页面的解析。</p>\n<p>由于async脚本何时加载完是不确定的，所以async脚本执行的时机是不确定的。</p>\n<p>因此，若有多个脚本，这种方法不能保证脚本按顺序执行。</p>\n<p>注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。</p>\n<p><strong>特点：可以跨域，多个脚本不能按顺序执行。</strong></p>\n<h3 id=\"2-方案二：-lt-script-gt-标签的defer-”defer”属性\"><a href=\"#2-方案二：-lt-script-gt-标签的defer-”defer”属性\" class=\"headerlink\" title=\"2. 方案二：&lt;script&gt;标签的defer=”defer”属性\"></a>2. 方案二：<code>&lt;script&gt;</code>标签的defer=”defer”属性</h3><p>defer的作用是：阻止脚本在下载完成后立即执行，会让脚本延迟到所有脚本加载执行完成后顺序执行。</p>\n<p>设置了defer属性之后，脚本会<strong>异步加载</strong>，加载完之后不会马上执行，等到页面解析完毕之后再按顺序执行。</p>\n<p>因此，设置了defer属性的脚本不会阻塞页面的执行。</p>\n<p>此外，这种方法可以确保所有设置defer属性的脚本按顺序执行。</p>\n<p><strong>特点：可以跨域，多个脚本可以按顺序执行。</strong></p>\n<p><strong>defer和async这两个特性的初衷也是希望能够解决或者缓解阻塞对于页面体验的影响</strong></p>\n<p>defer和async优先级的问题：</p>\n<ul>\n<li>如果<code>&lt;script&gt;</code>元素同时定义了defer和async特性，则按async来处理（注意：对于不支持async的浏览器会直接忽略async特性）</li>\n<li>如果<code>&lt;script&gt;</code>元素只定义了defer，则按延迟脚本的方式处理</li>\n<li>如果<code>&lt;script&gt;</code>元素没有定义defer也没有定义async，则按正常情况处理，即：脚本立即加载和执行</li>\n</ul>\n<h3 id=\"3-方案三：动态创建-lt-script-gt-标签\"><a href=\"#3-方案三：动态创建-lt-script-gt-标签\" class=\"headerlink\" title=\"3. 方案三：动态创建&lt;script&gt;标签\"></a>3. 方案三：动态创建<code>&lt;script&gt;</code>标签</h3><p>示例：<br>        <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">  \t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">\t    \t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t    \t<span class=\"keyword\">var</span> s = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">\t\t    \ts.type = <span class=\"string\">'text/javascript'</span>;</span><br><span class=\"line\">\t\t    \ts.src = <span class=\"string\">\"http://code.jquery.com/jquery-1.7.2.min.js\"</span>;</span><br><span class=\"line\">\t\t    \t<span class=\"keyword\">var</span> tmp = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'script'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t    \ttmp.parentNode.insertBefore(s, tmp);<span class=\"comment\">//在这个script标签前再加一个script标签</span></span><br><span class=\"line\">\t    \t&#125;)();</span><br><span class=\"line\">    \t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg\"</span> /&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>在执行最后一行代码之前，是不会加载外部文件的。</p>\n<p>此文件元素添加到页面后立即开始下载。此技术的重点在于：无论在何处启动下载，脚本的下载和运行都不会阻塞页面的处理过程。</p>\n<p><strong>优点：允许跨域，多个脚本可以按顺序执行。</strong></p>\n<h3 id=\"4-AJAX\"><a href=\"#4-AJAX\" class=\"headerlink\" title=\"4. AJAX\"></a>4. AJAX</h3><p>使用XHR对象加载js代码并注入页面</p>\n<p><strong>思路1：XHR 注入</strong></p>\n<p>先创建一个XMLHttpRequest对象，加载js文件，最后通过<strong>动态添加<code>&lt;script&gt;</code>元素</strong>将代码注入页面。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"get\"</span>,<span class=\"string\">\"file.js\"</span>,<span class=\"literal\">true</span>);<span class=\"comment\">//发送GET请求file.js文件</span></span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(xhr.readyState == <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> myScript = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">\t\t\tmyScript.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">\t\t\tmyScript.text = xhr.responseText;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">document</span>.body.appendChild(myScript);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>思路2：XHR eval</strong></p>\n<p>先创建一个XMLHttpRequest对象，加载js文件，然后将加载得到的js代码放到eval()函数内</p>\n<p>eval() 它是一个动态执行函数,可以把脚本语句写成字符串,然后用它来执行，eval() 函数可计算某个字符串，并执行其中的 JavaScript 代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>,<span class=\"string\">'file.js'</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(xhr.readystate == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt;= <span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">eval</span>(xhr.responseText);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>特点：这两种方法都不允许跨域，不能确保多个脚本按顺序执行。</strong></p>\n<h3 id=\"5-iframe方式（这里可以参照：iframe异步加载技术及性能-中关于Meboo的部分）\"><a href=\"#5-iframe方式（这里可以参照：iframe异步加载技术及性能-中关于Meboo的部分）\" class=\"headerlink\" title=\"5. iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）\"></a>5. iframe方式（这里可以参照：iframe异步加载技术及性能 中关于Meboo的部分）</h3><p>不允许跨域访问。</p>\n<p>使用iframe是因为它可以和主页面并行加载，不会阻塞主页面。</p>\n<p>iframe会阻塞主页面的onload事件</p>\n<p>主页面和iframe共享同一个连接池</p>\n"},{"layout":"post","title":"浏览器本地存储","date":"2016-03-28T16:00:00.000Z","description":null,"_content":"\n#### 一. 什么是缓存\n\n**web缓存**是一个设备，这个设备可以自动保存常用的文档的副本。在客户端发起请求的时候，如果就近的缓存拥有客户端想要的副本，那么就会加快网站的响应速度。\n\n在出现**带宽不足**、**瞬间拥塞**（很多用户同时访问某一站点）、**距离时延**（由于距离很远产生时延）这些情况下，缓存的优势就会体现出来了。\n\n缓存可分为：**私有缓存**和**公有缓存**。\n\n**私有缓存**是个人缓存，包含单个用户最常用的页面。（浏览器的缓存是私有缓存）\n\n**公有缓存**包含了某个用户团体的常用的页面。\n\n#### 二. 浏览器存储\n\n**浏览器存储**（Browser Caching）是浏览器的一种优化机制。浏览器的缓存中保存了用户经常访问的一些文档的副本，避免了一些重复的网络请求，浏览器能够快速地读取本地的数据，这样就会加快网站的访问速度。\n\n##### 1. 浏览器有哪几种缓存机制\n\n浏览器一共有九种缓存机制\n\n打开浏览器 -> 点击F12 -> 点resourses\n\n可以看到浏览器的八种缓存机制\n\n![浏览器的几种缓存机制](/uploads/post/20160329/broswer-caching.jpg)\n\n#### (1). http缓存\n\nhttp缓存是基于http协议的浏览器文件缓存机制，当重复请求某一个文件时，浏览器可以根据协议的头文件判断是从服务器端请求文件还是从本地读取文件。\n\n上图中的Frames展示的就是http缓存\n\n![http缓存](/uploads/post/20160329/http-caching.jpg)\n\n**a. 判断过期的两种方式：Expires和Cache-Control:max-age**\n\n    Expires：存的是绝对的过期的日期（例如：牛奶的保质期）\n    \n    Cache-Control:max-age 存的是还可以保鲜多久，是相对时间，用秒做单位\n\n**b. 如果a中判断缓存已经过期，那么就要进行缓存再验证**\n\n缓存再验证的两种方式：\n请求报文里携带\nIf-Modified-Since:Date和If-None-Match\n\n    If-Modified-Since:Date  对修改日期进行验证\n    \n    If-None-Match：<tags> 对实体标签的版本标识符进行验证\n    \n例如：\n\n    响应报文：\n    \n      HTTP/1.1 200 OK   \n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n      ETag: \"10c24bc-4ab-457e1c1f\"   \n      Content-Length: 12195\n\n    下一次的请求报文 ：\n    \n      GET /i/yahoo.gif HTTP/1.1   \n      Host: us.yimg.com   \n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n      If-None-Match: \"10c24bc-4ab-457e1c1f\"  \n      \n    再次响应的报文：\n     \n      HTTP/1.1 304 Not Modified\n\n**c. b中再验证的结果有两种：服务器中的文件未修改 和 服务器中的文件有修改**\n\n    服务器中的文件未修改：缓存中的副本可以使用，那么浏览器直接从缓存读取文档，返回304\n    \n    服务器中的文件有修改：缓存中的副本不能使用，那么直接从服务器端读取文档，返回200\n\n#### (2). indexDB 客户端本地数据库（大型数据库）\n\nindexDB是浏览器中的一种数据库，用来保存结构化数据。\n\nindexDB设计的操作完全是异步进行的。\n\nindexDB最大的特色是**使用对象保存数据**。\n\nindexDB.open(\"database\") 打开数据库 或者 创建并打开数据库\n\nindexDB.setVersion(\"1.0\") 为数据库指定一个版本号\n\ndatabase.transaction(); 创建事务，对数据库进行操作\n\nopenCursor() 在对象存储空间上调用这个方法，通过游标查找数据\n\ncreateIndex() 创建索引\n\nindexDB的并发问题\n\n#### (3). Cookies \n\n **1.cookies是什么**\n\ncookies是服务器用来标识web用户的一小块数据。\n\ncookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。\n\nCookies是由服务器端生成，发送给浏览器，浏览器会将Cookies的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookies给服务器（前提是浏览器设置为启用cookies）。\n\nCookies一般存在用户本地终端上，通常经过加密处理。\n\nCookies一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递。\n\n一条cookie记录主要由键、值、域、过期时间、大小组成。\n\n**2. cookies的分类：持久cookies 和 会话cookies**\n\n\t一般而言，我们所说的cookie是指的持久cookie（设置了过期时间的cookie）\n\n    持久cookie：存储在硬盘上\n\n    持久cookie：是在过期时间之后消失。\n\n\t持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n\n**补充一点点：**\n\n不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。\n\n**3. cookies的安全性问题：**\n\n第三方web站点使用持久cookie来跟踪用户，当用户访问同一个广告公司提供的站点，浏览器就会回送之前设置的持久cookie，广告公司便可构建成一个用户档案和浏览习惯的详尽数据集。\n\n#### (4). storage类型\n\n有如下方法：\n\n- clear()\n- getItem(name)\n- key(index)\n- removeItem(name)\n- setItem(name,value)\n\n\n- localStorage对象：要访问同一个localStorage对象，页面必须同源\n- sessionstorage对象：只能被最初给对象存储的页面所访问\n- globalStorage对象：已被localStorage对象所取代\n\n修改localStorage对象、sessionstorage对象都会触发 document 的 storage事件\n\n**localstorage** 和 **sessionstorage** 都是**HTML5**提供的在**客户端**存储数据的新方法。\n\n这两个都是windows对象的属性。\n\n**其主要区别是：**\n\nlocalStorage - 没有时间限制的数据存储，主要用来存储ajax返回的数据，加快下次访问的渲染速度。\n\nsessionStorage - 针对一个 session 的数据存储。浏览器关闭后就删除。\n\n不同的浏览器无法共享localStorage或sessionStorage中的信息。\n\n\n    注意：cookies、localStorage、sessionStorage的区别\n    \n    1. 存储时间不同\n    \n    持久cookies在过期日期之前都会存在\n    \n    localStorage会一直存在，除非主动删除\n    \n    sessionStorage在标签页关闭之后就会删除\n    \n    2. 存储的位置不同\n    \n    持久cookies是存在用户终端，也就是电脑硬盘上，cookies始终在同源的http请求中携带，会在浏览器和服务器间来回传递。\n    \n    localStorage和sessionStorage是存在浏览器端\n    \n    3. 存储大小不同\n    \n    cookies数据大小不能超过4k\n    \n    sessionStorage和localStorage存储大小比cookies大得多，可以达到5M\n    \n    4. cookie还需要指定作用域，不允许跨域调用\n\nlocalStorage、sessionStorage的使用场景：\n\nlocalStorage实现离线操作，新闻编辑上传功能，离线时保存在本地，有线时上传；保存用户配置项。\n\n希望用户关闭页面之后就销毁的数据可以保存在sessionStorage中\n\n#### (6). application cache 离线存储\n\n**1.什么是application cache**\n\napplication cache是**HTML5**的新特性，允许**浏览器**在本地存储页面所需要的资源，使得页面离线也可以访问。\n\n在用户没有与因特网进行连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\napplication cache是从浏览器的缓存中分出来的一块缓存区。\n\n**如何判断设备是否离线？**\n\n```\nif(navigator.onLine) {\n\n\t//设备在线时的操作\n\n} else {\n\t//设备离线时的操作\n}\n```\n\nwindow对象上定义了2个事件：\n\n- online: 设备从离线变成在线\n- offline: 设备从在线变成离线  \n\n**2.使用方法**\n\na. 首先需要写一下application cache的配置文件\n\n配置文件称为缓存清单文件（cache manifest），这个很好理解，可以理解成我们**通过这个文件告诉浏览器需要缓存哪些文件**。\n\n这个文件一般为.appcache类型\n\n缓存清单文件一般包括4个部分：\n\n第一部分  文件头部信息 标注文件类型\n\n    CACHE MANIFEST\n    # version XX.XX.XX\n\n第二部分  CACHE部分  标注哪些资源文件需要被缓存\n\n    CACHE：\n    image.png\n    myjavascript.js\n\n第三部分  NETWORK部分  标注哪些文件需要连接服务器\n\n    NETWORK：\n    login.php\n\n<font color=\"red\">注意：如果CACHE和NETWORK里面有相同的资源，那么这个资源还是会被离线缓存，CACHE的有限级更高。</font>\n\n第四部分  FALLBACK  表示没有响应时的替代方案\n\n    FALLBACK：\n    static.htmi\n\nb. 在html标签上添加manifest属性\n\n    <html manifest=\"name.appcache\">\n    \n    name.appcache为离线存储的配置文件\n\nc. 在离线状态下操作window.applicationCache进行需求实现\n\n另外，需要注意的是更新缓存。可以通过window.applicationCache 对象来访问浏览器的app cache。\n\n    window.applicationCache.status 为cache当前的状态\n    \n    window.applicationCache.update() 会更新当前的缓存\n\n    window.applicationCache.swapCache() 会启用新的缓存\n\n    oncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。\n\n    onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件\n    ondownloading:当浏览器开始下载离线资源的时候会触发这个事件\n\n    onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。\n\n    onupdateready:当浏览器对离线资源更新完成之后会触发这个事件\n\n    onnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件\n\n在网上看到的一篇讲离线存储讲得很好的文章，[https://segmentfault.com/a/1190000000732617](https://segmentfault.com/a/1190000000732617 \"HTML5：离线储存\")\n\n#### (7). cacheStorage\n\ncacheStorage 在浏览器上的引用名叫 caches \n\nCacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象\n\ncacheStorage有open、match、has、delete、keys五个核心方法，可以对cache对象的不同匹配进行不同的响应\n\n[https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage \"CacheStorage的MDN\")\n\n#### (8). flash缓存\n\n这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能，同时也可以向js提供调用的api，则页面可以通过js调用flash去读写特定的磁盘目录，达到本地数据缓存的目的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-29-浏览器本地存储.md","raw":"---\nlayout: post\ntitle: 浏览器本地存储\ndate: 2016-03-29\ncategories: 浏览器\ntags: [浏览器,缓存]\ndescription: \n---\n\n#### 一. 什么是缓存\n\n**web缓存**是一个设备，这个设备可以自动保存常用的文档的副本。在客户端发起请求的时候，如果就近的缓存拥有客户端想要的副本，那么就会加快网站的响应速度。\n\n在出现**带宽不足**、**瞬间拥塞**（很多用户同时访问某一站点）、**距离时延**（由于距离很远产生时延）这些情况下，缓存的优势就会体现出来了。\n\n缓存可分为：**私有缓存**和**公有缓存**。\n\n**私有缓存**是个人缓存，包含单个用户最常用的页面。（浏览器的缓存是私有缓存）\n\n**公有缓存**包含了某个用户团体的常用的页面。\n\n#### 二. 浏览器存储\n\n**浏览器存储**（Browser Caching）是浏览器的一种优化机制。浏览器的缓存中保存了用户经常访问的一些文档的副本，避免了一些重复的网络请求，浏览器能够快速地读取本地的数据，这样就会加快网站的访问速度。\n\n##### 1. 浏览器有哪几种缓存机制\n\n浏览器一共有九种缓存机制\n\n打开浏览器 -> 点击F12 -> 点resourses\n\n可以看到浏览器的八种缓存机制\n\n![浏览器的几种缓存机制](/uploads/post/20160329/broswer-caching.jpg)\n\n#### (1). http缓存\n\nhttp缓存是基于http协议的浏览器文件缓存机制，当重复请求某一个文件时，浏览器可以根据协议的头文件判断是从服务器端请求文件还是从本地读取文件。\n\n上图中的Frames展示的就是http缓存\n\n![http缓存](/uploads/post/20160329/http-caching.jpg)\n\n**a. 判断过期的两种方式：Expires和Cache-Control:max-age**\n\n    Expires：存的是绝对的过期的日期（例如：牛奶的保质期）\n    \n    Cache-Control:max-age 存的是还可以保鲜多久，是相对时间，用秒做单位\n\n**b. 如果a中判断缓存已经过期，那么就要进行缓存再验证**\n\n缓存再验证的两种方式：\n请求报文里携带\nIf-Modified-Since:Date和If-None-Match\n\n    If-Modified-Since:Date  对修改日期进行验证\n    \n    If-None-Match：<tags> 对实体标签的版本标识符进行验证\n    \n例如：\n\n    响应报文：\n    \n      HTTP/1.1 200 OK   \n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n      ETag: \"10c24bc-4ab-457e1c1f\"   \n      Content-Length: 12195\n\n    下一次的请求报文 ：\n    \n      GET /i/yahoo.gif HTTP/1.1   \n      Host: us.yimg.com   \n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n      If-None-Match: \"10c24bc-4ab-457e1c1f\"  \n      \n    再次响应的报文：\n     \n      HTTP/1.1 304 Not Modified\n\n**c. b中再验证的结果有两种：服务器中的文件未修改 和 服务器中的文件有修改**\n\n    服务器中的文件未修改：缓存中的副本可以使用，那么浏览器直接从缓存读取文档，返回304\n    \n    服务器中的文件有修改：缓存中的副本不能使用，那么直接从服务器端读取文档，返回200\n\n#### (2). indexDB 客户端本地数据库（大型数据库）\n\nindexDB是浏览器中的一种数据库，用来保存结构化数据。\n\nindexDB设计的操作完全是异步进行的。\n\nindexDB最大的特色是**使用对象保存数据**。\n\nindexDB.open(\"database\") 打开数据库 或者 创建并打开数据库\n\nindexDB.setVersion(\"1.0\") 为数据库指定一个版本号\n\ndatabase.transaction(); 创建事务，对数据库进行操作\n\nopenCursor() 在对象存储空间上调用这个方法，通过游标查找数据\n\ncreateIndex() 创建索引\n\nindexDB的并发问题\n\n#### (3). Cookies \n\n **1.cookies是什么**\n\ncookies是服务器用来标识web用户的一小块数据。\n\ncookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。\n\nCookies是由服务器端生成，发送给浏览器，浏览器会将Cookies的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookies给服务器（前提是浏览器设置为启用cookies）。\n\nCookies一般存在用户本地终端上，通常经过加密处理。\n\nCookies一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递。\n\n一条cookie记录主要由键、值、域、过期时间、大小组成。\n\n**2. cookies的分类：持久cookies 和 会话cookies**\n\n\t一般而言，我们所说的cookie是指的持久cookie（设置了过期时间的cookie）\n\n    持久cookie：存储在硬盘上\n\n    持久cookie：是在过期时间之后消失。\n\n\t持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n\n**补充一点点：**\n\n不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。\n\n**3. cookies的安全性问题：**\n\n第三方web站点使用持久cookie来跟踪用户，当用户访问同一个广告公司提供的站点，浏览器就会回送之前设置的持久cookie，广告公司便可构建成一个用户档案和浏览习惯的详尽数据集。\n\n#### (4). storage类型\n\n有如下方法：\n\n- clear()\n- getItem(name)\n- key(index)\n- removeItem(name)\n- setItem(name,value)\n\n\n- localStorage对象：要访问同一个localStorage对象，页面必须同源\n- sessionstorage对象：只能被最初给对象存储的页面所访问\n- globalStorage对象：已被localStorage对象所取代\n\n修改localStorage对象、sessionstorage对象都会触发 document 的 storage事件\n\n**localstorage** 和 **sessionstorage** 都是**HTML5**提供的在**客户端**存储数据的新方法。\n\n这两个都是windows对象的属性。\n\n**其主要区别是：**\n\nlocalStorage - 没有时间限制的数据存储，主要用来存储ajax返回的数据，加快下次访问的渲染速度。\n\nsessionStorage - 针对一个 session 的数据存储。浏览器关闭后就删除。\n\n不同的浏览器无法共享localStorage或sessionStorage中的信息。\n\n\n    注意：cookies、localStorage、sessionStorage的区别\n    \n    1. 存储时间不同\n    \n    持久cookies在过期日期之前都会存在\n    \n    localStorage会一直存在，除非主动删除\n    \n    sessionStorage在标签页关闭之后就会删除\n    \n    2. 存储的位置不同\n    \n    持久cookies是存在用户终端，也就是电脑硬盘上，cookies始终在同源的http请求中携带，会在浏览器和服务器间来回传递。\n    \n    localStorage和sessionStorage是存在浏览器端\n    \n    3. 存储大小不同\n    \n    cookies数据大小不能超过4k\n    \n    sessionStorage和localStorage存储大小比cookies大得多，可以达到5M\n    \n    4. cookie还需要指定作用域，不允许跨域调用\n\nlocalStorage、sessionStorage的使用场景：\n\nlocalStorage实现离线操作，新闻编辑上传功能，离线时保存在本地，有线时上传；保存用户配置项。\n\n希望用户关闭页面之后就销毁的数据可以保存在sessionStorage中\n\n#### (6). application cache 离线存储\n\n**1.什么是application cache**\n\napplication cache是**HTML5**的新特性，允许**浏览器**在本地存储页面所需要的资源，使得页面离线也可以访问。\n\n在用户没有与因特网进行连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\napplication cache是从浏览器的缓存中分出来的一块缓存区。\n\n**如何判断设备是否离线？**\n\n```\nif(navigator.onLine) {\n\n\t//设备在线时的操作\n\n} else {\n\t//设备离线时的操作\n}\n```\n\nwindow对象上定义了2个事件：\n\n- online: 设备从离线变成在线\n- offline: 设备从在线变成离线  \n\n**2.使用方法**\n\na. 首先需要写一下application cache的配置文件\n\n配置文件称为缓存清单文件（cache manifest），这个很好理解，可以理解成我们**通过这个文件告诉浏览器需要缓存哪些文件**。\n\n这个文件一般为.appcache类型\n\n缓存清单文件一般包括4个部分：\n\n第一部分  文件头部信息 标注文件类型\n\n    CACHE MANIFEST\n    # version XX.XX.XX\n\n第二部分  CACHE部分  标注哪些资源文件需要被缓存\n\n    CACHE：\n    image.png\n    myjavascript.js\n\n第三部分  NETWORK部分  标注哪些文件需要连接服务器\n\n    NETWORK：\n    login.php\n\n<font color=\"red\">注意：如果CACHE和NETWORK里面有相同的资源，那么这个资源还是会被离线缓存，CACHE的有限级更高。</font>\n\n第四部分  FALLBACK  表示没有响应时的替代方案\n\n    FALLBACK：\n    static.htmi\n\nb. 在html标签上添加manifest属性\n\n    <html manifest=\"name.appcache\">\n    \n    name.appcache为离线存储的配置文件\n\nc. 在离线状态下操作window.applicationCache进行需求实现\n\n另外，需要注意的是更新缓存。可以通过window.applicationCache 对象来访问浏览器的app cache。\n\n    window.applicationCache.status 为cache当前的状态\n    \n    window.applicationCache.update() 会更新当前的缓存\n\n    window.applicationCache.swapCache() 会启用新的缓存\n\n    oncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。\n\n    onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件\n    ondownloading:当浏览器开始下载离线资源的时候会触发这个事件\n\n    onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。\n\n    onupdateready:当浏览器对离线资源更新完成之后会触发这个事件\n\n    onnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件\n\n在网上看到的一篇讲离线存储讲得很好的文章，[https://segmentfault.com/a/1190000000732617](https://segmentfault.com/a/1190000000732617 \"HTML5：离线储存\")\n\n#### (7). cacheStorage\n\ncacheStorage 在浏览器上的引用名叫 caches \n\nCacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象\n\ncacheStorage有open、match、has、delete、keys五个核心方法，可以对cache对象的不同匹配进行不同的响应\n\n[https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage \"CacheStorage的MDN\")\n\n#### (8). flash缓存\n\n这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能，同时也可以向js提供调用的api，则页面可以通过js调用flash去读写特定的磁盘目录，达到本地数据缓存的目的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-29-浏览器本地存储","published":1,"updated":"2016-10-12T11:55:52.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocd3001kd5u865snwpt7","content":"<h4 id=\"一-什么是缓存\"><a href=\"#一-什么是缓存\" class=\"headerlink\" title=\"一. 什么是缓存\"></a>一. 什么是缓存</h4><p><strong>web缓存</strong>是一个设备，这个设备可以自动保存常用的文档的副本。在客户端发起请求的时候，如果就近的缓存拥有客户端想要的副本，那么就会加快网站的响应速度。</p>\n<p>在出现<strong>带宽不足</strong>、<strong>瞬间拥塞</strong>（很多用户同时访问某一站点）、<strong>距离时延</strong>（由于距离很远产生时延）这些情况下，缓存的优势就会体现出来了。</p>\n<p>缓存可分为：<strong>私有缓存</strong>和<strong>公有缓存</strong>。</p>\n<p><strong>私有缓存</strong>是个人缓存，包含单个用户最常用的页面。（浏览器的缓存是私有缓存）</p>\n<p><strong>公有缓存</strong>包含了某个用户团体的常用的页面。</p>\n<h4 id=\"二-浏览器存储\"><a href=\"#二-浏览器存储\" class=\"headerlink\" title=\"二. 浏览器存储\"></a>二. 浏览器存储</h4><p><strong>浏览器存储</strong>（Browser Caching）是浏览器的一种优化机制。浏览器的缓存中保存了用户经常访问的一些文档的副本，避免了一些重复的网络请求，浏览器能够快速地读取本地的数据，这样就会加快网站的访问速度。</p>\n<h5 id=\"1-浏览器有哪几种缓存机制\"><a href=\"#1-浏览器有哪几种缓存机制\" class=\"headerlink\" title=\"1. 浏览器有哪几种缓存机制\"></a>1. 浏览器有哪几种缓存机制</h5><p>浏览器一共有九种缓存机制</p>\n<p>打开浏览器 -&gt; 点击F12 -&gt; 点resourses</p>\n<p>可以看到浏览器的八种缓存机制</p>\n<p><img src=\"/uploads/post/20160329/broswer-caching.jpg\" alt=\"浏览器的几种缓存机制\"></p>\n<h4 id=\"1-http缓存\"><a href=\"#1-http缓存\" class=\"headerlink\" title=\"(1). http缓存\"></a>(1). http缓存</h4><p>http缓存是基于http协议的浏览器文件缓存机制，当重复请求某一个文件时，浏览器可以根据协议的头文件判断是从服务器端请求文件还是从本地读取文件。</p>\n<p>上图中的Frames展示的就是http缓存</p>\n<p><img src=\"/uploads/post/20160329/http-caching.jpg\" alt=\"http缓存\"></p>\n<p><strong>a. 判断过期的两种方式：Expires和Cache-Control:max-age</strong></p>\n<pre><code>Expires：存的是绝对的过期的日期（例如：牛奶的保质期）\n\nCache-Control:max-age 存的是还可以保鲜多久，是相对时间，用秒做单位\n</code></pre><p><strong>b. 如果a中判断缓存已经过期，那么就要进行缓存再验证</strong></p>\n<p>缓存再验证的两种方式：<br>请求报文里携带<br>If-Modified-Since:Date和If-None-Match</p>\n<pre><code>If-Modified-Since:Date  对修改日期进行验证\n\nIf-None-Match：&lt;tags&gt; 对实体标签的版本标识符进行验证\n</code></pre><p>例如：</p>\n<pre><code>响应报文：\n\n  HTTP/1.1 200 OK   \n  Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n  ETag: &quot;10c24bc-4ab-457e1c1f&quot;   \n  Content-Length: 12195\n\n下一次的请求报文 ：\n\n  GET /i/yahoo.gif HTTP/1.1   \n  Host: us.yimg.com   \n  If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n  If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;  \n\n再次响应的报文：\n\n  HTTP/1.1 304 Not Modified\n</code></pre><p><strong>c. b中再验证的结果有两种：服务器中的文件未修改 和 服务器中的文件有修改</strong></p>\n<pre><code>服务器中的文件未修改：缓存中的副本可以使用，那么浏览器直接从缓存读取文档，返回304\n\n服务器中的文件有修改：缓存中的副本不能使用，那么直接从服务器端读取文档，返回200\n</code></pre><h4 id=\"2-indexDB-客户端本地数据库（大型数据库）\"><a href=\"#2-indexDB-客户端本地数据库（大型数据库）\" class=\"headerlink\" title=\"(2). indexDB 客户端本地数据库（大型数据库）\"></a>(2). indexDB 客户端本地数据库（大型数据库）</h4><p>indexDB是浏览器中的一种数据库，用来保存结构化数据。</p>\n<p>indexDB设计的操作完全是异步进行的。</p>\n<p>indexDB最大的特色是<strong>使用对象保存数据</strong>。</p>\n<p>indexDB.open(“database”) 打开数据库 或者 创建并打开数据库</p>\n<p>indexDB.setVersion(“1.0”) 为数据库指定一个版本号</p>\n<p>database.transaction(); 创建事务，对数据库进行操作</p>\n<p>openCursor() 在对象存储空间上调用这个方法，通过游标查找数据</p>\n<p>createIndex() 创建索引</p>\n<p>indexDB的并发问题</p>\n<h4 id=\"3-Cookies\"><a href=\"#3-Cookies\" class=\"headerlink\" title=\"(3). Cookies\"></a>(3). Cookies</h4><p> <strong>1.cookies是什么</strong></p>\n<p>cookies是服务器用来标识web用户的一小块数据。</p>\n<p>cookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。</p>\n<p>Cookies是由服务器端生成，发送给浏览器，浏览器会将Cookies的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookies给服务器（前提是浏览器设置为启用cookies）。</p>\n<p>Cookies一般存在用户本地终端上，通常经过加密处理。</p>\n<p>Cookies一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递。</p>\n<p>一条cookie记录主要由键、值、域、过期时间、大小组成。</p>\n<p><strong>2. cookies的分类：持久cookies 和 会话cookies</strong></p>\n<pre><code>一般而言，我们所说的cookie是指的持久cookie（设置了过期时间的cookie）\n\n持久cookie：存储在硬盘上\n\n持久cookie：是在过期时间之后消失。\n\n持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n</code></pre><p><strong>补充一点点：</strong></p>\n<p>不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。</p>\n<p><strong>3. cookies的安全性问题：</strong></p>\n<p>第三方web站点使用持久cookie来跟踪用户，当用户访问同一个广告公司提供的站点，浏览器就会回送之前设置的持久cookie，广告公司便可构建成一个用户档案和浏览习惯的详尽数据集。</p>\n<h4 id=\"4-storage类型\"><a href=\"#4-storage类型\" class=\"headerlink\" title=\"(4). storage类型\"></a>(4). storage类型</h4><p>有如下方法：</p>\n<ul>\n<li>clear()</li>\n<li>getItem(name)</li>\n<li>key(index)</li>\n<li>removeItem(name)</li>\n<li>setItem(name,value)</li>\n</ul>\n<ul>\n<li>localStorage对象：要访问同一个localStorage对象，页面必须同源</li>\n<li>sessionstorage对象：只能被最初给对象存储的页面所访问</li>\n<li>globalStorage对象：已被localStorage对象所取代</li>\n</ul>\n<p>修改localStorage对象、sessionstorage对象都会触发 document 的 storage事件</p>\n<p><strong>localstorage</strong> 和 <strong>sessionstorage</strong> 都是<strong>HTML5</strong>提供的在<strong>客户端</strong>存储数据的新方法。</p>\n<p>这两个都是windows对象的属性。</p>\n<p><strong>其主要区别是：</strong></p>\n<p>localStorage - 没有时间限制的数据存储，主要用来存储ajax返回的数据，加快下次访问的渲染速度。</p>\n<p>sessionStorage - 针对一个 session 的数据存储。浏览器关闭后就删除。</p>\n<p>不同的浏览器无法共享localStorage或sessionStorage中的信息。</p>\n<pre><code>注意：cookies、localStorage、sessionStorage的区别\n\n1. 存储时间不同\n\n持久cookies在过期日期之前都会存在\n\nlocalStorage会一直存在，除非主动删除\n\nsessionStorage在标签页关闭之后就会删除\n\n2. 存储的位置不同\n\n持久cookies是存在用户终端，也就是电脑硬盘上，cookies始终在同源的http请求中携带，会在浏览器和服务器间来回传递。\n\nlocalStorage和sessionStorage是存在浏览器端\n\n3. 存储大小不同\n\ncookies数据大小不能超过4k\n\nsessionStorage和localStorage存储大小比cookies大得多，可以达到5M\n\n4. cookie还需要指定作用域，不允许跨域调用\n</code></pre><p>localStorage、sessionStorage的使用场景：</p>\n<p>localStorage实现离线操作，新闻编辑上传功能，离线时保存在本地，有线时上传；保存用户配置项。</p>\n<p>希望用户关闭页面之后就销毁的数据可以保存在sessionStorage中</p>\n<h4 id=\"6-application-cache-离线存储\"><a href=\"#6-application-cache-离线存储\" class=\"headerlink\" title=\"(6). application cache 离线存储\"></a>(6). application cache 离线存储</h4><p><strong>1.什么是application cache</strong></p>\n<p>application cache是<strong>HTML5</strong>的新特性，允许<strong>浏览器</strong>在本地存储页面所需要的资源，使得页面离线也可以访问。</p>\n<p>在用户没有与因特网进行连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p>application cache是从浏览器的缓存中分出来的一块缓存区。</p>\n<p><strong>如何判断设备是否离线？</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span><span class=\"params\">(navigator.onLine)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//设备在线时的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//设备离线时的操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>window对象上定义了2个事件：</p>\n<ul>\n<li>online: 设备从离线变成在线</li>\n<li>offline: 设备从在线变成离线  </li>\n</ul>\n<p><strong>2.使用方法</strong></p>\n<p>a. 首先需要写一下application cache的配置文件</p>\n<p>配置文件称为缓存清单文件（cache manifest），这个很好理解，可以理解成我们<strong>通过这个文件告诉浏览器需要缓存哪些文件</strong>。</p>\n<p>这个文件一般为.appcache类型</p>\n<p>缓存清单文件一般包括4个部分：</p>\n<p>第一部分  文件头部信息 标注文件类型</p>\n<pre><code>CACHE MANIFEST\n# version XX.XX.XX\n</code></pre><p>第二部分  CACHE部分  标注哪些资源文件需要被缓存</p>\n<pre><code>CACHE：\nimage.png\nmyjavascript.js\n</code></pre><p>第三部分  NETWORK部分  标注哪些文件需要连接服务器</p>\n<pre><code>NETWORK：\nlogin.php\n</code></pre><font color=\"red\">注意：如果CACHE和NETWORK里面有相同的资源，那么这个资源还是会被离线缓存，CACHE的有限级更高。</font>\n\n<p>第四部分  FALLBACK  表示没有响应时的替代方案</p>\n<pre><code>FALLBACK：\nstatic.htmi\n</code></pre><p>b. 在html标签上添加manifest属性</p>\n<pre><code>&lt;html manifest=&quot;name.appcache&quot;&gt;\n\nname.appcache为离线存储的配置文件\n</code></pre><p>c. 在离线状态下操作window.applicationCache进行需求实现</p>\n<p>另外，需要注意的是更新缓存。可以通过window.applicationCache 对象来访问浏览器的app cache。</p>\n<pre><code>window.applicationCache.status 为cache当前的状态\n\nwindow.applicationCache.update() 会更新当前的缓存\n\nwindow.applicationCache.swapCache() 会启用新的缓存\n\noncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。\n\nonchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件\nondownloading:当浏览器开始下载离线资源的时候会触发这个事件\n\nonprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。\n\nonupdateready:当浏览器对离线资源更新完成之后会触发这个事件\n\nonnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件\n</code></pre><p>在网上看到的一篇讲离线存储讲得很好的文章，<a href=\"https://segmentfault.com/a/1190000000732617\" title=\"HTML5：离线储存\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000000732617</a></p>\n<h4 id=\"7-cacheStorage\"><a href=\"#7-cacheStorage\" class=\"headerlink\" title=\"(7). cacheStorage\"></a>(7). cacheStorage</h4><p>cacheStorage 在浏览器上的引用名叫 caches </p>\n<p>CacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象</p>\n<p>cacheStorage有open、match、has、delete、keys五个核心方法，可以对cache对象的不同匹配进行不同的响应</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage\" title=\"CacheStorage的MDN\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage</a></p>\n<h4 id=\"8-flash缓存\"><a href=\"#8-flash缓存\" class=\"headerlink\" title=\"(8). flash缓存\"></a>(8). flash缓存</h4><p>这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能，同时也可以向js提供调用的api，则页面可以通过js调用flash去读写特定的磁盘目录，达到本地数据缓存的目的。</p>\n","excerpt":"","more":"<h4 id=\"一-什么是缓存\"><a href=\"#一-什么是缓存\" class=\"headerlink\" title=\"一. 什么是缓存\"></a>一. 什么是缓存</h4><p><strong>web缓存</strong>是一个设备，这个设备可以自动保存常用的文档的副本。在客户端发起请求的时候，如果就近的缓存拥有客户端想要的副本，那么就会加快网站的响应速度。</p>\n<p>在出现<strong>带宽不足</strong>、<strong>瞬间拥塞</strong>（很多用户同时访问某一站点）、<strong>距离时延</strong>（由于距离很远产生时延）这些情况下，缓存的优势就会体现出来了。</p>\n<p>缓存可分为：<strong>私有缓存</strong>和<strong>公有缓存</strong>。</p>\n<p><strong>私有缓存</strong>是个人缓存，包含单个用户最常用的页面。（浏览器的缓存是私有缓存）</p>\n<p><strong>公有缓存</strong>包含了某个用户团体的常用的页面。</p>\n<h4 id=\"二-浏览器存储\"><a href=\"#二-浏览器存储\" class=\"headerlink\" title=\"二. 浏览器存储\"></a>二. 浏览器存储</h4><p><strong>浏览器存储</strong>（Browser Caching）是浏览器的一种优化机制。浏览器的缓存中保存了用户经常访问的一些文档的副本，避免了一些重复的网络请求，浏览器能够快速地读取本地的数据，这样就会加快网站的访问速度。</p>\n<h5 id=\"1-浏览器有哪几种缓存机制\"><a href=\"#1-浏览器有哪几种缓存机制\" class=\"headerlink\" title=\"1. 浏览器有哪几种缓存机制\"></a>1. 浏览器有哪几种缓存机制</h5><p>浏览器一共有九种缓存机制</p>\n<p>打开浏览器 -&gt; 点击F12 -&gt; 点resourses</p>\n<p>可以看到浏览器的八种缓存机制</p>\n<p><img src=\"/uploads/post/20160329/broswer-caching.jpg\" alt=\"浏览器的几种缓存机制\"></p>\n<h4 id=\"1-http缓存\"><a href=\"#1-http缓存\" class=\"headerlink\" title=\"(1). http缓存\"></a>(1). http缓存</h4><p>http缓存是基于http协议的浏览器文件缓存机制，当重复请求某一个文件时，浏览器可以根据协议的头文件判断是从服务器端请求文件还是从本地读取文件。</p>\n<p>上图中的Frames展示的就是http缓存</p>\n<p><img src=\"/uploads/post/20160329/http-caching.jpg\" alt=\"http缓存\"></p>\n<p><strong>a. 判断过期的两种方式：Expires和Cache-Control:max-age</strong></p>\n<pre><code>Expires：存的是绝对的过期的日期（例如：牛奶的保质期）\n\nCache-Control:max-age 存的是还可以保鲜多久，是相对时间，用秒做单位\n</code></pre><p><strong>b. 如果a中判断缓存已经过期，那么就要进行缓存再验证</strong></p>\n<p>缓存再验证的两种方式：<br>请求报文里携带<br>If-Modified-Since:Date和If-None-Match</p>\n<pre><code>If-Modified-Since:Date  对修改日期进行验证\n\nIf-None-Match：&lt;tags&gt; 对实体标签的版本标识符进行验证\n</code></pre><p>例如：</p>\n<pre><code>响应报文：\n\n  HTTP/1.1 200 OK   \n  Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n  ETag: &quot;10c24bc-4ab-457e1c1f&quot;   \n  Content-Length: 12195\n\n下一次的请求报文 ：\n\n  GET /i/yahoo.gif HTTP/1.1   \n  Host: us.yimg.com   \n  If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n  If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;  \n\n再次响应的报文：\n\n  HTTP/1.1 304 Not Modified\n</code></pre><p><strong>c. b中再验证的结果有两种：服务器中的文件未修改 和 服务器中的文件有修改</strong></p>\n<pre><code>服务器中的文件未修改：缓存中的副本可以使用，那么浏览器直接从缓存读取文档，返回304\n\n服务器中的文件有修改：缓存中的副本不能使用，那么直接从服务器端读取文档，返回200\n</code></pre><h4 id=\"2-indexDB-客户端本地数据库（大型数据库）\"><a href=\"#2-indexDB-客户端本地数据库（大型数据库）\" class=\"headerlink\" title=\"(2). indexDB 客户端本地数据库（大型数据库）\"></a>(2). indexDB 客户端本地数据库（大型数据库）</h4><p>indexDB是浏览器中的一种数据库，用来保存结构化数据。</p>\n<p>indexDB设计的操作完全是异步进行的。</p>\n<p>indexDB最大的特色是<strong>使用对象保存数据</strong>。</p>\n<p>indexDB.open(“database”) 打开数据库 或者 创建并打开数据库</p>\n<p>indexDB.setVersion(“1.0”) 为数据库指定一个版本号</p>\n<p>database.transaction(); 创建事务，对数据库进行操作</p>\n<p>openCursor() 在对象存储空间上调用这个方法，通过游标查找数据</p>\n<p>createIndex() 创建索引</p>\n<p>indexDB的并发问题</p>\n<h4 id=\"3-Cookies\"><a href=\"#3-Cookies\" class=\"headerlink\" title=\"(3). Cookies\"></a>(3). Cookies</h4><p> <strong>1.cookies是什么</strong></p>\n<p>cookies是服务器用来标识web用户的一小块数据。</p>\n<p>cookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。</p>\n<p>Cookies是由服务器端生成，发送给浏览器，浏览器会将Cookies的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookies给服务器（前提是浏览器设置为启用cookies）。</p>\n<p>Cookies一般存在用户本地终端上，通常经过加密处理。</p>\n<p>Cookies一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递。</p>\n<p>一条cookie记录主要由键、值、域、过期时间、大小组成。</p>\n<p><strong>2. cookies的分类：持久cookies 和 会话cookies</strong></p>\n<pre><code>一般而言，我们所说的cookie是指的持久cookie（设置了过期时间的cookie）\n\n持久cookie：存储在硬盘上\n\n持久cookie：是在过期时间之后消失。\n\n持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n</code></pre><p><strong>补充一点点：</strong></p>\n<p>不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。</p>\n<p><strong>3. cookies的安全性问题：</strong></p>\n<p>第三方web站点使用持久cookie来跟踪用户，当用户访问同一个广告公司提供的站点，浏览器就会回送之前设置的持久cookie，广告公司便可构建成一个用户档案和浏览习惯的详尽数据集。</p>\n<h4 id=\"4-storage类型\"><a href=\"#4-storage类型\" class=\"headerlink\" title=\"(4). storage类型\"></a>(4). storage类型</h4><p>有如下方法：</p>\n<ul>\n<li>clear()</li>\n<li>getItem(name)</li>\n<li>key(index)</li>\n<li>removeItem(name)</li>\n<li>setItem(name,value)</li>\n</ul>\n<ul>\n<li>localStorage对象：要访问同一个localStorage对象，页面必须同源</li>\n<li>sessionstorage对象：只能被最初给对象存储的页面所访问</li>\n<li>globalStorage对象：已被localStorage对象所取代</li>\n</ul>\n<p>修改localStorage对象、sessionstorage对象都会触发 document 的 storage事件</p>\n<p><strong>localstorage</strong> 和 <strong>sessionstorage</strong> 都是<strong>HTML5</strong>提供的在<strong>客户端</strong>存储数据的新方法。</p>\n<p>这两个都是windows对象的属性。</p>\n<p><strong>其主要区别是：</strong></p>\n<p>localStorage - 没有时间限制的数据存储，主要用来存储ajax返回的数据，加快下次访问的渲染速度。</p>\n<p>sessionStorage - 针对一个 session 的数据存储。浏览器关闭后就删除。</p>\n<p>不同的浏览器无法共享localStorage或sessionStorage中的信息。</p>\n<pre><code>注意：cookies、localStorage、sessionStorage的区别\n\n1. 存储时间不同\n\n持久cookies在过期日期之前都会存在\n\nlocalStorage会一直存在，除非主动删除\n\nsessionStorage在标签页关闭之后就会删除\n\n2. 存储的位置不同\n\n持久cookies是存在用户终端，也就是电脑硬盘上，cookies始终在同源的http请求中携带，会在浏览器和服务器间来回传递。\n\nlocalStorage和sessionStorage是存在浏览器端\n\n3. 存储大小不同\n\ncookies数据大小不能超过4k\n\nsessionStorage和localStorage存储大小比cookies大得多，可以达到5M\n\n4. cookie还需要指定作用域，不允许跨域调用\n</code></pre><p>localStorage、sessionStorage的使用场景：</p>\n<p>localStorage实现离线操作，新闻编辑上传功能，离线时保存在本地，有线时上传；保存用户配置项。</p>\n<p>希望用户关闭页面之后就销毁的数据可以保存在sessionStorage中</p>\n<h4 id=\"6-application-cache-离线存储\"><a href=\"#6-application-cache-离线存储\" class=\"headerlink\" title=\"(6). application cache 离线存储\"></a>(6). application cache 离线存储</h4><p><strong>1.什么是application cache</strong></p>\n<p>application cache是<strong>HTML5</strong>的新特性，允许<strong>浏览器</strong>在本地存储页面所需要的资源，使得页面离线也可以访问。</p>\n<p>在用户没有与因特网进行连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p>application cache是从浏览器的缓存中分出来的一块缓存区。</p>\n<p><strong>如何判断设备是否离线？</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span><span class=\"params\">(navigator.onLine)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//设备在线时的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//设备离线时的操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>window对象上定义了2个事件：</p>\n<ul>\n<li>online: 设备从离线变成在线</li>\n<li>offline: 设备从在线变成离线  </li>\n</ul>\n<p><strong>2.使用方法</strong></p>\n<p>a. 首先需要写一下application cache的配置文件</p>\n<p>配置文件称为缓存清单文件（cache manifest），这个很好理解，可以理解成我们<strong>通过这个文件告诉浏览器需要缓存哪些文件</strong>。</p>\n<p>这个文件一般为.appcache类型</p>\n<p>缓存清单文件一般包括4个部分：</p>\n<p>第一部分  文件头部信息 标注文件类型</p>\n<pre><code>CACHE MANIFEST\n# version XX.XX.XX\n</code></pre><p>第二部分  CACHE部分  标注哪些资源文件需要被缓存</p>\n<pre><code>CACHE：\nimage.png\nmyjavascript.js\n</code></pre><p>第三部分  NETWORK部分  标注哪些文件需要连接服务器</p>\n<pre><code>NETWORK：\nlogin.php\n</code></pre><font color=\"red\">注意：如果CACHE和NETWORK里面有相同的资源，那么这个资源还是会被离线缓存，CACHE的有限级更高。</font>\n\n<p>第四部分  FALLBACK  表示没有响应时的替代方案</p>\n<pre><code>FALLBACK：\nstatic.htmi\n</code></pre><p>b. 在html标签上添加manifest属性</p>\n<pre><code>&lt;html manifest=&quot;name.appcache&quot;&gt;\n\nname.appcache为离线存储的配置文件\n</code></pre><p>c. 在离线状态下操作window.applicationCache进行需求实现</p>\n<p>另外，需要注意的是更新缓存。可以通过window.applicationCache 对象来访问浏览器的app cache。</p>\n<pre><code>window.applicationCache.status 为cache当前的状态\n\nwindow.applicationCache.update() 会更新当前的缓存\n\nwindow.applicationCache.swapCache() 会启用新的缓存\n\noncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。\n\nonchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件\nondownloading:当浏览器开始下载离线资源的时候会触发这个事件\n\nonprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。\n\nonupdateready:当浏览器对离线资源更新完成之后会触发这个事件\n\nonnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件\n</code></pre><p>在网上看到的一篇讲离线存储讲得很好的文章，<a href=\"https://segmentfault.com/a/1190000000732617\" title=\"HTML5：离线储存\">https://segmentfault.com/a/1190000000732617</a></p>\n<h4 id=\"7-cacheStorage\"><a href=\"#7-cacheStorage\" class=\"headerlink\" title=\"(7). cacheStorage\"></a>(7). cacheStorage</h4><p>cacheStorage 在浏览器上的引用名叫 caches </p>\n<p>CacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象</p>\n<p>cacheStorage有open、match、has、delete、keys五个核心方法，可以对cache对象的不同匹配进行不同的响应</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage\" title=\"CacheStorage的MDN\">https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage</a></p>\n<h4 id=\"8-flash缓存\"><a href=\"#8-flash缓存\" class=\"headerlink\" title=\"(8). flash缓存\"></a>(8). flash缓存</h4><p>这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能，同时也可以向js提供调用的api，则页面可以通过js调用flash去读写特定的磁盘目录，达到本地数据缓存的目的。</p>\n"},{"layout":"post","title":"js实现快速排序和冒泡排序","date":"2016-03-30T16:00:00.000Z","description":null,"_content":"\n### 一. 排序算法\n\n#### 1. 排序算法的稳定性\n\n**稳定：**如果 a=b，a原本在b的前面，排序之后，a仍然在b的前面，那么这个排序算法就是稳定的。\n\n反之，就是不稳定的排序算法。\n\n稳定的排序算法有：\n\n\n\n### 二. 快速排序\n\n**思想：**\n\n选取中间的数为基准值，然后将比它小的放在左边，比它大的放在右边，然后将左右两边的数组进行同样的操作，使用递归的思想。\n\n**注意三点：**\n\n- 要判断递归的边界条件，当数组的长度<=1时，跳出递归\n- 最后进行数组合并时，需要将基准值也合并进去\n- splice是对原数组进行操作，返回的是要删除的数组\n\n```\nvar QuickSort = function(arr) {\n\tif (arr.length <= 1) {\n\t\treturn arr;\n\t}\n\t\n\tvar pivotIndex = Math.floor(arr.length/2);\n\tvar pivot = arr.splice(pivotIndex,1)[0];\n\tvar left = [], right = [];\n\t\n\tfor(var i = 0; i < arr.length; i++) {\n\t\tif(arr[i] < pivot) {\n\t\t\tleft.push(arr[i]);\n\t\t} else {\n\t\t\tright.push(arr[i]);\n\t\t}\n\t}\n\t\n\treturn QuickSort(left).concat(pivot,QuickSort(right));\n\t\n\t\n}\n\n\n\tquickSort([1,4,7,8,3,12,35]);\n\tconsole.log(quickSort([1,4,7,8,3,12,35]));\n\n``` \n\n### 三. 冒泡排序\n\n**冒泡排序的原理：**\n\n比方说有五个数字54321，要按从小到大排列；\n\n首先比较前两个，就是5和4，如果第一个小于第二个，不做操作，如果第一个大于第二个，那么交换二者的位置，即变成45321，然后比较第二个和第三个，交换位置，变成43521，然后第三个和第四个，第四个和第五个，这样一次循环下来，变成43215\n\n所以，一层循环的效果就是挑出最大的一个数字5，冒泡到最后面。\n\n但是还要挑出第二大，第三大的数字，等等。\n\n所以一层循环根本就不够用，必须再套一层才行。\n\n像这个例子，五个数字，起码要进行四轮循环才行。至于为什么要this.length-i，是因为第一次比较五个数字，第二个只要比较前四个就行了，第五个肯定是最大的了。。\n\n```\nvar bubbleSort = function(arr) {\n\tvar temp;\n\tfor(var i = 0; i < arr.length; i++) {\n\t\tfor(var j = 0; j < arr.length - 1 - i; j++) {\n\t\t\tif(arr[j] > arr[j+1]) {\n\t\t\t\ttemp = arr[j];\n\t\t\t\tarr[j]= arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn arr;\n\n}\n```\n\n**改进后的冒泡排序：**\n\n改进的思路：将每趟排序中最后一次进行交换的位置pos记录下来，下次排序只要扫描到pos即可。\n\n```\n\n\tfunction bubbleSort2() {\n\n\t\t//初始时，最后的位置保持不变\n\t\tvar i = arr.length - 1;\n\t\twhile(i > 0) {\n\t\t\t\n\t\t\t//每趟开始时，没有记录交换的最后位置\n\t\t\tvar pos = 0;\n\n\t\t\tfor(var j = 0; j < i; j++) {\n\t\t\t\tif(arr[j] > arr[j+1]) {\n\t\t\t\t\t\n\t\t\t\t\t//记录交换位置\n\t\t\t\t\tpos = j;\n\t\t\t\t\tvar tmp = arr[j];\n\t\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\t\tarr[j+1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//为下一趟排序做准备\n\t\t\ti = pos;\n\t\t}\n\t\treturn arr;\n\t}\n```\n\n### 四. 选择排序\n\n最直观的排序算法\n\n依次找出第一大、第二大、第三大...依次放在数组中\n\n```\n\t\n\tfunction selectSort(arr) {\n\t\tvar len = arr.length;\n\t\tvar minIndex, temp;\n\n\t\tfor(var i = 0; i < len - 1; i++) {\n\t\t\tminIndex = i;\n\t\t\tfor(var j = i + 1; j < len; j++) {\n\t\t\t\tif(arr[minIndex] > arr[j]) {\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemp = arr[i];\n\t\t\tarr[i] = arr[minIndex];\n\t\t\tarr[minIndex] = temp;\n\t\t}\n\n\t\treturn arr;\n\t}\n```\n\n### 五. 堆排序\n\n#### 1. 什么是堆？\n\n在一个完全二叉树中，所有的**非终端结点的值**均不大于（或不小于）其左、右孩子结点的值。\n\n例如：\n\n\t最大化堆：\n\n\t\t\t 96\n\t\t83        27\n    11      9  \n\n\t最小化堆：\n\t \t\t 12\n\t\t36        24\n    85      47  \n\n利用堆的概念来排序，若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。\n\ni结点的左子节点为`2*i+1`，i结点的右子节点为`2*i+2`\n\n```\n\n\tfunction heapSort(arr) {\n\t\tvar type = Object.prototype.toString().call(arr).slice(8,-1);\n\n\t\tif(type == 'Array') {\n\t\t\tvar heapSize = arr.length, temp;\n\t\t\t\n\t\t\t//将无序数组变成大顶堆\n\t\t\t//Math.floor(heapSize/2)-1指的是除去叶子结点外的最右边的一个结点，也就是二叉树中倒数第二行最右边的一个节点。\n\t\t\tfor(var i = Math.floor(heapSize/2)-1; i >= 0; i--) {\n\n\t\t\t\t//heapify是为了让每个节点都满足大顶堆的特性\n\t\t\t\theapify(arr, i, heapSize);\n\t\t\t}\n\t\t\t\n\t\t\t//从最后一个开始循环\n\t\t\tfor(var j = heapSize - 1; j >= 1; j--) {\n\n\t\t\t\t//将数组第一个数和最后一个数交换位置，因为现在数组时大顶堆，因此arr[0]最大\n\t\t\t\t//交换后，将除了最后一个元素的数组也变成大顶堆\n\t\t\t\ttemp = arr[0];\n\t\t\t\tarr[0] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t\theapify(arr, 0, --heapSize);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n\n\tfunction heapify(arr, x, len) {\n\t\tvar arrType = Object.prototype.toString().call(arr).slice(8,-1);\n\t\tvar len = arr.length;\n\n\t\tif(arrType == 'Array' && typeof x == 'number') {\n\t\t\tvar left = 2*x+1;\n\t\t\tvar right = 2*x+2;\n\t\t\tvar large = x;\n\n\t\t\tif(left < len && arr[left] > arr[large]) {\n\t\t\t\tlarge = left;\n\t\t\t}\n\n\t\t\tif(right < len && arr[right] > arr[large]) {\n\t\t\t\tlarge = right;\n\t\t\t}\n\n\t\t\tif(large != x) {\n\t\t\t\tvar temp = arr[x];\n\t\t\t\tarr[x] = arr[large];\n\t\t\t\tarr[large] = arr[x];\n\t\t\t\theapify(arr, large, len);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-31-js实现快速排序和冒泡排序.md","raw":"---\nlayout: post\ntitle: js实现快速排序和冒泡排序\ndate: 2016-03-31\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一. 排序算法\n\n#### 1. 排序算法的稳定性\n\n**稳定：**如果 a=b，a原本在b的前面，排序之后，a仍然在b的前面，那么这个排序算法就是稳定的。\n\n反之，就是不稳定的排序算法。\n\n稳定的排序算法有：\n\n\n\n### 二. 快速排序\n\n**思想：**\n\n选取中间的数为基准值，然后将比它小的放在左边，比它大的放在右边，然后将左右两边的数组进行同样的操作，使用递归的思想。\n\n**注意三点：**\n\n- 要判断递归的边界条件，当数组的长度<=1时，跳出递归\n- 最后进行数组合并时，需要将基准值也合并进去\n- splice是对原数组进行操作，返回的是要删除的数组\n\n```\nvar QuickSort = function(arr) {\n\tif (arr.length <= 1) {\n\t\treturn arr;\n\t}\n\t\n\tvar pivotIndex = Math.floor(arr.length/2);\n\tvar pivot = arr.splice(pivotIndex,1)[0];\n\tvar left = [], right = [];\n\t\n\tfor(var i = 0; i < arr.length; i++) {\n\t\tif(arr[i] < pivot) {\n\t\t\tleft.push(arr[i]);\n\t\t} else {\n\t\t\tright.push(arr[i]);\n\t\t}\n\t}\n\t\n\treturn QuickSort(left).concat(pivot,QuickSort(right));\n\t\n\t\n}\n\n\n\tquickSort([1,4,7,8,3,12,35]);\n\tconsole.log(quickSort([1,4,7,8,3,12,35]));\n\n``` \n\n### 三. 冒泡排序\n\n**冒泡排序的原理：**\n\n比方说有五个数字54321，要按从小到大排列；\n\n首先比较前两个，就是5和4，如果第一个小于第二个，不做操作，如果第一个大于第二个，那么交换二者的位置，即变成45321，然后比较第二个和第三个，交换位置，变成43521，然后第三个和第四个，第四个和第五个，这样一次循环下来，变成43215\n\n所以，一层循环的效果就是挑出最大的一个数字5，冒泡到最后面。\n\n但是还要挑出第二大，第三大的数字，等等。\n\n所以一层循环根本就不够用，必须再套一层才行。\n\n像这个例子，五个数字，起码要进行四轮循环才行。至于为什么要this.length-i，是因为第一次比较五个数字，第二个只要比较前四个就行了，第五个肯定是最大的了。。\n\n```\nvar bubbleSort = function(arr) {\n\tvar temp;\n\tfor(var i = 0; i < arr.length; i++) {\n\t\tfor(var j = 0; j < arr.length - 1 - i; j++) {\n\t\t\tif(arr[j] > arr[j+1]) {\n\t\t\t\ttemp = arr[j];\n\t\t\t\tarr[j]= arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn arr;\n\n}\n```\n\n**改进后的冒泡排序：**\n\n改进的思路：将每趟排序中最后一次进行交换的位置pos记录下来，下次排序只要扫描到pos即可。\n\n```\n\n\tfunction bubbleSort2() {\n\n\t\t//初始时，最后的位置保持不变\n\t\tvar i = arr.length - 1;\n\t\twhile(i > 0) {\n\t\t\t\n\t\t\t//每趟开始时，没有记录交换的最后位置\n\t\t\tvar pos = 0;\n\n\t\t\tfor(var j = 0; j < i; j++) {\n\t\t\t\tif(arr[j] > arr[j+1]) {\n\t\t\t\t\t\n\t\t\t\t\t//记录交换位置\n\t\t\t\t\tpos = j;\n\t\t\t\t\tvar tmp = arr[j];\n\t\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\t\tarr[j+1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//为下一趟排序做准备\n\t\t\ti = pos;\n\t\t}\n\t\treturn arr;\n\t}\n```\n\n### 四. 选择排序\n\n最直观的排序算法\n\n依次找出第一大、第二大、第三大...依次放在数组中\n\n```\n\t\n\tfunction selectSort(arr) {\n\t\tvar len = arr.length;\n\t\tvar minIndex, temp;\n\n\t\tfor(var i = 0; i < len - 1; i++) {\n\t\t\tminIndex = i;\n\t\t\tfor(var j = i + 1; j < len; j++) {\n\t\t\t\tif(arr[minIndex] > arr[j]) {\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemp = arr[i];\n\t\t\tarr[i] = arr[minIndex];\n\t\t\tarr[minIndex] = temp;\n\t\t}\n\n\t\treturn arr;\n\t}\n```\n\n### 五. 堆排序\n\n#### 1. 什么是堆？\n\n在一个完全二叉树中，所有的**非终端结点的值**均不大于（或不小于）其左、右孩子结点的值。\n\n例如：\n\n\t最大化堆：\n\n\t\t\t 96\n\t\t83        27\n    11      9  \n\n\t最小化堆：\n\t \t\t 12\n\t\t36        24\n    85      47  \n\n利用堆的概念来排序，若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。\n\ni结点的左子节点为`2*i+1`，i结点的右子节点为`2*i+2`\n\n```\n\n\tfunction heapSort(arr) {\n\t\tvar type = Object.prototype.toString().call(arr).slice(8,-1);\n\n\t\tif(type == 'Array') {\n\t\t\tvar heapSize = arr.length, temp;\n\t\t\t\n\t\t\t//将无序数组变成大顶堆\n\t\t\t//Math.floor(heapSize/2)-1指的是除去叶子结点外的最右边的一个结点，也就是二叉树中倒数第二行最右边的一个节点。\n\t\t\tfor(var i = Math.floor(heapSize/2)-1; i >= 0; i--) {\n\n\t\t\t\t//heapify是为了让每个节点都满足大顶堆的特性\n\t\t\t\theapify(arr, i, heapSize);\n\t\t\t}\n\t\t\t\n\t\t\t//从最后一个开始循环\n\t\t\tfor(var j = heapSize - 1; j >= 1; j--) {\n\n\t\t\t\t//将数组第一个数和最后一个数交换位置，因为现在数组时大顶堆，因此arr[0]最大\n\t\t\t\t//交换后，将除了最后一个元素的数组也变成大顶堆\n\t\t\t\ttemp = arr[0];\n\t\t\t\tarr[0] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t\theapify(arr, 0, --heapSize);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n\n\tfunction heapify(arr, x, len) {\n\t\tvar arrType = Object.prototype.toString().call(arr).slice(8,-1);\n\t\tvar len = arr.length;\n\n\t\tif(arrType == 'Array' && typeof x == 'number') {\n\t\t\tvar left = 2*x+1;\n\t\t\tvar right = 2*x+2;\n\t\t\tvar large = x;\n\n\t\t\tif(left < len && arr[left] > arr[large]) {\n\t\t\t\tlarge = left;\n\t\t\t}\n\n\t\t\tif(right < len && arr[right] > arr[large]) {\n\t\t\t\tlarge = right;\n\t\t\t}\n\n\t\t\tif(large != x) {\n\t\t\t\tvar temp = arr[x];\n\t\t\t\tarr[x] = arr[large];\n\t\t\t\tarr[large] = arr[x];\n\t\t\t\theapify(arr, large, len);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-31-js实现快速排序和冒泡排序","published":1,"updated":"2016-10-15T14:09:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocd5001nd5u88w5u3j07","content":"<h3 id=\"一-排序算法\"><a href=\"#一-排序算法\" class=\"headerlink\" title=\"一. 排序算法\"></a>一. 排序算法</h3><h4 id=\"1-排序算法的稳定性\"><a href=\"#1-排序算法的稳定性\" class=\"headerlink\" title=\"1. 排序算法的稳定性\"></a>1. 排序算法的稳定性</h4><p><strong>稳定：</strong>如果 a=b，a原本在b的前面，排序之后，a仍然在b的前面，那么这个排序算法就是稳定的。</p>\n<p>反之，就是不稳定的排序算法。</p>\n<p>稳定的排序算法有：</p>\n<h3 id=\"二-快速排序\"><a href=\"#二-快速排序\" class=\"headerlink\" title=\"二. 快速排序\"></a>二. 快速排序</h3><p><strong>思想：</strong></p>\n<p>选取中间的数为基准值，然后将比它小的放在左边，比它大的放在右边，然后将左右两边的数组进行同样的操作，使用递归的思想。</p>\n<p><strong>注意三点：</strong></p>\n<ul>\n<li>要判断递归的边界条件，当数组的长度&lt;=1时，跳出递归</li>\n<li>最后进行数组合并时，需要将基准值也合并进去</li>\n<li>splice是对原数组进行操作，返回的是要删除的数组</li>\n</ul>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> QuickSort = function(arr) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr.<span class=\"built_in\">length</span> &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> pivotIndex = Math.<span class=\"built_in\">floor</span>(arr.<span class=\"built_in\">length</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> pivot = arr.<span class=\"built_in\">splice</span>(pivotIndex,<span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> left = [], right = [];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">\t\t\tleft.<span class=\"built_in\">push</span>(arr[i]);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tright.<span class=\"built_in\">push</span>(arr[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> QuickSort(left).<span class=\"built_in\">concat</span>(pivot,QuickSort(right));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tquickSort([<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">12</span>,<span class=\"number\">35</span>]);</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(quickSort([<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">12</span>,<span class=\"number\">35</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">### 三. 冒泡排序</span><br><span class=\"line\"></span><br><span class=\"line\">**冒泡排序的原理：**</span><br><span class=\"line\"></span><br><span class=\"line\">比方说有五个数字<span class=\"number\">54321</span>，要按从小到大排列；</span><br><span class=\"line\"></span><br><span class=\"line\">首先比较前两个，就是<span class=\"number\">5</span>和<span class=\"number\">4</span>，如果第一个小于第二个，不做操作，如果第一个大于第二个，那么交换二者的位置，即变成<span class=\"number\">45321</span>，然后比较第二个和第三个，交换位置，变成<span class=\"number\">43521</span>，然后第三个和第四个，第四个和第五个，这样一次循环下来，变成<span class=\"number\">43215</span></span><br><span class=\"line\"></span><br><span class=\"line\">所以，一层循环的效果就是挑出最大的一个数字<span class=\"number\">5</span>，冒泡到最后面。</span><br><span class=\"line\"></span><br><span class=\"line\">但是还要挑出第二大，第三大的数字，等等。</span><br><span class=\"line\"></span><br><span class=\"line\">所以一层循环根本就不够用，必须再套一层才行。</span><br><span class=\"line\"></span><br><span class=\"line\">像这个例子，五个数字，起码要进行四轮循环才行。至于为什么要this.<span class=\"built_in\">length</span>-i，是因为第一次比较五个数字，第二个只要比较前四个就行了，第五个肯定是最大的了。。</span><br></pre></td></tr></table></figure>\n<p>var bubbleSort = function(arr) {<br>    var temp;<br>    for(var i = 0; i &lt; arr.length; i++) {<br>        for(var j = 0; j &lt; arr.length - 1 - i; j++) {<br>            if(arr[j] &gt; arr[j+1]) {<br>                temp = arr[j];<br>                arr[j]= arr[j+1];<br>                arr[j+1] = temp;<br>            }<br>        }<br>    }</p>\n<pre><code>return arr;\n</code></pre><p>}<br><figure class=\"highlight hsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**改进后的冒泡排序：**</span><br><span class=\"line\"></span><br><span class=\"line\">改进的思路：将每趟排序中最后一次进行交换的位置<span class=\"keyword\">pos</span>记录下来，下次排序只要扫描到<span class=\"keyword\">pos</span>即可。</span><br></pre></td></tr></table></figure></p>\n<pre><code>function bubbleSort2() {\n\n    //初始时，最后的位置保持不变\n    var i = arr.length - 1;\n    while(i &gt; 0) {\n\n        //每趟开始时，没有记录交换的最后位置\n        var pos = 0;\n\n        for(var j = 0; j &lt; i; j++) {\n            if(arr[j] &gt; arr[j+1]) {\n\n                //记录交换位置\n                pos = j;\n                var tmp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = tmp;\n            }\n        }\n\n        //为下一趟排序做准备\n        i = pos;\n    }\n    return arr;\n}\n</code></pre><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 四. 选择排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">最直观的排序算法</span><br><span class=\"line\"></span><br><span class=\"line\">依次找出第一大、第二大、第三大<span class=\"keyword\">...</span>依次放在数组中</span><br></pre></td></tr></table></figure>\n<pre><code>function selectSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n\n    for(var i = 0; i &lt; len - 1; i++) {\n        minIndex = i;\n        for(var j = i + 1; j &lt; len; j++) {\n            if(arr[minIndex] &gt; arr[j]) {\n                minIndex = j;\n            }\n        }\n\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n\n    return arr;\n}\n</code></pre><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">### 五. 堆排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">#### 1. 什么是堆？</span></span><br><span class=\"line\"></span><br><span class=\"line\">在一个完全二叉树中，所有的<span class=\"strong\">**非终端结点的值**</span>均不大于（或不小于）其左、右孩子结点的值。</span><br><span class=\"line\"></span><br><span class=\"line\">例如：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">\t最大化堆：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">\t\t\t 96</span></span><br><span class=\"line\"><span class=\"code\">\t\t83        27</span></span><br><span class=\"line\"><span class=\"code\">    11      9  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">\t最小化堆：</span></span><br><span class=\"line\"><span class=\"code\">\t \t\t 12</span></span><br><span class=\"line\"><span class=\"code\">\t\t36        24</span></span><br><span class=\"line\"><span class=\"code\">    85      47  </span></span><br><span class=\"line\"></span><br><span class=\"line\">利用堆的概念来排序，若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</span><br><span class=\"line\"></span><br><span class=\"line\">i结点的左子节点为<span class=\"code\">`2*i+1`</span>，i结点的右子节点为<span class=\"code\">`2*i+2`</span></span><br></pre></td></tr></table></figure>\n<pre><code>function heapSort(arr) {\n    var type = Object.prototype.toString().call(arr).slice(8,-1);\n\n    if(type == &apos;Array&apos;) {\n        var heapSize = arr.length, temp;\n\n        //将无序数组变成大顶堆\n        //Math.floor(heapSize/2)-1指的是除去叶子结点外的最右边的一个结点，也就是二叉树中倒数第二行最右边的一个节点。\n        for(var i = Math.floor(heapSize/2)-1; i &gt;= 0; i--) {\n\n            //heapify是为了让每个节点都满足大顶堆的特性\n            heapify(arr, i, heapSize);\n        }\n\n        //从最后一个开始循环\n        for(var j = heapSize - 1; j &gt;= 1; j--) {\n\n            //将数组第一个数和最后一个数交换位置，因为现在数组时大顶堆，因此arr[0]最大\n            //交换后，将除了最后一个元素的数组也变成大顶堆\n            temp = arr[0];\n            arr[0] = arr[j];\n            arr[j] = temp;\n            heapify(arr, 0, --heapSize);\n        }\n        return arr;\n    }\n}\n\nfunction heapify(arr, x, len) {\n    var arrType = Object.prototype.toString().call(arr).slice(8,-1);\n    var len = arr.length;\n\n    if(arrType == &apos;Array&apos; &amp;&amp; typeof x == &apos;number&apos;) {\n        var left = 2*x+1;\n        var right = 2*x+2;\n        var large = x;\n\n        if(left &lt; len &amp;&amp; arr[left] &gt; arr[large]) {\n            large = left;\n        }\n\n        if(right &lt; len &amp;&amp; arr[right] &gt; arr[large]) {\n            large = right;\n        }\n\n        if(large != x) {\n            var temp = arr[x];\n            arr[x] = arr[large];\n            arr[large] = arr[x];\n            heapify(arr, large, len);\n        }\n\n    }\n}\n</code></pre><p>```</p>\n","excerpt":"","more":"<h3 id=\"一-排序算法\"><a href=\"#一-排序算法\" class=\"headerlink\" title=\"一. 排序算法\"></a>一. 排序算法</h3><h4 id=\"1-排序算法的稳定性\"><a href=\"#1-排序算法的稳定性\" class=\"headerlink\" title=\"1. 排序算法的稳定性\"></a>1. 排序算法的稳定性</h4><p><strong>稳定：</strong>如果 a=b，a原本在b的前面，排序之后，a仍然在b的前面，那么这个排序算法就是稳定的。</p>\n<p>反之，就是不稳定的排序算法。</p>\n<p>稳定的排序算法有：</p>\n<h3 id=\"二-快速排序\"><a href=\"#二-快速排序\" class=\"headerlink\" title=\"二. 快速排序\"></a>二. 快速排序</h3><p><strong>思想：</strong></p>\n<p>选取中间的数为基准值，然后将比它小的放在左边，比它大的放在右边，然后将左右两边的数组进行同样的操作，使用递归的思想。</p>\n<p><strong>注意三点：</strong></p>\n<ul>\n<li>要判断递归的边界条件，当数组的长度&lt;=1时，跳出递归</li>\n<li>最后进行数组合并时，需要将基准值也合并进去</li>\n<li>splice是对原数组进行操作，返回的是要删除的数组</li>\n</ul>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> QuickSort = function(arr) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr.<span class=\"built_in\">length</span> &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> pivotIndex = Math.<span class=\"built_in\">floor</span>(arr.<span class=\"built_in\">length</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> pivot = arr.<span class=\"built_in\">splice</span>(pivotIndex,<span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> left = [], right = [];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">\t\t\tleft.<span class=\"built_in\">push</span>(arr[i]);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tright.<span class=\"built_in\">push</span>(arr[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> QuickSort(left).<span class=\"built_in\">concat</span>(pivot,QuickSort(right));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tquickSort([<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">12</span>,<span class=\"number\">35</span>]);</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(quickSort([<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">12</span>,<span class=\"number\">35</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">### 三. 冒泡排序</span><br><span class=\"line\"></span><br><span class=\"line\">**冒泡排序的原理：**</span><br><span class=\"line\"></span><br><span class=\"line\">比方说有五个数字<span class=\"number\">54321</span>，要按从小到大排列；</span><br><span class=\"line\"></span><br><span class=\"line\">首先比较前两个，就是<span class=\"number\">5</span>和<span class=\"number\">4</span>，如果第一个小于第二个，不做操作，如果第一个大于第二个，那么交换二者的位置，即变成<span class=\"number\">45321</span>，然后比较第二个和第三个，交换位置，变成<span class=\"number\">43521</span>，然后第三个和第四个，第四个和第五个，这样一次循环下来，变成<span class=\"number\">43215</span></span><br><span class=\"line\"></span><br><span class=\"line\">所以，一层循环的效果就是挑出最大的一个数字<span class=\"number\">5</span>，冒泡到最后面。</span><br><span class=\"line\"></span><br><span class=\"line\">但是还要挑出第二大，第三大的数字，等等。</span><br><span class=\"line\"></span><br><span class=\"line\">所以一层循环根本就不够用，必须再套一层才行。</span><br><span class=\"line\"></span><br><span class=\"line\">像这个例子，五个数字，起码要进行四轮循环才行。至于为什么要this.<span class=\"built_in\">length</span>-i，是因为第一次比较五个数字，第二个只要比较前四个就行了，第五个肯定是最大的了。。</span><br></pre></td></tr></table></figure>\n<p>var bubbleSort = function(arr) {<br>    var temp;<br>    for(var i = 0; i &lt; arr.length; i++) {<br>        for(var j = 0; j &lt; arr.length - 1 - i; j++) {<br>            if(arr[j] &gt; arr[j+1]) {<br>                temp = arr[j];<br>                arr[j]= arr[j+1];<br>                arr[j+1] = temp;<br>            }<br>        }<br>    }</p>\n<pre><code>return arr;\n</code></pre><p>}<br><figure class=\"highlight hsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**改进后的冒泡排序：**</span><br><span class=\"line\"></span><br><span class=\"line\">改进的思路：将每趟排序中最后一次进行交换的位置<span class=\"keyword\">pos</span>记录下来，下次排序只要扫描到<span class=\"keyword\">pos</span>即可。</span><br></pre></td></tr></table></figure></p>\n<pre><code>function bubbleSort2() {\n\n    //初始时，最后的位置保持不变\n    var i = arr.length - 1;\n    while(i &gt; 0) {\n\n        //每趟开始时，没有记录交换的最后位置\n        var pos = 0;\n\n        for(var j = 0; j &lt; i; j++) {\n            if(arr[j] &gt; arr[j+1]) {\n\n                //记录交换位置\n                pos = j;\n                var tmp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = tmp;\n            }\n        }\n\n        //为下一趟排序做准备\n        i = pos;\n    }\n    return arr;\n}\n</code></pre><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 四. 选择排序</span></span><br><span class=\"line\"></span><br><span class=\"line\">最直观的排序算法</span><br><span class=\"line\"></span><br><span class=\"line\">依次找出第一大、第二大、第三大<span class=\"keyword\">...</span>依次放在数组中</span><br></pre></td></tr></table></figure>\n<pre><code>function selectSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n\n    for(var i = 0; i &lt; len - 1; i++) {\n        minIndex = i;\n        for(var j = i + 1; j &lt; len; j++) {\n            if(arr[minIndex] &gt; arr[j]) {\n                minIndex = j;\n            }\n        }\n\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n\n    return arr;\n}\n</code></pre><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">### 五. 堆排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">#### 1. 什么是堆？</span></span><br><span class=\"line\"></span><br><span class=\"line\">在一个完全二叉树中，所有的<span class=\"strong\">**非终端结点的值**</span>均不大于（或不小于）其左、右孩子结点的值。</span><br><span class=\"line\"></span><br><span class=\"line\">例如：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">\t最大化堆：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">\t\t\t 96</span></span><br><span class=\"line\"><span class=\"code\">\t\t83        27</span></span><br><span class=\"line\"><span class=\"code\">    11      9  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">\t最小化堆：</span></span><br><span class=\"line\"><span class=\"code\">\t \t\t 12</span></span><br><span class=\"line\"><span class=\"code\">\t\t36        24</span></span><br><span class=\"line\"><span class=\"code\">    85      47  </span></span><br><span class=\"line\"></span><br><span class=\"line\">利用堆的概念来排序，若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</span><br><span class=\"line\"></span><br><span class=\"line\">i结点的左子节点为<span class=\"code\">`2*i+1`</span>，i结点的右子节点为<span class=\"code\">`2*i+2`</span></span><br></pre></td></tr></table></figure>\n<pre><code>function heapSort(arr) {\n    var type = Object.prototype.toString().call(arr).slice(8,-1);\n\n    if(type == &apos;Array&apos;) {\n        var heapSize = arr.length, temp;\n\n        //将无序数组变成大顶堆\n        //Math.floor(heapSize/2)-1指的是除去叶子结点外的最右边的一个结点，也就是二叉树中倒数第二行最右边的一个节点。\n        for(var i = Math.floor(heapSize/2)-1; i &gt;= 0; i--) {\n\n            //heapify是为了让每个节点都满足大顶堆的特性\n            heapify(arr, i, heapSize);\n        }\n\n        //从最后一个开始循环\n        for(var j = heapSize - 1; j &gt;= 1; j--) {\n\n            //将数组第一个数和最后一个数交换位置，因为现在数组时大顶堆，因此arr[0]最大\n            //交换后，将除了最后一个元素的数组也变成大顶堆\n            temp = arr[0];\n            arr[0] = arr[j];\n            arr[j] = temp;\n            heapify(arr, 0, --heapSize);\n        }\n        return arr;\n    }\n}\n\nfunction heapify(arr, x, len) {\n    var arrType = Object.prototype.toString().call(arr).slice(8,-1);\n    var len = arr.length;\n\n    if(arrType == &apos;Array&apos; &amp;&amp; typeof x == &apos;number&apos;) {\n        var left = 2*x+1;\n        var right = 2*x+2;\n        var large = x;\n\n        if(left &lt; len &amp;&amp; arr[left] &gt; arr[large]) {\n            large = left;\n        }\n\n        if(right &lt; len &amp;&amp; arr[right] &gt; arr[large]) {\n            large = right;\n        }\n\n        if(large != x) {\n            var temp = arr[x];\n            arr[x] = arr[large];\n            arr[large] = arr[x];\n            heapify(arr, large, len);\n        }\n\n    }\n}\n</code></pre><p>```</p>\n"},{"layout":"post","title":"CSS选择器总结","date":"2016-03-30T16:00:00.000Z","description":null,"_content":"\n最近在做百度前端公开课第一阶段的任务，第一阶段主要是针对HTML和CSS来进行训练的，然后发现有一些不常用CSS选择器都记得不太清楚，于是就总结了这篇博客，常用的那些就没用写进来。\n\n### 一. 元素选择器\n\n    article\n    p\n    h1\n    ...\n\n### 二. 关系选择器\n\n#### 1. 后代选择器`X Y`\n\n选择X的所有子孙元素中为Y的元素\n\n#### 2. 子选择器`X > Y`\n\n与`X Y`不同的是，`X > Y`只选择X的直接子元素Y，而不包括其他的子孙元素。\n\n#### 3. 相邻兄弟选择器`X + Y`\n\n匹配X后面紧邻的第一个元素，只匹配一个元素。\n\n#### 4. 一般兄弟选择器`X ~ Y`\n\n匹配任何在X之后的所有的同级元素Y\n\n### 三. 属性选择器\n\n#### 1. X[attr]\n\n匹配具有attr属性的所有X元素\n\n#### 2. X[attr=\"val\"]\n\n`X[title=\"a\"]` 选择带有title=\"a\"的所有X\n\n#### 3. X[attr*=\"val\"]\n\n`X[title*=\"h\"]` 匹配属性值包含h的所有的X\n\n#### 4. X[attr^=\"val\"]\n\n`X[title^=\"a\"]` 匹配属性值以a开头的属性\n\n#### 5. X[attr$=\"val\"]\n\n`X[href$=\".png\"]` 匹配结尾带有特定字符串的X\n\n#### 6. X[attr|=\"val\"]\n\n`p[class|=a]` 匹配页面里所有的P段落里具有class属性且属性值为a或是a-开始的，比如`class=\"a\"`以及`class=\"a-b\"`\n\n#### 7. X[attr~=\"val\"]\n\n`div[title~=english]` 匹配页面里所有具有属性title且属性值里拥有完整单词english的div容器，比如`title=\"english\"`以及`title=\"a english\"`\n\n### 四. 伪类\n\n#### 1. X:link  X:visited  X:hover  X:active\n\n这个主要是要注意写的顺序，原因是css后面的优先级比前面的高。\n\n顺序为：**l** o **v** e **h** **a** t e\n\n#### 2. 其他伪类\n\n`X:checked` 匹配带有checked属性的元素\n\n`X:not(selector)` 否定伪类选择器   \n\n### 五. 伪元素\n\n为了与伪类区分，伪元素使用`双冒号::`\n\nX::after X::before\n\n    .clearfix:after { \n    content: \"\"; \n    display: block; \n    clear: both; \n    visibility: hidden; \n    font-size: 0; \n    height: 0; \n    } \n    \n    .clearfix { \n    \t*display: inline-block; \n    \t_height: 1%; \n    } \n\n`p::first-line`  `p::first-letter`\n\n`X:nth-child(n)` 匹配第n个子元素，从第一个子元素开始索引\n\n`X:nth-last-child(n)` 从最后一个子元素开始索引\n\n    X:nth-of-type(n) \n    \n    X:nth-last-of-type(n) \n    \n    X:first-child\n    \n    X:last-child\n    \n    X:only-child\n    \n    X:only-of-type\n    \n    X:first-of-type\n\n### 六.  * 通配符\n\n    * { margin: 0; } \n    \n    #id *{ margin: 0; }\n\n### 七. css选择器的权重\n\n- 行内样式style:**1000**\n- ID选择器：**100**\n- 类class/属性选择器/伪类(:hover/:focus等)：**10**\n- 元素(标签)/伪元素：**1**\n\n<font color=\"red\">注意：**伪类**指的是一种状态，例如hover，active；**伪元素**指的是文档的某个特定部分的表现。</font>\n\n    权重的计算：\n    \n    body #content .data img:hover\n    \n    权重为：1 + 100 + 10 + 1 + 10 = 122\n\n\t不同的权重，权重高的有效；\n\t相同的权重，后定义的有效。\n\n一个例子：\n\n求下面四个选择器权重的大小\n\n```\n\n\t<div class='myDiv' id='myDiv'>\n\t\t<span class='myDiv' id='myDiv'>hhhh</span>\n\t</div>\n\n\t<style>\t\n\t\t//1\t\n\t\t.myDiv #myDiv{\n\t\t\tbackground: black;\n\t\t}\n\n\t\t//2\n\t\t#myDiv .myDiv{\n\t\t\tbackground: red;\n\t\t}\n\n\t\t//3\n\t\tbody .myDiv {\n\t\t\tbackground: yellow;\n\t\t}\n\n\t\t//4\n\t\tdiv.myDiv {\n\t\t\tbackground: green;\n\t\t}\n\t</style>\n```\n\n选择器1：10 + 100 = 110\n选择器2：100 + 10 = 110\n选择器3：1 + 10 = 11\n选择器4：1 + 10 = 11\n\n权重一样的，后定义的有效\n\n所以选择器的优先级的顺序是 2 > 1 > 4 > 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-31-CSS选择器总结.md","raw":"---\nlayout: post\ntitle: CSS选择器总结\ndate: 2016-03-31\ncategories: CSS\ntags: [css]\ndescription: \n---\n\n最近在做百度前端公开课第一阶段的任务，第一阶段主要是针对HTML和CSS来进行训练的，然后发现有一些不常用CSS选择器都记得不太清楚，于是就总结了这篇博客，常用的那些就没用写进来。\n\n### 一. 元素选择器\n\n    article\n    p\n    h1\n    ...\n\n### 二. 关系选择器\n\n#### 1. 后代选择器`X Y`\n\n选择X的所有子孙元素中为Y的元素\n\n#### 2. 子选择器`X > Y`\n\n与`X Y`不同的是，`X > Y`只选择X的直接子元素Y，而不包括其他的子孙元素。\n\n#### 3. 相邻兄弟选择器`X + Y`\n\n匹配X后面紧邻的第一个元素，只匹配一个元素。\n\n#### 4. 一般兄弟选择器`X ~ Y`\n\n匹配任何在X之后的所有的同级元素Y\n\n### 三. 属性选择器\n\n#### 1. X[attr]\n\n匹配具有attr属性的所有X元素\n\n#### 2. X[attr=\"val\"]\n\n`X[title=\"a\"]` 选择带有title=\"a\"的所有X\n\n#### 3. X[attr*=\"val\"]\n\n`X[title*=\"h\"]` 匹配属性值包含h的所有的X\n\n#### 4. X[attr^=\"val\"]\n\n`X[title^=\"a\"]` 匹配属性值以a开头的属性\n\n#### 5. X[attr$=\"val\"]\n\n`X[href$=\".png\"]` 匹配结尾带有特定字符串的X\n\n#### 6. X[attr|=\"val\"]\n\n`p[class|=a]` 匹配页面里所有的P段落里具有class属性且属性值为a或是a-开始的，比如`class=\"a\"`以及`class=\"a-b\"`\n\n#### 7. X[attr~=\"val\"]\n\n`div[title~=english]` 匹配页面里所有具有属性title且属性值里拥有完整单词english的div容器，比如`title=\"english\"`以及`title=\"a english\"`\n\n### 四. 伪类\n\n#### 1. X:link  X:visited  X:hover  X:active\n\n这个主要是要注意写的顺序，原因是css后面的优先级比前面的高。\n\n顺序为：**l** o **v** e **h** **a** t e\n\n#### 2. 其他伪类\n\n`X:checked` 匹配带有checked属性的元素\n\n`X:not(selector)` 否定伪类选择器   \n\n### 五. 伪元素\n\n为了与伪类区分，伪元素使用`双冒号::`\n\nX::after X::before\n\n    .clearfix:after { \n    content: \"\"; \n    display: block; \n    clear: both; \n    visibility: hidden; \n    font-size: 0; \n    height: 0; \n    } \n    \n    .clearfix { \n    \t*display: inline-block; \n    \t_height: 1%; \n    } \n\n`p::first-line`  `p::first-letter`\n\n`X:nth-child(n)` 匹配第n个子元素，从第一个子元素开始索引\n\n`X:nth-last-child(n)` 从最后一个子元素开始索引\n\n    X:nth-of-type(n) \n    \n    X:nth-last-of-type(n) \n    \n    X:first-child\n    \n    X:last-child\n    \n    X:only-child\n    \n    X:only-of-type\n    \n    X:first-of-type\n\n### 六.  * 通配符\n\n    * { margin: 0; } \n    \n    #id *{ margin: 0; }\n\n### 七. css选择器的权重\n\n- 行内样式style:**1000**\n- ID选择器：**100**\n- 类class/属性选择器/伪类(:hover/:focus等)：**10**\n- 元素(标签)/伪元素：**1**\n\n<font color=\"red\">注意：**伪类**指的是一种状态，例如hover，active；**伪元素**指的是文档的某个特定部分的表现。</font>\n\n    权重的计算：\n    \n    body #content .data img:hover\n    \n    权重为：1 + 100 + 10 + 1 + 10 = 122\n\n\t不同的权重，权重高的有效；\n\t相同的权重，后定义的有效。\n\n一个例子：\n\n求下面四个选择器权重的大小\n\n```\n\n\t<div class='myDiv' id='myDiv'>\n\t\t<span class='myDiv' id='myDiv'>hhhh</span>\n\t</div>\n\n\t<style>\t\n\t\t//1\t\n\t\t.myDiv #myDiv{\n\t\t\tbackground: black;\n\t\t}\n\n\t\t//2\n\t\t#myDiv .myDiv{\n\t\t\tbackground: red;\n\t\t}\n\n\t\t//3\n\t\tbody .myDiv {\n\t\t\tbackground: yellow;\n\t\t}\n\n\t\t//4\n\t\tdiv.myDiv {\n\t\t\tbackground: green;\n\t\t}\n\t</style>\n```\n\n选择器1：10 + 100 = 110\n选择器2：100 + 10 = 110\n选择器3：1 + 10 = 11\n选择器4：1 + 10 = 11\n\n权重一样的，后定义的有效\n\n所以选择器的优先级的顺序是 2 > 1 > 4 > 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-31-CSS选择器总结","published":1,"updated":"2016-09-20T03:28:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocd8001rd5u8n0pss0ls","content":"<p>最近在做百度前端公开课第一阶段的任务，第一阶段主要是针对HTML和CSS来进行训练的，然后发现有一些不常用CSS选择器都记得不太清楚，于是就总结了这篇博客，常用的那些就没用写进来。</p>\n<h3 id=\"一-元素选择器\"><a href=\"#一-元素选择器\" class=\"headerlink\" title=\"一. 元素选择器\"></a>一. 元素选择器</h3><pre><code>article\np\nh1\n...\n</code></pre><h3 id=\"二-关系选择器\"><a href=\"#二-关系选择器\" class=\"headerlink\" title=\"二. 关系选择器\"></a>二. 关系选择器</h3><h4 id=\"1-后代选择器X-Y\"><a href=\"#1-后代选择器X-Y\" class=\"headerlink\" title=\"1. 后代选择器X Y\"></a>1. 后代选择器<code>X Y</code></h4><p>选择X的所有子孙元素中为Y的元素</p>\n<h4 id=\"2-子选择器X-gt-Y\"><a href=\"#2-子选择器X-gt-Y\" class=\"headerlink\" title=\"2. 子选择器X &gt; Y\"></a>2. 子选择器<code>X &gt; Y</code></h4><p>与<code>X Y</code>不同的是，<code>X &gt; Y</code>只选择X的直接子元素Y，而不包括其他的子孙元素。</p>\n<h4 id=\"3-相邻兄弟选择器X-Y\"><a href=\"#3-相邻兄弟选择器X-Y\" class=\"headerlink\" title=\"3. 相邻兄弟选择器X + Y\"></a>3. 相邻兄弟选择器<code>X + Y</code></h4><p>匹配X后面紧邻的第一个元素，只匹配一个元素。</p>\n<h4 id=\"4-一般兄弟选择器X-Y\"><a href=\"#4-一般兄弟选择器X-Y\" class=\"headerlink\" title=\"4. 一般兄弟选择器X ~ Y\"></a>4. 一般兄弟选择器<code>X ~ Y</code></h4><p>匹配任何在X之后的所有的同级元素Y</p>\n<h3 id=\"三-属性选择器\"><a href=\"#三-属性选择器\" class=\"headerlink\" title=\"三. 属性选择器\"></a>三. 属性选择器</h3><h4 id=\"1-X-attr\"><a href=\"#1-X-attr\" class=\"headerlink\" title=\"1. X[attr]\"></a>1. X[attr]</h4><p>匹配具有attr属性的所有X元素</p>\n<h4 id=\"2-X-attr-”val”\"><a href=\"#2-X-attr-”val”\" class=\"headerlink\" title=\"2. X[attr=”val”]\"></a>2. X[attr=”val”]</h4><p><code>X[title=&quot;a&quot;]</code> 选择带有title=”a”的所有X</p>\n<h4 id=\"3-X-attr-”val”\"><a href=\"#3-X-attr-”val”\" class=\"headerlink\" title=\"3. X[attr*=”val”]\"></a>3. X[attr*=”val”]</h4><p><code>X[title*=&quot;h&quot;]</code> 匹配属性值包含h的所有的X</p>\n<h4 id=\"4-X-attr-”val”\"><a href=\"#4-X-attr-”val”\" class=\"headerlink\" title=\"4. X[attr^=”val”]\"></a>4. X[attr^=”val”]</h4><p><code>X[title^=&quot;a&quot;]</code> 匹配属性值以a开头的属性</p>\n<h4 id=\"5-X-attr-”val”\"><a href=\"#5-X-attr-”val”\" class=\"headerlink\" title=\"5. X[attr$=”val”]\"></a>5. X[attr$=”val”]</h4><p><code>X[href$=&quot;.png&quot;]</code> 匹配结尾带有特定字符串的X</p>\n<h4 id=\"6-X-attr-”val”\"><a href=\"#6-X-attr-”val”\" class=\"headerlink\" title=\"6. X[attr|=”val”]\"></a>6. X[attr|=”val”]</h4><p><code>p[class|=a]</code> 匹配页面里所有的P段落里具有class属性且属性值为a或是a-开始的，比如<code>class=&quot;a&quot;</code>以及<code>class=&quot;a-b&quot;</code></p>\n<h4 id=\"7-X-attr-”val”\"><a href=\"#7-X-attr-”val”\" class=\"headerlink\" title=\"7. X[attr~=”val”]\"></a>7. X[attr~=”val”]</h4><p><code>div[title~=english]</code> 匹配页面里所有具有属性title且属性值里拥有完整单词english的div容器，比如<code>title=&quot;english&quot;</code>以及<code>title=&quot;a english&quot;</code></p>\n<h3 id=\"四-伪类\"><a href=\"#四-伪类\" class=\"headerlink\" title=\"四. 伪类\"></a>四. 伪类</h3><h4 id=\"1-X-link-X-visited-X-hover-X-active\"><a href=\"#1-X-link-X-visited-X-hover-X-active\" class=\"headerlink\" title=\"1. X:link  X:visited  X:hover  X:active\"></a>1. X:link  X:visited  X:hover  X:active</h4><p>这个主要是要注意写的顺序，原因是css后面的优先级比前面的高。</p>\n<p>顺序为：<strong>l</strong> o <strong>v</strong> e <strong>h</strong> <strong>a</strong> t e</p>\n<h4 id=\"2-其他伪类\"><a href=\"#2-其他伪类\" class=\"headerlink\" title=\"2. 其他伪类\"></a>2. 其他伪类</h4><p><code>X:checked</code> 匹配带有checked属性的元素</p>\n<p><code>X:not(selector)</code> 否定伪类选择器   </p>\n<h3 id=\"五-伪元素\"><a href=\"#五-伪元素\" class=\"headerlink\" title=\"五. 伪元素\"></a>五. 伪元素</h3><p>为了与伪类区分，伪元素使用<code>双冒号::</code></p>\n<p>X::after X::before</p>\n<pre><code>.clearfix:after { \ncontent: &quot;&quot;; \ndisplay: block; \nclear: both; \nvisibility: hidden; \nfont-size: 0; \nheight: 0; \n} \n\n.clearfix { \n    *display: inline-block; \n    _height: 1%; \n} \n</code></pre><p><code>p::first-line</code>  <code>p::first-letter</code></p>\n<p><code>X:nth-child(n)</code> 匹配第n个子元素，从第一个子元素开始索引</p>\n<p><code>X:nth-last-child(n)</code> 从最后一个子元素开始索引</p>\n<pre><code>X:nth-of-type(n) \n\nX:nth-last-of-type(n) \n\nX:first-child\n\nX:last-child\n\nX:only-child\n\nX:only-of-type\n\nX:first-of-type\n</code></pre><h3 id=\"六-通配符\"><a href=\"#六-通配符\" class=\"headerlink\" title=\"六.  * 通配符\"></a>六.  * 通配符</h3><pre><code>* { margin: 0; } \n\n#id *{ margin: 0; }\n</code></pre><h3 id=\"七-css选择器的权重\"><a href=\"#七-css选择器的权重\" class=\"headerlink\" title=\"七. css选择器的权重\"></a>七. css选择器的权重</h3><ul>\n<li>行内样式style:<strong>1000</strong></li>\n<li>ID选择器：<strong>100</strong></li>\n<li>类class/属性选择器/伪类(:hover/:focus等)：<strong>10</strong></li>\n<li>元素(标签)/伪元素：<strong>1</strong></li>\n</ul>\n<font color=\"red\">注意：<strong>伪类</strong>指的是一种状态，例如hover，active；<strong>伪元素</strong>指的是文档的某个特定部分的表现。</font>\n\n<pre><code>权重的计算：\n\nbody #content .data img:hover\n\n权重为：1 + 100 + 10 + 1 + 10 = 122\n\n不同的权重，权重高的有效；\n相同的权重，后定义的有效。\n</code></pre><p>一个例子：</p>\n<p>求下面四个选择器权重的大小</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'myDiv'</span> id=<span class=\"string\">'myDiv'</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"selector-tag\">span</span> class=<span class=\"string\">'myDiv'</span> id=<span class=\"string\">'myDiv'</span>&gt;hhhh&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;\t</span><br><span class=\"line\">\t<span class=\"comment\">//1\t</span></span><br><span class=\"line\">\t<span class=\"selector-class\">.myDiv</span> #myDiv&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//2</span></span><br><span class=\"line\">\t<span class=\"selector-id\">#myDiv</span> .myDiv&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//3</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">body</span> <span class=\"selector-class\">.myDiv</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//4</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">div</span><span class=\"selector-class\">.myDiv</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>选择器1：10 + 100 = 110<br>选择器2：100 + 10 = 110<br>选择器3：1 + 10 = 11<br>选择器4：1 + 10 = 11</p>\n<p>权重一样的，后定义的有效</p>\n<p>所以选择器的优先级的顺序是 2 &gt; 1 &gt; 4 &gt; 3</p>\n","excerpt":"","more":"<p>最近在做百度前端公开课第一阶段的任务，第一阶段主要是针对HTML和CSS来进行训练的，然后发现有一些不常用CSS选择器都记得不太清楚，于是就总结了这篇博客，常用的那些就没用写进来。</p>\n<h3 id=\"一-元素选择器\"><a href=\"#一-元素选择器\" class=\"headerlink\" title=\"一. 元素选择器\"></a>一. 元素选择器</h3><pre><code>article\np\nh1\n...\n</code></pre><h3 id=\"二-关系选择器\"><a href=\"#二-关系选择器\" class=\"headerlink\" title=\"二. 关系选择器\"></a>二. 关系选择器</h3><h4 id=\"1-后代选择器X-Y\"><a href=\"#1-后代选择器X-Y\" class=\"headerlink\" title=\"1. 后代选择器X Y\"></a>1. 后代选择器<code>X Y</code></h4><p>选择X的所有子孙元素中为Y的元素</p>\n<h4 id=\"2-子选择器X-gt-Y\"><a href=\"#2-子选择器X-gt-Y\" class=\"headerlink\" title=\"2. 子选择器X &gt; Y\"></a>2. 子选择器<code>X &gt; Y</code></h4><p>与<code>X Y</code>不同的是，<code>X &gt; Y</code>只选择X的直接子元素Y，而不包括其他的子孙元素。</p>\n<h4 id=\"3-相邻兄弟选择器X-Y\"><a href=\"#3-相邻兄弟选择器X-Y\" class=\"headerlink\" title=\"3. 相邻兄弟选择器X + Y\"></a>3. 相邻兄弟选择器<code>X + Y</code></h4><p>匹配X后面紧邻的第一个元素，只匹配一个元素。</p>\n<h4 id=\"4-一般兄弟选择器X-Y\"><a href=\"#4-一般兄弟选择器X-Y\" class=\"headerlink\" title=\"4. 一般兄弟选择器X ~ Y\"></a>4. 一般兄弟选择器<code>X ~ Y</code></h4><p>匹配任何在X之后的所有的同级元素Y</p>\n<h3 id=\"三-属性选择器\"><a href=\"#三-属性选择器\" class=\"headerlink\" title=\"三. 属性选择器\"></a>三. 属性选择器</h3><h4 id=\"1-X-attr\"><a href=\"#1-X-attr\" class=\"headerlink\" title=\"1. X[attr]\"></a>1. X[attr]</h4><p>匹配具有attr属性的所有X元素</p>\n<h4 id=\"2-X-attr-”val”\"><a href=\"#2-X-attr-”val”\" class=\"headerlink\" title=\"2. X[attr=”val”]\"></a>2. X[attr=”val”]</h4><p><code>X[title=&quot;a&quot;]</code> 选择带有title=”a”的所有X</p>\n<h4 id=\"3-X-attr-”val”\"><a href=\"#3-X-attr-”val”\" class=\"headerlink\" title=\"3. X[attr*=”val”]\"></a>3. X[attr*=”val”]</h4><p><code>X[title*=&quot;h&quot;]</code> 匹配属性值包含h的所有的X</p>\n<h4 id=\"4-X-attr-”val”\"><a href=\"#4-X-attr-”val”\" class=\"headerlink\" title=\"4. X[attr^=”val”]\"></a>4. X[attr^=”val”]</h4><p><code>X[title^=&quot;a&quot;]</code> 匹配属性值以a开头的属性</p>\n<h4 id=\"5-X-attr-”val”\"><a href=\"#5-X-attr-”val”\" class=\"headerlink\" title=\"5. X[attr$=”val”]\"></a>5. X[attr$=”val”]</h4><p><code>X[href$=&quot;.png&quot;]</code> 匹配结尾带有特定字符串的X</p>\n<h4 id=\"6-X-attr-”val”\"><a href=\"#6-X-attr-”val”\" class=\"headerlink\" title=\"6. X[attr|=”val”]\"></a>6. X[attr|=”val”]</h4><p><code>p[class|=a]</code> 匹配页面里所有的P段落里具有class属性且属性值为a或是a-开始的，比如<code>class=&quot;a&quot;</code>以及<code>class=&quot;a-b&quot;</code></p>\n<h4 id=\"7-X-attr-”val”\"><a href=\"#7-X-attr-”val”\" class=\"headerlink\" title=\"7. X[attr~=”val”]\"></a>7. X[attr~=”val”]</h4><p><code>div[title~=english]</code> 匹配页面里所有具有属性title且属性值里拥有完整单词english的div容器，比如<code>title=&quot;english&quot;</code>以及<code>title=&quot;a english&quot;</code></p>\n<h3 id=\"四-伪类\"><a href=\"#四-伪类\" class=\"headerlink\" title=\"四. 伪类\"></a>四. 伪类</h3><h4 id=\"1-X-link-X-visited-X-hover-X-active\"><a href=\"#1-X-link-X-visited-X-hover-X-active\" class=\"headerlink\" title=\"1. X:link  X:visited  X:hover  X:active\"></a>1. X:link  X:visited  X:hover  X:active</h4><p>这个主要是要注意写的顺序，原因是css后面的优先级比前面的高。</p>\n<p>顺序为：<strong>l</strong> o <strong>v</strong> e <strong>h</strong> <strong>a</strong> t e</p>\n<h4 id=\"2-其他伪类\"><a href=\"#2-其他伪类\" class=\"headerlink\" title=\"2. 其他伪类\"></a>2. 其他伪类</h4><p><code>X:checked</code> 匹配带有checked属性的元素</p>\n<p><code>X:not(selector)</code> 否定伪类选择器   </p>\n<h3 id=\"五-伪元素\"><a href=\"#五-伪元素\" class=\"headerlink\" title=\"五. 伪元素\"></a>五. 伪元素</h3><p>为了与伪类区分，伪元素使用<code>双冒号::</code></p>\n<p>X::after X::before</p>\n<pre><code>.clearfix:after { \ncontent: &quot;&quot;; \ndisplay: block; \nclear: both; \nvisibility: hidden; \nfont-size: 0; \nheight: 0; \n} \n\n.clearfix { \n    *display: inline-block; \n    _height: 1%; \n} \n</code></pre><p><code>p::first-line</code>  <code>p::first-letter</code></p>\n<p><code>X:nth-child(n)</code> 匹配第n个子元素，从第一个子元素开始索引</p>\n<p><code>X:nth-last-child(n)</code> 从最后一个子元素开始索引</p>\n<pre><code>X:nth-of-type(n) \n\nX:nth-last-of-type(n) \n\nX:first-child\n\nX:last-child\n\nX:only-child\n\nX:only-of-type\n\nX:first-of-type\n</code></pre><h3 id=\"六-通配符\"><a href=\"#六-通配符\" class=\"headerlink\" title=\"六.  * 通配符\"></a>六.  * 通配符</h3><pre><code>* { margin: 0; } \n\n#id *{ margin: 0; }\n</code></pre><h3 id=\"七-css选择器的权重\"><a href=\"#七-css选择器的权重\" class=\"headerlink\" title=\"七. css选择器的权重\"></a>七. css选择器的权重</h3><ul>\n<li>行内样式style:<strong>1000</strong></li>\n<li>ID选择器：<strong>100</strong></li>\n<li>类class/属性选择器/伪类(:hover/:focus等)：<strong>10</strong></li>\n<li>元素(标签)/伪元素：<strong>1</strong></li>\n</ul>\n<font color=\"red\">注意：<strong>伪类</strong>指的是一种状态，例如hover，active；<strong>伪元素</strong>指的是文档的某个特定部分的表现。</font>\n\n<pre><code>权重的计算：\n\nbody #content .data img:hover\n\n权重为：1 + 100 + 10 + 1 + 10 = 122\n\n不同的权重，权重高的有效；\n相同的权重，后定义的有效。\n</code></pre><p>一个例子：</p>\n<p>求下面四个选择器权重的大小</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'myDiv'</span> id=<span class=\"string\">'myDiv'</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"selector-tag\">span</span> class=<span class=\"string\">'myDiv'</span> id=<span class=\"string\">'myDiv'</span>&gt;hhhh&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;\t</span><br><span class=\"line\">\t<span class=\"comment\">//1\t</span></span><br><span class=\"line\">\t<span class=\"selector-class\">.myDiv</span> #myDiv&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//2</span></span><br><span class=\"line\">\t<span class=\"selector-id\">#myDiv</span> .myDiv&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//3</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">body</span> <span class=\"selector-class\">.myDiv</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//4</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">div</span><span class=\"selector-class\">.myDiv</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>选择器1：10 + 100 = 110<br>选择器2：100 + 10 = 110<br>选择器3：1 + 10 = 11<br>选择器4：1 + 10 = 11</p>\n<p>权重一样的，后定义的有效</p>\n<p>所以选择器的优先级的顺序是 2 &gt; 1 &gt; 4 &gt; 3</p>\n"},{"layout":"post","title":"js数组去重","date":"2016-03-30T16:00:00.000Z","description":null,"_content":" \n### 一. 方法一（会改变数组顺序）\n    \n    Array.prototype.unique1 = function(){\n     this.sort(); //先排序\n     var res = [this[0]];//将arr[0]存入结果数组\n     for(var i = 1; i < this.length; i++){//从第一项开始比较\n      if(this[i] !== res[res.length - 1]){//要用不全等符号\n       res.push(this[i]);\n      }\n     }\n     return res;\n    }\n    var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]\n    alert(arr.unique1());\n\n\t思路：将数组排序之后，数组中相同的元素只可能出现在相邻的位置上。\n\t注意：这里进行比较时，一定要用**不全等符号**（！==）\n\t因为 \"1\" !== 1 为true\n\t\t \"1\" != 1 为false\n\n\n### 二. 不改变数组顺序的方法\n\n### 1. 方法一\n\n```\n    Array.prototype.unique2 = function(){\n     var res = [];//一个数组存放去重后的结果\n     var isIn = {};//一个hash表，用来查询，数组中是否存在当前项,hashtable的结构记录已有的元素\n     for(var i = 0; i < this.length; i++){\n      if(!isIn[typeof this[i] + this[i]]){//json中不存在数组当前的元素作为的属性\n       res.push(this[i]);\n       isIn[typeof this[i] + this[i]] = 1;\n      }\n     }\n     return res;\n    }\n    var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];\n    alert(arr.unique2());\n```\n\n注意：这里的'112' 和 112不应该是重复的，所以都应该保留，所以在hash表中，应该把类型也拼接成key\n     \n     isIn[typeof this[i] + this[i]]\n     \n### 2. 方法二\n\n```\n \tArray.prototype.unique3 = function()\n    {\n    \tvar res = []; //一个新的临时数组\n    \tfor(var i = 0; i < this.length; i++) //遍历当前数组\n    \t{\n    \t\t//如果当前数组的第i已经保存进了临时数组，那么跳过，\n    \t\t//否则把当前项push到临时数组里面\n    \t\tif (res.indexOf(this[i]) == -1) {\n\t\t\t\tres.push(this[i]);\n\t\t\t}\n    \t}\n    \treturn res;\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-31-js数组去重.md","raw":"---\nlayout: post\ntitle: js数组去重\ndate: 2016-03-31\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n \n### 一. 方法一（会改变数组顺序）\n    \n    Array.prototype.unique1 = function(){\n     this.sort(); //先排序\n     var res = [this[0]];//将arr[0]存入结果数组\n     for(var i = 1; i < this.length; i++){//从第一项开始比较\n      if(this[i] !== res[res.length - 1]){//要用不全等符号\n       res.push(this[i]);\n      }\n     }\n     return res;\n    }\n    var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]\n    alert(arr.unique1());\n\n\t思路：将数组排序之后，数组中相同的元素只可能出现在相邻的位置上。\n\t注意：这里进行比较时，一定要用**不全等符号**（！==）\n\t因为 \"1\" !== 1 为true\n\t\t \"1\" != 1 为false\n\n\n### 二. 不改变数组顺序的方法\n\n### 1. 方法一\n\n```\n    Array.prototype.unique2 = function(){\n     var res = [];//一个数组存放去重后的结果\n     var isIn = {};//一个hash表，用来查询，数组中是否存在当前项,hashtable的结构记录已有的元素\n     for(var i = 0; i < this.length; i++){\n      if(!isIn[typeof this[i] + this[i]]){//json中不存在数组当前的元素作为的属性\n       res.push(this[i]);\n       isIn[typeof this[i] + this[i]] = 1;\n      }\n     }\n     return res;\n    }\n    var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];\n    alert(arr.unique2());\n```\n\n注意：这里的'112' 和 112不应该是重复的，所以都应该保留，所以在hash表中，应该把类型也拼接成key\n     \n     isIn[typeof this[i] + this[i]]\n     \n### 2. 方法二\n\n```\n \tArray.prototype.unique3 = function()\n    {\n    \tvar res = []; //一个新的临时数组\n    \tfor(var i = 0; i < this.length; i++) //遍历当前数组\n    \t{\n    \t\t//如果当前数组的第i已经保存进了临时数组，那么跳过，\n    \t\t//否则把当前项push到临时数组里面\n    \t\tif (res.indexOf(this[i]) == -1) {\n\t\t\t\tres.push(this[i]);\n\t\t\t}\n    \t}\n    \treturn res;\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-31-js数组去重","published":1,"updated":"2016-08-23T14:14:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocda001ud5u8zy9f6xo1","content":"<h3 id=\"一-方法一（会改变数组顺序）\"><a href=\"#一-方法一（会改变数组顺序）\" class=\"headerlink\" title=\"一. 方法一（会改变数组顺序）\"></a>一. 方法一（会改变数组顺序）</h3><pre><code>Array.prototype.unique1 = function(){\n this.sort(); //先排序\n var res = [this[0]];//将arr[0]存入结果数组\n for(var i = 1; i &lt; this.length; i++){//从第一项开始比较\n  if(this[i] !== res[res.length - 1]){//要用不全等符号\n   res.push(this[i]);\n  }\n }\n return res;\n}\nvar arr = [1, &apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;, &apos;e&apos;, 1, 0]\nalert(arr.unique1());\n\n思路：将数组排序之后，数组中相同的元素只可能出现在相邻的位置上。\n注意：这里进行比较时，一定要用**不全等符号**（！==）\n因为 &quot;1&quot; !== 1 为true\n     &quot;1&quot; != 1 为false\n</code></pre><h3 id=\"二-不改变数组顺序的方法\"><a href=\"#二-不改变数组顺序的方法\" class=\"headerlink\" title=\"二. 不改变数组顺序的方法\"></a>二. 不改变数组顺序的方法</h3><h3 id=\"1-方法一\"><a href=\"#1-方法一\" class=\"headerlink\" title=\"1. 方法一\"></a>1. 方法一</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique2 = function()&#123;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> res = [];<span class=\"comment\">//一个数组存放去重后的结果</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> isIn = &#123;&#125;;<span class=\"comment\">//一个hash表，用来查询，数组中是否存在当前项,hashtable的结构记录已有的元素</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!isIn[typeof <span class=\"keyword\">this</span>[i] + <span class=\"keyword\">this</span>[i]])&#123;<span class=\"comment\">//json中不存在数组当前的元素作为的属性</span></span><br><span class=\"line\">   res.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">   isIn[typeof <span class=\"keyword\">this</span>[i] + <span class=\"keyword\">this</span>[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">'你好'</span>,<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">'你好'</span>,<span class=\"string\">'str'</span>,<span class=\"string\">'str1'</span>];</span><br><span class=\"line\">alert(arr.unique2());</span><br></pre></td></tr></table></figure>\n<p>注意：这里的’112’ 和 112不应该是重复的，所以都应该保留，所以在hash表中，应该把类型也拼接成key</p>\n<pre><code>isIn[typeof this[i] + this[i]]\n</code></pre><h3 id=\"2-方法二\"><a href=\"#2-方法二\" class=\"headerlink\" title=\"2. 方法二\"></a>2. 方法二</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span><br><span class=\"line\">  </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">var</span> res = []; <span class=\"comment\">//一个新的临时数组</span></span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++) <span class=\"comment\">//遍历当前数组</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">  \t\t<span class=\"comment\">//如果当前数组的第i已经保存进了临时数组，那么跳过，</span></span><br><span class=\"line\">  \t\t<span class=\"comment\">//否则把当前项push到临时数组里面</span></span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span> (res.indexOf(<span class=\"keyword\">this</span>[i]) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\tres.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-方法一（会改变数组顺序）\"><a href=\"#一-方法一（会改变数组顺序）\" class=\"headerlink\" title=\"一. 方法一（会改变数组顺序）\"></a>一. 方法一（会改变数组顺序）</h3><pre><code>Array.prototype.unique1 = function(){\n this.sort(); //先排序\n var res = [this[0]];//将arr[0]存入结果数组\n for(var i = 1; i &lt; this.length; i++){//从第一项开始比较\n  if(this[i] !== res[res.length - 1]){//要用不全等符号\n   res.push(this[i]);\n  }\n }\n return res;\n}\nvar arr = [1, &apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;, &apos;e&apos;, 1, 0]\nalert(arr.unique1());\n\n思路：将数组排序之后，数组中相同的元素只可能出现在相邻的位置上。\n注意：这里进行比较时，一定要用**不全等符号**（！==）\n因为 &quot;1&quot; !== 1 为true\n     &quot;1&quot; != 1 为false\n</code></pre><h3 id=\"二-不改变数组顺序的方法\"><a href=\"#二-不改变数组顺序的方法\" class=\"headerlink\" title=\"二. 不改变数组顺序的方法\"></a>二. 不改变数组顺序的方法</h3><h3 id=\"1-方法一\"><a href=\"#1-方法一\" class=\"headerlink\" title=\"1. 方法一\"></a>1. 方法一</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique2 = function()&#123;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> res = [];<span class=\"comment\">//一个数组存放去重后的结果</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> isIn = &#123;&#125;;<span class=\"comment\">//一个hash表，用来查询，数组中是否存在当前项,hashtable的结构记录已有的元素</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!isIn[typeof <span class=\"keyword\">this</span>[i] + <span class=\"keyword\">this</span>[i]])&#123;<span class=\"comment\">//json中不存在数组当前的元素作为的属性</span></span><br><span class=\"line\">   res.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">   isIn[typeof <span class=\"keyword\">this</span>[i] + <span class=\"keyword\">this</span>[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">'你好'</span>,<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">'你好'</span>,<span class=\"string\">'str'</span>,<span class=\"string\">'str1'</span>];</span><br><span class=\"line\">alert(arr.unique2());</span><br></pre></td></tr></table></figure>\n<p>注意：这里的’112’ 和 112不应该是重复的，所以都应该保留，所以在hash表中，应该把类型也拼接成key</p>\n<pre><code>isIn[typeof this[i] + this[i]]\n</code></pre><h3 id=\"2-方法二\"><a href=\"#2-方法二\" class=\"headerlink\" title=\"2. 方法二\"></a>2. 方法二</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span><br><span class=\"line\">  </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">var</span> res = []; <span class=\"comment\">//一个新的临时数组</span></span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++) <span class=\"comment\">//遍历当前数组</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">  \t\t<span class=\"comment\">//如果当前数组的第i已经保存进了临时数组，那么跳过，</span></span><br><span class=\"line\">  \t\t<span class=\"comment\">//否则把当前项push到临时数组里面</span></span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span> (res.indexOf(<span class=\"keyword\">this</span>[i]) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\tres.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"git使用","date":"2016-03-24T16:00:00.000Z","description":null,"_content":"\n### 一. git的一些常用命令\n\n    git checkout -b panpan\n    git新建一个分支\n\n    git branch panpan\n    git checkout panpan\n\ngit是什么：分布式版本控制系统\n\n自动记录每次文件的改动，还可以让同事协作编辑\n\n    git init 创建版本库\n\n**.git 目录是git用来跟踪管理版本库的，千万不要手动修改这个目录里的文件**\n\n    git add 把文件添加到仓库\n\n    git commit 把文件提交到仓库  \n    git commit -m  \"-m\"后面添加本次提交的说明\n\n\n\n    git status 查看仓库当前的状态\n    git diff  查看difference\n    git log 查看提交历史记录\n    git reflog 查看命令历史\n    git reset  --hard commit_id 回退到上一个版本\n    \n    git clone\n    git push\n    \n    git pull   相当于是从远程获取最新版本到本地，不会自动merge\n    git fetch 相当于是从远程获取最新版本并merge到本地\n\n**git提交文件的步骤**\n    \n    1.查看目前代码的修改状态 git status\n    \n    2.查看代码修改内容 git diff  <file>\n    \n    3.暂存需要提交的文件git add  <file>\n    \n    4.提交已暂存的文件git commit\n    \n    5.同步到服务器\n    \n    同步到服务器前先需要将服务器代码同步到本地git pull\n    \n    同步到服务器\n    命令： git push origin  <本地分支名>\n    \n\n","source":"_posts/2016-03-27-git使用.md","raw":"---\nlayout: post\ntitle: git使用\ndate: 2016-03-25\ncategories: 前端笔记\ntags: [github]\ndescription: \n---\n\n### 一. git的一些常用命令\n\n    git checkout -b panpan\n    git新建一个分支\n\n    git branch panpan\n    git checkout panpan\n\ngit是什么：分布式版本控制系统\n\n自动记录每次文件的改动，还可以让同事协作编辑\n\n    git init 创建版本库\n\n**.git 目录是git用来跟踪管理版本库的，千万不要手动修改这个目录里的文件**\n\n    git add 把文件添加到仓库\n\n    git commit 把文件提交到仓库  \n    git commit -m  \"-m\"后面添加本次提交的说明\n\n\n\n    git status 查看仓库当前的状态\n    git diff  查看difference\n    git log 查看提交历史记录\n    git reflog 查看命令历史\n    git reset  --hard commit_id 回退到上一个版本\n    \n    git clone\n    git push\n    \n    git pull   相当于是从远程获取最新版本到本地，不会自动merge\n    git fetch 相当于是从远程获取最新版本并merge到本地\n\n**git提交文件的步骤**\n    \n    1.查看目前代码的修改状态 git status\n    \n    2.查看代码修改内容 git diff  <file>\n    \n    3.暂存需要提交的文件git add  <file>\n    \n    4.提交已暂存的文件git commit\n    \n    5.同步到服务器\n    \n    同步到服务器前先需要将服务器代码同步到本地git pull\n    \n    同步到服务器\n    命令： git push origin  <本地分支名>\n    \n\n","slug":"2016-03-27-git使用","published":1,"updated":"2017-03-09T06:35:57.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocdd001yd5u86duvz335","content":"<h3 id=\"一-git的一些常用命令\"><a href=\"#一-git的一些常用命令\" class=\"headerlink\" title=\"一. git的一些常用命令\"></a>一. git的一些常用命令</h3><pre><code>git checkout -b panpan\ngit新建一个分支\n\ngit branch panpan\ngit checkout panpan\n</code></pre><p>git是什么：分布式版本控制系统</p>\n<p>自动记录每次文件的改动，还可以让同事协作编辑</p>\n<pre><code>git init 创建版本库\n</code></pre><p><strong>.git 目录是git用来跟踪管理版本库的，千万不要手动修改这个目录里的文件</strong></p>\n<pre><code>git add 把文件添加到仓库\n\ngit commit 把文件提交到仓库  \ngit commit -m  &quot;-m&quot;后面添加本次提交的说明\n\n\n\ngit status 查看仓库当前的状态\ngit diff  查看difference\ngit log 查看提交历史记录\ngit reflog 查看命令历史\ngit reset  --hard commit_id 回退到上一个版本\n\ngit clone\ngit push\n\ngit pull   相当于是从远程获取最新版本到本地，不会自动merge\ngit fetch 相当于是从远程获取最新版本并merge到本地\n</code></pre><p><strong>git提交文件的步骤</strong></p>\n<pre><code>1.查看目前代码的修改状态 git status\n\n2.查看代码修改内容 git diff  &lt;file&gt;\n\n3.暂存需要提交的文件git add  &lt;file&gt;\n\n4.提交已暂存的文件git commit\n\n5.同步到服务器\n\n同步到服务器前先需要将服务器代码同步到本地git pull\n\n同步到服务器\n命令： git push origin  &lt;本地分支名&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"一-git的一些常用命令\"><a href=\"#一-git的一些常用命令\" class=\"headerlink\" title=\"一. git的一些常用命令\"></a>一. git的一些常用命令</h3><pre><code>git checkout -b panpan\ngit新建一个分支\n\ngit branch panpan\ngit checkout panpan\n</code></pre><p>git是什么：分布式版本控制系统</p>\n<p>自动记录每次文件的改动，还可以让同事协作编辑</p>\n<pre><code>git init 创建版本库\n</code></pre><p><strong>.git 目录是git用来跟踪管理版本库的，千万不要手动修改这个目录里的文件</strong></p>\n<pre><code>git add 把文件添加到仓库\n\ngit commit 把文件提交到仓库  \ngit commit -m  &quot;-m&quot;后面添加本次提交的说明\n\n\n\ngit status 查看仓库当前的状态\ngit diff  查看difference\ngit log 查看提交历史记录\ngit reflog 查看命令历史\ngit reset  --hard commit_id 回退到上一个版本\n\ngit clone\ngit push\n\ngit pull   相当于是从远程获取最新版本到本地，不会自动merge\ngit fetch 相当于是从远程获取最新版本并merge到本地\n</code></pre><p><strong>git提交文件的步骤</strong></p>\n<pre><code>1.查看目前代码的修改状态 git status\n\n2.查看代码修改内容 git diff  &lt;file&gt;\n\n3.暂存需要提交的文件git add  &lt;file&gt;\n\n4.提交已暂存的文件git commit\n\n5.同步到服务器\n\n同步到服务器前先需要将服务器代码同步到本地git pull\n\n同步到服务器\n命令： git push origin  &lt;本地分支名&gt;\n</code></pre>"},{"layout":"post","title":"击鼓传花-用循环队列实现","date":"2016-03-30T16:00:00.000Z","description":null,"_content":"\n### 一.  什么是队列\n\n   队列是遵循**先进先出**的原则的一组有序的项。\n\n（类似我们平时生活中排队买东西，队伍最前面的先买到，然后离开）\n\n### 二. 创建队列\n\n**1. 声明一个队列的类**\n\n    function Queue() {\n\tvar items = [];//使用数组来储存队列中的元素\n    //队列的属性和方法\n    }\n\n**2. 声明队列中的一些方法**\n\n**a. enqueue(element) 向队列尾部添加一项或多项**\n    \n    this.enqueue = function(element){\n    \titems.push(element);\n    }\n\n**b. dequeue() 删除队列头部的一项，并返回移除的元素**\n\t\t\n\tthis.dequeue = function()\n\t{\n\t\treturn items.shift();\n\t}\n\n**c. front() 返回队列中的第一个元素，队列不做任何改变**\n     \n    this.front = function()\n    {\n    \treturn items[0];\n    }\n\n**d. isEmpty() 判断队列是否为空，若为空，则返回true；若不为空，则返回false**\n  \n    this.isEmpty = function()\n    {\n    \treturn items.length == 0;\n    }\n\n**e. size() 返回队列包含元素的个数**\n\n    this.size = function()\n    {\n    \treturn items.length;\n    }\n\n**f. print() 以字符串的形式在控制台打印出来队列中的所有元素**\n\n    this.print = function()\n    {\n    \tconsole.log(items.toString());\n    }\n\n3. 使用queue类\n\n实例化我们创建的queue类\n\nvar myqueue = new Queue();\n\n### 三. 队列的一些修改的版本\n\n二中定义的队列是普通的版本，现实生活中有一些修改的队列。\n\n**1. 优先队列**\n\n实例：机场登机的时候，乘客是分有优先级的，优先级高的乘客可以先登机。\n\n（1）. 声明一个优先队列的类\n\n    function PriorityQueue()\n    {\n    \tvar items = [];//还是使用一个数组来保存队列中的值\n    }\n\n（2）. 定义优先队列里的一些方法\n\n**a. QueueElement()创建一个特殊的元素，包含队列中的元素和对应的优先级**\n\nfunction QueueElement(element,priority)\n{\n\tthis.element = element;\n}\n\n**b. enqueue() 向队列中按照优先级插入元素**\n\n优先级越高，元素越靠前（优先级数字越小，优先级越高）\n\n    this.enqueue = function(element,priority)\n    {\n    \tvar queueElement = new QueueElement(element,priority);\n    \t\n    \tif(this.isEmpty())\n    \t{\n    \t\titems.push(queueElement);//如果队列为空，则直接把这个元素插入队列\n    \t}\n    \telse\n    \t{\n    \t\tvar added = false;\n    \t\t//如果队列不为空，则将队列中的元素优先级从0位置逐一与要插入的元素的优先级比较，遇到第一个优先级数字比插入元素优先级数字大的，则将元素插入到这个元素的前面\n    \t\tfor(var i = 0; i<items.length;i++)\n    \t\t{\n    \t\t\tif(queueElement.priority < items[i].priority)\n    \t\t\t{\n    \t\t\t\titems.splice(1,0,queueElement);\n    \t\t\t\tadded = true;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(!added)\n    \t\t{\n    \t\t\titems.push(queueElement);//如果队列中所有元素的优先级数字都比插入元素优先级数字小，则将元素插到队列末尾\n    \t\t}\n    \t}\n    }\n\n<font color=\"red\">注意：这种插入可以保证，在优先级一样的情况下，仍然是先进先出</font>\n\n**c. 补充解释js中的三个方法：**\n\n**shift()**   移除数组的第一个元素，并返回第一个元素\n\n\t<script type=\"text/javascript\">\n\t\n\t\tvar arr = new Array(3)\n\t\tarr[0] = \"George\"\n\t\tarr[1] = \"John\"\n\t\tarr[2] = \"Thomas\"\n\t\t\n\t\tdocument.write(arr.shift() + \"<br />\")\n\t\n\t</script>\n\n\n    输出结果：George\n\n**splice(index,howmany,item1,...,itemX)**\n\n从index的地方开始删除howmany个元素，然后插入item\n\n若howmany=0，则不删除元素，直接插入\n\n    <script type=\"text/javascript\">\n    \n    \tvar arr = new Array(6)\n    \tarr[0] = \"1\"\n    \tarr[1] = \"2\"\n    \tarr[2] = \"3\"\n    \t   \t\n    \tdocument.write(arr + \"<br />\")\n    \tarr.splice(2,0,\"4\")\n    \tdocument.write(arr + \"<br />\")\n    \n    </script>\n    \n    输出结果：\n    1，2，3\n    1，2，4，3\n\nslice(start,end)\n\n不对原数组进行操作（原数组不变），生成一个新的数组（子数组）\n\n**2. 循环队列** 实现一个模拟的击鼓传花的游戏\n\n(1). 用程序语言理解击鼓传花的游戏\n\n击鼓传花是一群人围成一个圈，那么用一个数组来保存这些人的名字。\n\n当敲鼓一段时间，鼓停止，花在谁手上谁就会被淘汰，那么定义这段时间为一个数字，数到这个数字的时候，花在谁手上谁就会被淘汰。\n\n那么这个游戏需要传入两个参数：保存人名的数组、鼓停止的时刻\n\n(2). 实现击鼓传花\n\n    function hotPotato(nameLIst,num)\n    {\n    \tvar queue = new Queue();//创建一个队列\n    \t\n    \t//将人名存入队列\n    \tfor(var i=0;i<nameList.length;i++)\n    \t{\n    \t\tqueue.enqueue(nameList[i]);\n    \t}\n    \t\n    \twhile(queue.size()>1)\n    \t{\n    \t\tvar loser = \"\";\n    \t\tfor(var i=0;i<num;i++)\n    \t\t{\n    \t\t\tqueue.enqueue(queue.dequeue());//在没有数到鼓停止的数字num时，从队列头部删除的元素queue.dequeue()需要被添加到队列尾部\n    \t\t}\n    \t\tloser = queue.dequeue();\n    \t\tconsole.log(loser+\"在游戏中被淘汰\")\n    \t}\n    \t\n    \treturn queue.dequeue();//最后的获胜者\n    }\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-31-击鼓传花-用循环队列实现.md","raw":"---\nlayout: post\ntitle: 击鼓传花-用循环队列实现\ndate: 2016-03-31\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一.  什么是队列\n\n   队列是遵循**先进先出**的原则的一组有序的项。\n\n（类似我们平时生活中排队买东西，队伍最前面的先买到，然后离开）\n\n### 二. 创建队列\n\n**1. 声明一个队列的类**\n\n    function Queue() {\n\tvar items = [];//使用数组来储存队列中的元素\n    //队列的属性和方法\n    }\n\n**2. 声明队列中的一些方法**\n\n**a. enqueue(element) 向队列尾部添加一项或多项**\n    \n    this.enqueue = function(element){\n    \titems.push(element);\n    }\n\n**b. dequeue() 删除队列头部的一项，并返回移除的元素**\n\t\t\n\tthis.dequeue = function()\n\t{\n\t\treturn items.shift();\n\t}\n\n**c. front() 返回队列中的第一个元素，队列不做任何改变**\n     \n    this.front = function()\n    {\n    \treturn items[0];\n    }\n\n**d. isEmpty() 判断队列是否为空，若为空，则返回true；若不为空，则返回false**\n  \n    this.isEmpty = function()\n    {\n    \treturn items.length == 0;\n    }\n\n**e. size() 返回队列包含元素的个数**\n\n    this.size = function()\n    {\n    \treturn items.length;\n    }\n\n**f. print() 以字符串的形式在控制台打印出来队列中的所有元素**\n\n    this.print = function()\n    {\n    \tconsole.log(items.toString());\n    }\n\n3. 使用queue类\n\n实例化我们创建的queue类\n\nvar myqueue = new Queue();\n\n### 三. 队列的一些修改的版本\n\n二中定义的队列是普通的版本，现实生活中有一些修改的队列。\n\n**1. 优先队列**\n\n实例：机场登机的时候，乘客是分有优先级的，优先级高的乘客可以先登机。\n\n（1）. 声明一个优先队列的类\n\n    function PriorityQueue()\n    {\n    \tvar items = [];//还是使用一个数组来保存队列中的值\n    }\n\n（2）. 定义优先队列里的一些方法\n\n**a. QueueElement()创建一个特殊的元素，包含队列中的元素和对应的优先级**\n\nfunction QueueElement(element,priority)\n{\n\tthis.element = element;\n}\n\n**b. enqueue() 向队列中按照优先级插入元素**\n\n优先级越高，元素越靠前（优先级数字越小，优先级越高）\n\n    this.enqueue = function(element,priority)\n    {\n    \tvar queueElement = new QueueElement(element,priority);\n    \t\n    \tif(this.isEmpty())\n    \t{\n    \t\titems.push(queueElement);//如果队列为空，则直接把这个元素插入队列\n    \t}\n    \telse\n    \t{\n    \t\tvar added = false;\n    \t\t//如果队列不为空，则将队列中的元素优先级从0位置逐一与要插入的元素的优先级比较，遇到第一个优先级数字比插入元素优先级数字大的，则将元素插入到这个元素的前面\n    \t\tfor(var i = 0; i<items.length;i++)\n    \t\t{\n    \t\t\tif(queueElement.priority < items[i].priority)\n    \t\t\t{\n    \t\t\t\titems.splice(1,0,queueElement);\n    \t\t\t\tadded = true;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(!added)\n    \t\t{\n    \t\t\titems.push(queueElement);//如果队列中所有元素的优先级数字都比插入元素优先级数字小，则将元素插到队列末尾\n    \t\t}\n    \t}\n    }\n\n<font color=\"red\">注意：这种插入可以保证，在优先级一样的情况下，仍然是先进先出</font>\n\n**c. 补充解释js中的三个方法：**\n\n**shift()**   移除数组的第一个元素，并返回第一个元素\n\n\t<script type=\"text/javascript\">\n\t\n\t\tvar arr = new Array(3)\n\t\tarr[0] = \"George\"\n\t\tarr[1] = \"John\"\n\t\tarr[2] = \"Thomas\"\n\t\t\n\t\tdocument.write(arr.shift() + \"<br />\")\n\t\n\t</script>\n\n\n    输出结果：George\n\n**splice(index,howmany,item1,...,itemX)**\n\n从index的地方开始删除howmany个元素，然后插入item\n\n若howmany=0，则不删除元素，直接插入\n\n    <script type=\"text/javascript\">\n    \n    \tvar arr = new Array(6)\n    \tarr[0] = \"1\"\n    \tarr[1] = \"2\"\n    \tarr[2] = \"3\"\n    \t   \t\n    \tdocument.write(arr + \"<br />\")\n    \tarr.splice(2,0,\"4\")\n    \tdocument.write(arr + \"<br />\")\n    \n    </script>\n    \n    输出结果：\n    1，2，3\n    1，2，4，3\n\nslice(start,end)\n\n不对原数组进行操作（原数组不变），生成一个新的数组（子数组）\n\n**2. 循环队列** 实现一个模拟的击鼓传花的游戏\n\n(1). 用程序语言理解击鼓传花的游戏\n\n击鼓传花是一群人围成一个圈，那么用一个数组来保存这些人的名字。\n\n当敲鼓一段时间，鼓停止，花在谁手上谁就会被淘汰，那么定义这段时间为一个数字，数到这个数字的时候，花在谁手上谁就会被淘汰。\n\n那么这个游戏需要传入两个参数：保存人名的数组、鼓停止的时刻\n\n(2). 实现击鼓传花\n\n    function hotPotato(nameLIst,num)\n    {\n    \tvar queue = new Queue();//创建一个队列\n    \t\n    \t//将人名存入队列\n    \tfor(var i=0;i<nameList.length;i++)\n    \t{\n    \t\tqueue.enqueue(nameList[i]);\n    \t}\n    \t\n    \twhile(queue.size()>1)\n    \t{\n    \t\tvar loser = \"\";\n    \t\tfor(var i=0;i<num;i++)\n    \t\t{\n    \t\t\tqueue.enqueue(queue.dequeue());//在没有数到鼓停止的数字num时，从队列头部删除的元素queue.dequeue()需要被添加到队列尾部\n    \t\t}\n    \t\tloser = queue.dequeue();\n    \t\tconsole.log(loser+\"在游戏中被淘汰\")\n    \t}\n    \t\n    \treturn queue.dequeue();//最后的获胜者\n    }\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-31-击鼓传花-用循环队列实现","published":1,"updated":"2016-04-19T03:26:52.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocde0021d5u8ue61a7dk","content":"<h3 id=\"一-什么是队列\"><a href=\"#一-什么是队列\" class=\"headerlink\" title=\"一.  什么是队列\"></a>一.  什么是队列</h3><p>   队列是遵循<strong>先进先出</strong>的原则的一组有序的项。</p>\n<p>（类似我们平时生活中排队买东西，队伍最前面的先买到，然后离开）</p>\n<h3 id=\"二-创建队列\"><a href=\"#二-创建队列\" class=\"headerlink\" title=\"二. 创建队列\"></a>二. 创建队列</h3><p><strong>1. 声明一个队列的类</strong></p>\n<pre><code>function Queue() {\nvar items = [];//使用数组来储存队列中的元素\n//队列的属性和方法\n}\n</code></pre><p><strong>2. 声明队列中的一些方法</strong></p>\n<p><strong>a. enqueue(element) 向队列尾部添加一项或多项</strong></p>\n<pre><code>this.enqueue = function(element){\n    items.push(element);\n}\n</code></pre><p><strong>b. dequeue() 删除队列头部的一项，并返回移除的元素</strong></p>\n<pre><code>this.dequeue = function()\n{\n    return items.shift();\n}\n</code></pre><p><strong>c. front() 返回队列中的第一个元素，队列不做任何改变</strong></p>\n<pre><code>this.front = function()\n{\n    return items[0];\n}\n</code></pre><p><strong>d. isEmpty() 判断队列是否为空，若为空，则返回true；若不为空，则返回false</strong></p>\n<pre><code>this.isEmpty = function()\n{\n    return items.length == 0;\n}\n</code></pre><p><strong>e. size() 返回队列包含元素的个数</strong></p>\n<pre><code>this.size = function()\n{\n    return items.length;\n}\n</code></pre><p><strong>f. print() 以字符串的形式在控制台打印出来队列中的所有元素</strong></p>\n<pre><code>this.print = function()\n{\n    console.log(items.toString());\n}\n</code></pre><ol>\n<li>使用queue类</li>\n</ol>\n<p>实例化我们创建的queue类</p>\n<p>var myqueue = new Queue();</p>\n<h3 id=\"三-队列的一些修改的版本\"><a href=\"#三-队列的一些修改的版本\" class=\"headerlink\" title=\"三. 队列的一些修改的版本\"></a>三. 队列的一些修改的版本</h3><p>二中定义的队列是普通的版本，现实生活中有一些修改的队列。</p>\n<p><strong>1. 优先队列</strong></p>\n<p>实例：机场登机的时候，乘客是分有优先级的，优先级高的乘客可以先登机。</p>\n<p>（1）. 声明一个优先队列的类</p>\n<pre><code>function PriorityQueue()\n{\n    var items = [];//还是使用一个数组来保存队列中的值\n}\n</code></pre><p>（2）. 定义优先队列里的一些方法</p>\n<p><strong>a. QueueElement()创建一个特殊的元素，包含队列中的元素和对应的优先级</strong></p>\n<p>function QueueElement(element,priority)<br>{<br>    this.element = element;<br>}</p>\n<p><strong>b. enqueue() 向队列中按照优先级插入元素</strong></p>\n<p>优先级越高，元素越靠前（优先级数字越小，优先级越高）</p>\n<pre><code>this.enqueue = function(element,priority)\n{\n    var queueElement = new QueueElement(element,priority);\n\n    if(this.isEmpty())\n    {\n        items.push(queueElement);//如果队列为空，则直接把这个元素插入队列\n    }\n    else\n    {\n        var added = false;\n        //如果队列不为空，则将队列中的元素优先级从0位置逐一与要插入的元素的优先级比较，遇到第一个优先级数字比插入元素优先级数字大的，则将元素插入到这个元素的前面\n        for(var i = 0; i&lt;items.length;i++)\n        {\n            if(queueElement.priority &lt; items[i].priority)\n            {\n                items.splice(1,0,queueElement);\n                added = true;\n                break;\n            }\n        }\n\n        if(!added)\n        {\n            items.push(queueElement);//如果队列中所有元素的优先级数字都比插入元素优先级数字小，则将元素插到队列末尾\n        }\n    }\n}\n</code></pre><font color=\"red\">注意：这种插入可以保证，在优先级一样的情况下，仍然是先进先出</font>\n\n<p><strong>c. 补充解释js中的三个方法：</strong></p>\n<p><strong>shift()</strong>   移除数组的第一个元素，并返回第一个元素</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n\n    var arr = new Array(3)\n    arr[0] = &quot;George&quot;\n    arr[1] = &quot;John&quot;\n    arr[2] = &quot;Thomas&quot;\n\n    document.write(arr.shift() + &quot;&lt;br /&gt;&quot;)\n\n&lt;/script&gt;\n\n\n输出结果：George\n</code></pre><p><strong>splice(index,howmany,item1,…,itemX)</strong></p>\n<p>从index的地方开始删除howmany个元素，然后插入item</p>\n<p>若howmany=0，则不删除元素，直接插入</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n\n    var arr = new Array(6)\n    arr[0] = &quot;1&quot;\n    arr[1] = &quot;2&quot;\n    arr[2] = &quot;3&quot;\n\n    document.write(arr + &quot;&lt;br /&gt;&quot;)\n    arr.splice(2,0,&quot;4&quot;)\n    document.write(arr + &quot;&lt;br /&gt;&quot;)\n\n&lt;/script&gt;\n\n输出结果：\n1，2，3\n1，2，4，3\n</code></pre><p>slice(start,end)</p>\n<p>不对原数组进行操作（原数组不变），生成一个新的数组（子数组）</p>\n<p><strong>2. 循环队列</strong> 实现一个模拟的击鼓传花的游戏</p>\n<p>(1). 用程序语言理解击鼓传花的游戏</p>\n<p>击鼓传花是一群人围成一个圈，那么用一个数组来保存这些人的名字。</p>\n<p>当敲鼓一段时间，鼓停止，花在谁手上谁就会被淘汰，那么定义这段时间为一个数字，数到这个数字的时候，花在谁手上谁就会被淘汰。</p>\n<p>那么这个游戏需要传入两个参数：保存人名的数组、鼓停止的时刻</p>\n<p>(2). 实现击鼓传花</p>\n<pre><code>function hotPotato(nameLIst,num)\n{\n    var queue = new Queue();//创建一个队列\n\n    //将人名存入队列\n    for(var i=0;i&lt;nameList.length;i++)\n    {\n        queue.enqueue(nameList[i]);\n    }\n\n    while(queue.size()&gt;1)\n    {\n        var loser = &quot;&quot;;\n        for(var i=0;i&lt;num;i++)\n        {\n            queue.enqueue(queue.dequeue());//在没有数到鼓停止的数字num时，从队列头部删除的元素queue.dequeue()需要被添加到队列尾部\n        }\n        loser = queue.dequeue();\n        console.log(loser+&quot;在游戏中被淘汰&quot;)\n    }\n\n    return queue.dequeue();//最后的获胜者\n}\n</code></pre>","excerpt":"","more":"<h3 id=\"一-什么是队列\"><a href=\"#一-什么是队列\" class=\"headerlink\" title=\"一.  什么是队列\"></a>一.  什么是队列</h3><p>   队列是遵循<strong>先进先出</strong>的原则的一组有序的项。</p>\n<p>（类似我们平时生活中排队买东西，队伍最前面的先买到，然后离开）</p>\n<h3 id=\"二-创建队列\"><a href=\"#二-创建队列\" class=\"headerlink\" title=\"二. 创建队列\"></a>二. 创建队列</h3><p><strong>1. 声明一个队列的类</strong></p>\n<pre><code>function Queue() {\nvar items = [];//使用数组来储存队列中的元素\n//队列的属性和方法\n}\n</code></pre><p><strong>2. 声明队列中的一些方法</strong></p>\n<p><strong>a. enqueue(element) 向队列尾部添加一项或多项</strong></p>\n<pre><code>this.enqueue = function(element){\n    items.push(element);\n}\n</code></pre><p><strong>b. dequeue() 删除队列头部的一项，并返回移除的元素</strong></p>\n<pre><code>this.dequeue = function()\n{\n    return items.shift();\n}\n</code></pre><p><strong>c. front() 返回队列中的第一个元素，队列不做任何改变</strong></p>\n<pre><code>this.front = function()\n{\n    return items[0];\n}\n</code></pre><p><strong>d. isEmpty() 判断队列是否为空，若为空，则返回true；若不为空，则返回false</strong></p>\n<pre><code>this.isEmpty = function()\n{\n    return items.length == 0;\n}\n</code></pre><p><strong>e. size() 返回队列包含元素的个数</strong></p>\n<pre><code>this.size = function()\n{\n    return items.length;\n}\n</code></pre><p><strong>f. print() 以字符串的形式在控制台打印出来队列中的所有元素</strong></p>\n<pre><code>this.print = function()\n{\n    console.log(items.toString());\n}\n</code></pre><ol>\n<li>使用queue类</li>\n</ol>\n<p>实例化我们创建的queue类</p>\n<p>var myqueue = new Queue();</p>\n<h3 id=\"三-队列的一些修改的版本\"><a href=\"#三-队列的一些修改的版本\" class=\"headerlink\" title=\"三. 队列的一些修改的版本\"></a>三. 队列的一些修改的版本</h3><p>二中定义的队列是普通的版本，现实生活中有一些修改的队列。</p>\n<p><strong>1. 优先队列</strong></p>\n<p>实例：机场登机的时候，乘客是分有优先级的，优先级高的乘客可以先登机。</p>\n<p>（1）. 声明一个优先队列的类</p>\n<pre><code>function PriorityQueue()\n{\n    var items = [];//还是使用一个数组来保存队列中的值\n}\n</code></pre><p>（2）. 定义优先队列里的一些方法</p>\n<p><strong>a. QueueElement()创建一个特殊的元素，包含队列中的元素和对应的优先级</strong></p>\n<p>function QueueElement(element,priority)<br>{<br>    this.element = element;<br>}</p>\n<p><strong>b. enqueue() 向队列中按照优先级插入元素</strong></p>\n<p>优先级越高，元素越靠前（优先级数字越小，优先级越高）</p>\n<pre><code>this.enqueue = function(element,priority)\n{\n    var queueElement = new QueueElement(element,priority);\n\n    if(this.isEmpty())\n    {\n        items.push(queueElement);//如果队列为空，则直接把这个元素插入队列\n    }\n    else\n    {\n        var added = false;\n        //如果队列不为空，则将队列中的元素优先级从0位置逐一与要插入的元素的优先级比较，遇到第一个优先级数字比插入元素优先级数字大的，则将元素插入到这个元素的前面\n        for(var i = 0; i&lt;items.length;i++)\n        {\n            if(queueElement.priority &lt; items[i].priority)\n            {\n                items.splice(1,0,queueElement);\n                added = true;\n                break;\n            }\n        }\n\n        if(!added)\n        {\n            items.push(queueElement);//如果队列中所有元素的优先级数字都比插入元素优先级数字小，则将元素插到队列末尾\n        }\n    }\n}\n</code></pre><font color=\"red\">注意：这种插入可以保证，在优先级一样的情况下，仍然是先进先出</font>\n\n<p><strong>c. 补充解释js中的三个方法：</strong></p>\n<p><strong>shift()</strong>   移除数组的第一个元素，并返回第一个元素</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n\n    var arr = new Array(3)\n    arr[0] = &quot;George&quot;\n    arr[1] = &quot;John&quot;\n    arr[2] = &quot;Thomas&quot;\n\n    document.write(arr.shift() + &quot;&lt;br /&gt;&quot;)\n\n&lt;/script&gt;\n\n\n输出结果：George\n</code></pre><p><strong>splice(index,howmany,item1,…,itemX)</strong></p>\n<p>从index的地方开始删除howmany个元素，然后插入item</p>\n<p>若howmany=0，则不删除元素，直接插入</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n\n    var arr = new Array(6)\n    arr[0] = &quot;1&quot;\n    arr[1] = &quot;2&quot;\n    arr[2] = &quot;3&quot;\n\n    document.write(arr + &quot;&lt;br /&gt;&quot;)\n    arr.splice(2,0,&quot;4&quot;)\n    document.write(arr + &quot;&lt;br /&gt;&quot;)\n\n&lt;/script&gt;\n\n输出结果：\n1，2，3\n1，2，4，3\n</code></pre><p>slice(start,end)</p>\n<p>不对原数组进行操作（原数组不变），生成一个新的数组（子数组）</p>\n<p><strong>2. 循环队列</strong> 实现一个模拟的击鼓传花的游戏</p>\n<p>(1). 用程序语言理解击鼓传花的游戏</p>\n<p>击鼓传花是一群人围成一个圈，那么用一个数组来保存这些人的名字。</p>\n<p>当敲鼓一段时间，鼓停止，花在谁手上谁就会被淘汰，那么定义这段时间为一个数字，数到这个数字的时候，花在谁手上谁就会被淘汰。</p>\n<p>那么这个游戏需要传入两个参数：保存人名的数组、鼓停止的时刻</p>\n<p>(2). 实现击鼓传花</p>\n<pre><code>function hotPotato(nameLIst,num)\n{\n    var queue = new Queue();//创建一个队列\n\n    //将人名存入队列\n    for(var i=0;i&lt;nameList.length;i++)\n    {\n        queue.enqueue(nameList[i]);\n    }\n\n    while(queue.size()&gt;1)\n    {\n        var loser = &quot;&quot;;\n        for(var i=0;i&lt;num;i++)\n        {\n            queue.enqueue(queue.dequeue());//在没有数到鼓停止的数字num时，从队列头部删除的元素queue.dequeue()需要被添加到队列尾部\n        }\n        loser = queue.dequeue();\n        console.log(loser+&quot;在游戏中被淘汰&quot;)\n    }\n\n    return queue.dequeue();//最后的获胜者\n}\n</code></pre>"},{"layout":"post","title":"Baidu IFE 第一阶段任务7~12","date":"2016-04-03T16:00:00.000Z","description":"参加百度前端公开课的第一阶段任务","_content":"\n\n## 三.  我的任务\n\n我的任务列表[http://panpanfish.com/baiduIFE/](http://panpanfish.com/baiduIFE/)\n\n### 7. 任务七\n\n#### (1). 任务七需要完成的示意图\n\n \n#### (2). 任务七demo\n\n\n#### (3). 任务七代码\n\n\n#### (4). 任务七笔记\n\n\n### 8. 任务八\n\n#### (1). 任务八需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_8_1.png)\n\n**任务要求：**\n\n- 使用 HTML 和 CSS 实现网格布局。根据屏幕宽度调整元素大小。\n- 参考 BootStrap 的网格系统DOM 元素类名。\n \n#### (2). 任务八demo\n\n[http://panpanfish.com/baiduIFE/task1-8.html](http://panpanfish.com/baiduIFE/task1-8.html)\n\n#### (3). 任务八代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html)\n\n#### (4). 任务八笔记\n\n这个任务中主要使用到的一个知识点是CSS3中的媒体查询，加深了我对bootstrap栅格布局的理解。\n\n**媒体查询media**\n\n简单来说：就是根据不同的媒体环境情况，来设置不同的样式\n\n**使用方法：**\n\n1. 在<link>标签里加上media属性\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" media=\"screen and (min-width: 768px)\">\n\n2. 在CSS文件中应用\n\n    @media screen and (max-width: 600px) { \n      .class {\n    background: #ccc;\n      }\n    }\n    \n<font color=\"red\">注意：</font>这里的screen and经常会被省略；max-width是条件，当媒体屏幕宽度小于600px时，条件成立，执行{}中的代码~~\n\n\n**兼容性问题：**\n\n1. IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：\n\n    <!--[if lt IE 9]>\n      <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n      <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n\n2. 首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：\n\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n\n- width = device-width：宽度等于当前设备的宽度\n- initial-scale：初始的缩放比例（默认设置为1.0）  \n- minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）    \n- maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）   \n- user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） \n\n**媒体查询常用的3个特性：**\n\n1. 设备宽度等于\n\n    @media screen and (max-device-width:960px){\n    \n    }\n\n2. 设备宽度小于\n\n    @media screen and (max-width:960px){\n    \n    }\n\n3. 设备宽度大于\n\n     @media screen and (min-width:960px){\n    \n    }\n\n如果容易把大于和小于记混，可以这样理解：执行这个样式的最小的宽度为960px(min-width:960px),那么大于960px的屏幕就会添加这个样式；反之亦然。\n\n在这个任务中还用到了box-sizing的设置。\n\n### 9. 任务九\n\n见博客《模拟文件报表排版》\n\n### 10. 任务十\n\n#### (1). 任务十需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。\n \n#### (2). 任务十demo\n\n[http://panpanfish.com/baiduIFE/task1-10.html](http://panpanfish.com/baiduIFE/task1-10.html)\n\n#### (3). 任务十代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html)\n\n#### (4). 任务十笔记\n\n任务十主要是练习使用Flexbox进行布局，学习笔记见[《CSS3 Flexbox布局》](http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/)\n\n### 11. 任务十一\n\n#### (1). 任务十一需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_11_1.jpg)\n\n**任务要求：**\n\n- 本任务只涉及 HTML 及 CSS\n- 实现的页面和设计图在iOS Safari，微信，Android浏览器中均基本一致\n- HTML 及 CSS 代码结构清晰、规范\n- 尝试在适合的地方使用CSS 3中的flex布局\n \n#### (2). 任务十一demo\n\n[http://panpanfish.com/baiduIFE/task1-11.html](http://panpanfish.com/baiduIFE/task1-11.html)\n\n#### (3). 任务十一代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html)\n\n#### (4). 任务十一笔记\n\n\n\n### 12. 任务十二\n\n#### (1). 任务十二需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_12_1.jpg)\n\n**任务要求：**\n\n- 实现单双行列不同颜色，且前三行特殊表示的表格\n- 实现正常状态和focus状态宽度不一致的input文本输入框，且鼠标焦点进入输入框时，宽度的变化以动画呈现\n- 不使用JavaScript，实现一个Banner图轮流播放的效果，且点击右下角的1，2，3可以切换到对应Banner图片\n \n#### (2). 任务十二demo\n\n[http://panpanfish.com/baiduIFE/task1-12.html](http://panpanfish.com/baiduIFE/task1-12.html)\n\n#### (3). 任务十二代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html)\n\n#### (4). 任务十二笔记\n\n任务十二主要是学习CSS3的一些新的特性，涉及到的特性有\ntransition、:target\n\n**transition属性**\n\ntransition是CSS3里面的一个新属性，可以用来设置过渡效果\n\ntransition属性是一个综合属性\n\n    transition: property duration timing-function delay;\n    \n    transition-property:设置过渡效果的css属性的名称\n    \n    transition-duration:过渡效果的时长（始终都要设置）\n    \n    transition-timing-function:速度效果的速度曲线\n    \n    transiition-delay:过渡效果的执行时延\n\neg:\n\n    div\n    {\n    width:100px;\n    height:100px;\n    background:blue;\n    transition:width 2s;\n    -moz-transition:width 2s; /* Firefox 4 */\n    -webkit-transition:width 2s; /* Safari and Chrome */\n    -o-transition:width 2s; /* Opera */\n    }\n    \n    div:hover\n    {\n    width:300px;\n    }\n\n:target选择器\n\n突出显示活动的锚\n\n<a href=\"#mydiv\"></a>\n<div id=\"mydiv\"></div>\n\n当点击`<a>`时，会指向`<div>`，那么此时div:target便是指的这个div\n\neg:\n\n    <ul>\n    \t<li><a href=\"#news1\">跳转至内容 1</a></li>\n    \t<li><a href=\"#news2\">跳转至内容 2</a></li>\n    </ul>\n    \n    <div id=\"news1\">内容 1...</div>\n    <div id=\"news2\">内容 2...</div>\n    \n    div:target\n    {\n    \tborder: 2px solid #D4D4D4;\n    \tbackground-color: #e5eecc;\n    }","source":"_posts/2016-04-04-Baidu-IFE-task1-7-12.md","raw":"---\nlayout: post\ntitle: Baidu IFE 第一阶段任务7~12\ndate: 2016-04-04\ncategories: Demo\ntags: [BaiduIFE]\ndescription: 参加百度前端公开课的第一阶段任务\n---\n\n\n## 三.  我的任务\n\n我的任务列表[http://panpanfish.com/baiduIFE/](http://panpanfish.com/baiduIFE/)\n\n### 7. 任务七\n\n#### (1). 任务七需要完成的示意图\n\n \n#### (2). 任务七demo\n\n\n#### (3). 任务七代码\n\n\n#### (4). 任务七笔记\n\n\n### 8. 任务八\n\n#### (1). 任务八需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_8_1.png)\n\n**任务要求：**\n\n- 使用 HTML 和 CSS 实现网格布局。根据屏幕宽度调整元素大小。\n- 参考 BootStrap 的网格系统DOM 元素类名。\n \n#### (2). 任务八demo\n\n[http://panpanfish.com/baiduIFE/task1-8.html](http://panpanfish.com/baiduIFE/task1-8.html)\n\n#### (3). 任务八代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html)\n\n#### (4). 任务八笔记\n\n这个任务中主要使用到的一个知识点是CSS3中的媒体查询，加深了我对bootstrap栅格布局的理解。\n\n**媒体查询media**\n\n简单来说：就是根据不同的媒体环境情况，来设置不同的样式\n\n**使用方法：**\n\n1. 在<link>标签里加上media属性\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" media=\"screen and (min-width: 768px)\">\n\n2. 在CSS文件中应用\n\n    @media screen and (max-width: 600px) { \n      .class {\n    background: #ccc;\n      }\n    }\n    \n<font color=\"red\">注意：</font>这里的screen and经常会被省略；max-width是条件，当媒体屏幕宽度小于600px时，条件成立，执行{}中的代码~~\n\n\n**兼容性问题：**\n\n1. IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：\n\n    <!--[if lt IE 9]>\n      <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n      <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n\n2. 首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：\n\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n\n- width = device-width：宽度等于当前设备的宽度\n- initial-scale：初始的缩放比例（默认设置为1.0）  \n- minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）    \n- maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）   \n- user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） \n\n**媒体查询常用的3个特性：**\n\n1. 设备宽度等于\n\n    @media screen and (max-device-width:960px){\n    \n    }\n\n2. 设备宽度小于\n\n    @media screen and (max-width:960px){\n    \n    }\n\n3. 设备宽度大于\n\n     @media screen and (min-width:960px){\n    \n    }\n\n如果容易把大于和小于记混，可以这样理解：执行这个样式的最小的宽度为960px(min-width:960px),那么大于960px的屏幕就会添加这个样式；反之亦然。\n\n在这个任务中还用到了box-sizing的设置。\n\n### 9. 任务九\n\n见博客《模拟文件报表排版》\n\n### 10. 任务十\n\n#### (1). 任务十需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- 屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。\n \n#### (2). 任务十demo\n\n[http://panpanfish.com/baiduIFE/task1-10.html](http://panpanfish.com/baiduIFE/task1-10.html)\n\n#### (3). 任务十代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html)\n\n#### (4). 任务十笔记\n\n任务十主要是练习使用Flexbox进行布局，学习笔记见[《CSS3 Flexbox布局》](http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/)\n\n### 11. 任务十一\n\n#### (1). 任务十一需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_11_1.jpg)\n\n**任务要求：**\n\n- 本任务只涉及 HTML 及 CSS\n- 实现的页面和设计图在iOS Safari，微信，Android浏览器中均基本一致\n- HTML 及 CSS 代码结构清晰、规范\n- 尝试在适合的地方使用CSS 3中的flex布局\n \n#### (2). 任务十一demo\n\n[http://panpanfish.com/baiduIFE/task1-11.html](http://panpanfish.com/baiduIFE/task1-11.html)\n\n#### (3). 任务十一代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html)\n\n#### (4). 任务十一笔记\n\n\n\n### 12. 任务十二\n\n#### (1). 任务十二需要完成的示意图\n\n![](http://7xrp04.com1.z0.glb.clouddn.com/task_1_12_1.jpg)\n\n**任务要求：**\n\n- 实现单双行列不同颜色，且前三行特殊表示的表格\n- 实现正常状态和focus状态宽度不一致的input文本输入框，且鼠标焦点进入输入框时，宽度的变化以动画呈现\n- 不使用JavaScript，实现一个Banner图轮流播放的效果，且点击右下角的1，2，3可以切换到对应Banner图片\n \n#### (2). 任务十二demo\n\n[http://panpanfish.com/baiduIFE/task1-12.html](http://panpanfish.com/baiduIFE/task1-12.html)\n\n#### (3). 任务十二代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html)\n\n#### (4). 任务十二笔记\n\n任务十二主要是学习CSS3的一些新的特性，涉及到的特性有\ntransition、:target\n\n**transition属性**\n\ntransition是CSS3里面的一个新属性，可以用来设置过渡效果\n\ntransition属性是一个综合属性\n\n    transition: property duration timing-function delay;\n    \n    transition-property:设置过渡效果的css属性的名称\n    \n    transition-duration:过渡效果的时长（始终都要设置）\n    \n    transition-timing-function:速度效果的速度曲线\n    \n    transiition-delay:过渡效果的执行时延\n\neg:\n\n    div\n    {\n    width:100px;\n    height:100px;\n    background:blue;\n    transition:width 2s;\n    -moz-transition:width 2s; /* Firefox 4 */\n    -webkit-transition:width 2s; /* Safari and Chrome */\n    -o-transition:width 2s; /* Opera */\n    }\n    \n    div:hover\n    {\n    width:300px;\n    }\n\n:target选择器\n\n突出显示活动的锚\n\n<a href=\"#mydiv\"></a>\n<div id=\"mydiv\"></div>\n\n当点击`<a>`时，会指向`<div>`，那么此时div:target便是指的这个div\n\neg:\n\n    <ul>\n    \t<li><a href=\"#news1\">跳转至内容 1</a></li>\n    \t<li><a href=\"#news2\">跳转至内容 2</a></li>\n    </ul>\n    \n    <div id=\"news1\">内容 1...</div>\n    <div id=\"news2\">内容 2...</div>\n    \n    div:target\n    {\n    \tborder: 2px solid #D4D4D4;\n    \tbackground-color: #e5eecc;\n    }","slug":"2016-04-04-Baidu-IFE-task1-7-12","published":1,"updated":"2016-06-13T07:18:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocdk0026d5u8ulyha3v3","content":"<h2 id=\"三-我的任务\"><a href=\"#三-我的任务\" class=\"headerlink\" title=\"三.  我的任务\"></a>三.  我的任务</h2><p>我的任务列表<a href=\"http://panpanfish.com/baiduIFE/\">http://panpanfish.com/baiduIFE/</a></p>\n<h3 id=\"7-任务七\"><a href=\"#7-任务七\" class=\"headerlink\" title=\"7. 任务七\"></a>7. 任务七</h3><h4 id=\"1-任务七需要完成的示意图\"><a href=\"#1-任务七需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务七需要完成的示意图\"></a>(1). 任务七需要完成的示意图</h4><h4 id=\"2-任务七demo\"><a href=\"#2-任务七demo\" class=\"headerlink\" title=\"(2). 任务七demo\"></a>(2). 任务七demo</h4><h4 id=\"3-任务七代码\"><a href=\"#3-任务七代码\" class=\"headerlink\" title=\"(3). 任务七代码\"></a>(3). 任务七代码</h4><h4 id=\"4-任务七笔记\"><a href=\"#4-任务七笔记\" class=\"headerlink\" title=\"(4). 任务七笔记\"></a>(4). 任务七笔记</h4><h3 id=\"8-任务八\"><a href=\"#8-任务八\" class=\"headerlink\" title=\"8. 任务八\"></a>8. 任务八</h3><h4 id=\"1-任务八需要完成的示意图\"><a href=\"#1-任务八需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务八需要完成的示意图\"></a>(1). 任务八需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_8_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>使用 HTML 和 CSS 实现网格布局。根据屏幕宽度调整元素大小。</li>\n<li>参考 BootStrap 的网格系统DOM 元素类名。</li>\n</ul>\n<h4 id=\"2-任务八demo\"><a href=\"#2-任务八demo\" class=\"headerlink\" title=\"(2). 任务八demo\"></a>(2). 任务八demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-8.html\">http://panpanfish.com/baiduIFE/task1-8.html</a></p>\n<h4 id=\"3-任务八代码\"><a href=\"#3-任务八代码\" class=\"headerlink\" title=\"(3). 任务八代码\"></a>(3). 任务八代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html</a></p>\n<h4 id=\"4-任务八笔记\"><a href=\"#4-任务八笔记\" class=\"headerlink\" title=\"(4). 任务八笔记\"></a>(4). 任务八笔记</h4><p>这个任务中主要使用到的一个知识点是CSS3中的媒体查询，加深了我对bootstrap栅格布局的理解。</p>\n<p><strong>媒体查询media</strong></p>\n<p>简单来说：就是根据不同的媒体环境情况，来设置不同的样式</p>\n<p><strong>使用方法：</strong></p>\n<ol>\n<li><p>在<link>标签里加上media属性</p>\n <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" media=\"screen and (min-width: 768px)\">\n</li>\n<li><p>在CSS文件中应用</p>\n<p> @media screen and (max-width: 600px) {<br>   .class {<br> background: #ccc;<br>   }<br> }</p>\n</li>\n</ol>\n<p><font color=\"red\">注意：</font>这里的screen and经常会被省略；max-width是条件，当媒体屏幕宽度小于600px时，条件成立，执行{}中的代码~~</p>\n<p><strong>兼容性问题：</strong></p>\n<ol>\n<li><p>IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：</p>\n <!--[if lt IE 9]>\n   <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n   <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n <![endif]-->\n</li>\n<li><p>首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：</p>\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n</li>\n</ol>\n<ul>\n<li>width = device-width：宽度等于当前设备的宽度</li>\n<li>initial-scale：初始的缩放比例（默认设置为1.0）  </li>\n<li>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）    </li>\n<li>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）   </li>\n<li>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） </li>\n</ul>\n<p><strong>媒体查询常用的3个特性：</strong></p>\n<ol>\n<li><p>设备宽度等于</p>\n<p> @media screen and (max-device-width:960px){</p>\n<p> }</p>\n</li>\n<li><p>设备宽度小于</p>\n<p> @media screen and (max-width:960px){</p>\n<p> }</p>\n</li>\n<li><p>设备宽度大于</p>\n<p>  @media screen and (min-width:960px){</p>\n<p> }</p>\n</li>\n</ol>\n<p>如果容易把大于和小于记混，可以这样理解：执行这个样式的最小的宽度为960px(min-width:960px),那么大于960px的屏幕就会添加这个样式；反之亦然。</p>\n<p>在这个任务中还用到了box-sizing的设置。</p>\n<h3 id=\"9-任务九\"><a href=\"#9-任务九\" class=\"headerlink\" title=\"9. 任务九\"></a>9. 任务九</h3><p>见博客《模拟文件报表排版》</p>\n<h3 id=\"10-任务十\"><a href=\"#10-任务十\" class=\"headerlink\" title=\"10. 任务十\"></a>10. 任务十</h3><h4 id=\"1-任务十需要完成的示意图\"><a href=\"#1-任务十需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务十需要完成的示意图\"></a>(1). 任务十需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。</li>\n</ul>\n<h4 id=\"2-任务十demo\"><a href=\"#2-任务十demo\" class=\"headerlink\" title=\"(2). 任务十demo\"></a>(2). 任务十demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-10.html\">http://panpanfish.com/baiduIFE/task1-10.html</a></p>\n<h4 id=\"3-任务十代码\"><a href=\"#3-任务十代码\" class=\"headerlink\" title=\"(3). 任务十代码\"></a>(3). 任务十代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html</a></p>\n<h4 id=\"4-任务十笔记\"><a href=\"#4-任务十笔记\" class=\"headerlink\" title=\"(4). 任务十笔记\"></a>(4). 任务十笔记</h4><p>任务十主要是练习使用Flexbox进行布局，学习笔记见<a href=\"http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/\">《CSS3 Flexbox布局》</a></p>\n<h3 id=\"11-任务十一\"><a href=\"#11-任务十一\" class=\"headerlink\" title=\"11. 任务十一\"></a>11. 任务十一</h3><h4 id=\"1-任务十一需要完成的示意图\"><a href=\"#1-任务十一需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务十一需要完成的示意图\"></a>(1). 任务十一需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_11_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>本任务只涉及 HTML 及 CSS</li>\n<li>实现的页面和设计图在iOS Safari，微信，Android浏览器中均基本一致</li>\n<li>HTML 及 CSS 代码结构清晰、规范</li>\n<li>尝试在适合的地方使用CSS 3中的flex布局</li>\n</ul>\n<h4 id=\"2-任务十一demo\"><a href=\"#2-任务十一demo\" class=\"headerlink\" title=\"(2). 任务十一demo\"></a>(2). 任务十一demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-11.html\">http://panpanfish.com/baiduIFE/task1-11.html</a></p>\n<h4 id=\"3-任务十一代码\"><a href=\"#3-任务十一代码\" class=\"headerlink\" title=\"(3). 任务十一代码\"></a>(3). 任务十一代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html</a></p>\n<h4 id=\"4-任务十一笔记\"><a href=\"#4-任务十一笔记\" class=\"headerlink\" title=\"(4). 任务十一笔记\"></a>(4). 任务十一笔记</h4><h3 id=\"12-任务十二\"><a href=\"#12-任务十二\" class=\"headerlink\" title=\"12. 任务十二\"></a>12. 任务十二</h3><h4 id=\"1-任务十二需要完成的示意图\"><a href=\"#1-任务十二需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务十二需要完成的示意图\"></a>(1). 任务十二需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_12_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>实现单双行列不同颜色，且前三行特殊表示的表格</li>\n<li>实现正常状态和focus状态宽度不一致的input文本输入框，且鼠标焦点进入输入框时，宽度的变化以动画呈现</li>\n<li>不使用JavaScript，实现一个Banner图轮流播放的效果，且点击右下角的1，2，3可以切换到对应Banner图片</li>\n</ul>\n<h4 id=\"2-任务十二demo\"><a href=\"#2-任务十二demo\" class=\"headerlink\" title=\"(2). 任务十二demo\"></a>(2). 任务十二demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-12.html\">http://panpanfish.com/baiduIFE/task1-12.html</a></p>\n<h4 id=\"3-任务十二代码\"><a href=\"#3-任务十二代码\" class=\"headerlink\" title=\"(3). 任务十二代码\"></a>(3). 任务十二代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html</a></p>\n<h4 id=\"4-任务十二笔记\"><a href=\"#4-任务十二笔记\" class=\"headerlink\" title=\"(4). 任务十二笔记\"></a>(4). 任务十二笔记</h4><p>任务十二主要是学习CSS3的一些新的特性，涉及到的特性有<br>transition、:target</p>\n<p><strong>transition属性</strong></p>\n<p>transition是CSS3里面的一个新属性，可以用来设置过渡效果</p>\n<p>transition属性是一个综合属性</p>\n<pre><code>transition: property duration timing-function delay;\n\ntransition-property:设置过渡效果的css属性的名称\n\ntransition-duration:过渡效果的时长（始终都要设置）\n\ntransition-timing-function:速度效果的速度曲线\n\ntransiition-delay:过渡效果的执行时延\n</code></pre><p>eg:</p>\n<pre><code>div\n{\nwidth:100px;\nheight:100px;\nbackground:blue;\ntransition:width 2s;\n-moz-transition:width 2s; /* Firefox 4 */\n-webkit-transition:width 2s; /* Safari and Chrome */\n-o-transition:width 2s; /* Opera */\n}\n\ndiv:hover\n{\nwidth:300px;\n}\n</code></pre><p>:target选择器</p>\n<p>突出显示活动的锚</p>\n<p><a href=\"#mydiv\"></a></p>\n<div id=\"mydiv\"></div>\n\n<p>当点击<code>&lt;a&gt;</code>时，会指向<code>&lt;div&gt;</code>，那么此时div:target便是指的这个div</p>\n<p>eg:</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;#news1&quot;&gt;跳转至内容 1&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=&quot;#news2&quot;&gt;跳转至内容 2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;div id=&quot;news1&quot;&gt;内容 1...&lt;/div&gt;\n&lt;div id=&quot;news2&quot;&gt;内容 2...&lt;/div&gt;\n\ndiv:target\n{\n    border: 2px solid #D4D4D4;\n    background-color: #e5eecc;\n}\n</code></pre>","excerpt":"","more":"<h2 id=\"三-我的任务\"><a href=\"#三-我的任务\" class=\"headerlink\" title=\"三.  我的任务\"></a>三.  我的任务</h2><p>我的任务列表<a href=\"http://panpanfish.com/baiduIFE/\">http://panpanfish.com/baiduIFE/</a></p>\n<h3 id=\"7-任务七\"><a href=\"#7-任务七\" class=\"headerlink\" title=\"7. 任务七\"></a>7. 任务七</h3><h4 id=\"1-任务七需要完成的示意图\"><a href=\"#1-任务七需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务七需要完成的示意图\"></a>(1). 任务七需要完成的示意图</h4><h4 id=\"2-任务七demo\"><a href=\"#2-任务七demo\" class=\"headerlink\" title=\"(2). 任务七demo\"></a>(2). 任务七demo</h4><h4 id=\"3-任务七代码\"><a href=\"#3-任务七代码\" class=\"headerlink\" title=\"(3). 任务七代码\"></a>(3). 任务七代码</h4><h4 id=\"4-任务七笔记\"><a href=\"#4-任务七笔记\" class=\"headerlink\" title=\"(4). 任务七笔记\"></a>(4). 任务七笔记</h4><h3 id=\"8-任务八\"><a href=\"#8-任务八\" class=\"headerlink\" title=\"8. 任务八\"></a>8. 任务八</h3><h4 id=\"1-任务八需要完成的示意图\"><a href=\"#1-任务八需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务八需要完成的示意图\"></a>(1). 任务八需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_8_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>使用 HTML 和 CSS 实现网格布局。根据屏幕宽度调整元素大小。</li>\n<li>参考 BootStrap 的网格系统DOM 元素类名。</li>\n</ul>\n<h4 id=\"2-任务八demo\"><a href=\"#2-任务八demo\" class=\"headerlink\" title=\"(2). 任务八demo\"></a>(2). 任务八demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-8.html\">http://panpanfish.com/baiduIFE/task1-8.html</a></p>\n<h4 id=\"3-任务八代码\"><a href=\"#3-任务八代码\" class=\"headerlink\" title=\"(3). 任务八代码\"></a>(3). 任务八代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-8.html</a></p>\n<h4 id=\"4-任务八笔记\"><a href=\"#4-任务八笔记\" class=\"headerlink\" title=\"(4). 任务八笔记\"></a>(4). 任务八笔记</h4><p>这个任务中主要使用到的一个知识点是CSS3中的媒体查询，加深了我对bootstrap栅格布局的理解。</p>\n<p><strong>媒体查询media</strong></p>\n<p>简单来说：就是根据不同的媒体环境情况，来设置不同的样式</p>\n<p><strong>使用方法：</strong></p>\n<ol>\n<li><p>在<link>标签里加上media属性</p>\n <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" media=\"screen and (min-width: 768px)\">\n</li>\n<li><p>在CSS文件中应用</p>\n<p> @media screen and (max-width: 600px) {<br>   .class {<br> background: #ccc;<br>   }<br> }</p>\n</li>\n</ol>\n<p><font color=\"red\">注意：</font>这里的screen and经常会被省略；max-width是条件，当媒体屏幕宽度小于600px时，条件成立，执行{}中的代码~~</p>\n<p><strong>兼容性问题：</strong></p>\n<ol>\n<li><p>IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：</p>\n <!--[if lt IE 9]>\n   <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n   <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n <![endif]-->\n</li>\n<li><p>首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：</p>\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n</li>\n</ol>\n<ul>\n<li>width = device-width：宽度等于当前设备的宽度</li>\n<li>initial-scale：初始的缩放比例（默认设置为1.0）  </li>\n<li>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）    </li>\n<li>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）   </li>\n<li>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） </li>\n</ul>\n<p><strong>媒体查询常用的3个特性：</strong></p>\n<ol>\n<li><p>设备宽度等于</p>\n<p> @media screen and (max-device-width:960px){</p>\n<p> }</p>\n</li>\n<li><p>设备宽度小于</p>\n<p> @media screen and (max-width:960px){</p>\n<p> }</p>\n</li>\n<li><p>设备宽度大于</p>\n<p>  @media screen and (min-width:960px){</p>\n<p> }</p>\n</li>\n</ol>\n<p>如果容易把大于和小于记混，可以这样理解：执行这个样式的最小的宽度为960px(min-width:960px),那么大于960px的屏幕就会添加这个样式；反之亦然。</p>\n<p>在这个任务中还用到了box-sizing的设置。</p>\n<h3 id=\"9-任务九\"><a href=\"#9-任务九\" class=\"headerlink\" title=\"9. 任务九\"></a>9. 任务九</h3><p>见博客《模拟文件报表排版》</p>\n<h3 id=\"10-任务十\"><a href=\"#10-任务十\" class=\"headerlink\" title=\"10. 任务十\"></a>10. 任务十</h3><h4 id=\"1-任务十需要完成的示意图\"><a href=\"#1-任务十需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务十需要完成的示意图\"></a>(1). 任务十需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。</li>\n</ul>\n<h4 id=\"2-任务十demo\"><a href=\"#2-任务十demo\" class=\"headerlink\" title=\"(2). 任务十demo\"></a>(2). 任务十demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-10.html\">http://panpanfish.com/baiduIFE/task1-10.html</a></p>\n<h4 id=\"3-任务十代码\"><a href=\"#3-任务十代码\" class=\"headerlink\" title=\"(3). 任务十代码\"></a>(3). 任务十代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-10.html</a></p>\n<h4 id=\"4-任务十笔记\"><a href=\"#4-任务十笔记\" class=\"headerlink\" title=\"(4). 任务十笔记\"></a>(4). 任务十笔记</h4><p>任务十主要是练习使用Flexbox进行布局，学习笔记见<a href=\"http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/\">《CSS3 Flexbox布局》</a></p>\n<h3 id=\"11-任务十一\"><a href=\"#11-任务十一\" class=\"headerlink\" title=\"11. 任务十一\"></a>11. 任务十一</h3><h4 id=\"1-任务十一需要完成的示意图\"><a href=\"#1-任务十一需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务十一需要完成的示意图\"></a>(1). 任务十一需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_11_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>本任务只涉及 HTML 及 CSS</li>\n<li>实现的页面和设计图在iOS Safari，微信，Android浏览器中均基本一致</li>\n<li>HTML 及 CSS 代码结构清晰、规范</li>\n<li>尝试在适合的地方使用CSS 3中的flex布局</li>\n</ul>\n<h4 id=\"2-任务十一demo\"><a href=\"#2-任务十一demo\" class=\"headerlink\" title=\"(2). 任务十一demo\"></a>(2). 任务十一demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-11.html\">http://panpanfish.com/baiduIFE/task1-11.html</a></p>\n<h4 id=\"3-任务十一代码\"><a href=\"#3-任务十一代码\" class=\"headerlink\" title=\"(3). 任务十一代码\"></a>(3). 任务十一代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-11.html</a></p>\n<h4 id=\"4-任务十一笔记\"><a href=\"#4-任务十一笔记\" class=\"headerlink\" title=\"(4). 任务十一笔记\"></a>(4). 任务十一笔记</h4><h3 id=\"12-任务十二\"><a href=\"#12-任务十二\" class=\"headerlink\" title=\"12. 任务十二\"></a>12. 任务十二</h3><h4 id=\"1-任务十二需要完成的示意图\"><a href=\"#1-任务十二需要完成的示意图\" class=\"headerlink\" title=\"(1). 任务十二需要完成的示意图\"></a>(1). 任务十二需要完成的示意图</h4><p><img src=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_12_1.jpg\" alt=\"\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>实现单双行列不同颜色，且前三行特殊表示的表格</li>\n<li>实现正常状态和focus状态宽度不一致的input文本输入框，且鼠标焦点进入输入框时，宽度的变化以动画呈现</li>\n<li>不使用JavaScript，实现一个Banner图轮流播放的效果，且点击右下角的1，2，3可以切换到对应Banner图片</li>\n</ul>\n<h4 id=\"2-任务十二demo\"><a href=\"#2-任务十二demo\" class=\"headerlink\" title=\"(2). 任务十二demo\"></a>(2). 任务十二demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task1-12.html\">http://panpanfish.com/baiduIFE/task1-12.html</a></p>\n<h4 id=\"3-任务十二代码\"><a href=\"#3-任务十二代码\" class=\"headerlink\" title=\"(3). 任务十二代码\"></a>(3). 任务十二代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task1-12.html</a></p>\n<h4 id=\"4-任务十二笔记\"><a href=\"#4-任务十二笔记\" class=\"headerlink\" title=\"(4). 任务十二笔记\"></a>(4). 任务十二笔记</h4><p>任务十二主要是学习CSS3的一些新的特性，涉及到的特性有<br>transition、:target</p>\n<p><strong>transition属性</strong></p>\n<p>transition是CSS3里面的一个新属性，可以用来设置过渡效果</p>\n<p>transition属性是一个综合属性</p>\n<pre><code>transition: property duration timing-function delay;\n\ntransition-property:设置过渡效果的css属性的名称\n\ntransition-duration:过渡效果的时长（始终都要设置）\n\ntransition-timing-function:速度效果的速度曲线\n\ntransiition-delay:过渡效果的执行时延\n</code></pre><p>eg:</p>\n<pre><code>div\n{\nwidth:100px;\nheight:100px;\nbackground:blue;\ntransition:width 2s;\n-moz-transition:width 2s; /* Firefox 4 */\n-webkit-transition:width 2s; /* Safari and Chrome */\n-o-transition:width 2s; /* Opera */\n}\n\ndiv:hover\n{\nwidth:300px;\n}\n</code></pre><p>:target选择器</p>\n<p>突出显示活动的锚</p>\n<p><a href=\"#mydiv\"></a></p>\n<div id=\"mydiv\"></div>\n\n<p>当点击<code>&lt;a&gt;</code>时，会指向<code>&lt;div&gt;</code>，那么此时div:target便是指的这个div</p>\n<p>eg:</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;#news1&quot;&gt;跳转至内容 1&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=&quot;#news2&quot;&gt;跳转至内容 2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;div id=&quot;news1&quot;&gt;内容 1...&lt;/div&gt;\n&lt;div id=&quot;news2&quot;&gt;内容 2...&lt;/div&gt;\n\ndiv:target\n{\n    border: 2px solid #D4D4D4;\n    background-color: #e5eecc;\n}\n</code></pre>"},{"layout":"post","title":"模拟文件报表排版","date":"2016-04-03T16:00:00.000Z","description":null,"_content":"\n### 一. 需要完成的示意图\n\n![模拟文件报表排版](/uploads/post/demo/report-form.jpg)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- tab只需要实现样式，有能力余力的同学可以尝试实现不使用JavaScript的情况下，实现Tab切换\n- 所有的下拉菜单（Select）均要求按照设计稿样式实现，下拉后的样式自定义，不需要实现下拉选择的功能，但样式要实现\n- 在Chrome中完美实现与设计稿的除了文字以外的各项图片、字体、颜色、布局、内外边距等样式\n \n### 二. 文件报表排版demo\n\n[http://panpanfish.com/myDemo/report-form.html](http://panpanfish.com/myDemo/report-form.html \"文件报表排版\")\n\n### 三. 文件报表排版代码\n\n[https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html](https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html)\n\n### 四. 实现过程中的笔记\n\n终于把任务九做完了，任务九挺复杂的，比之前的任务都要复杂一点。\n\n主要涉及到的模块有：\n\n#### 1. 面包屑导航\n\n    \t<ul class=\"breadcrumb-nav\">\n      \t\t<li><a href=\"#\">C站</a></li>\n      \t\t<li><a href=\"#\">个人报表</a></li>\n      \t\t<li><a href=\"#\">文件一</a></li>\n      \t\t<li class=\"active\">文档一</li>\n    \t</ul>\n\n **css样式：**\n    \n\t    .breadcrumb-nav {\n\t    padding:10px 0px 10px 20px;\n\t    background: #fff;\n\t    }\n\t    .breadcrumb-nav li{display:inline-block;}\n\t    .breadcrumb-nav > li + li:before {\n\t    color: #CCCCCC;\n\t    content: \"/ \";\n\t    padding: 0 5px;\n\t      \n\t    }\n\t    .breadcrumb-nav li a{color:#9E9C9C;\n\t    \t\t\t\t\ttext-decoration: none;\n\t    }\n\t    .breadcrumb-nav li a:hover{color:#4291cc;}\n\t    .active {color:#4291cc;}\n\n- A > B 是选择A下面的第一代为B的子元素\n\n- A + B 是选择A后面相邻的第一个为B的兄弟元素\n\n- A:before 允许在A元素的前面插入内容\n\n**因此：.breadcrumb-nav > li + li:before 表示的是除了第一个li之外的每一个li的前面都加上\"/\"。**\n\n#### 2. css3进度条\n\n    <div class=\"barControl-space\">\n    \t<span class=\"orange-bgcolor\" style=\"width:70%\"></span>\n    </div>\n\n静态进度条的实现原理很简单，就是一个外层div和里面的span的颜色设成不一样即可，通过控制span的宽度来显示进度。\n\n#### 3. 仅仅用css实现tab页的切换\n\n这一块见博客[《使用纯CSS实现tab页的切换》](http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/)\n\n#### 4. 然后就是学习到了一些之前没用过的css选择器\n\n这一块见博客[《CSS选择器总结》](http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/)\n\n#### 5. 一些之前没遇到过的问题\n\n**verticle-align属性**\n\nverticle-align用来设置元素的垂直对齐方式，一般要设置在元素本身上才有用。\n\n在设置了float属性的元素的内部使用verticle-align会失效\n\n一般verticle-align：middle属性会经常失效，因此设置行内居中一般使用 height=line-height\n\n**隐藏select的箭头**\n\nappearance是css3的新属性\n\n    appearance:none;/* 清除系统默认原生样式 */\n    -moz-appearance:none; /* Firefox */\n    -webkit-appearance:none; /* Safari 和 Chrome */\n\n**表格<table border=\"1\">边框有空格，如何清除**\n\n设置 border-spacing:0px;\n\n    border-spacing：水平间距 垂直间距；\n    /* 是用来设置表格边框之间的空白 */\n\n**select让文字居中显示，设置text-align:center;无效**\n\n**可以设置div:hover的样式**\n\n**可通过设置cursor属性来改变光标的形状**\n\n","source":"_posts/2016-04-04-模拟文件报表排版.md","raw":"---\nlayout: post\ntitle: 模拟文件报表排版\ndate: 2016-04-04\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n### 一. 需要完成的示意图\n\n![模拟文件报表排版](/uploads/post/demo/report-form.jpg)\n\n**任务要求：**\n\n- 只需要完成HTML，CSS代码编写，不需要写JavaScript\n- tab只需要实现样式，有能力余力的同学可以尝试实现不使用JavaScript的情况下，实现Tab切换\n- 所有的下拉菜单（Select）均要求按照设计稿样式实现，下拉后的样式自定义，不需要实现下拉选择的功能，但样式要实现\n- 在Chrome中完美实现与设计稿的除了文字以外的各项图片、字体、颜色、布局、内外边距等样式\n \n### 二. 文件报表排版demo\n\n[http://panpanfish.com/myDemo/report-form.html](http://panpanfish.com/myDemo/report-form.html \"文件报表排版\")\n\n### 三. 文件报表排版代码\n\n[https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html](https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html)\n\n### 四. 实现过程中的笔记\n\n终于把任务九做完了，任务九挺复杂的，比之前的任务都要复杂一点。\n\n主要涉及到的模块有：\n\n#### 1. 面包屑导航\n\n    \t<ul class=\"breadcrumb-nav\">\n      \t\t<li><a href=\"#\">C站</a></li>\n      \t\t<li><a href=\"#\">个人报表</a></li>\n      \t\t<li><a href=\"#\">文件一</a></li>\n      \t\t<li class=\"active\">文档一</li>\n    \t</ul>\n\n **css样式：**\n    \n\t    .breadcrumb-nav {\n\t    padding:10px 0px 10px 20px;\n\t    background: #fff;\n\t    }\n\t    .breadcrumb-nav li{display:inline-block;}\n\t    .breadcrumb-nav > li + li:before {\n\t    color: #CCCCCC;\n\t    content: \"/ \";\n\t    padding: 0 5px;\n\t      \n\t    }\n\t    .breadcrumb-nav li a{color:#9E9C9C;\n\t    \t\t\t\t\ttext-decoration: none;\n\t    }\n\t    .breadcrumb-nav li a:hover{color:#4291cc;}\n\t    .active {color:#4291cc;}\n\n- A > B 是选择A下面的第一代为B的子元素\n\n- A + B 是选择A后面相邻的第一个为B的兄弟元素\n\n- A:before 允许在A元素的前面插入内容\n\n**因此：.breadcrumb-nav > li + li:before 表示的是除了第一个li之外的每一个li的前面都加上\"/\"。**\n\n#### 2. css3进度条\n\n    <div class=\"barControl-space\">\n    \t<span class=\"orange-bgcolor\" style=\"width:70%\"></span>\n    </div>\n\n静态进度条的实现原理很简单，就是一个外层div和里面的span的颜色设成不一样即可，通过控制span的宽度来显示进度。\n\n#### 3. 仅仅用css实现tab页的切换\n\n这一块见博客[《使用纯CSS实现tab页的切换》](http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/)\n\n#### 4. 然后就是学习到了一些之前没用过的css选择器\n\n这一块见博客[《CSS选择器总结》](http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/)\n\n#### 5. 一些之前没遇到过的问题\n\n**verticle-align属性**\n\nverticle-align用来设置元素的垂直对齐方式，一般要设置在元素本身上才有用。\n\n在设置了float属性的元素的内部使用verticle-align会失效\n\n一般verticle-align：middle属性会经常失效，因此设置行内居中一般使用 height=line-height\n\n**隐藏select的箭头**\n\nappearance是css3的新属性\n\n    appearance:none;/* 清除系统默认原生样式 */\n    -moz-appearance:none; /* Firefox */\n    -webkit-appearance:none; /* Safari 和 Chrome */\n\n**表格<table border=\"1\">边框有空格，如何清除**\n\n设置 border-spacing:0px;\n\n    border-spacing：水平间距 垂直间距；\n    /* 是用来设置表格边框之间的空白 */\n\n**select让文字居中显示，设置text-align:center;无效**\n\n**可以设置div:hover的样式**\n\n**可通过设置cursor属性来改变光标的形状**\n\n","slug":"2016-04-04-模拟文件报表排版","published":1,"updated":"2016-06-13T07:39:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocdl0028d5u88x1dxha2","content":"<h3 id=\"一-需要完成的示意图\"><a href=\"#一-需要完成的示意图\" class=\"headerlink\" title=\"一. 需要完成的示意图\"></a>一. 需要完成的示意图</h3><p><img src=\"/uploads/post/demo/report-form.jpg\" alt=\"模拟文件报表排版\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>tab只需要实现样式，有能力余力的同学可以尝试实现不使用JavaScript的情况下，实现Tab切换</li>\n<li>所有的下拉菜单（Select）均要求按照设计稿样式实现，下拉后的样式自定义，不需要实现下拉选择的功能，但样式要实现</li>\n<li>在Chrome中完美实现与设计稿的除了文字以外的各项图片、字体、颜色、布局、内外边距等样式</li>\n</ul>\n<h3 id=\"二-文件报表排版demo\"><a href=\"#二-文件报表排版demo\" class=\"headerlink\" title=\"二. 文件报表排版demo\"></a>二. 文件报表排版demo</h3><p><a href=\"http://panpanfish.com/myDemo/report-form.html\" title=\"文件报表排版\">http://panpanfish.com/myDemo/report-form.html</a></p>\n<h3 id=\"三-文件报表排版代码\"><a href=\"#三-文件报表排版代码\" class=\"headerlink\" title=\"三. 文件报表排版代码\"></a>三. 文件报表排版代码</h3><p><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html</a></p>\n<h3 id=\"四-实现过程中的笔记\"><a href=\"#四-实现过程中的笔记\" class=\"headerlink\" title=\"四. 实现过程中的笔记\"></a>四. 实现过程中的笔记</h3><p>终于把任务九做完了，任务九挺复杂的，比之前的任务都要复杂一点。</p>\n<p>主要涉及到的模块有：</p>\n<h4 id=\"1-面包屑导航\"><a href=\"#1-面包屑导航\" class=\"headerlink\" title=\"1. 面包屑导航\"></a>1. 面包屑导航</h4><pre><code>&lt;ul class=&quot;breadcrumb-nav&quot;&gt;\n      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;C站&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人报表&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;文件一&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=&quot;active&quot;&gt;文档一&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p> <strong>css样式：</strong></p>\n<pre><code>.breadcrumb-nav {\npadding:10px 0px 10px 20px;\nbackground: #fff;\n}\n.breadcrumb-nav li{display:inline-block;}\n.breadcrumb-nav &gt; li + li:before {\ncolor: #CCCCCC;\ncontent: &quot;/ &quot;;\npadding: 0 5px;\n\n}\n.breadcrumb-nav li a{color:#9E9C9C;\n                    text-decoration: none;\n}\n.breadcrumb-nav li a:hover{color:#4291cc;}\n.active {color:#4291cc;}\n</code></pre><ul>\n<li><p>A &gt; B 是选择A下面的第一代为B的子元素</p>\n</li>\n<li><p>A + B 是选择A后面相邻的第一个为B的兄弟元素</p>\n</li>\n<li><p>A:before 允许在A元素的前面插入内容</p>\n</li>\n</ul>\n<p><strong>因此：.breadcrumb-nav &gt; li + li:before 表示的是除了第一个li之外的每一个li的前面都加上”/“。</strong></p>\n<h4 id=\"2-css3进度条\"><a href=\"#2-css3进度条\" class=\"headerlink\" title=\"2. css3进度条\"></a>2. css3进度条</h4><pre><code>&lt;div class=&quot;barControl-space&quot;&gt;\n    &lt;span class=&quot;orange-bgcolor&quot; style=&quot;width:70%&quot;&gt;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre><p>静态进度条的实现原理很简单，就是一个外层div和里面的span的颜色设成不一样即可，通过控制span的宽度来显示进度。</p>\n<h4 id=\"3-仅仅用css实现tab页的切换\"><a href=\"#3-仅仅用css实现tab页的切换\" class=\"headerlink\" title=\"3. 仅仅用css实现tab页的切换\"></a>3. 仅仅用css实现tab页的切换</h4><p>这一块见博客<a href=\"http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/\">《使用纯CSS实现tab页的切换》</a></p>\n<h4 id=\"4-然后就是学习到了一些之前没用过的css选择器\"><a href=\"#4-然后就是学习到了一些之前没用过的css选择器\" class=\"headerlink\" title=\"4. 然后就是学习到了一些之前没用过的css选择器\"></a>4. 然后就是学习到了一些之前没用过的css选择器</h4><p>这一块见博客<a href=\"http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/\">《CSS选择器总结》</a></p>\n<h4 id=\"5-一些之前没遇到过的问题\"><a href=\"#5-一些之前没遇到过的问题\" class=\"headerlink\" title=\"5. 一些之前没遇到过的问题\"></a>5. 一些之前没遇到过的问题</h4><p><strong>verticle-align属性</strong></p>\n<p>verticle-align用来设置元素的垂直对齐方式，一般要设置在元素本身上才有用。</p>\n<p>在设置了float属性的元素的内部使用verticle-align会失效</p>\n<p>一般verticle-align：middle属性会经常失效，因此设置行内居中一般使用 height=line-height</p>\n<p><strong>隐藏select的箭头</strong></p>\n<p>appearance是css3的新属性</p>\n<pre><code>appearance:none;/* 清除系统默认原生样式 */\n-moz-appearance:none; /* Firefox */\n-webkit-appearance:none; /* Safari 和 Chrome */\n</code></pre><p><strong>表格<table border=\"1\">边框有空格，如何清除</table></strong></p>\n<p>设置 border-spacing:0px;</p>\n<pre><code>border-spacing：水平间距 垂直间距；\n/* 是用来设置表格边框之间的空白 */\n</code></pre><p><strong>select让文字居中显示，设置text-align:center;无效</strong></p>\n<p><strong>可以设置div:hover的样式</strong></p>\n<p><strong>可通过设置cursor属性来改变光标的形状</strong></p>\n","excerpt":"","more":"<h3 id=\"一-需要完成的示意图\"><a href=\"#一-需要完成的示意图\" class=\"headerlink\" title=\"一. 需要完成的示意图\"></a>一. 需要完成的示意图</h3><p><img src=\"/uploads/post/demo/report-form.jpg\" alt=\"模拟文件报表排版\"></p>\n<p><strong>任务要求：</strong></p>\n<ul>\n<li>只需要完成HTML，CSS代码编写，不需要写JavaScript</li>\n<li>tab只需要实现样式，有能力余力的同学可以尝试实现不使用JavaScript的情况下，实现Tab切换</li>\n<li>所有的下拉菜单（Select）均要求按照设计稿样式实现，下拉后的样式自定义，不需要实现下拉选择的功能，但样式要实现</li>\n<li>在Chrome中完美实现与设计稿的除了文字以外的各项图片、字体、颜色、布局、内外边距等样式</li>\n</ul>\n<h3 id=\"二-文件报表排版demo\"><a href=\"#二-文件报表排版demo\" class=\"headerlink\" title=\"二. 文件报表排版demo\"></a>二. 文件报表排版demo</h3><p><a href=\"http://panpanfish.com/myDemo/report-form.html\" title=\"文件报表排版\">http://panpanfish.com/myDemo/report-form.html</a></p>\n<h3 id=\"三-文件报表排版代码\"><a href=\"#三-文件报表排版代码\" class=\"headerlink\" title=\"三. 文件报表排版代码\"></a>三. 文件报表排版代码</h3><p><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html\">https://github.com/panpan040828/myDemo/blob/gh-pages/report-form.html</a></p>\n<h3 id=\"四-实现过程中的笔记\"><a href=\"#四-实现过程中的笔记\" class=\"headerlink\" title=\"四. 实现过程中的笔记\"></a>四. 实现过程中的笔记</h3><p>终于把任务九做完了，任务九挺复杂的，比之前的任务都要复杂一点。</p>\n<p>主要涉及到的模块有：</p>\n<h4 id=\"1-面包屑导航\"><a href=\"#1-面包屑导航\" class=\"headerlink\" title=\"1. 面包屑导航\"></a>1. 面包屑导航</h4><pre><code>&lt;ul class=&quot;breadcrumb-nav&quot;&gt;\n      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;C站&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人报表&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;文件一&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=&quot;active&quot;&gt;文档一&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p> <strong>css样式：</strong></p>\n<pre><code>.breadcrumb-nav {\npadding:10px 0px 10px 20px;\nbackground: #fff;\n}\n.breadcrumb-nav li{display:inline-block;}\n.breadcrumb-nav &gt; li + li:before {\ncolor: #CCCCCC;\ncontent: &quot;/ &quot;;\npadding: 0 5px;\n\n}\n.breadcrumb-nav li a{color:#9E9C9C;\n                    text-decoration: none;\n}\n.breadcrumb-nav li a:hover{color:#4291cc;}\n.active {color:#4291cc;}\n</code></pre><ul>\n<li><p>A &gt; B 是选择A下面的第一代为B的子元素</p>\n</li>\n<li><p>A + B 是选择A后面相邻的第一个为B的兄弟元素</p>\n</li>\n<li><p>A:before 允许在A元素的前面插入内容</p>\n</li>\n</ul>\n<p><strong>因此：.breadcrumb-nav &gt; li + li:before 表示的是除了第一个li之外的每一个li的前面都加上”/“。</strong></p>\n<h4 id=\"2-css3进度条\"><a href=\"#2-css3进度条\" class=\"headerlink\" title=\"2. css3进度条\"></a>2. css3进度条</h4><pre><code>&lt;div class=&quot;barControl-space&quot;&gt;\n    &lt;span class=&quot;orange-bgcolor&quot; style=&quot;width:70%&quot;&gt;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre><p>静态进度条的实现原理很简单，就是一个外层div和里面的span的颜色设成不一样即可，通过控制span的宽度来显示进度。</p>\n<h4 id=\"3-仅仅用css实现tab页的切换\"><a href=\"#3-仅仅用css实现tab页的切换\" class=\"headerlink\" title=\"3. 仅仅用css实现tab页的切换\"></a>3. 仅仅用css实现tab页的切换</h4><p>这一块见博客<a href=\"http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/\">《使用纯CSS实现tab页的切换》</a></p>\n<h4 id=\"4-然后就是学习到了一些之前没用过的css选择器\"><a href=\"#4-然后就是学习到了一些之前没用过的css选择器\" class=\"headerlink\" title=\"4. 然后就是学习到了一些之前没用过的css选择器\"></a>4. 然后就是学习到了一些之前没用过的css选择器</h4><p>这一块见博客<a href=\"http://panpanfish.com/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/03/25/CSS3-flexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/\">《CSS选择器总结》</a></p>\n<h4 id=\"5-一些之前没遇到过的问题\"><a href=\"#5-一些之前没遇到过的问题\" class=\"headerlink\" title=\"5. 一些之前没遇到过的问题\"></a>5. 一些之前没遇到过的问题</h4><p><strong>verticle-align属性</strong></p>\n<p>verticle-align用来设置元素的垂直对齐方式，一般要设置在元素本身上才有用。</p>\n<p>在设置了float属性的元素的内部使用verticle-align会失效</p>\n<p>一般verticle-align：middle属性会经常失效，因此设置行内居中一般使用 height=line-height</p>\n<p><strong>隐藏select的箭头</strong></p>\n<p>appearance是css3的新属性</p>\n<pre><code>appearance:none;/* 清除系统默认原生样式 */\n-moz-appearance:none; /* Firefox */\n-webkit-appearance:none; /* Safari 和 Chrome */\n</code></pre><p><strong>表格<table border=\"1\">边框有空格，如何清除</strong></p>\n<p>设置 border-spacing:0px;</p>\n<pre><code>border-spacing：水平间距 垂直间距；\n/* 是用来设置表格边框之间的空白 */\n</code></pre><p><strong>select让文字居中显示，设置text-align:center;无效</strong></p>\n<p><strong>可以设置div:hover的样式</strong></p>\n<p><strong>可通过设置cursor属性来改变光标的形状</strong></p>\n"},{"layout":"post","title":"洗牌算法","date":"2016-05-15T16:00:00.000Z","description":null,"_content":"\n洗牌算法的本质其实就是将有序的数组变成无序。\n       \n### 一. 方法一\n\n算法思路：\n\n1. 选中数组中的最后一个数（基准尾数）\n2. 随机选取从第一个数到基准尾数之间的一个数，将选中的数和基准尾数中的数位置互换\n3. 选取倒数第二个数作为基准尾数，重复上面两步\n4. 以此类推\n\n选择两个[0...array.Length)之间的随机数\n\n```\n\tArray.prototype.shuffle = function() {\n\t\tvar input = this;\n\t\tfor (var i = input.length-1; i >=0; i--) {\n\t\t\tvar randomIndex = Math.floor(Math.random()*(i+1)); //产生0到i之间的随机整数\n\t\t\tvar itemAtIndex = input[randomIndex]; \n\t\t\tinput[randomIndex] = input[i]; \n\t\t\tinput[i] = itemAtIndex;\n\t\t}\n\t\treturn input;\n\t}\n\n\tvar tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n\ttempArray.shuffle();\n\t// and the result is...\n\talert(tempArray); \n```\n\n### 二. 方法二\n\n```\n\t//洗牌算法 \n\tfunction shuffle(arr){            \n                var len = arr.length, i, j, temp, index,\n                n = Math.floor(len/2)+1; \n                \n                while( n-- ){ \n                    i = Math.floor(Math.random()*len); \n                    j = Math.floor(Math.random()*len); \n                    if( i!==j ){ \n                        temp = arr[i]; \n                        arr[i] = arr[j]; \n                        arr[j] = temp; \n                    } \n                } \n                //增加切牌操作 \n                index = Math.floor(Math.random()*len);\n\t\t\t\tvar half = arr.splice(0,i) ;\n                arr.push.apply(arr, half); //splice会改变原数组\n                return arr; \n       } \n\tvar test = [1, 2, 3, 4, 5, 6, 7, 8, 9]; \n\tvar newarr = test.slice(0); \n\tmess(newarr); \n\tconsole.log(test); \n\tconsole.log(newarr); \n```\n\n### 三. 方法三（乱序效率可能不高）\n\n```\n\tvar testArray3=[1,2,3,4,5,6,7,8,9,10,22,33,55,77,88,99]; \n\t\n\ttestArray3.sort(function(){return Math.random()>0.5?-1:1;}); \n\t\n\talert(testArray3);\n```\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-31-洗牌算法.md","raw":"---\nlayout: post\ntitle: 洗牌算法\ndate: 2016-05-16\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n洗牌算法的本质其实就是将有序的数组变成无序。\n       \n### 一. 方法一\n\n算法思路：\n\n1. 选中数组中的最后一个数（基准尾数）\n2. 随机选取从第一个数到基准尾数之间的一个数，将选中的数和基准尾数中的数位置互换\n3. 选取倒数第二个数作为基准尾数，重复上面两步\n4. 以此类推\n\n选择两个[0...array.Length)之间的随机数\n\n```\n\tArray.prototype.shuffle = function() {\n\t\tvar input = this;\n\t\tfor (var i = input.length-1; i >=0; i--) {\n\t\t\tvar randomIndex = Math.floor(Math.random()*(i+1)); //产生0到i之间的随机整数\n\t\t\tvar itemAtIndex = input[randomIndex]; \n\t\t\tinput[randomIndex] = input[i]; \n\t\t\tinput[i] = itemAtIndex;\n\t\t}\n\t\treturn input;\n\t}\n\n\tvar tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n\ttempArray.shuffle();\n\t// and the result is...\n\talert(tempArray); \n```\n\n### 二. 方法二\n\n```\n\t//洗牌算法 \n\tfunction shuffle(arr){            \n                var len = arr.length, i, j, temp, index,\n                n = Math.floor(len/2)+1; \n                \n                while( n-- ){ \n                    i = Math.floor(Math.random()*len); \n                    j = Math.floor(Math.random()*len); \n                    if( i!==j ){ \n                        temp = arr[i]; \n                        arr[i] = arr[j]; \n                        arr[j] = temp; \n                    } \n                } \n                //增加切牌操作 \n                index = Math.floor(Math.random()*len);\n\t\t\t\tvar half = arr.splice(0,i) ;\n                arr.push.apply(arr, half); //splice会改变原数组\n                return arr; \n       } \n\tvar test = [1, 2, 3, 4, 5, 6, 7, 8, 9]; \n\tvar newarr = test.slice(0); \n\tmess(newarr); \n\tconsole.log(test); \n\tconsole.log(newarr); \n```\n\n### 三. 方法三（乱序效率可能不高）\n\n```\n\tvar testArray3=[1,2,3,4,5,6,7,8,9,10,22,33,55,77,88,99]; \n\t\n\ttestArray3.sort(function(){return Math.random()>0.5?-1:1;}); \n\t\n\talert(testArray3);\n```\n\n\n\n\n\n\n\n\n","slug":"2016-03-31-洗牌算法","published":1,"updated":"2016-08-21T13:32:50.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocdp002bd5u8u7jd78pe","content":"<p>洗牌算法的本质其实就是将有序的数组变成无序。</p>\n<h3 id=\"一-方法一\"><a href=\"#一-方法一\" class=\"headerlink\" title=\"一. 方法一\"></a>一. 方法一</h3><p>算法思路：</p>\n<ol>\n<li>选中数组中的最后一个数（基准尾数）</li>\n<li>随机选取从第一个数到基准尾数之间的一个数，将选中的数和基准尾数中的数位置互换</li>\n<li>选取倒数第二个数作为基准尾数，重复上面两步</li>\n<li>以此类推</li>\n</ol>\n<p>选择两个[0…array.Length)之间的随机数</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array<span class=\"variable\">.prototype</span><span class=\"variable\">.shuffle</span> = <span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"keyword\">input</span> = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"keyword\">input</span><span class=\"variable\">.length</span>-<span class=\"number\">1</span>; i &gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> randomIndex = Math<span class=\"variable\">.floor</span>(Math<span class=\"variable\">.random</span>()*(i+<span class=\"number\">1</span>)); <span class=\"comment\">//产生0到i之间的随机整数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> itemAtIndex = <span class=\"keyword\">input</span>[randomIndex]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">input</span>[randomIndex] = <span class=\"keyword\">input</span>[i]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">input</span>[i] = itemAtIndex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">input</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tempArray = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span> ]</span><br><span class=\"line\">tempArray<span class=\"variable\">.shuffle</span>();</span><br><span class=\"line\"><span class=\"comment\">// and the result is...</span></span><br><span class=\"line\">alert(tempArray);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-方法二\"><a href=\"#二-方法二\" class=\"headerlink\" title=\"二. 方法二\"></a>二. 方法二</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//洗牌算法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">arr</span>)</span>&#123;            </span><br><span class=\"line\">               <span class=\"keyword\">var</span> len = arr.length, i, j, temp, index,</span><br><span class=\"line\">               n = <span class=\"built_in\">Math</span>.floor(len/<span class=\"number\">2</span>)+<span class=\"number\">1</span>; </span><br><span class=\"line\">               </span><br><span class=\"line\">               <span class=\"keyword\">while</span>( n-- )&#123; </span><br><span class=\"line\">                   i = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*len); </span><br><span class=\"line\">                   j = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*len); </span><br><span class=\"line\">                   <span class=\"keyword\">if</span>( i!==j )&#123; </span><br><span class=\"line\">                       temp = arr[i]; </span><br><span class=\"line\">                       arr[i] = arr[j]; </span><br><span class=\"line\">                       arr[j] = temp; </span><br><span class=\"line\">                   &#125; </span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"comment\">//增加切牌操作 </span></span><br><span class=\"line\">               index = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*len);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> half = arr.splice(<span class=\"number\">0</span>,i) ;</span><br><span class=\"line\">               arr.push.apply(arr, half); <span class=\"comment\">//splice会改变原数组</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> arr; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]; </span><br><span class=\"line\"><span class=\"keyword\">var</span> newarr = test.slice(<span class=\"number\">0</span>); </span><br><span class=\"line\">mess(newarr); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newarr);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-方法三（乱序效率可能不高）\"><a href=\"#三-方法三（乱序效率可能不高）\" class=\"headerlink\" title=\"三. 方法三（乱序效率可能不高）\"></a>三. 方法三（乱序效率可能不高）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> testArray3=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">55</span>,<span class=\"number\">77</span>,<span class=\"number\">88</span>,<span class=\"number\">99</span>]; </span><br><span class=\"line\"></span><br><span class=\"line\">testArray3.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random()&gt;<span class=\"number\">0.5</span>?<span class=\"number\">-1</span>:<span class=\"number\">1</span>;&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">alert(testArray3);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>洗牌算法的本质其实就是将有序的数组变成无序。</p>\n<h3 id=\"一-方法一\"><a href=\"#一-方法一\" class=\"headerlink\" title=\"一. 方法一\"></a>一. 方法一</h3><p>算法思路：</p>\n<ol>\n<li>选中数组中的最后一个数（基准尾数）</li>\n<li>随机选取从第一个数到基准尾数之间的一个数，将选中的数和基准尾数中的数位置互换</li>\n<li>选取倒数第二个数作为基准尾数，重复上面两步</li>\n<li>以此类推</li>\n</ol>\n<p>选择两个[0…array.Length)之间的随机数</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array<span class=\"variable\">.prototype</span><span class=\"variable\">.shuffle</span> = <span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"keyword\">input</span> = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"keyword\">input</span><span class=\"variable\">.length</span>-<span class=\"number\">1</span>; i &gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> randomIndex = Math<span class=\"variable\">.floor</span>(Math<span class=\"variable\">.random</span>()*(i+<span class=\"number\">1</span>)); <span class=\"comment\">//产生0到i之间的随机整数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> itemAtIndex = <span class=\"keyword\">input</span>[randomIndex]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">input</span>[randomIndex] = <span class=\"keyword\">input</span>[i]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">input</span>[i] = itemAtIndex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">input</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tempArray = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span> ]</span><br><span class=\"line\">tempArray<span class=\"variable\">.shuffle</span>();</span><br><span class=\"line\"><span class=\"comment\">// and the result is...</span></span><br><span class=\"line\">alert(tempArray);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-方法二\"><a href=\"#二-方法二\" class=\"headerlink\" title=\"二. 方法二\"></a>二. 方法二</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//洗牌算法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">arr</span>)</span>&#123;            </span><br><span class=\"line\">               <span class=\"keyword\">var</span> len = arr.length, i, j, temp, index,</span><br><span class=\"line\">               n = <span class=\"built_in\">Math</span>.floor(len/<span class=\"number\">2</span>)+<span class=\"number\">1</span>; </span><br><span class=\"line\">               </span><br><span class=\"line\">               <span class=\"keyword\">while</span>( n-- )&#123; </span><br><span class=\"line\">                   i = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*len); </span><br><span class=\"line\">                   j = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*len); </span><br><span class=\"line\">                   <span class=\"keyword\">if</span>( i!==j )&#123; </span><br><span class=\"line\">                       temp = arr[i]; </span><br><span class=\"line\">                       arr[i] = arr[j]; </span><br><span class=\"line\">                       arr[j] = temp; </span><br><span class=\"line\">                   &#125; </span><br><span class=\"line\">               &#125; </span><br><span class=\"line\">               <span class=\"comment\">//增加切牌操作 </span></span><br><span class=\"line\">               index = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*len);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> half = arr.splice(<span class=\"number\">0</span>,i) ;</span><br><span class=\"line\">               arr.push.apply(arr, half); <span class=\"comment\">//splice会改变原数组</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> arr; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]; </span><br><span class=\"line\"><span class=\"keyword\">var</span> newarr = test.slice(<span class=\"number\">0</span>); </span><br><span class=\"line\">mess(newarr); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newarr);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-方法三（乱序效率可能不高）\"><a href=\"#三-方法三（乱序效率可能不高）\" class=\"headerlink\" title=\"三. 方法三（乱序效率可能不高）\"></a>三. 方法三（乱序效率可能不高）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> testArray3=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">55</span>,<span class=\"number\">77</span>,<span class=\"number\">88</span>,<span class=\"number\">99</span>]; </span><br><span class=\"line\"></span><br><span class=\"line\">testArray3.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random()&gt;<span class=\"number\">0.5</span>?<span class=\"number\">-1</span>:<span class=\"number\">1</span>;&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">alert(testArray3);</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"清除浮动的几种方法","date":"2016-04-04T16:00:00.000Z","description":null,"_content":"\n### 一. 为什么要清除浮动\n\n给元素设置了float属性之后，元素就会脱离文档流，这样就会引起排版的混乱。\n\n元素脱离文档流的结果：\n\n元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。\n\neg:\n\n    <div class=\"outer\">\n    \t<div class=\"div1\">1</div>\n    </div>\n    \n    .outer{border: 1px solid #ccc;background: #fc9;color: #fff; margin: 50px auto;padding: 50px;}\n    .div1{width: 80px;height: 80px;background: red;float: left;}\n\n如上例所示，如果子元素不浮动的话，那么这个外层的高是会自动被撑开的。但是当内层元素浮动后，就出现了一下影响：\n\n1. 背景不能显示 \n1. 边框不能撑开 \n1. margin 设置值不能正确显示\n\n### 二. 清除浮动的方法\n\n#### 1. 在浮动的元素下面加一个空的`<div>`，设置`clear:both;`属性\n\n这个也是我最常使用的一种方法，但是这种方法有一个缺点就是，会增加一个多余的DOM节点。\n\n    <div class=\"outer\">\n\t    <div class=\"div1\">1</div>\n\t    <div class=\"div2\">2</div>\n\t    <div class=\"div3\">3</div>\n\t    <div class=\"clear\"></div>\n    </div>\n    \n    .clear{clear:both; height: 0; line-height: 0; font-size: 0}\n\n    插播clear属性：\n    \n    clear:left; /* 元素左边不允许有浮动的元素 */\n    \n    clear:right; /* 元素右边不允许有浮动元素*/\n\n#### 2. 父元素定义 overflow：hidden；zoom:1;\n\n不能定义height，使用overflow:hidden;时，浏览器会自动检查浮动区的位置\n\n    <div class=\"outer\">\n\t    <div class=\"div1\">1</div>\n\t    <div class=\"div2\">2</div>\n\t    <div class=\"div3\">3</div>\n    </div>\n\n    .outer{overflow:hidden;zoom:1;}\n\n与这个类似的一个方法是：\n\n**父元素定义 overflow:auto;zoom:1;** —— 这里是利用元素的BFC特性\n\n注意：这里的zoom:1;是用来解决浏览器的兼容性。\n\n#### 3. 给父元素加一个:after{clear:both;}\n    \n    .outer:after {\n\t    clear:both;//清除浮动\n\t    content:'';\n\t    display:block;//这个属性是必须的\n\t    visibility:hidden;//允许浏览器渲染，但是不显示出来\n    }\n\n    插播一个visibility:hidden;和display:none;的区别：\n    \n    visibility:none; **在页面中**看不见摸得着，页面中会留出空间，只是不可见\n    \n    display:none; **在页面中**看不见摸不着，存在dom节点，但是在页面中没有这个对象。\n\n- :after指的是在该标签里面的所有元素之后，添加内容（而不是标签之后！！！注意）\n- :before指的是在该标签里面的所有元素之前，添加内容\n\n#### 4. 给父元素加一个高度\n\n解决父元素无法自动获取高度的问题\n\n但是这种方法使用太局限了，不建议使用\n\n#### 5. 父元素也一起浮动\n\n不建议使用\n\n#### 6.父元素定义display:table\n\n不建议使用\n\n","source":"_posts/2016-04-05-清除浮动的几种方法.md","raw":"---\nlayout: post\ntitle: 清除浮动的几种方法\ndate: 2016-04-05\ncategories: 前端笔记\ntags: [css]\ndescription: \n---\n\n### 一. 为什么要清除浮动\n\n给元素设置了float属性之后，元素就会脱离文档流，这样就会引起排版的混乱。\n\n元素脱离文档流的结果：\n\n元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。\n\neg:\n\n    <div class=\"outer\">\n    \t<div class=\"div1\">1</div>\n    </div>\n    \n    .outer{border: 1px solid #ccc;background: #fc9;color: #fff; margin: 50px auto;padding: 50px;}\n    .div1{width: 80px;height: 80px;background: red;float: left;}\n\n如上例所示，如果子元素不浮动的话，那么这个外层的高是会自动被撑开的。但是当内层元素浮动后，就出现了一下影响：\n\n1. 背景不能显示 \n1. 边框不能撑开 \n1. margin 设置值不能正确显示\n\n### 二. 清除浮动的方法\n\n#### 1. 在浮动的元素下面加一个空的`<div>`，设置`clear:both;`属性\n\n这个也是我最常使用的一种方法，但是这种方法有一个缺点就是，会增加一个多余的DOM节点。\n\n    <div class=\"outer\">\n\t    <div class=\"div1\">1</div>\n\t    <div class=\"div2\">2</div>\n\t    <div class=\"div3\">3</div>\n\t    <div class=\"clear\"></div>\n    </div>\n    \n    .clear{clear:both; height: 0; line-height: 0; font-size: 0}\n\n    插播clear属性：\n    \n    clear:left; /* 元素左边不允许有浮动的元素 */\n    \n    clear:right; /* 元素右边不允许有浮动元素*/\n\n#### 2. 父元素定义 overflow：hidden；zoom:1;\n\n不能定义height，使用overflow:hidden;时，浏览器会自动检查浮动区的位置\n\n    <div class=\"outer\">\n\t    <div class=\"div1\">1</div>\n\t    <div class=\"div2\">2</div>\n\t    <div class=\"div3\">3</div>\n    </div>\n\n    .outer{overflow:hidden;zoom:1;}\n\n与这个类似的一个方法是：\n\n**父元素定义 overflow:auto;zoom:1;** —— 这里是利用元素的BFC特性\n\n注意：这里的zoom:1;是用来解决浏览器的兼容性。\n\n#### 3. 给父元素加一个:after{clear:both;}\n    \n    .outer:after {\n\t    clear:both;//清除浮动\n\t    content:'';\n\t    display:block;//这个属性是必须的\n\t    visibility:hidden;//允许浏览器渲染，但是不显示出来\n    }\n\n    插播一个visibility:hidden;和display:none;的区别：\n    \n    visibility:none; **在页面中**看不见摸得着，页面中会留出空间，只是不可见\n    \n    display:none; **在页面中**看不见摸不着，存在dom节点，但是在页面中没有这个对象。\n\n- :after指的是在该标签里面的所有元素之后，添加内容（而不是标签之后！！！注意）\n- :before指的是在该标签里面的所有元素之前，添加内容\n\n#### 4. 给父元素加一个高度\n\n解决父元素无法自动获取高度的问题\n\n但是这种方法使用太局限了，不建议使用\n\n#### 5. 父元素也一起浮动\n\n不建议使用\n\n#### 6.父元素定义display:table\n\n不建议使用\n\n","slug":"2016-04-05-清除浮动的几种方法","published":1,"updated":"2016-09-20T03:44:54.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocds002fd5u89auhcagj","content":"<h3 id=\"一-为什么要清除浮动\"><a href=\"#一-为什么要清除浮动\" class=\"headerlink\" title=\"一. 为什么要清除浮动\"></a>一. 为什么要清除浮动</h3><p>给元素设置了float属性之后，元素就会脱离文档流，这样就会引起排版的混乱。</p>\n<p>元素脱离文档流的结果：</p>\n<p>元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。</p>\n<p>eg:</p>\n<pre><code>&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;\n&lt;/div&gt;\n\n.outer{border: 1px solid #ccc;background: #fc9;color: #fff; margin: 50px auto;padding: 50px;}\n.div1{width: 80px;height: 80px;background: red;float: left;}\n</code></pre><p>如上例所示，如果子元素不浮动的话，那么这个外层的高是会自动被撑开的。但是当内层元素浮动后，就出现了一下影响：</p>\n<ol>\n<li>背景不能显示 </li>\n<li>边框不能撑开 </li>\n<li>margin 设置值不能正确显示</li>\n</ol>\n<h3 id=\"二-清除浮动的方法\"><a href=\"#二-清除浮动的方法\" class=\"headerlink\" title=\"二. 清除浮动的方法\"></a>二. 清除浮动的方法</h3><h4 id=\"1-在浮动的元素下面加一个空的-lt-div-gt-，设置clear-both-属性\"><a href=\"#1-在浮动的元素下面加一个空的-lt-div-gt-，设置clear-both-属性\" class=\"headerlink\" title=\"1. 在浮动的元素下面加一个空的&lt;div&gt;，设置clear:both;属性\"></a>1. 在浮动的元素下面加一个空的<code>&lt;div&gt;</code>，设置<code>clear:both;</code>属性</h4><p>这个也是我最常使用的一种方法，但是这种方法有一个缺点就是，会增加一个多余的DOM节点。</p>\n<pre><code>&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;\n    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;\n    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;\n    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n.clear{clear:both; height: 0; line-height: 0; font-size: 0}\n\n插播clear属性：\n\nclear:left; /* 元素左边不允许有浮动的元素 */\n\nclear:right; /* 元素右边不允许有浮动元素*/\n</code></pre><h4 id=\"2-父元素定义-overflow：hidden；zoom-1\"><a href=\"#2-父元素定义-overflow：hidden；zoom-1\" class=\"headerlink\" title=\"2. 父元素定义 overflow：hidden；zoom:1;\"></a>2. 父元素定义 overflow：hidden；zoom:1;</h4><p>不能定义height，使用overflow:hidden;时，浏览器会自动检查浮动区的位置</p>\n<pre><code>&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;\n    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;\n    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;\n&lt;/div&gt;\n\n.outer{overflow:hidden;zoom:1;}\n</code></pre><p>与这个类似的一个方法是：</p>\n<p><strong>父元素定义 overflow:auto;zoom:1;</strong> —— 这里是利用元素的BFC特性</p>\n<p>注意：这里的zoom:1;是用来解决浏览器的兼容性。</p>\n<h4 id=\"3-给父元素加一个-after-clear-both\"><a href=\"#3-给父元素加一个-after-clear-both\" class=\"headerlink\" title=\"3. 给父元素加一个:after{clear:both;}\"></a>3. 给父元素加一个:after{clear:both;}</h4><pre><code>.outer:after {\n    clear:both;//清除浮动\n    content:&apos;&apos;;\n    display:block;//这个属性是必须的\n    visibility:hidden;//允许浏览器渲染，但是不显示出来\n}\n\n插播一个visibility:hidden;和display:none;的区别：\n\nvisibility:none; **在页面中**看不见摸得着，页面中会留出空间，只是不可见\n\ndisplay:none; **在页面中**看不见摸不着，存在dom节点，但是在页面中没有这个对象。\n</code></pre><ul>\n<li>:after指的是在该标签里面的所有元素之后，添加内容（而不是标签之后！！！注意）</li>\n<li>:before指的是在该标签里面的所有元素之前，添加内容</li>\n</ul>\n<h4 id=\"4-给父元素加一个高度\"><a href=\"#4-给父元素加一个高度\" class=\"headerlink\" title=\"4. 给父元素加一个高度\"></a>4. 给父元素加一个高度</h4><p>解决父元素无法自动获取高度的问题</p>\n<p>但是这种方法使用太局限了，不建议使用</p>\n<h4 id=\"5-父元素也一起浮动\"><a href=\"#5-父元素也一起浮动\" class=\"headerlink\" title=\"5. 父元素也一起浮动\"></a>5. 父元素也一起浮动</h4><p>不建议使用</p>\n<h4 id=\"6-父元素定义display-table\"><a href=\"#6-父元素定义display-table\" class=\"headerlink\" title=\"6.父元素定义display:table\"></a>6.父元素定义display:table</h4><p>不建议使用</p>\n","excerpt":"","more":"<h3 id=\"一-为什么要清除浮动\"><a href=\"#一-为什么要清除浮动\" class=\"headerlink\" title=\"一. 为什么要清除浮动\"></a>一. 为什么要清除浮动</h3><p>给元素设置了float属性之后，元素就会脱离文档流，这样就会引起排版的混乱。</p>\n<p>元素脱离文档流的结果：</p>\n<p>元素从普通布局排版中拿走，其他盒子在定位的时候，会把脱离文档流的元素当做不存在来进行定位。</p>\n<p>eg:</p>\n<pre><code>&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;\n&lt;/div&gt;\n\n.outer{border: 1px solid #ccc;background: #fc9;color: #fff; margin: 50px auto;padding: 50px;}\n.div1{width: 80px;height: 80px;background: red;float: left;}\n</code></pre><p>如上例所示，如果子元素不浮动的话，那么这个外层的高是会自动被撑开的。但是当内层元素浮动后，就出现了一下影响：</p>\n<ol>\n<li>背景不能显示 </li>\n<li>边框不能撑开 </li>\n<li>margin 设置值不能正确显示</li>\n</ol>\n<h3 id=\"二-清除浮动的方法\"><a href=\"#二-清除浮动的方法\" class=\"headerlink\" title=\"二. 清除浮动的方法\"></a>二. 清除浮动的方法</h3><h4 id=\"1-在浮动的元素下面加一个空的-lt-div-gt-，设置clear-both-属性\"><a href=\"#1-在浮动的元素下面加一个空的-lt-div-gt-，设置clear-both-属性\" class=\"headerlink\" title=\"1. 在浮动的元素下面加一个空的&lt;div&gt;，设置clear:both;属性\"></a>1. 在浮动的元素下面加一个空的<code>&lt;div&gt;</code>，设置<code>clear:both;</code>属性</h4><p>这个也是我最常使用的一种方法，但是这种方法有一个缺点就是，会增加一个多余的DOM节点。</p>\n<pre><code>&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;\n    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;\n    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;\n    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n.clear{clear:both; height: 0; line-height: 0; font-size: 0}\n\n插播clear属性：\n\nclear:left; /* 元素左边不允许有浮动的元素 */\n\nclear:right; /* 元素右边不允许有浮动元素*/\n</code></pre><h4 id=\"2-父元素定义-overflow：hidden；zoom-1\"><a href=\"#2-父元素定义-overflow：hidden；zoom-1\" class=\"headerlink\" title=\"2. 父元素定义 overflow：hidden；zoom:1;\"></a>2. 父元素定义 overflow：hidden；zoom:1;</h4><p>不能定义height，使用overflow:hidden;时，浏览器会自动检查浮动区的位置</p>\n<pre><code>&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;\n    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;\n    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;\n&lt;/div&gt;\n\n.outer{overflow:hidden;zoom:1;}\n</code></pre><p>与这个类似的一个方法是：</p>\n<p><strong>父元素定义 overflow:auto;zoom:1;</strong> —— 这里是利用元素的BFC特性</p>\n<p>注意：这里的zoom:1;是用来解决浏览器的兼容性。</p>\n<h4 id=\"3-给父元素加一个-after-clear-both\"><a href=\"#3-给父元素加一个-after-clear-both\" class=\"headerlink\" title=\"3. 给父元素加一个:after{clear:both;}\"></a>3. 给父元素加一个:after{clear:both;}</h4><pre><code>.outer:after {\n    clear:both;//清除浮动\n    content:&apos;&apos;;\n    display:block;//这个属性是必须的\n    visibility:hidden;//允许浏览器渲染，但是不显示出来\n}\n\n插播一个visibility:hidden;和display:none;的区别：\n\nvisibility:none; **在页面中**看不见摸得着，页面中会留出空间，只是不可见\n\ndisplay:none; **在页面中**看不见摸不着，存在dom节点，但是在页面中没有这个对象。\n</code></pre><ul>\n<li>:after指的是在该标签里面的所有元素之后，添加内容（而不是标签之后！！！注意）</li>\n<li>:before指的是在该标签里面的所有元素之前，添加内容</li>\n</ul>\n<h4 id=\"4-给父元素加一个高度\"><a href=\"#4-给父元素加一个高度\" class=\"headerlink\" title=\"4. 给父元素加一个高度\"></a>4. 给父元素加一个高度</h4><p>解决父元素无法自动获取高度的问题</p>\n<p>但是这种方法使用太局限了，不建议使用</p>\n<h4 id=\"5-父元素也一起浮动\"><a href=\"#5-父元素也一起浮动\" class=\"headerlink\" title=\"5. 父元素也一起浮动\"></a>5. 父元素也一起浮动</h4><p>不建议使用</p>\n<h4 id=\"6-父元素定义display-table\"><a href=\"#6-父元素定义display-table\" class=\"headerlink\" title=\"6.父元素定义display:table\"></a>6.父元素定义display:table</h4><p>不建议使用</p>\n"},{"layout":"post","title":"Baidu IFE 第二阶段任务13~18","date":"2016-04-04T16:00:00.000Z","description":"参加百度前端公开课的第一阶段任务","_content":"\n### 一.  第二阶段任务\n\n百度前端技术学院的第一阶段主要是针对HTML和CSS的学习和训练，第二阶段就进入javascript的学习了。\n\n进入js之后发现很多基础的东西虽然之前看过，但是用起来时候还是得再返回去看一下，希望自己能在做任务的过程中不断进步~~\n\n![第二阶段任务](/uploads/post/demo/baidu-ife-task2.jpg)\n\n### 二.  我的任务\n\n我的任务列表[http://panpanfish.com/baiduIFE/](http://panpanfish.com/baiduIFE/)\n\n#### 1. 任务十三\n\n#### (1). 任务十三需要完成的功能\n\n**任务要求：**\n\n本任务完成的功能为：用户可以在输入框中输入任何内容，点击“确认填写”按钮后，用户输入的内容会显示在“您输入的值是”文字的右边\n\n#### (2). 任务十三demo\n\n[http://panpanfish.com/baiduIFE/task2-13.html](http://panpanfish.com/baiduIFE/task2-13.html)\n\n#### (3). 任务十三代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html)\n\n#### (4). 任务十三笔记\n\n**a. (function(){})();**\n\n这个代表一个**自执行的匿名函数**，function(){}代表一个函数，但是没有对函数命名，于是用()将其括起来，后面的()代表函数自动执行\n\n**b. click()和onclick的区别**\n\n**click()**是一个方法，对某一个DOM节点调用这个方法之后，就会执行click这个动作。\n\n**onclick**是一个事件，我们可以给这个事件添加响应这个事件的函数（事件处理程序）。\n\n    onclick = function(){}\n    \n    函数里面的内容代表：当执行这个事件时（click这个动作时）会做出什么样的响应\n\n**c. 利用id名获取DOM节点**\n\n    document.getElementById(\"myid\")\n\n**d. 获取input框的输入值**\n\n    document.getElementById(\"myinput\").value\n\n**e. DOM 的innerHTML属性**\n\n获取或者设置标签内部的HTML\n\n#### 2. 任务十四\n\n#### (1). 任务十四需要完成的功能\n\n**任务要求：**\n\n页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上\n\n    \t<li>第一名：福州（样例），10</li>\n      \t<li>第二名：福州（样例），10</li> \n\n#### (2). 任务十四demo\n\n[http://panpanfish.com/baiduIFE/task2-14.html](http://panpanfish.com/baiduIFE/task2-14.html)\n\n#### (3). 任务十四代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html)\n\n#### (4). 任务十四笔记\n\n**a. 数组的重排序方法**\n\n**sort()** 会将数组的元素进行排序，是直接将原数组进行排序。\n\n\n- **直接调用array.sort()时，将会按照字符编码的顺序进行升序排序。**\n\n\tsort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。\n\neg:\n\n    var values=[0,1,5,10,15]\n    values.sort();\n    alert(values);\n    \n    结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n\n\n\n- **给sort()传入一个比较函数，可以按照数值大小进行排序**\n\n\t    values.sort(compare);\n    \n    \tcompare为比较函数\n    \n    \tfunction compare(value1,value2)\n    \t{\n    \t\tif(value1 < value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 = value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 > value2)\n    \t\t{return 1;}\n    \t}\n    \n    \t**比较函数返回参数解释：**\n    \t- 若为正数：第一个参数位于第二个参数之后\n    \t- 若为0：两个参数相等\n    \t- 若为负数：第一个参数位于第二个参数之前\n    \n    \t所以上面举例的比较函数是升序排列的比较函数\n\n\t\t简化的比较函数\n\n\t\t升序排列的比较函数 function compare(a,b){return a-b}\n\n\t\t降序排列的比较函数 function compare(a,b){return b-a}\n\n**reverse()**方法，反转数组项的顺序\n\n**b. 数组的迭代方法**\n\n这里只记录用到**filter()方法**和**map()方法**\n\n- filter是满足条件的留下，是对原数组的过滤；\n- map则是对原数组的加工，映射成一一映射的新数组\n\n**filter()** 顾名思义，可以理解成用某种条件来过滤数组的方法，用某种条件来选出符合该条件的项，并组成一个新的数组。\n\neg:\n\n    var numbers = [1,2,3,4,5,6,7];\n    \n    var filterResult = numbers.filter(function(item,index,array){\n    \treturn (item > 2);//返回数组中大于2的项\n    \n    });\n\n**map()** 映射，新数组中的每一项都是由原数组的对应项经过某种操作得来的\n\neg:\n\n    var numbers = [1,2,3,4,5];\n    \n    var mapResult = numbers.map(function(item,index,array){\n    \treturn item * 2;\n    });\n","source":"_posts/2016-04-05-Baidu-IFE-task2-13-18.md","raw":"---\nlayout: post\ntitle: Baidu IFE 第二阶段任务13~18\ndate: 2016-04-05\ncategories: Demo\ntags: [BaiduIFE]\ndescription: 参加百度前端公开课的第一阶段任务\n---\n\n### 一.  第二阶段任务\n\n百度前端技术学院的第一阶段主要是针对HTML和CSS的学习和训练，第二阶段就进入javascript的学习了。\n\n进入js之后发现很多基础的东西虽然之前看过，但是用起来时候还是得再返回去看一下，希望自己能在做任务的过程中不断进步~~\n\n![第二阶段任务](/uploads/post/demo/baidu-ife-task2.jpg)\n\n### 二.  我的任务\n\n我的任务列表[http://panpanfish.com/baiduIFE/](http://panpanfish.com/baiduIFE/)\n\n#### 1. 任务十三\n\n#### (1). 任务十三需要完成的功能\n\n**任务要求：**\n\n本任务完成的功能为：用户可以在输入框中输入任何内容，点击“确认填写”按钮后，用户输入的内容会显示在“您输入的值是”文字的右边\n\n#### (2). 任务十三demo\n\n[http://panpanfish.com/baiduIFE/task2-13.html](http://panpanfish.com/baiduIFE/task2-13.html)\n\n#### (3). 任务十三代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html)\n\n#### (4). 任务十三笔记\n\n**a. (function(){})();**\n\n这个代表一个**自执行的匿名函数**，function(){}代表一个函数，但是没有对函数命名，于是用()将其括起来，后面的()代表函数自动执行\n\n**b. click()和onclick的区别**\n\n**click()**是一个方法，对某一个DOM节点调用这个方法之后，就会执行click这个动作。\n\n**onclick**是一个事件，我们可以给这个事件添加响应这个事件的函数（事件处理程序）。\n\n    onclick = function(){}\n    \n    函数里面的内容代表：当执行这个事件时（click这个动作时）会做出什么样的响应\n\n**c. 利用id名获取DOM节点**\n\n    document.getElementById(\"myid\")\n\n**d. 获取input框的输入值**\n\n    document.getElementById(\"myinput\").value\n\n**e. DOM 的innerHTML属性**\n\n获取或者设置标签内部的HTML\n\n#### 2. 任务十四\n\n#### (1). 任务十四需要完成的功能\n\n**任务要求：**\n\n页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上\n\n    \t<li>第一名：福州（样例），10</li>\n      \t<li>第二名：福州（样例），10</li> \n\n#### (2). 任务十四demo\n\n[http://panpanfish.com/baiduIFE/task2-14.html](http://panpanfish.com/baiduIFE/task2-14.html)\n\n#### (3). 任务十四代码\n\n[https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html](https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html)\n\n#### (4). 任务十四笔记\n\n**a. 数组的重排序方法**\n\n**sort()** 会将数组的元素进行排序，是直接将原数组进行排序。\n\n\n- **直接调用array.sort()时，将会按照字符编码的顺序进行升序排序。**\n\n\tsort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。\n\neg:\n\n    var values=[0,1,5,10,15]\n    values.sort();\n    alert(values);\n    \n    结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n\n\n\n- **给sort()传入一个比较函数，可以按照数值大小进行排序**\n\n\t    values.sort(compare);\n    \n    \tcompare为比较函数\n    \n    \tfunction compare(value1,value2)\n    \t{\n    \t\tif(value1 < value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 = value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 > value2)\n    \t\t{return 1;}\n    \t}\n    \n    \t**比较函数返回参数解释：**\n    \t- 若为正数：第一个参数位于第二个参数之后\n    \t- 若为0：两个参数相等\n    \t- 若为负数：第一个参数位于第二个参数之前\n    \n    \t所以上面举例的比较函数是升序排列的比较函数\n\n\t\t简化的比较函数\n\n\t\t升序排列的比较函数 function compare(a,b){return a-b}\n\n\t\t降序排列的比较函数 function compare(a,b){return b-a}\n\n**reverse()**方法，反转数组项的顺序\n\n**b. 数组的迭代方法**\n\n这里只记录用到**filter()方法**和**map()方法**\n\n- filter是满足条件的留下，是对原数组的过滤；\n- map则是对原数组的加工，映射成一一映射的新数组\n\n**filter()** 顾名思义，可以理解成用某种条件来过滤数组的方法，用某种条件来选出符合该条件的项，并组成一个新的数组。\n\neg:\n\n    var numbers = [1,2,3,4,5,6,7];\n    \n    var filterResult = numbers.filter(function(item,index,array){\n    \treturn (item > 2);//返回数组中大于2的项\n    \n    });\n\n**map()** 映射，新数组中的每一项都是由原数组的对应项经过某种操作得来的\n\neg:\n\n    var numbers = [1,2,3,4,5];\n    \n    var mapResult = numbers.map(function(item,index,array){\n    \treturn item * 2;\n    });\n","slug":"2016-04-05-Baidu-IFE-task2-13-18","published":1,"updated":"2016-05-30T09:43:06.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocdu002jd5u80ri2ljr7","content":"<h3 id=\"一-第二阶段任务\"><a href=\"#一-第二阶段任务\" class=\"headerlink\" title=\"一.  第二阶段任务\"></a>一.  第二阶段任务</h3><p>百度前端技术学院的第一阶段主要是针对HTML和CSS的学习和训练，第二阶段就进入javascript的学习了。</p>\n<p>进入js之后发现很多基础的东西虽然之前看过，但是用起来时候还是得再返回去看一下，希望自己能在做任务的过程中不断进步~~</p>\n<p><img src=\"/uploads/post/demo/baidu-ife-task2.jpg\" alt=\"第二阶段任务\"></p>\n<h3 id=\"二-我的任务\"><a href=\"#二-我的任务\" class=\"headerlink\" title=\"二.  我的任务\"></a>二.  我的任务</h3><p>我的任务列表<a href=\"http://panpanfish.com/baiduIFE/\">http://panpanfish.com/baiduIFE/</a></p>\n<h4 id=\"1-任务十三\"><a href=\"#1-任务十三\" class=\"headerlink\" title=\"1. 任务十三\"></a>1. 任务十三</h4><h4 id=\"1-任务十三需要完成的功能\"><a href=\"#1-任务十三需要完成的功能\" class=\"headerlink\" title=\"(1). 任务十三需要完成的功能\"></a>(1). 任务十三需要完成的功能</h4><p><strong>任务要求：</strong></p>\n<p>本任务完成的功能为：用户可以在输入框中输入任何内容，点击“确认填写”按钮后，用户输入的内容会显示在“您输入的值是”文字的右边</p>\n<h4 id=\"2-任务十三demo\"><a href=\"#2-任务十三demo\" class=\"headerlink\" title=\"(2). 任务十三demo\"></a>(2). 任务十三demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task2-13.html\">http://panpanfish.com/baiduIFE/task2-13.html</a></p>\n<h4 id=\"3-任务十三代码\"><a href=\"#3-任务十三代码\" class=\"headerlink\" title=\"(3). 任务十三代码\"></a>(3). 任务十三代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html</a></p>\n<h4 id=\"4-任务十三笔记\"><a href=\"#4-任务十三笔记\" class=\"headerlink\" title=\"(4). 任务十三笔记\"></a>(4). 任务十三笔记</h4><p><strong>a. (function(){})();</strong></p>\n<p>这个代表一个<strong>自执行的匿名函数</strong>，function(){}代表一个函数，但是没有对函数命名，于是用()将其括起来，后面的()代表函数自动执行</p>\n<p><strong>b. click()和onclick的区别</strong></p>\n<p><strong>click()</strong>是一个方法，对某一个DOM节点调用这个方法之后，就会执行click这个动作。</p>\n<p><strong>onclick</strong>是一个事件，我们可以给这个事件添加响应这个事件的函数（事件处理程序）。</p>\n<pre><code>onclick = function(){}\n\n函数里面的内容代表：当执行这个事件时（click这个动作时）会做出什么样的响应\n</code></pre><p><strong>c. 利用id名获取DOM节点</strong></p>\n<pre><code>document.getElementById(&quot;myid&quot;)\n</code></pre><p><strong>d. 获取input框的输入值</strong></p>\n<pre><code>document.getElementById(&quot;myinput&quot;).value\n</code></pre><p><strong>e. DOM 的innerHTML属性</strong></p>\n<p>获取或者设置标签内部的HTML</p>\n<h4 id=\"2-任务十四\"><a href=\"#2-任务十四\" class=\"headerlink\" title=\"2. 任务十四\"></a>2. 任务十四</h4><h4 id=\"1-任务十四需要完成的功能\"><a href=\"#1-任务十四需要完成的功能\" class=\"headerlink\" title=\"(1). 任务十四需要完成的功能\"></a>(1). 任务十四需要完成的功能</h4><p><strong>任务要求：</strong></p>\n<p>页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上</p>\n<pre><code>&lt;li&gt;第一名：福州（样例），10&lt;/li&gt;\n  &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; \n</code></pre><h4 id=\"2-任务十四demo\"><a href=\"#2-任务十四demo\" class=\"headerlink\" title=\"(2). 任务十四demo\"></a>(2). 任务十四demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task2-14.html\">http://panpanfish.com/baiduIFE/task2-14.html</a></p>\n<h4 id=\"3-任务十四代码\"><a href=\"#3-任务十四代码\" class=\"headerlink\" title=\"(3). 任务十四代码\"></a>(3). 任务十四代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html</a></p>\n<h4 id=\"4-任务十四笔记\"><a href=\"#4-任务十四笔记\" class=\"headerlink\" title=\"(4). 任务十四笔记\"></a>(4). 任务十四笔记</h4><p><strong>a. 数组的重排序方法</strong></p>\n<p><strong>sort()</strong> 会将数组的元素进行排序，是直接将原数组进行排序。</p>\n<ul>\n<li><p><strong>直接调用array.sort()时，将会按照字符编码的顺序进行升序排序。</strong></p>\n<p>  sort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。</p>\n</li>\n</ul>\n<p>eg:</p>\n<pre><code>var values=[0,1,5,10,15]\nvalues.sort();\nalert(values);\n\n结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n</code></pre><ul>\n<li><p><strong>给sort()传入一个比较函数，可以按照数值大小进行排序</strong></p>\n<pre><code>values.sort(compare);\n\ncompare为比较函数\n\nfunction compare(value1,value2)\n{\n    if(value1 &lt; value2)\n    {return -1;}\n\n    if(value1 = value2)\n    {return -1;}\n\n    if(value1 &gt; value2)\n    {return 1;}\n}\n\n**比较函数返回参数解释：**\n- 若为正数：第一个参数位于第二个参数之后\n- 若为0：两个参数相等\n- 若为负数：第一个参数位于第二个参数之前\n\n所以上面举例的比较函数是升序排列的比较函数\n\n简化的比较函数\n\n升序排列的比较函数 function compare(a,b){return a-b}\n\n降序排列的比较函数 function compare(a,b){return b-a}\n</code></pre></li>\n</ul>\n<p><strong>reverse()</strong>方法，反转数组项的顺序</p>\n<p><strong>b. 数组的迭代方法</strong></p>\n<p>这里只记录用到<strong>filter()方法</strong>和<strong>map()方法</strong></p>\n<ul>\n<li>filter是满足条件的留下，是对原数组的过滤；</li>\n<li>map则是对原数组的加工，映射成一一映射的新数组</li>\n</ul>\n<p><strong>filter()</strong> 顾名思义，可以理解成用某种条件来过滤数组的方法，用某种条件来选出符合该条件的项，并组成一个新的数组。</p>\n<p>eg:</p>\n<pre><code>var numbers = [1,2,3,4,5,6,7];\n\nvar filterResult = numbers.filter(function(item,index,array){\n    return (item &gt; 2);//返回数组中大于2的项\n\n});\n</code></pre><p><strong>map()</strong> 映射，新数组中的每一项都是由原数组的对应项经过某种操作得来的</p>\n<p>eg:</p>\n<pre><code>var numbers = [1,2,3,4,5];\n\nvar mapResult = numbers.map(function(item,index,array){\n    return item * 2;\n});\n</code></pre>","excerpt":"","more":"<h3 id=\"一-第二阶段任务\"><a href=\"#一-第二阶段任务\" class=\"headerlink\" title=\"一.  第二阶段任务\"></a>一.  第二阶段任务</h3><p>百度前端技术学院的第一阶段主要是针对HTML和CSS的学习和训练，第二阶段就进入javascript的学习了。</p>\n<p>进入js之后发现很多基础的东西虽然之前看过，但是用起来时候还是得再返回去看一下，希望自己能在做任务的过程中不断进步~~</p>\n<p><img src=\"/uploads/post/demo/baidu-ife-task2.jpg\" alt=\"第二阶段任务\"></p>\n<h3 id=\"二-我的任务\"><a href=\"#二-我的任务\" class=\"headerlink\" title=\"二.  我的任务\"></a>二.  我的任务</h3><p>我的任务列表<a href=\"http://panpanfish.com/baiduIFE/\">http://panpanfish.com/baiduIFE/</a></p>\n<h4 id=\"1-任务十三\"><a href=\"#1-任务十三\" class=\"headerlink\" title=\"1. 任务十三\"></a>1. 任务十三</h4><h4 id=\"1-任务十三需要完成的功能\"><a href=\"#1-任务十三需要完成的功能\" class=\"headerlink\" title=\"(1). 任务十三需要完成的功能\"></a>(1). 任务十三需要完成的功能</h4><p><strong>任务要求：</strong></p>\n<p>本任务完成的功能为：用户可以在输入框中输入任何内容，点击“确认填写”按钮后，用户输入的内容会显示在“您输入的值是”文字的右边</p>\n<h4 id=\"2-任务十三demo\"><a href=\"#2-任务十三demo\" class=\"headerlink\" title=\"(2). 任务十三demo\"></a>(2). 任务十三demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task2-13.html\">http://panpanfish.com/baiduIFE/task2-13.html</a></p>\n<h4 id=\"3-任务十三代码\"><a href=\"#3-任务十三代码\" class=\"headerlink\" title=\"(3). 任务十三代码\"></a>(3). 任务十三代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-13.html</a></p>\n<h4 id=\"4-任务十三笔记\"><a href=\"#4-任务十三笔记\" class=\"headerlink\" title=\"(4). 任务十三笔记\"></a>(4). 任务十三笔记</h4><p><strong>a. (function(){})();</strong></p>\n<p>这个代表一个<strong>自执行的匿名函数</strong>，function(){}代表一个函数，但是没有对函数命名，于是用()将其括起来，后面的()代表函数自动执行</p>\n<p><strong>b. click()和onclick的区别</strong></p>\n<p><strong>click()</strong>是一个方法，对某一个DOM节点调用这个方法之后，就会执行click这个动作。</p>\n<p><strong>onclick</strong>是一个事件，我们可以给这个事件添加响应这个事件的函数（事件处理程序）。</p>\n<pre><code>onclick = function(){}\n\n函数里面的内容代表：当执行这个事件时（click这个动作时）会做出什么样的响应\n</code></pre><p><strong>c. 利用id名获取DOM节点</strong></p>\n<pre><code>document.getElementById(&quot;myid&quot;)\n</code></pre><p><strong>d. 获取input框的输入值</strong></p>\n<pre><code>document.getElementById(&quot;myinput&quot;).value\n</code></pre><p><strong>e. DOM 的innerHTML属性</strong></p>\n<p>获取或者设置标签内部的HTML</p>\n<h4 id=\"2-任务十四\"><a href=\"#2-任务十四\" class=\"headerlink\" title=\"2. 任务十四\"></a>2. 任务十四</h4><h4 id=\"1-任务十四需要完成的功能\"><a href=\"#1-任务十四需要完成的功能\" class=\"headerlink\" title=\"(1). 任务十四需要完成的功能\"></a>(1). 任务十四需要完成的功能</h4><p><strong>任务要求：</strong></p>\n<p>页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上</p>\n<pre><code>&lt;li&gt;第一名：福州（样例），10&lt;/li&gt;\n  &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; \n</code></pre><h4 id=\"2-任务十四demo\"><a href=\"#2-任务十四demo\" class=\"headerlink\" title=\"(2). 任务十四demo\"></a>(2). 任务十四demo</h4><p><a href=\"http://panpanfish.com/baiduIFE/task2-14.html\">http://panpanfish.com/baiduIFE/task2-14.html</a></p>\n<h4 id=\"3-任务十四代码\"><a href=\"#3-任务十四代码\" class=\"headerlink\" title=\"(3). 任务十四代码\"></a>(3). 任务十四代码</h4><p><a href=\"https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html\">https://github.com/panpan040828/baiduIFE/blob/gh-pages/task2-14.html</a></p>\n<h4 id=\"4-任务十四笔记\"><a href=\"#4-任务十四笔记\" class=\"headerlink\" title=\"(4). 任务十四笔记\"></a>(4). 任务十四笔记</h4><p><strong>a. 数组的重排序方法</strong></p>\n<p><strong>sort()</strong> 会将数组的元素进行排序，是直接将原数组进行排序。</p>\n<ul>\n<li><p><strong>直接调用array.sort()时，将会按照字符编码的顺序进行升序排序。</strong></p>\n<p>  sort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。</p>\n</li>\n</ul>\n<p>eg:</p>\n<pre><code>var values=[0,1,5,10,15]\nvalues.sort();\nalert(values);\n\n结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n</code></pre><ul>\n<li><p><strong>给sort()传入一个比较函数，可以按照数值大小进行排序</strong></p>\n<pre><code>values.sort(compare);\n\ncompare为比较函数\n\nfunction compare(value1,value2)\n{\n    if(value1 &lt; value2)\n    {return -1;}\n\n    if(value1 = value2)\n    {return -1;}\n\n    if(value1 &gt; value2)\n    {return 1;}\n}\n\n**比较函数返回参数解释：**\n- 若为正数：第一个参数位于第二个参数之后\n- 若为0：两个参数相等\n- 若为负数：第一个参数位于第二个参数之前\n\n所以上面举例的比较函数是升序排列的比较函数\n\n简化的比较函数\n\n升序排列的比较函数 function compare(a,b){return a-b}\n\n降序排列的比较函数 function compare(a,b){return b-a}\n</code></pre></li>\n</ul>\n<p><strong>reverse()</strong>方法，反转数组项的顺序</p>\n<p><strong>b. 数组的迭代方法</strong></p>\n<p>这里只记录用到<strong>filter()方法</strong>和<strong>map()方法</strong></p>\n<ul>\n<li>filter是满足条件的留下，是对原数组的过滤；</li>\n<li>map则是对原数组的加工，映射成一一映射的新数组</li>\n</ul>\n<p><strong>filter()</strong> 顾名思义，可以理解成用某种条件来过滤数组的方法，用某种条件来选出符合该条件的项，并组成一个新的数组。</p>\n<p>eg:</p>\n<pre><code>var numbers = [1,2,3,4,5,6,7];\n\nvar filterResult = numbers.filter(function(item,index,array){\n    return (item &gt; 2);//返回数组中大于2的项\n\n});\n</code></pre><p><strong>map()</strong> 映射，新数组中的每一项都是由原数组的对应项经过某种操作得来的</p>\n<p>eg:</p>\n<pre><code>var numbers = [1,2,3,4,5];\n\nvar mapResult = numbers.map(function(item,index,array){\n    return item * 2;\n});\n</code></pre>"},{"layout":"post","title":"用css实现tab页的切换","date":"2016-04-03T16:00:00.000Z","description":null,"_content":"\n由于在百度前端学院的第一阶段的第9个任务中有涉及到用纯css实现tab页的切换，于是就研究了一下这个。\n\n### 一.  css实现tab页的基本思想\n\ntab页也就是标签页，点击一个标签选择一个页面，基本思想就是，点击标签，让对应的页面显示（display:block;）\n\n由于不能使用javascript，这里就要借助html里面一个特殊的标签`<input type=\"radio\" />`，也就是单选框，每一个tab按钮对应一个单选框，如果单选框的状态是checked，那么就让对应的div显示。\n\n这里还有一个小技巧，就是利用label标签的for属性，点击label，就可以选中input框。\n\n    <label for=\"myinput\"></label>\n    <input id=\"myinput\" type=\"radio\" />\n\n### 二. 用CSS实现tab页的代码\n\n\t<ul class=\"tabs\">\n        <li>\n          <input type=\"radio\" name=\"tabs\" id=\"tab1\" checked />\n          <label for=\"tab1\">选项卡 1</label>\n          <div id=\"tab-content1\" class=\"tab-content\">\n            <p>选项卡内容 1</p>\n          </div>\n        </li>\n\n        <li>\n          <input type=\"radio\" name=\"tabs\" id=\"tab2\" />\n          <label for=\"tab2\">选项卡 2</label>\n          <div id=\"tab-content2\" class=\"tab-content\">\n            <p>选项卡内容 2</p>\n          </div>\n        </li>\n      </ul>\n\n**css代码**\n\n    .tabs {\n      width: 650px;\n      float: none;\n      list-style: none;\n      position: relative;\n      margin: 80px 0 0 10px;\n      text-align: left;\n    }\n    .tabs li {\n      float: left;\n      display: block;\n    }\n    .tabs input[type=\"radio\"] {\n      position: absolute;\n      top: -9999px;\n      left: -9999px; /*这一段代码主要是为了隐藏掉input单选框 */\n    }\n    .tabs label {\n      display: block;\n      padding: 14px 21px;\n      border-radius: 2px 2px 0 0;\n      font-size: 20px;\n      font-weight: normal;\n      text-transform: uppercase;\n      background: #8e44ad;\n      cursor: pointer; /*指定光标移上的形状*/\n      position: relative;\n      top: 4px;\n      -webkit-transition: all 0.2s ease-in-out;\n      -moz-transition: all 0.2s ease-in-out;\n      -o-transition: all 0.2s ease-in-out;\n      transition: all 0.2s ease-in-out;\n    }\n    .tabs label:hover {\n      background: #703688;\n    }\n    .tabs .tab-content {\n      z-index: 2;\n      display: none;\n      overflow: hidden;/**/\n      width: 100%;\n      font-size: 17px;\n      line-height: 25px;\n      padding: 25px;\n      position: absolute;\n      top: 53px;\n      left: 0;\n      background: #612e76;\n    }\n    .tabs [id^=\"tab\"]:checked + label {\n      top: 0;\n      padding-top: 17px;\n      background: #612e76;/*.tab的子孙元素里，id里面含有\"tab\"的元素，如果状态是checked，那么input相邻的label元素的样式发生变化*/\n    }\n    .tabs [id^=\"tab\"]:checked ~ [id^=\"tab-content\"] {\n      display: block;/*.tab的子孙元素里，id里面含有\"tab\"的元素，如果状态是checked，那么input相邻的元素，如果id里面包含\"tab-content\",那么就显示为block*/\n    }\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-04-04-用CSS实现tab页的切换.md","raw":"---\nlayout: post\ntitle: 用css实现tab页的切换\ndate: 2016-04-04\ncategories: 前端笔记\ntags: [css]\ndescription: \n---\n\n由于在百度前端学院的第一阶段的第9个任务中有涉及到用纯css实现tab页的切换，于是就研究了一下这个。\n\n### 一.  css实现tab页的基本思想\n\ntab页也就是标签页，点击一个标签选择一个页面，基本思想就是，点击标签，让对应的页面显示（display:block;）\n\n由于不能使用javascript，这里就要借助html里面一个特殊的标签`<input type=\"radio\" />`，也就是单选框，每一个tab按钮对应一个单选框，如果单选框的状态是checked，那么就让对应的div显示。\n\n这里还有一个小技巧，就是利用label标签的for属性，点击label，就可以选中input框。\n\n    <label for=\"myinput\"></label>\n    <input id=\"myinput\" type=\"radio\" />\n\n### 二. 用CSS实现tab页的代码\n\n\t<ul class=\"tabs\">\n        <li>\n          <input type=\"radio\" name=\"tabs\" id=\"tab1\" checked />\n          <label for=\"tab1\">选项卡 1</label>\n          <div id=\"tab-content1\" class=\"tab-content\">\n            <p>选项卡内容 1</p>\n          </div>\n        </li>\n\n        <li>\n          <input type=\"radio\" name=\"tabs\" id=\"tab2\" />\n          <label for=\"tab2\">选项卡 2</label>\n          <div id=\"tab-content2\" class=\"tab-content\">\n            <p>选项卡内容 2</p>\n          </div>\n        </li>\n      </ul>\n\n**css代码**\n\n    .tabs {\n      width: 650px;\n      float: none;\n      list-style: none;\n      position: relative;\n      margin: 80px 0 0 10px;\n      text-align: left;\n    }\n    .tabs li {\n      float: left;\n      display: block;\n    }\n    .tabs input[type=\"radio\"] {\n      position: absolute;\n      top: -9999px;\n      left: -9999px; /*这一段代码主要是为了隐藏掉input单选框 */\n    }\n    .tabs label {\n      display: block;\n      padding: 14px 21px;\n      border-radius: 2px 2px 0 0;\n      font-size: 20px;\n      font-weight: normal;\n      text-transform: uppercase;\n      background: #8e44ad;\n      cursor: pointer; /*指定光标移上的形状*/\n      position: relative;\n      top: 4px;\n      -webkit-transition: all 0.2s ease-in-out;\n      -moz-transition: all 0.2s ease-in-out;\n      -o-transition: all 0.2s ease-in-out;\n      transition: all 0.2s ease-in-out;\n    }\n    .tabs label:hover {\n      background: #703688;\n    }\n    .tabs .tab-content {\n      z-index: 2;\n      display: none;\n      overflow: hidden;/**/\n      width: 100%;\n      font-size: 17px;\n      line-height: 25px;\n      padding: 25px;\n      position: absolute;\n      top: 53px;\n      left: 0;\n      background: #612e76;\n    }\n    .tabs [id^=\"tab\"]:checked + label {\n      top: 0;\n      padding-top: 17px;\n      background: #612e76;/*.tab的子孙元素里，id里面含有\"tab\"的元素，如果状态是checked，那么input相邻的label元素的样式发生变化*/\n    }\n    .tabs [id^=\"tab\"]:checked ~ [id^=\"tab-content\"] {\n      display: block;/*.tab的子孙元素里，id里面含有\"tab\"的元素，如果状态是checked，那么input相邻的元素，如果id里面包含\"tab-content\",那么就显示为block*/\n    }\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-04-04-用CSS实现tab页的切换","published":1,"updated":"2016-07-03T13:51:26.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocdy002nd5u8wt1ght16","content":"<p>由于在百度前端学院的第一阶段的第9个任务中有涉及到用纯css实现tab页的切换，于是就研究了一下这个。</p>\n<h3 id=\"一-css实现tab页的基本思想\"><a href=\"#一-css实现tab页的基本思想\" class=\"headerlink\" title=\"一.  css实现tab页的基本思想\"></a>一.  css实现tab页的基本思想</h3><p>tab页也就是标签页，点击一个标签选择一个页面，基本思想就是，点击标签，让对应的页面显示（display:block;）</p>\n<p>由于不能使用javascript，这里就要借助html里面一个特殊的标签<code>&lt;input type=&quot;radio&quot; /&gt;</code>，也就是单选框，每一个tab按钮对应一个单选框，如果单选框的状态是checked，那么就让对应的div显示。</p>\n<p>这里还有一个小技巧，就是利用label标签的for属性，点击label，就可以选中input框。</p>\n<pre><code>&lt;label for=&quot;myinput&quot;&gt;&lt;/label&gt;\n&lt;input id=&quot;myinput&quot; type=&quot;radio&quot; /&gt;\n</code></pre><h3 id=\"二-用CSS实现tab页的代码\"><a href=\"#二-用CSS实现tab页的代码\" class=\"headerlink\" title=\"二. 用CSS实现tab页的代码\"></a>二. 用CSS实现tab页的代码</h3><pre><code>&lt;ul class=&quot;tabs&quot;&gt;\n    &lt;li&gt;\n      &lt;input type=&quot;radio&quot; name=&quot;tabs&quot; id=&quot;tab1&quot; checked /&gt;\n      &lt;label for=&quot;tab1&quot;&gt;选项卡 1&lt;/label&gt;\n      &lt;div id=&quot;tab-content1&quot; class=&quot;tab-content&quot;&gt;\n        &lt;p&gt;选项卡内容 1&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n\n    &lt;li&gt;\n      &lt;input type=&quot;radio&quot; name=&quot;tabs&quot; id=&quot;tab2&quot; /&gt;\n      &lt;label for=&quot;tab2&quot;&gt;选项卡 2&lt;/label&gt;\n      &lt;div id=&quot;tab-content2&quot; class=&quot;tab-content&quot;&gt;\n        &lt;p&gt;选项卡内容 2&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n</code></pre><p><strong>css代码</strong></p>\n<pre><code>.tabs {\n  width: 650px;\n  float: none;\n  list-style: none;\n  position: relative;\n  margin: 80px 0 0 10px;\n  text-align: left;\n}\n.tabs li {\n  float: left;\n  display: block;\n}\n.tabs input[type=&quot;radio&quot;] {\n  position: absolute;\n  top: -9999px;\n  left: -9999px; /*这一段代码主要是为了隐藏掉input单选框 */\n}\n.tabs label {\n  display: block;\n  padding: 14px 21px;\n  border-radius: 2px 2px 0 0;\n  font-size: 20px;\n  font-weight: normal;\n  text-transform: uppercase;\n  background: #8e44ad;\n  cursor: pointer; /*指定光标移上的形状*/\n  position: relative;\n  top: 4px;\n  -webkit-transition: all 0.2s ease-in-out;\n  -moz-transition: all 0.2s ease-in-out;\n  -o-transition: all 0.2s ease-in-out;\n  transition: all 0.2s ease-in-out;\n}\n.tabs label:hover {\n  background: #703688;\n}\n.tabs .tab-content {\n  z-index: 2;\n  display: none;\n  overflow: hidden;/**/\n  width: 100%;\n  font-size: 17px;\n  line-height: 25px;\n  padding: 25px;\n  position: absolute;\n  top: 53px;\n  left: 0;\n  background: #612e76;\n}\n.tabs [id^=&quot;tab&quot;]:checked + label {\n  top: 0;\n  padding-top: 17px;\n  background: #612e76;/*.tab的子孙元素里，id里面含有&quot;tab&quot;的元素，如果状态是checked，那么input相邻的label元素的样式发生变化*/\n}\n.tabs [id^=&quot;tab&quot;]:checked ~ [id^=&quot;tab-content&quot;] {\n  display: block;/*.tab的子孙元素里，id里面含有&quot;tab&quot;的元素，如果状态是checked，那么input相邻的元素，如果id里面包含&quot;tab-content&quot;,那么就显示为block*/\n}\n</code></pre>","excerpt":"","more":"<p>由于在百度前端学院的第一阶段的第9个任务中有涉及到用纯css实现tab页的切换，于是就研究了一下这个。</p>\n<h3 id=\"一-css实现tab页的基本思想\"><a href=\"#一-css实现tab页的基本思想\" class=\"headerlink\" title=\"一.  css实现tab页的基本思想\"></a>一.  css实现tab页的基本思想</h3><p>tab页也就是标签页，点击一个标签选择一个页面，基本思想就是，点击标签，让对应的页面显示（display:block;）</p>\n<p>由于不能使用javascript，这里就要借助html里面一个特殊的标签<code>&lt;input type=&quot;radio&quot; /&gt;</code>，也就是单选框，每一个tab按钮对应一个单选框，如果单选框的状态是checked，那么就让对应的div显示。</p>\n<p>这里还有一个小技巧，就是利用label标签的for属性，点击label，就可以选中input框。</p>\n<pre><code>&lt;label for=&quot;myinput&quot;&gt;&lt;/label&gt;\n&lt;input id=&quot;myinput&quot; type=&quot;radio&quot; /&gt;\n</code></pre><h3 id=\"二-用CSS实现tab页的代码\"><a href=\"#二-用CSS实现tab页的代码\" class=\"headerlink\" title=\"二. 用CSS实现tab页的代码\"></a>二. 用CSS实现tab页的代码</h3><pre><code>&lt;ul class=&quot;tabs&quot;&gt;\n    &lt;li&gt;\n      &lt;input type=&quot;radio&quot; name=&quot;tabs&quot; id=&quot;tab1&quot; checked /&gt;\n      &lt;label for=&quot;tab1&quot;&gt;选项卡 1&lt;/label&gt;\n      &lt;div id=&quot;tab-content1&quot; class=&quot;tab-content&quot;&gt;\n        &lt;p&gt;选项卡内容 1&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n\n    &lt;li&gt;\n      &lt;input type=&quot;radio&quot; name=&quot;tabs&quot; id=&quot;tab2&quot; /&gt;\n      &lt;label for=&quot;tab2&quot;&gt;选项卡 2&lt;/label&gt;\n      &lt;div id=&quot;tab-content2&quot; class=&quot;tab-content&quot;&gt;\n        &lt;p&gt;选项卡内容 2&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n</code></pre><p><strong>css代码</strong></p>\n<pre><code>.tabs {\n  width: 650px;\n  float: none;\n  list-style: none;\n  position: relative;\n  margin: 80px 0 0 10px;\n  text-align: left;\n}\n.tabs li {\n  float: left;\n  display: block;\n}\n.tabs input[type=&quot;radio&quot;] {\n  position: absolute;\n  top: -9999px;\n  left: -9999px; /*这一段代码主要是为了隐藏掉input单选框 */\n}\n.tabs label {\n  display: block;\n  padding: 14px 21px;\n  border-radius: 2px 2px 0 0;\n  font-size: 20px;\n  font-weight: normal;\n  text-transform: uppercase;\n  background: #8e44ad;\n  cursor: pointer; /*指定光标移上的形状*/\n  position: relative;\n  top: 4px;\n  -webkit-transition: all 0.2s ease-in-out;\n  -moz-transition: all 0.2s ease-in-out;\n  -o-transition: all 0.2s ease-in-out;\n  transition: all 0.2s ease-in-out;\n}\n.tabs label:hover {\n  background: #703688;\n}\n.tabs .tab-content {\n  z-index: 2;\n  display: none;\n  overflow: hidden;/**/\n  width: 100%;\n  font-size: 17px;\n  line-height: 25px;\n  padding: 25px;\n  position: absolute;\n  top: 53px;\n  left: 0;\n  background: #612e76;\n}\n.tabs [id^=&quot;tab&quot;]:checked + label {\n  top: 0;\n  padding-top: 17px;\n  background: #612e76;/*.tab的子孙元素里，id里面含有&quot;tab&quot;的元素，如果状态是checked，那么input相邻的label元素的样式发生变化*/\n}\n.tabs [id^=&quot;tab&quot;]:checked ~ [id^=&quot;tab-content&quot;] {\n  display: block;/*.tab的子孙元素里，id里面含有&quot;tab&quot;的元素，如果状态是checked，那么input相邻的元素，如果id里面包含&quot;tab-content&quot;,那么就显示为block*/\n}\n</code></pre>"},{"layout":"post","title":"浏览器事件模型","date":"2016-04-04T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是事件模型\n\n#### 1. 事件\n\n事件是**用户对浏览器的一个动作**或者**浏览器自身执行的某种动作**，文档或浏览器窗口发生特定交互的瞬间。\n\n#### 2. 事件流\n\n事件流：从页面中接收事件的顺序。\n\nIE和Netscape提出了两种相反的事件流：事件冒泡流、事件捕获流。\n\n**事件冒泡流：由具体的节点逐级往上传播**\n```\n    <!DOCTYPE HTML>\n    <html>\n    \t<head>\n    \t</head>\n    \t<body>\n    \t\t<div>click me</div>\n    \t</body>\n    </html>\n```\n如果单击了div，那么click事件的传播为：` div -> body -> html -> Document -> windows`\n\n**事件捕获流：由最上层的节点逐级往下传到具体节点**\n```\n    <!DOCTYPE HTML>\n    <html>\n    \t<head>\n    \t</head>\n    \t<body>\n    \t\t<div>click me</div>\n    \t</body>\n    </html>\n```\n如果单击了div，那么click事件的传播为：`windows -> Document -> html -> body -> div`\n```\n    插播一个windows对象和Document对象的区别：\n    \n    windows对象：指的是浏览器的窗口\n    \n    Document对象：指的是显示于窗口的一个文档\n    \n    Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问\n```\n\n#### 3. DOM2级事件规定的事件流\n\nW3C为了兼顾之前的标准，将事件发生定义成三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段\n\n事件捕获阶段：`windows -> Document -> html -> body`\n\n事件捕获阶段，事件到`<body>`就停止了\n\n处于目标阶段：事件在<div>上发生\n\n事件冒泡阶段：`body -> html -> Document -> windows`\n\nDOM2级事件明确要求捕获阶段不会涉及到事件目标，但是很多高版本的浏览器都会在捕获阶段触发事件对象上的事件。\n\n### 二. W3C和IE绑定事件\n\n一般绑定事件可以用\n\n    obj.onclick = function(){}；\n\n但如果要给同一个元素绑定多个事件，上面那种方法就行不通了\n```\n    obj.onclick = function(){\n    \t\t\talert(\"1\");\n    \t\t}\n    \n    obj.onclick = function(){\n    \t\t\talert(\"2\");\n    \t\t}\n    \n    obj.onclick = function(){\n    \t\t\talert(\"3\");\n    \t\t}\n    \n\t只会alert(\"3\")\n```\n可以采用下面的绑定事件的方式：\n\n#### 1. W3C\n\n    W3C绑定事件 \n    \n    obj.addEventListener(event,function,usecapture)\n    \n    W3C解绑事件\n    \n    obj.removeEventListener(event,function,usecapture)\n\n\tusecapture可选值有\n    false:事件在冒泡阶段执行（默认）\n    true：事件在捕获阶段执行\n\n下面是一个冒泡阶段和捕获阶段执行事件的例子\n```\n    <!DOCTYPE html>\n    <html>\n\t    <head>\n\t\t    <style>\n\t\t\t    div {\n\t\t\t\t    background-color: coral;\n\t\t\t\t    border: 1px solid;\n\t\t\t\t    padding: 50px;\n\t\t\t    }\n\t\t    </style>\n\t    </head>\n\t    <body>\n\t    \n\t\t    <p>该实例演示了在添加事件监听时冒泡与捕获阶段的不同。</p>\n\t\t    \n\t\t    <div id=\"myDiv\">\n\t\t      <p id=\"myP\">点击该段落， 我是冒泡</p>\n\t\t    </div><br>\n\t\t    \n\t\t    <div id=\"myDiv2\">\n\t\t      <p id=\"myP2\">点击该段落， 我是捕获</p>\n\t\t    </div>\n\t\t    \n\t\t    <script>\n\t\t\t    document.getElementById(\"myP\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 P 元素!\");\n\t\t\t    }, false);\n\t\t\t    \n\t\t\t    document.getElementById(\"myDiv\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 DIV 元素!\");\n\t\t\t    }, false);\n\t\t\t    \n\t\t\t    document.getElementById(\"myP2\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 P 元素!\");\n\t\t\t    }, true);\n\t\t\t    \n\t\t\t    document.getElementById(\"myDiv2\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 DIV 元素!\");\n\t\t\t    }, true);\n\t    \t</script>\n\t    \n\t    </body>\n    </html>\n```\n\n如果用addEventListener给同一个对象绑定了多个事件，执行顺序如下：\n```\n    obj.addEventListener(\"click\",function1,false)\n    obj.addEventListener(\"click\",function2,false)\n    obj.addEventListener(\"click\",function3,false)\n\n    function1->function2->function3\n```\n\n#### 2. IE中绑定事件  事件冒泡流\n\n    IE中绑定事件\n    obj.attachEvent(event,function)\n    IE中解绑事件\n    obj.detachEvent(event,function)\n\n如果用attachEvent给同一个对象绑定了多个事件，执行顺序如下：\n\n    obj.attachEvent(\"onclick\",function1)\n    obj.attachEvent(\"onclick\",function2)\n    obj.attachEvent(\"onclick\",function3)\n\n    IE11下：function1->function2->function3\n\tIE8下：function3->function2->function1 颠倒顺序执行\n\n#### 3. W3C和IE中绑定事件的不同点\n\n(1) 参数不同，W3C可以控制事件是在捕获阶段还是在冒泡阶段执行\n\n(2) 绑定事件的名称不同：\n\n    W3C没有on  eg:click\n    IE 有on    eg:onclick\n\n(3) 绑定多个事件的执行顺序\n\n    W3C按顺序执行\n    \n    IE8中是倒序执行，高一点的版本貌似是按顺序执行\n\n<font color=\"red\">注意：新版本的ie在绑定事件上有所修改</font>\n\n经过测试：\n\n    ie10（不包括ie10）以上就只支持addEventListener绑定事件了\n    ie9,ie10支持addeventListener和attachEvent\n    ie8及其以下都只支持attachEvent\n\n### 三. 事件对象\n\n**DOM中的事件对象**和**IE中的事件对象**也不同。\n\n#### 1. DOM中的事件对象\n\n触发某个事件时，会产生一个事件对象event。\n\n**不管绑定事件处理程序的方式是什么**，浏览器会将这个事件对象传入事件处理程序中，作为第一个参数\n\nevent\n\n    event.currentTarget：绑定事件的元素\n    在事件处理程序内部：this永远等于event.currentTarget\n    \n    event.target：触发事件的元素(事件的实际目标)\n    \n    event.type：事件类型\n\n\tevent.stopPropagation();\n\t取消事件进一步捕获或冒泡\t\n\n**什么是事件冒泡：**\n\neg:\n\n\t<body>\n\t\t<input id=\"btn\" type=\"submit\" />\n\t</body>\n\n\t//给按钮绑定一个点击事件\n\tbtn.addEventListener(\"click\",function(event){\n\t\t\t\t\t\talert(\"1\")});\n\t//给其父元素绑定一个点击事件\n\tdocument.body.addEventListener(\"click\",function(event){\n\t\t\t\t\t\talert(\"2\")});\n\n\t当我们点击按钮时，会触发两个点击事件，因为按钮的点击事件冒泡到其父元素上了。\n\n**使用event.stopPropagation()阻止冒泡**\n\n\t//给按钮绑定一个点击事件\n    btn.addEventListener(\"click\",function(event){\n                        alert(\"1\");\n                        event.stopPropagation();\n                    });\n    //给其父元素绑定一个点击事件\n    document.body.addEventListener(\"click\",function(event){\n                        alert(\"2\")});\n\n#### 2. IE中的事件对象\n\n**访问ie中事件对象event的三种不同方式：**\n\n(1) 使用.onclick方式绑定时\n\n通过window.event的方式访问\n\n(2) 使用attachEvent的方式绑定时\n\n通过传入event参数访问\n\n也可以通过windoe.event来访问\n\n(3) 在html里面绑定时\n\n直接通过一个event的变量访问\n\n```\n\teg:\n\n\t<input type=\"submit\" onClick=\"alert(event.type)\">\n```\n\nie中的event对象有srcElement属性，但没有target属性\n\nevent.srcElement = event.target\n\n#### 3. 兼容写法\n\nie中事件是全局变量window.event可以随时拿到 ，其它浏览器必须在参数中传递才能获取事件\n\n    var event = event || window.event;\n\n\tobj = event.srcElement ? event.srcElement : event.target;\n\t\n### 四. 事件委托代理机制\n\n#### 1. 事件委托代理机制运用的场景\n\n```\n    <ul class=\"data-list\">\n\t     <li>1</li>\n\t     <li>2</li>\n\t     <li>3</li>\n    </ul>\n\t<div class=\"data-show\"></div>\n```\n\n点击每一个li执行一个事件，让数字显示在div里\n\n思路：若给列表的每一项分别绑定点击事件，这样做的弊端在于，增加了内存，因为$(’#data-list li’)里有100个li对象。同时降低了代码性能，因为$(’#data-list li’)会搜索ul#data-list下所有的li元素\n\n这时，可以使用**事件委托代理机制**\n\n思路：将li的点击事件委托给其父元素ul，当内层元素的某个事件被触发，事件会一级一级地冒泡到外层元素。给父元素绑定事件，当被触发时，判断当前触发事件的对象是否是目标元素li，如果是，则执行回调函数。\n\nevent.target 当前触发事件的对象，即用户真正单击到的对象\nevent.currentTarget 当前绑定事件的对象 UL.data-list\n\n\n<font color=\"red\">**手写原生js实现事件代理，并要求兼容浏览器**</font>\n\n考察对事件对象e的了解程度，以及在IE下对应的属性名\n\n```\n    // ============ 简单的事件委托\n    function delegateEvent(mydiv, childName, type, fn) {\n\t\t//这四个参分别指的是\n\t\t//mydiv——>绑定事件的父元素（事件委托者）\n\t\t//childName——>实际执行事件的元素\n\t\t//type——>绑定事件的类型\n\t\t//fn——>事件处理程序\n\n\t\t//给父元素绑定事件，注意兼容性\n\t    if(mydiv.addEventListener){\n\t    \tmydiv.addEventListener(type, eventfn);\n\t    }else if(mydiv.attachEvent){\n\t    \tmydiv.attachEvent(\"on\"+type, eventfn);\n\t    }else {\n\t    \tmydiv['on'+type] = eventfn\n\t    }\n\t    \n\t\t//事件处理程序\n\t    function eventfn(event){\n\t\t    var event = event || window.event;\n\t\t    var target = event.target || event.srcElement;\n\t\t    if (matchSelector(target, childName)) {\n\t\t\t    if(fn) {\n\t\t\t    \tfn.call(target, event);\n\t\t\t    }\n\t\t    }\n\t\t }\n\t  }\n\t    /**\n\t     * only support #id\n\t     */\n\t\n\t//这个函数主要是判断当前事件源是否与我们想绑定事件的元素相同\n\tfunction matchSelector(target, childName) {\n\t    //如果通过id名指定\n\t    if (childName.charAt(0) === \"#\") {\n\t    \treturn target.id === childName.slice(1);\n\t    }\n    }\n\n    //调用\n    var mydiv = document.getElementById(\"myDiv\");\n    delegateEvent(mydiv,\"a\",\"click\",function(){\n    \talert(\"1\");\n    })\n```\n\n### 五. 不支持冒泡的事件\n\n- focus\n- blur\n- mouseenter\n- mouseleave\n\nfocus和blur如何实现事件代理：\n\n由于事件代理是基于事件的冒泡机制，但是focus和blur不支持冒泡。\n\n在IE中可以使用**focusein**和**focusout**来实现\n\t\n在非IE浏览器中可以在**捕获阶段**绑定事件\n\n.addEventListener(\"click\",function(event){},true);\n\n\t\n### 六. js中如何自定义事件\n```\n   //创建一个事件\n var event = document.createEvent('Event');\n\n //初始化创建的事件event.initEvent(type, bubbles, cancelable);\n\n event.initEvent('build', true, true);\n \n //自定义的事件与click事件不一样，需要在程序中分发，类似于订阅发布模式\n elem.dispatchEvent(event);\n```\n\n\n","source":"_posts/2016-04-05-浏览器事件模型.md","raw":"---\nlayout: post\ntitle: 浏览器事件模型\ndate: 2016-04-05\ncategories: javaScript\ntags: [javaScript,事件]\ndescription: \n---\n\n### 一. 什么是事件模型\n\n#### 1. 事件\n\n事件是**用户对浏览器的一个动作**或者**浏览器自身执行的某种动作**，文档或浏览器窗口发生特定交互的瞬间。\n\n#### 2. 事件流\n\n事件流：从页面中接收事件的顺序。\n\nIE和Netscape提出了两种相反的事件流：事件冒泡流、事件捕获流。\n\n**事件冒泡流：由具体的节点逐级往上传播**\n```\n    <!DOCTYPE HTML>\n    <html>\n    \t<head>\n    \t</head>\n    \t<body>\n    \t\t<div>click me</div>\n    \t</body>\n    </html>\n```\n如果单击了div，那么click事件的传播为：` div -> body -> html -> Document -> windows`\n\n**事件捕获流：由最上层的节点逐级往下传到具体节点**\n```\n    <!DOCTYPE HTML>\n    <html>\n    \t<head>\n    \t</head>\n    \t<body>\n    \t\t<div>click me</div>\n    \t</body>\n    </html>\n```\n如果单击了div，那么click事件的传播为：`windows -> Document -> html -> body -> div`\n```\n    插播一个windows对象和Document对象的区别：\n    \n    windows对象：指的是浏览器的窗口\n    \n    Document对象：指的是显示于窗口的一个文档\n    \n    Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问\n```\n\n#### 3. DOM2级事件规定的事件流\n\nW3C为了兼顾之前的标准，将事件发生定义成三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段\n\n事件捕获阶段：`windows -> Document -> html -> body`\n\n事件捕获阶段，事件到`<body>`就停止了\n\n处于目标阶段：事件在<div>上发生\n\n事件冒泡阶段：`body -> html -> Document -> windows`\n\nDOM2级事件明确要求捕获阶段不会涉及到事件目标，但是很多高版本的浏览器都会在捕获阶段触发事件对象上的事件。\n\n### 二. W3C和IE绑定事件\n\n一般绑定事件可以用\n\n    obj.onclick = function(){}；\n\n但如果要给同一个元素绑定多个事件，上面那种方法就行不通了\n```\n    obj.onclick = function(){\n    \t\t\talert(\"1\");\n    \t\t}\n    \n    obj.onclick = function(){\n    \t\t\talert(\"2\");\n    \t\t}\n    \n    obj.onclick = function(){\n    \t\t\talert(\"3\");\n    \t\t}\n    \n\t只会alert(\"3\")\n```\n可以采用下面的绑定事件的方式：\n\n#### 1. W3C\n\n    W3C绑定事件 \n    \n    obj.addEventListener(event,function,usecapture)\n    \n    W3C解绑事件\n    \n    obj.removeEventListener(event,function,usecapture)\n\n\tusecapture可选值有\n    false:事件在冒泡阶段执行（默认）\n    true：事件在捕获阶段执行\n\n下面是一个冒泡阶段和捕获阶段执行事件的例子\n```\n    <!DOCTYPE html>\n    <html>\n\t    <head>\n\t\t    <style>\n\t\t\t    div {\n\t\t\t\t    background-color: coral;\n\t\t\t\t    border: 1px solid;\n\t\t\t\t    padding: 50px;\n\t\t\t    }\n\t\t    </style>\n\t    </head>\n\t    <body>\n\t    \n\t\t    <p>该实例演示了在添加事件监听时冒泡与捕获阶段的不同。</p>\n\t\t    \n\t\t    <div id=\"myDiv\">\n\t\t      <p id=\"myP\">点击该段落， 我是冒泡</p>\n\t\t    </div><br>\n\t\t    \n\t\t    <div id=\"myDiv2\">\n\t\t      <p id=\"myP2\">点击该段落， 我是捕获</p>\n\t\t    </div>\n\t\t    \n\t\t    <script>\n\t\t\t    document.getElementById(\"myP\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 P 元素!\");\n\t\t\t    }, false);\n\t\t\t    \n\t\t\t    document.getElementById(\"myDiv\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 DIV 元素!\");\n\t\t\t    }, false);\n\t\t\t    \n\t\t\t    document.getElementById(\"myP2\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 P 元素!\");\n\t\t\t    }, true);\n\t\t\t    \n\t\t\t    document.getElementById(\"myDiv2\").addEventListener(\"click\", function() {\n\t\t\t    alert(\"你点击了 DIV 元素!\");\n\t\t\t    }, true);\n\t    \t</script>\n\t    \n\t    </body>\n    </html>\n```\n\n如果用addEventListener给同一个对象绑定了多个事件，执行顺序如下：\n```\n    obj.addEventListener(\"click\",function1,false)\n    obj.addEventListener(\"click\",function2,false)\n    obj.addEventListener(\"click\",function3,false)\n\n    function1->function2->function3\n```\n\n#### 2. IE中绑定事件  事件冒泡流\n\n    IE中绑定事件\n    obj.attachEvent(event,function)\n    IE中解绑事件\n    obj.detachEvent(event,function)\n\n如果用attachEvent给同一个对象绑定了多个事件，执行顺序如下：\n\n    obj.attachEvent(\"onclick\",function1)\n    obj.attachEvent(\"onclick\",function2)\n    obj.attachEvent(\"onclick\",function3)\n\n    IE11下：function1->function2->function3\n\tIE8下：function3->function2->function1 颠倒顺序执行\n\n#### 3. W3C和IE中绑定事件的不同点\n\n(1) 参数不同，W3C可以控制事件是在捕获阶段还是在冒泡阶段执行\n\n(2) 绑定事件的名称不同：\n\n    W3C没有on  eg:click\n    IE 有on    eg:onclick\n\n(3) 绑定多个事件的执行顺序\n\n    W3C按顺序执行\n    \n    IE8中是倒序执行，高一点的版本貌似是按顺序执行\n\n<font color=\"red\">注意：新版本的ie在绑定事件上有所修改</font>\n\n经过测试：\n\n    ie10（不包括ie10）以上就只支持addEventListener绑定事件了\n    ie9,ie10支持addeventListener和attachEvent\n    ie8及其以下都只支持attachEvent\n\n### 三. 事件对象\n\n**DOM中的事件对象**和**IE中的事件对象**也不同。\n\n#### 1. DOM中的事件对象\n\n触发某个事件时，会产生一个事件对象event。\n\n**不管绑定事件处理程序的方式是什么**，浏览器会将这个事件对象传入事件处理程序中，作为第一个参数\n\nevent\n\n    event.currentTarget：绑定事件的元素\n    在事件处理程序内部：this永远等于event.currentTarget\n    \n    event.target：触发事件的元素(事件的实际目标)\n    \n    event.type：事件类型\n\n\tevent.stopPropagation();\n\t取消事件进一步捕获或冒泡\t\n\n**什么是事件冒泡：**\n\neg:\n\n\t<body>\n\t\t<input id=\"btn\" type=\"submit\" />\n\t</body>\n\n\t//给按钮绑定一个点击事件\n\tbtn.addEventListener(\"click\",function(event){\n\t\t\t\t\t\talert(\"1\")});\n\t//给其父元素绑定一个点击事件\n\tdocument.body.addEventListener(\"click\",function(event){\n\t\t\t\t\t\talert(\"2\")});\n\n\t当我们点击按钮时，会触发两个点击事件，因为按钮的点击事件冒泡到其父元素上了。\n\n**使用event.stopPropagation()阻止冒泡**\n\n\t//给按钮绑定一个点击事件\n    btn.addEventListener(\"click\",function(event){\n                        alert(\"1\");\n                        event.stopPropagation();\n                    });\n    //给其父元素绑定一个点击事件\n    document.body.addEventListener(\"click\",function(event){\n                        alert(\"2\")});\n\n#### 2. IE中的事件对象\n\n**访问ie中事件对象event的三种不同方式：**\n\n(1) 使用.onclick方式绑定时\n\n通过window.event的方式访问\n\n(2) 使用attachEvent的方式绑定时\n\n通过传入event参数访问\n\n也可以通过windoe.event来访问\n\n(3) 在html里面绑定时\n\n直接通过一个event的变量访问\n\n```\n\teg:\n\n\t<input type=\"submit\" onClick=\"alert(event.type)\">\n```\n\nie中的event对象有srcElement属性，但没有target属性\n\nevent.srcElement = event.target\n\n#### 3. 兼容写法\n\nie中事件是全局变量window.event可以随时拿到 ，其它浏览器必须在参数中传递才能获取事件\n\n    var event = event || window.event;\n\n\tobj = event.srcElement ? event.srcElement : event.target;\n\t\n### 四. 事件委托代理机制\n\n#### 1. 事件委托代理机制运用的场景\n\n```\n    <ul class=\"data-list\">\n\t     <li>1</li>\n\t     <li>2</li>\n\t     <li>3</li>\n    </ul>\n\t<div class=\"data-show\"></div>\n```\n\n点击每一个li执行一个事件，让数字显示在div里\n\n思路：若给列表的每一项分别绑定点击事件，这样做的弊端在于，增加了内存，因为$(’#data-list li’)里有100个li对象。同时降低了代码性能，因为$(’#data-list li’)会搜索ul#data-list下所有的li元素\n\n这时，可以使用**事件委托代理机制**\n\n思路：将li的点击事件委托给其父元素ul，当内层元素的某个事件被触发，事件会一级一级地冒泡到外层元素。给父元素绑定事件，当被触发时，判断当前触发事件的对象是否是目标元素li，如果是，则执行回调函数。\n\nevent.target 当前触发事件的对象，即用户真正单击到的对象\nevent.currentTarget 当前绑定事件的对象 UL.data-list\n\n\n<font color=\"red\">**手写原生js实现事件代理，并要求兼容浏览器**</font>\n\n考察对事件对象e的了解程度，以及在IE下对应的属性名\n\n```\n    // ============ 简单的事件委托\n    function delegateEvent(mydiv, childName, type, fn) {\n\t\t//这四个参分别指的是\n\t\t//mydiv——>绑定事件的父元素（事件委托者）\n\t\t//childName——>实际执行事件的元素\n\t\t//type——>绑定事件的类型\n\t\t//fn——>事件处理程序\n\n\t\t//给父元素绑定事件，注意兼容性\n\t    if(mydiv.addEventListener){\n\t    \tmydiv.addEventListener(type, eventfn);\n\t    }else if(mydiv.attachEvent){\n\t    \tmydiv.attachEvent(\"on\"+type, eventfn);\n\t    }else {\n\t    \tmydiv['on'+type] = eventfn\n\t    }\n\t    \n\t\t//事件处理程序\n\t    function eventfn(event){\n\t\t    var event = event || window.event;\n\t\t    var target = event.target || event.srcElement;\n\t\t    if (matchSelector(target, childName)) {\n\t\t\t    if(fn) {\n\t\t\t    \tfn.call(target, event);\n\t\t\t    }\n\t\t    }\n\t\t }\n\t  }\n\t    /**\n\t     * only support #id\n\t     */\n\t\n\t//这个函数主要是判断当前事件源是否与我们想绑定事件的元素相同\n\tfunction matchSelector(target, childName) {\n\t    //如果通过id名指定\n\t    if (childName.charAt(0) === \"#\") {\n\t    \treturn target.id === childName.slice(1);\n\t    }\n    }\n\n    //调用\n    var mydiv = document.getElementById(\"myDiv\");\n    delegateEvent(mydiv,\"a\",\"click\",function(){\n    \talert(\"1\");\n    })\n```\n\n### 五. 不支持冒泡的事件\n\n- focus\n- blur\n- mouseenter\n- mouseleave\n\nfocus和blur如何实现事件代理：\n\n由于事件代理是基于事件的冒泡机制，但是focus和blur不支持冒泡。\n\n在IE中可以使用**focusein**和**focusout**来实现\n\t\n在非IE浏览器中可以在**捕获阶段**绑定事件\n\n.addEventListener(\"click\",function(event){},true);\n\n\t\n### 六. js中如何自定义事件\n```\n   //创建一个事件\n var event = document.createEvent('Event');\n\n //初始化创建的事件event.initEvent(type, bubbles, cancelable);\n\n event.initEvent('build', true, true);\n \n //自定义的事件与click事件不一样，需要在程序中分发，类似于订阅发布模式\n elem.dispatchEvent(event);\n```\n\n\n","slug":"2016-04-05-浏览器事件模型","published":1,"updated":"2016-08-19T06:58:54.000Z","comments":1,"photos":[],"link":"","_id":"cj035oce2002qd5u8dqqz6kk6","content":"<h3 id=\"一-什么是事件模型\"><a href=\"#一-什么是事件模型\" class=\"headerlink\" title=\"一. 什么是事件模型\"></a>一. 什么是事件模型</h3><h4 id=\"1-事件\"><a href=\"#1-事件\" class=\"headerlink\" title=\"1. 事件\"></a>1. 事件</h4><p>事件是<strong>用户对浏览器的一个动作</strong>或者<strong>浏览器自身执行的某种动作</strong>，文档或浏览器窗口发生特定交互的瞬间。</p>\n<h4 id=\"2-事件流\"><a href=\"#2-事件流\" class=\"headerlink\" title=\"2. 事件流\"></a>2. 事件流</h4><p>事件流：从页面中接收事件的顺序。</p>\n<p>IE和Netscape提出了两种相反的事件流：事件冒泡流、事件捕获流。</p>\n<p><strong>事件冒泡流：由具体的节点逐级往上传播</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果单击了div，那么click事件的传播为：<code>div -&gt; body -&gt; html -&gt; Document -&gt; windows</code></p>\n<p><strong>事件捕获流：由最上层的节点逐级往下传到具体节点</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果单击了div，那么click事件的传播为：<code>windows -&gt; Document -&gt; html -&gt; body -&gt; div</code><br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插播一个windows对象和Document对象的区别：</span><br><span class=\"line\"></span><br><span class=\"line\">windows对象：指的是浏览器的窗口</span><br><span class=\"line\"></span><br><span class=\"line\">Document对象：指的是显示于窗口的一个文档</span><br><span class=\"line\"></span><br><span class=\"line\">Document 对象是 Window 对象的一部分，可通过 <span class=\"built_in\">window</span>.<span class=\"built_in\">document</span> 属性对其进行访问</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-DOM2级事件规定的事件流\"><a href=\"#3-DOM2级事件规定的事件流\" class=\"headerlink\" title=\"3. DOM2级事件规定的事件流\"></a>3. DOM2级事件规定的事件流</h4><p>W3C为了兼顾之前的标准，将事件发生定义成三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</p>\n<p>事件捕获阶段：<code>windows -&gt; Document -&gt; html -&gt; body</code></p>\n<p>事件捕获阶段，事件到<code>&lt;body&gt;</code>就停止了</p>\n<p>处于目标阶段：事件在<div>上发生</div></p>\n<p>事件冒泡阶段：<code>body -&gt; html -&gt; Document -&gt; windows</code></p>\n<p>DOM2级事件明确要求捕获阶段不会涉及到事件目标，但是很多高版本的浏览器都会在捕获阶段触发事件对象上的事件。</p>\n<h3 id=\"二-W3C和IE绑定事件\"><a href=\"#二-W3C和IE绑定事件\" class=\"headerlink\" title=\"二. W3C和IE绑定事件\"></a>二. W3C和IE绑定事件</h3><p>一般绑定事件可以用</p>\n<pre><code>obj.onclick = function(){}；\n</code></pre><p>但如果要给同一个元素绑定多个事件，上面那种方法就行不通了<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   obj.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \t\t\talert(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">   \t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   obj.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \t\t\talert(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">   \t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   obj.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \t\t\talert(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">   \t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">只会alert(<span class=\"string\">\"3\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可以采用下面的绑定事件的方式：</p>\n<h4 id=\"1-W3C\"><a href=\"#1-W3C\" class=\"headerlink\" title=\"1. W3C\"></a>1. W3C</h4><pre><code>W3C绑定事件 \n\nobj.addEventListener(event,function,usecapture)\n\nW3C解绑事件\n\nobj.removeEventListener(event,function,usecapture)\n\nusecapture可选值有\nfalse:事件在冒泡阶段执行（默认）\ntrue：事件在捕获阶段执行\n</code></pre><p>下面是一个冒泡阶段和捕获阶段执行事件的例子<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span><br><span class=\"line\">   <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>该实例演示了在添加事件监听时冒泡与捕获阶段的不同。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myP\"</span>&gt;</span>点击该段落， 我是冒泡<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv2\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myP2\"</span>&gt;</span>点击该段落， 我是捕获<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myP\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 P 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 DIV 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myP2\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 P 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv2\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 DIV 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\"> \t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果用addEventListener给同一个对象绑定了多个事件，执行顺序如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"keyword\">function</span>1,<span class=\"literal\">false</span>)</span><br><span class=\"line\">obj.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"keyword\">function</span>2,<span class=\"literal\">false</span>)</span><br><span class=\"line\">obj.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"keyword\">function</span>3,<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>1-&gt;<span class=\"keyword\">function</span>2-&gt;<span class=\"keyword\">function</span>3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-IE中绑定事件-事件冒泡流\"><a href=\"#2-IE中绑定事件-事件冒泡流\" class=\"headerlink\" title=\"2. IE中绑定事件  事件冒泡流\"></a>2. IE中绑定事件  事件冒泡流</h4><pre><code>IE中绑定事件\nobj.attachEvent(event,function)\nIE中解绑事件\nobj.detachEvent(event,function)\n</code></pre><p>如果用attachEvent给同一个对象绑定了多个事件，执行顺序如下：</p>\n<pre><code>obj.attachEvent(&quot;onclick&quot;,function1)\nobj.attachEvent(&quot;onclick&quot;,function2)\nobj.attachEvent(&quot;onclick&quot;,function3)\n\nIE11下：function1-&gt;function2-&gt;function3\nIE8下：function3-&gt;function2-&gt;function1 颠倒顺序执行\n</code></pre><h4 id=\"3-W3C和IE中绑定事件的不同点\"><a href=\"#3-W3C和IE中绑定事件的不同点\" class=\"headerlink\" title=\"3. W3C和IE中绑定事件的不同点\"></a>3. W3C和IE中绑定事件的不同点</h4><p>(1) 参数不同，W3C可以控制事件是在捕获阶段还是在冒泡阶段执行</p>\n<p>(2) 绑定事件的名称不同：</p>\n<pre><code>W3C没有on  eg:click\nIE 有on    eg:onclick\n</code></pre><p>(3) 绑定多个事件的执行顺序</p>\n<pre><code>W3C按顺序执行\n\nIE8中是倒序执行，高一点的版本貌似是按顺序执行\n</code></pre><font color=\"red\">注意：新版本的ie在绑定事件上有所修改</font>\n\n<p>经过测试：</p>\n<pre><code>ie10（不包括ie10）以上就只支持addEventListener绑定事件了\nie9,ie10支持addeventListener和attachEvent\nie8及其以下都只支持attachEvent\n</code></pre><h3 id=\"三-事件对象\"><a href=\"#三-事件对象\" class=\"headerlink\" title=\"三. 事件对象\"></a>三. 事件对象</h3><p><strong>DOM中的事件对象</strong>和<strong>IE中的事件对象</strong>也不同。</p>\n<h4 id=\"1-DOM中的事件对象\"><a href=\"#1-DOM中的事件对象\" class=\"headerlink\" title=\"1. DOM中的事件对象\"></a>1. DOM中的事件对象</h4><p>触发某个事件时，会产生一个事件对象event。</p>\n<p><strong>不管绑定事件处理程序的方式是什么</strong>，浏览器会将这个事件对象传入事件处理程序中，作为第一个参数</p>\n<p>event</p>\n<pre><code>event.currentTarget：绑定事件的元素\n在事件处理程序内部：this永远等于event.currentTarget\n\nevent.target：触发事件的元素(事件的实际目标)\n\nevent.type：事件类型\n\nevent.stopPropagation();\n取消事件进一步捕获或冒泡    \n</code></pre><p><strong>什么是事件冒泡：</strong></p>\n<p>eg:</p>\n<pre><code>&lt;body&gt;\n    &lt;input id=&quot;btn&quot; type=&quot;submit&quot; /&gt;\n&lt;/body&gt;\n\n//给按钮绑定一个点击事件\nbtn.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;1&quot;)});\n//给其父元素绑定一个点击事件\ndocument.body.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;2&quot;)});\n\n当我们点击按钮时，会触发两个点击事件，因为按钮的点击事件冒泡到其父元素上了。\n</code></pre><p><strong>使用event.stopPropagation()阻止冒泡</strong></p>\n<pre><code>//给按钮绑定一个点击事件\nbtn.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;1&quot;);\n                    event.stopPropagation();\n                });\n//给其父元素绑定一个点击事件\ndocument.body.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;2&quot;)});\n</code></pre><h4 id=\"2-IE中的事件对象\"><a href=\"#2-IE中的事件对象\" class=\"headerlink\" title=\"2. IE中的事件对象\"></a>2. IE中的事件对象</h4><p><strong>访问ie中事件对象event的三种不同方式：</strong></p>\n<p>(1) 使用.onclick方式绑定时</p>\n<p>通过window.event的方式访问</p>\n<p>(2) 使用attachEvent的方式绑定时</p>\n<p>通过传入event参数访问</p>\n<p>也可以通过windoe.event来访问</p>\n<p>(3) 在html里面绑定时</p>\n<p>直接通过一个event的变量访问</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">e</span><span class=\"variable\">g:</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"built_in\">input</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"submit\"</span> onClick=<span class=\"string\">\"alert(event.type)\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>ie中的event对象有srcElement属性，但没有target属性</p>\n<p>event.srcElement = event.target</p>\n<h4 id=\"3-兼容写法\"><a href=\"#3-兼容写法\" class=\"headerlink\" title=\"3. 兼容写法\"></a>3. 兼容写法</h4><p>ie中事件是全局变量window.event可以随时拿到 ，其它浏览器必须在参数中传递才能获取事件</p>\n<pre><code>var event = event || window.event;\n\nobj = event.srcElement ? event.srcElement : event.target;\n</code></pre><h3 id=\"四-事件委托代理机制\"><a href=\"#四-事件委托代理机制\" class=\"headerlink\" title=\"四. 事件委托代理机制\"></a>四. 事件委托代理机制</h3><h4 id=\"1-事件委托代理机制运用的场景\"><a href=\"#1-事件委托代理机制运用的场景\" class=\"headerlink\" title=\"1. 事件委托代理机制运用的场景\"></a>1. 事件委托代理机制运用的场景</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"data-list\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"data-show\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>点击每一个li执行一个事件，让数字显示在div里</p>\n<p>思路：若给列表的每一项分别绑定点击事件，这样做的弊端在于，增加了内存，因为$(’#data-list li’)里有100个li对象。同时降低了代码性能，因为$(’#data-list li’)会搜索ul#data-list下所有的li元素</p>\n<p>这时，可以使用<strong>事件委托代理机制</strong></p>\n<p>思路：将li的点击事件委托给其父元素ul，当内层元素的某个事件被触发，事件会一级一级地冒泡到外层元素。给父元素绑定事件，当被触发时，判断当前触发事件的对象是否是目标元素li，如果是，则执行回调函数。</p>\n<p>event.target 当前触发事件的对象，即用户真正单击到的对象<br>event.currentTarget 当前绑定事件的对象 UL.data-list</p>\n<font color=\"red\"><strong>手写原生js实现事件代理，并要求兼容浏览器</strong></font>\n\n<p>考察对事件对象e的了解程度，以及在IE下对应的属性名</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">// ============ 简单的事件委托</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegateEvent</span>(<span class=\"params\">mydiv, childName, type, fn</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//这四个参分别指的是</span></span><br><span class=\"line\">\t<span class=\"comment\">//mydiv——&gt;绑定事件的父元素（事件委托者）</span></span><br><span class=\"line\">\t<span class=\"comment\">//childName——&gt;实际执行事件的元素</span></span><br><span class=\"line\">\t<span class=\"comment\">//type——&gt;绑定事件的类型</span></span><br><span class=\"line\">\t<span class=\"comment\">//fn——&gt;事件处理程序</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//给父元素绑定事件，注意兼容性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mydiv.addEventListener)&#123;</span><br><span class=\"line\">    \tmydiv.addEventListener(type, eventfn);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mydiv.attachEvent)&#123;</span><br><span class=\"line\">    \tmydiv.attachEvent(<span class=\"string\">\"on\"</span>+type, eventfn);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    \tmydiv[<span class=\"string\">'on'</span>+type] = eventfn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//事件处理程序</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventfn</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> target = event.target || event.srcElement;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (matchSelector(target, childName)) &#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(fn) &#123;</span><br><span class=\"line\">\t\t    \tfn.call(target, event);</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * only support #id</span><br><span class=\"line\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数主要是判断当前事件源是否与我们想绑定事件的元素相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matchSelector</span>(<span class=\"params\">target, childName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果通过id名指定</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childName.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\"#\"</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> target.id === childName.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//调用</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\">   delegateEvent(mydiv,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   \talert(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-不支持冒泡的事件\"><a href=\"#五-不支持冒泡的事件\" class=\"headerlink\" title=\"五. 不支持冒泡的事件\"></a>五. 不支持冒泡的事件</h3><ul>\n<li>focus</li>\n<li>blur</li>\n<li>mouseenter</li>\n<li>mouseleave</li>\n</ul>\n<p>focus和blur如何实现事件代理：</p>\n<p>由于事件代理是基于事件的冒泡机制，但是focus和blur不支持冒泡。</p>\n<p>在IE中可以使用<strong>focusein</strong>和<strong>focusout</strong>来实现</p>\n<p>在非IE浏览器中可以在<strong>捕获阶段</strong>绑定事件</p>\n<p>.addEventListener(“click”,function(event){},true);</p>\n<h3 id=\"六-js中如何自定义事件\"><a href=\"#六-js中如何自定义事件\" class=\"headerlink\" title=\"六. js中如何自定义事件\"></a>六. js中如何自定义事件</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//创建一个事件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">event</span> = document.createEvent(<span class=\"string\">'Event'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化创建的事件event.initEvent(type, bubbles, cancelable);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">event</span>.initEvent(<span class=\"string\">'build'</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//自定义的事件与click事件不一样，需要在程序中分发，类似于订阅发布模式</span></span><br><span class=\"line\">elem.dispatchEvent(<span class=\"keyword\">event</span>);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-什么是事件模型\"><a href=\"#一-什么是事件模型\" class=\"headerlink\" title=\"一. 什么是事件模型\"></a>一. 什么是事件模型</h3><h4 id=\"1-事件\"><a href=\"#1-事件\" class=\"headerlink\" title=\"1. 事件\"></a>1. 事件</h4><p>事件是<strong>用户对浏览器的一个动作</strong>或者<strong>浏览器自身执行的某种动作</strong>，文档或浏览器窗口发生特定交互的瞬间。</p>\n<h4 id=\"2-事件流\"><a href=\"#2-事件流\" class=\"headerlink\" title=\"2. 事件流\"></a>2. 事件流</h4><p>事件流：从页面中接收事件的顺序。</p>\n<p>IE和Netscape提出了两种相反的事件流：事件冒泡流、事件捕获流。</p>\n<p><strong>事件冒泡流：由具体的节点逐级往上传播</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果单击了div，那么click事件的传播为：<code>div -&gt; body -&gt; html -&gt; Document -&gt; windows</code></p>\n<p><strong>事件捕获流：由最上层的节点逐级往下传到具体节点</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果单击了div，那么click事件的传播为：<code>windows -&gt; Document -&gt; html -&gt; body -&gt; div</code><br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插播一个windows对象和Document对象的区别：</span><br><span class=\"line\"></span><br><span class=\"line\">windows对象：指的是浏览器的窗口</span><br><span class=\"line\"></span><br><span class=\"line\">Document对象：指的是显示于窗口的一个文档</span><br><span class=\"line\"></span><br><span class=\"line\">Document 对象是 Window 对象的一部分，可通过 <span class=\"built_in\">window</span>.<span class=\"built_in\">document</span> 属性对其进行访问</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-DOM2级事件规定的事件流\"><a href=\"#3-DOM2级事件规定的事件流\" class=\"headerlink\" title=\"3. DOM2级事件规定的事件流\"></a>3. DOM2级事件规定的事件流</h4><p>W3C为了兼顾之前的标准，将事件发生定义成三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</p>\n<p>事件捕获阶段：<code>windows -&gt; Document -&gt; html -&gt; body</code></p>\n<p>事件捕获阶段，事件到<code>&lt;body&gt;</code>就停止了</p>\n<p>处于目标阶段：事件在<div>上发生</p>\n<p>事件冒泡阶段：<code>body -&gt; html -&gt; Document -&gt; windows</code></p>\n<p>DOM2级事件明确要求捕获阶段不会涉及到事件目标，但是很多高版本的浏览器都会在捕获阶段触发事件对象上的事件。</p>\n<h3 id=\"二-W3C和IE绑定事件\"><a href=\"#二-W3C和IE绑定事件\" class=\"headerlink\" title=\"二. W3C和IE绑定事件\"></a>二. W3C和IE绑定事件</h3><p>一般绑定事件可以用</p>\n<pre><code>obj.onclick = function(){}；\n</code></pre><p>但如果要给同一个元素绑定多个事件，上面那种方法就行不通了<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   obj.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \t\t\talert(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">   \t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   obj.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \t\t\talert(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">   \t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   obj.onclick = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \t\t\talert(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">   \t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">只会alert(<span class=\"string\">\"3\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可以采用下面的绑定事件的方式：</p>\n<h4 id=\"1-W3C\"><a href=\"#1-W3C\" class=\"headerlink\" title=\"1. W3C\"></a>1. W3C</h4><pre><code>W3C绑定事件 \n\nobj.addEventListener(event,function,usecapture)\n\nW3C解绑事件\n\nobj.removeEventListener(event,function,usecapture)\n\nusecapture可选值有\nfalse:事件在冒泡阶段执行（默认）\ntrue：事件在捕获阶段执行\n</code></pre><p>下面是一个冒泡阶段和捕获阶段执行事件的例子<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span><br><span class=\"line\">   <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>该实例演示了在添加事件监听时冒泡与捕获阶段的不同。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myP\"</span>&gt;</span>点击该段落， 我是冒泡<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv2\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myP2\"</span>&gt;</span>点击该段落， 我是捕获<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myP\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 P 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 DIV 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myP2\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 P 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv2\"</span>).addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"你点击了 DIV 元素!\"</span>);</span><br><span class=\"line\">   &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\"> \t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果用addEventListener给同一个对象绑定了多个事件，执行顺序如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"keyword\">function</span>1,<span class=\"literal\">false</span>)</span><br><span class=\"line\">obj.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"keyword\">function</span>2,<span class=\"literal\">false</span>)</span><br><span class=\"line\">obj.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"keyword\">function</span>3,<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>1-&gt;<span class=\"keyword\">function</span>2-&gt;<span class=\"keyword\">function</span>3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-IE中绑定事件-事件冒泡流\"><a href=\"#2-IE中绑定事件-事件冒泡流\" class=\"headerlink\" title=\"2. IE中绑定事件  事件冒泡流\"></a>2. IE中绑定事件  事件冒泡流</h4><pre><code>IE中绑定事件\nobj.attachEvent(event,function)\nIE中解绑事件\nobj.detachEvent(event,function)\n</code></pre><p>如果用attachEvent给同一个对象绑定了多个事件，执行顺序如下：</p>\n<pre><code>obj.attachEvent(&quot;onclick&quot;,function1)\nobj.attachEvent(&quot;onclick&quot;,function2)\nobj.attachEvent(&quot;onclick&quot;,function3)\n\nIE11下：function1-&gt;function2-&gt;function3\nIE8下：function3-&gt;function2-&gt;function1 颠倒顺序执行\n</code></pre><h4 id=\"3-W3C和IE中绑定事件的不同点\"><a href=\"#3-W3C和IE中绑定事件的不同点\" class=\"headerlink\" title=\"3. W3C和IE中绑定事件的不同点\"></a>3. W3C和IE中绑定事件的不同点</h4><p>(1) 参数不同，W3C可以控制事件是在捕获阶段还是在冒泡阶段执行</p>\n<p>(2) 绑定事件的名称不同：</p>\n<pre><code>W3C没有on  eg:click\nIE 有on    eg:onclick\n</code></pre><p>(3) 绑定多个事件的执行顺序</p>\n<pre><code>W3C按顺序执行\n\nIE8中是倒序执行，高一点的版本貌似是按顺序执行\n</code></pre><font color=\"red\">注意：新版本的ie在绑定事件上有所修改</font>\n\n<p>经过测试：</p>\n<pre><code>ie10（不包括ie10）以上就只支持addEventListener绑定事件了\nie9,ie10支持addeventListener和attachEvent\nie8及其以下都只支持attachEvent\n</code></pre><h3 id=\"三-事件对象\"><a href=\"#三-事件对象\" class=\"headerlink\" title=\"三. 事件对象\"></a>三. 事件对象</h3><p><strong>DOM中的事件对象</strong>和<strong>IE中的事件对象</strong>也不同。</p>\n<h4 id=\"1-DOM中的事件对象\"><a href=\"#1-DOM中的事件对象\" class=\"headerlink\" title=\"1. DOM中的事件对象\"></a>1. DOM中的事件对象</h4><p>触发某个事件时，会产生一个事件对象event。</p>\n<p><strong>不管绑定事件处理程序的方式是什么</strong>，浏览器会将这个事件对象传入事件处理程序中，作为第一个参数</p>\n<p>event</p>\n<pre><code>event.currentTarget：绑定事件的元素\n在事件处理程序内部：this永远等于event.currentTarget\n\nevent.target：触发事件的元素(事件的实际目标)\n\nevent.type：事件类型\n\nevent.stopPropagation();\n取消事件进一步捕获或冒泡    \n</code></pre><p><strong>什么是事件冒泡：</strong></p>\n<p>eg:</p>\n<pre><code>&lt;body&gt;\n    &lt;input id=&quot;btn&quot; type=&quot;submit&quot; /&gt;\n&lt;/body&gt;\n\n//给按钮绑定一个点击事件\nbtn.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;1&quot;)});\n//给其父元素绑定一个点击事件\ndocument.body.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;2&quot;)});\n\n当我们点击按钮时，会触发两个点击事件，因为按钮的点击事件冒泡到其父元素上了。\n</code></pre><p><strong>使用event.stopPropagation()阻止冒泡</strong></p>\n<pre><code>//给按钮绑定一个点击事件\nbtn.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;1&quot;);\n                    event.stopPropagation();\n                });\n//给其父元素绑定一个点击事件\ndocument.body.addEventListener(&quot;click&quot;,function(event){\n                    alert(&quot;2&quot;)});\n</code></pre><h4 id=\"2-IE中的事件对象\"><a href=\"#2-IE中的事件对象\" class=\"headerlink\" title=\"2. IE中的事件对象\"></a>2. IE中的事件对象</h4><p><strong>访问ie中事件对象event的三种不同方式：</strong></p>\n<p>(1) 使用.onclick方式绑定时</p>\n<p>通过window.event的方式访问</p>\n<p>(2) 使用attachEvent的方式绑定时</p>\n<p>通过传入event参数访问</p>\n<p>也可以通过windoe.event来访问</p>\n<p>(3) 在html里面绑定时</p>\n<p>直接通过一个event的变量访问</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">e</span><span class=\"variable\">g:</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"built_in\">input</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"submit\"</span> onClick=<span class=\"string\">\"alert(event.type)\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>ie中的event对象有srcElement属性，但没有target属性</p>\n<p>event.srcElement = event.target</p>\n<h4 id=\"3-兼容写法\"><a href=\"#3-兼容写法\" class=\"headerlink\" title=\"3. 兼容写法\"></a>3. 兼容写法</h4><p>ie中事件是全局变量window.event可以随时拿到 ，其它浏览器必须在参数中传递才能获取事件</p>\n<pre><code>var event = event || window.event;\n\nobj = event.srcElement ? event.srcElement : event.target;\n</code></pre><h3 id=\"四-事件委托代理机制\"><a href=\"#四-事件委托代理机制\" class=\"headerlink\" title=\"四. 事件委托代理机制\"></a>四. 事件委托代理机制</h3><h4 id=\"1-事件委托代理机制运用的场景\"><a href=\"#1-事件委托代理机制运用的场景\" class=\"headerlink\" title=\"1. 事件委托代理机制运用的场景\"></a>1. 事件委托代理机制运用的场景</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"data-list\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"data-show\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>点击每一个li执行一个事件，让数字显示在div里</p>\n<p>思路：若给列表的每一项分别绑定点击事件，这样做的弊端在于，增加了内存，因为$(’#data-list li’)里有100个li对象。同时降低了代码性能，因为$(’#data-list li’)会搜索ul#data-list下所有的li元素</p>\n<p>这时，可以使用<strong>事件委托代理机制</strong></p>\n<p>思路：将li的点击事件委托给其父元素ul，当内层元素的某个事件被触发，事件会一级一级地冒泡到外层元素。给父元素绑定事件，当被触发时，判断当前触发事件的对象是否是目标元素li，如果是，则执行回调函数。</p>\n<p>event.target 当前触发事件的对象，即用户真正单击到的对象<br>event.currentTarget 当前绑定事件的对象 UL.data-list</p>\n<font color=\"red\"><strong>手写原生js实现事件代理，并要求兼容浏览器</strong></font>\n\n<p>考察对事件对象e的了解程度，以及在IE下对应的属性名</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">// ============ 简单的事件委托</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegateEvent</span>(<span class=\"params\">mydiv, childName, type, fn</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//这四个参分别指的是</span></span><br><span class=\"line\">\t<span class=\"comment\">//mydiv——&gt;绑定事件的父元素（事件委托者）</span></span><br><span class=\"line\">\t<span class=\"comment\">//childName——&gt;实际执行事件的元素</span></span><br><span class=\"line\">\t<span class=\"comment\">//type——&gt;绑定事件的类型</span></span><br><span class=\"line\">\t<span class=\"comment\">//fn——&gt;事件处理程序</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//给父元素绑定事件，注意兼容性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mydiv.addEventListener)&#123;</span><br><span class=\"line\">    \tmydiv.addEventListener(type, eventfn);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mydiv.attachEvent)&#123;</span><br><span class=\"line\">    \tmydiv.attachEvent(<span class=\"string\">\"on\"</span>+type, eventfn);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    \tmydiv[<span class=\"string\">'on'</span>+type] = eventfn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">//事件处理程序</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventfn</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> target = event.target || event.srcElement;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (matchSelector(target, childName)) &#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(fn) &#123;</span><br><span class=\"line\">\t\t    \tfn.call(target, event);</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * only support #id</span><br><span class=\"line\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数主要是判断当前事件源是否与我们想绑定事件的元素相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matchSelector</span>(<span class=\"params\">target, childName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果通过id名指定</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childName.charAt(<span class=\"number\">0</span>) === <span class=\"string\">\"#\"</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> target.id === childName.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//调用</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\">   delegateEvent(mydiv,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   \talert(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-不支持冒泡的事件\"><a href=\"#五-不支持冒泡的事件\" class=\"headerlink\" title=\"五. 不支持冒泡的事件\"></a>五. 不支持冒泡的事件</h3><ul>\n<li>focus</li>\n<li>blur</li>\n<li>mouseenter</li>\n<li>mouseleave</li>\n</ul>\n<p>focus和blur如何实现事件代理：</p>\n<p>由于事件代理是基于事件的冒泡机制，但是focus和blur不支持冒泡。</p>\n<p>在IE中可以使用<strong>focusein</strong>和<strong>focusout</strong>来实现</p>\n<p>在非IE浏览器中可以在<strong>捕获阶段</strong>绑定事件</p>\n<p>.addEventListener(“click”,function(event){},true);</p>\n<h3 id=\"六-js中如何自定义事件\"><a href=\"#六-js中如何自定义事件\" class=\"headerlink\" title=\"六. js中如何自定义事件\"></a>六. js中如何自定义事件</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//创建一个事件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">event</span> = document.createEvent(<span class=\"string\">'Event'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化创建的事件event.initEvent(type, bubbles, cancelable);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">event</span>.initEvent(<span class=\"string\">'build'</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//自定义的事件与click事件不一样，需要在程序中分发，类似于订阅发布模式</span></span><br><span class=\"line\">elem.dispatchEvent(<span class=\"keyword\">event</span>);</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"实现轮播","date":"2016-04-05T16:00:00.000Z","description":null,"_content":"\n之前用bootstrap里面的collapse（轮播）插件实现过轮播效果，但是一直只知其然而不知其所以然，于是今天就研究了一下怎么实现和bootstrap轮播插件一样的轮播效果。\n\n### 一. 轮播图的demo\n\n轮播图demo地址\n[http://panpanfish.com/myDemo/collapse.html](http://panpanfish.com/myDemo/collapse.html \"轮播图效果\")\n\n轮播图的代码地址\n[https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html](https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html \"轮播图的代码地址\")\n\n\n### 二. 轮播图的原理\n\n先上一段HTML代码\n\n    <div class=\"container\" id=\"container\" >\n    \t<div class=\"img-list\" id=\"imgList\" style=\"left:-450px;\">    \t\t\n    \t\t<img src=\"img/1.jpg\" />\n    \t\t<img src=\"img/2.jpg\" />\n    \t\t<img src=\"img/3.jpg\" />\n    \t\t<img src=\"img/4.jpg\" />\n    \t\t<img src=\"img/5.jpg\" />\t\t\n    \t</div>\n    </div>\n\nid为container的容器可以看成是轮播的框，给container设定一定的宽度，并且设置overflow:hidden;\n\n    .container{position:relative;\n    \twidth:450px;\n    \theight:300px;\n    \toverflow:hidden;\n    }\n\nid为imgList的div里面是需要轮播的图片（图片一排显示）\n\n    .img-list{position:absolute;\n    \tz-index:1;\n    \twidth:3150px;/*很重要，让图片连续显示*/   \n    }\n    .img-list img {float:left;\n    \t\t\t\twidth:450px;\n    \t\t\t\theight:300px;\n    }\n\n**轮播的过程可以想象成，把imgList的div向左移动的过程，每次改变left值，可以实现在container里面显示不同的图片。**\n\n**小圆点标签控制图片播放** 和 **左右箭头控制图片播放**，都是基于改变imgList的left值。\n\n**图片自动播放**功能是采用定时器，定时触发右箭头点击事件\n\n### 三. 实现过程中用到的知识点\n\n#### 1. DOM操作\n\n    document.getElementById(\"container\")；//由id获取dom节点\n    \n    document.getElementById(\"buttons\").getElementsByTagName(\"span\");//由标签名获取dom节点\n\n#### 2. 定时器\n\n**setTimeout**\n\n    setTimeout(code,time);  表示在时间time之后执行code里面的代码\n    \n    setTimeout只执行code一次，如果想多次调用，可以让code自身再次调用setTimeout(一种递归的思想)\n\n在这个例子中，让图片缓慢向左移动的函数go里面使用到了setTimeout\n    \n**setInterval**\n\n    setInterval(code,interval); 表示每隔interval时间调用一次code\n    \n    setInterval会执行code无数次，直到取消了这个定时器为止\n\n在这个例子中，就是使用setInterval这个函数来制作图片自动播放这个功能。\n\n**clearTimeout**\n\n    clearTimeout(定时器的名称); 取消定时执行的事件操作\n\neg：\n\n    function autoPlay(){\n    \t\ttimer = setInterval(function(){\n    \t\t\tnext.onclick();\n    \t\t\t\n    \t\t},interval);\n    \t}\n    \n    \tfunction stop(){\n    \t\tclearTimeout(timer);//取消timer，图片不再自动播放\n    \t}\n\n### 3. 实现图片可以向两边循环滚动\n\n在二的轮播图的原理中，我讲到轮播图可以看成是imgList向左移，或者向右移，那么假设一种情况，当移到最左边（第一张图片），或者最右边（第二张图片）时，如果还想循环播放图片，应该怎么办？\n\n这就是图片的无限循环播放问题\n\n这里的解决方案是：\n\n\t<div class=\"img-list\" id=\"imgList\" style=\"left:-450px;\">\n\t\t<img src=\"img/5.jpg\" /><!-- left:0px;为了实现无限滚动 -->\n\t\t<img src=\"img/1.jpg\" /><!-- left:-450px; -->\n\t\t<img src=\"img/2.jpg\" /><!-- left:-900px; -->\n\t\t<img src=\"img/3.jpg\" /><!-- left:-1350px; -->\n\t\t<img src=\"img/4.jpg\" /><!-- left:-1800px; -->\n\t\t<img src=\"img/5.jpg\" /><!-- left:-2250px; -->\n\t\t<img src=\"img/1.jpg\" /><!--left:-2700px; 为了实现无限滚动 -->\n\t</div>\n\n- 在图片1的左边加一个图片5的副本，在图片5的右边加一个图片1的副本。\n- 我在上段代码中标出了，当left值为多少时，显示哪一张图片。\n- 检测left值，当检测到left值不在[-450px,-2250px]这个范围内时，执行调回操作。具体如下：\n\n    当left>-450px时，使left=-2250px，跳回第5张\n    当left<-2250px时，时left=-450px，跳回第1张\n\n- 增加两个图片副本主要是为了用户在视觉上没有发现。\n\n#### 4. 程序的一些优化\n\n(1). 考虑到用户在当前图片页，仍然点击对应的标签的情况，可以设置return，跳出当前函数\n\n\tfor(var i = 0;i < buttons.length;i++)\n\t{\n\t\tbuttons[i].onclick = function(){\n\n\t\t\t/*优化工作，当当前页面是要显示的页面时，点击对应按钮，不执行下面的语句*/\n\t\t\tif(this.className == \"buttonOn\")\n\t\t\t{\n\t\t\t\treturn;//return的意思是，当程序跑到这里时，就会退出当前函数\n\t\t\t}\n\n\t\t\tvar myIndex = parseInt(this.getAttribute(\"index\"));\n\t\t\tvar offset = -450 * (myIndex - index);\t\t\t\n\t\t\tanimate(offset);\n\t\t\tindex = myIndex;\n\t\t\tshowButtons();\n\t\t\t//debugger;\n\t\t}\n\t}\n\n(2). 图片的自动播放功能\n\n这里的图片自动播放功能使用的是js，让imgList的left的值在一定时间内增加或者减少到目标值。\n\n我想利用css3的一些新的属性来制作轮播的动画。\n\ncss3动画属性：animation\n\n    .img-list{-webkit-animation: slide 8s linear infinite;\n    -o-animation: slide 8s linear infinite;\n    animation: slide 8s linear infinite;}\n    slide是动画的名字\n    infinite表示动画应该无限次播放\n\n     @-webkit-keyframes slide {\n    0%,10% {\n    \tleft: -450px;\n    }\n     20% ,30%{\n    \tleft: -900px;\n    }\n    40%,50%{\n    \tleft: -1350px;\n    }\n    60%,70% {\n    \tleft: -1800px;\n    }\n    80%,100% {\n    \tleft: -2250px;\n    }\n\n    }\n\n用animation来实现自动播放时，有一个问题就是，当播放到最后一张，如何平滑地滑到第一张。这个问题还有待思考。\n\n(3). 图片左右移动也可以使用css3的新属性\n\n    transform:translateX(450px);\n\n(4). 图片过渡效果也可以使用css3的新属性\n\n    transition:left 0.6s;","source":"_posts/2016-04-06-实现轮播特效.md","raw":"---\nlayout: post\ntitle: 实现轮播\ndate: 2016-04-06\ncategories: Demo\ntags: [css,javascript]\ndescription: \n---\n\n之前用bootstrap里面的collapse（轮播）插件实现过轮播效果，但是一直只知其然而不知其所以然，于是今天就研究了一下怎么实现和bootstrap轮播插件一样的轮播效果。\n\n### 一. 轮播图的demo\n\n轮播图demo地址\n[http://panpanfish.com/myDemo/collapse.html](http://panpanfish.com/myDemo/collapse.html \"轮播图效果\")\n\n轮播图的代码地址\n[https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html](https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html \"轮播图的代码地址\")\n\n\n### 二. 轮播图的原理\n\n先上一段HTML代码\n\n    <div class=\"container\" id=\"container\" >\n    \t<div class=\"img-list\" id=\"imgList\" style=\"left:-450px;\">    \t\t\n    \t\t<img src=\"img/1.jpg\" />\n    \t\t<img src=\"img/2.jpg\" />\n    \t\t<img src=\"img/3.jpg\" />\n    \t\t<img src=\"img/4.jpg\" />\n    \t\t<img src=\"img/5.jpg\" />\t\t\n    \t</div>\n    </div>\n\nid为container的容器可以看成是轮播的框，给container设定一定的宽度，并且设置overflow:hidden;\n\n    .container{position:relative;\n    \twidth:450px;\n    \theight:300px;\n    \toverflow:hidden;\n    }\n\nid为imgList的div里面是需要轮播的图片（图片一排显示）\n\n    .img-list{position:absolute;\n    \tz-index:1;\n    \twidth:3150px;/*很重要，让图片连续显示*/   \n    }\n    .img-list img {float:left;\n    \t\t\t\twidth:450px;\n    \t\t\t\theight:300px;\n    }\n\n**轮播的过程可以想象成，把imgList的div向左移动的过程，每次改变left值，可以实现在container里面显示不同的图片。**\n\n**小圆点标签控制图片播放** 和 **左右箭头控制图片播放**，都是基于改变imgList的left值。\n\n**图片自动播放**功能是采用定时器，定时触发右箭头点击事件\n\n### 三. 实现过程中用到的知识点\n\n#### 1. DOM操作\n\n    document.getElementById(\"container\")；//由id获取dom节点\n    \n    document.getElementById(\"buttons\").getElementsByTagName(\"span\");//由标签名获取dom节点\n\n#### 2. 定时器\n\n**setTimeout**\n\n    setTimeout(code,time);  表示在时间time之后执行code里面的代码\n    \n    setTimeout只执行code一次，如果想多次调用，可以让code自身再次调用setTimeout(一种递归的思想)\n\n在这个例子中，让图片缓慢向左移动的函数go里面使用到了setTimeout\n    \n**setInterval**\n\n    setInterval(code,interval); 表示每隔interval时间调用一次code\n    \n    setInterval会执行code无数次，直到取消了这个定时器为止\n\n在这个例子中，就是使用setInterval这个函数来制作图片自动播放这个功能。\n\n**clearTimeout**\n\n    clearTimeout(定时器的名称); 取消定时执行的事件操作\n\neg：\n\n    function autoPlay(){\n    \t\ttimer = setInterval(function(){\n    \t\t\tnext.onclick();\n    \t\t\t\n    \t\t},interval);\n    \t}\n    \n    \tfunction stop(){\n    \t\tclearTimeout(timer);//取消timer，图片不再自动播放\n    \t}\n\n### 3. 实现图片可以向两边循环滚动\n\n在二的轮播图的原理中，我讲到轮播图可以看成是imgList向左移，或者向右移，那么假设一种情况，当移到最左边（第一张图片），或者最右边（第二张图片）时，如果还想循环播放图片，应该怎么办？\n\n这就是图片的无限循环播放问题\n\n这里的解决方案是：\n\n\t<div class=\"img-list\" id=\"imgList\" style=\"left:-450px;\">\n\t\t<img src=\"img/5.jpg\" /><!-- left:0px;为了实现无限滚动 -->\n\t\t<img src=\"img/1.jpg\" /><!-- left:-450px; -->\n\t\t<img src=\"img/2.jpg\" /><!-- left:-900px; -->\n\t\t<img src=\"img/3.jpg\" /><!-- left:-1350px; -->\n\t\t<img src=\"img/4.jpg\" /><!-- left:-1800px; -->\n\t\t<img src=\"img/5.jpg\" /><!-- left:-2250px; -->\n\t\t<img src=\"img/1.jpg\" /><!--left:-2700px; 为了实现无限滚动 -->\n\t</div>\n\n- 在图片1的左边加一个图片5的副本，在图片5的右边加一个图片1的副本。\n- 我在上段代码中标出了，当left值为多少时，显示哪一张图片。\n- 检测left值，当检测到left值不在[-450px,-2250px]这个范围内时，执行调回操作。具体如下：\n\n    当left>-450px时，使left=-2250px，跳回第5张\n    当left<-2250px时，时left=-450px，跳回第1张\n\n- 增加两个图片副本主要是为了用户在视觉上没有发现。\n\n#### 4. 程序的一些优化\n\n(1). 考虑到用户在当前图片页，仍然点击对应的标签的情况，可以设置return，跳出当前函数\n\n\tfor(var i = 0;i < buttons.length;i++)\n\t{\n\t\tbuttons[i].onclick = function(){\n\n\t\t\t/*优化工作，当当前页面是要显示的页面时，点击对应按钮，不执行下面的语句*/\n\t\t\tif(this.className == \"buttonOn\")\n\t\t\t{\n\t\t\t\treturn;//return的意思是，当程序跑到这里时，就会退出当前函数\n\t\t\t}\n\n\t\t\tvar myIndex = parseInt(this.getAttribute(\"index\"));\n\t\t\tvar offset = -450 * (myIndex - index);\t\t\t\n\t\t\tanimate(offset);\n\t\t\tindex = myIndex;\n\t\t\tshowButtons();\n\t\t\t//debugger;\n\t\t}\n\t}\n\n(2). 图片的自动播放功能\n\n这里的图片自动播放功能使用的是js，让imgList的left的值在一定时间内增加或者减少到目标值。\n\n我想利用css3的一些新的属性来制作轮播的动画。\n\ncss3动画属性：animation\n\n    .img-list{-webkit-animation: slide 8s linear infinite;\n    -o-animation: slide 8s linear infinite;\n    animation: slide 8s linear infinite;}\n    slide是动画的名字\n    infinite表示动画应该无限次播放\n\n     @-webkit-keyframes slide {\n    0%,10% {\n    \tleft: -450px;\n    }\n     20% ,30%{\n    \tleft: -900px;\n    }\n    40%,50%{\n    \tleft: -1350px;\n    }\n    60%,70% {\n    \tleft: -1800px;\n    }\n    80%,100% {\n    \tleft: -2250px;\n    }\n\n    }\n\n用animation来实现自动播放时，有一个问题就是，当播放到最后一张，如何平滑地滑到第一张。这个问题还有待思考。\n\n(3). 图片左右移动也可以使用css3的新属性\n\n    transform:translateX(450px);\n\n(4). 图片过渡效果也可以使用css3的新属性\n\n    transition:left 0.6s;","slug":"2016-04-06-实现轮播特效","published":1,"updated":"2016-07-03T13:53:24.000Z","comments":1,"photos":[],"link":"","_id":"cj035oce6002vd5u8icyf7ax1","content":"<p>之前用bootstrap里面的collapse（轮播）插件实现过轮播效果，但是一直只知其然而不知其所以然，于是今天就研究了一下怎么实现和bootstrap轮播插件一样的轮播效果。</p>\n<h3 id=\"一-轮播图的demo\"><a href=\"#一-轮播图的demo\" class=\"headerlink\" title=\"一. 轮播图的demo\"></a>一. 轮播图的demo</h3><p>轮播图demo地址<br><a href=\"http://panpanfish.com/myDemo/collapse.html\" title=\"轮播图效果\">http://panpanfish.com/myDemo/collapse.html</a></p>\n<p>轮播图的代码地址<br><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html\" title=\"轮播图的代码地址\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html</a></p>\n<h3 id=\"二-轮播图的原理\"><a href=\"#二-轮播图的原理\" class=\"headerlink\" title=\"二. 轮播图的原理\"></a>二. 轮播图的原理</h3><p>先上一段HTML代码</p>\n<pre><code>&lt;div class=&quot;container&quot; id=&quot;container&quot; &gt;\n    &lt;div class=&quot;img-list&quot; id=&quot;imgList&quot; style=&quot;left:-450px;&quot;&gt;            \n        &lt;img src=&quot;img/1.jpg&quot; /&gt;\n        &lt;img src=&quot;img/2.jpg&quot; /&gt;\n        &lt;img src=&quot;img/3.jpg&quot; /&gt;\n        &lt;img src=&quot;img/4.jpg&quot; /&gt;\n        &lt;img src=&quot;img/5.jpg&quot; /&gt;        \n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>id为container的容器可以看成是轮播的框，给container设定一定的宽度，并且设置overflow:hidden;</p>\n<pre><code>.container{position:relative;\n    width:450px;\n    height:300px;\n    overflow:hidden;\n}\n</code></pre><p>id为imgList的div里面是需要轮播的图片（图片一排显示）</p>\n<pre><code>.img-list{position:absolute;\n    z-index:1;\n    width:3150px;/*很重要，让图片连续显示*/   \n}\n.img-list img {float:left;\n                width:450px;\n                height:300px;\n}\n</code></pre><p><strong>轮播的过程可以想象成，把imgList的div向左移动的过程，每次改变left值，可以实现在container里面显示不同的图片。</strong></p>\n<p><strong>小圆点标签控制图片播放</strong> 和 <strong>左右箭头控制图片播放</strong>，都是基于改变imgList的left值。</p>\n<p><strong>图片自动播放</strong>功能是采用定时器，定时触发右箭头点击事件</p>\n<h3 id=\"三-实现过程中用到的知识点\"><a href=\"#三-实现过程中用到的知识点\" class=\"headerlink\" title=\"三. 实现过程中用到的知识点\"></a>三. 实现过程中用到的知识点</h3><h4 id=\"1-DOM操作\"><a href=\"#1-DOM操作\" class=\"headerlink\" title=\"1. DOM操作\"></a>1. DOM操作</h4><pre><code>document.getElementById(&quot;container&quot;)；//由id获取dom节点\n\ndocument.getElementById(&quot;buttons&quot;).getElementsByTagName(&quot;span&quot;);//由标签名获取dom节点\n</code></pre><h4 id=\"2-定时器\"><a href=\"#2-定时器\" class=\"headerlink\" title=\"2. 定时器\"></a>2. 定时器</h4><p><strong>setTimeout</strong></p>\n<pre><code>setTimeout(code,time);  表示在时间time之后执行code里面的代码\n\nsetTimeout只执行code一次，如果想多次调用，可以让code自身再次调用setTimeout(一种递归的思想)\n</code></pre><p>在这个例子中，让图片缓慢向左移动的函数go里面使用到了setTimeout</p>\n<p><strong>setInterval</strong></p>\n<pre><code>setInterval(code,interval); 表示每隔interval时间调用一次code\n\nsetInterval会执行code无数次，直到取消了这个定时器为止\n</code></pre><p>在这个例子中，就是使用setInterval这个函数来制作图片自动播放这个功能。</p>\n<p><strong>clearTimeout</strong></p>\n<pre><code>clearTimeout(定时器的名称); 取消定时执行的事件操作\n</code></pre><p>eg：</p>\n<pre><code>function autoPlay(){\n        timer = setInterval(function(){\n            next.onclick();\n\n        },interval);\n    }\n\n    function stop(){\n        clearTimeout(timer);//取消timer，图片不再自动播放\n    }\n</code></pre><h3 id=\"3-实现图片可以向两边循环滚动\"><a href=\"#3-实现图片可以向两边循环滚动\" class=\"headerlink\" title=\"3. 实现图片可以向两边循环滚动\"></a>3. 实现图片可以向两边循环滚动</h3><p>在二的轮播图的原理中，我讲到轮播图可以看成是imgList向左移，或者向右移，那么假设一种情况，当移到最左边（第一张图片），或者最右边（第二张图片）时，如果还想循环播放图片，应该怎么办？</p>\n<p>这就是图片的无限循环播放问题</p>\n<p>这里的解决方案是：</p>\n<pre><code>&lt;div class=&quot;img-list&quot; id=&quot;imgList&quot; style=&quot;left:-450px;&quot;&gt;\n    &lt;img src=&quot;img/5.jpg&quot; /&gt;&lt;!-- left:0px;为了实现无限滚动 --&gt;\n    &lt;img src=&quot;img/1.jpg&quot; /&gt;&lt;!-- left:-450px; --&gt;\n    &lt;img src=&quot;img/2.jpg&quot; /&gt;&lt;!-- left:-900px; --&gt;\n    &lt;img src=&quot;img/3.jpg&quot; /&gt;&lt;!-- left:-1350px; --&gt;\n    &lt;img src=&quot;img/4.jpg&quot; /&gt;&lt;!-- left:-1800px; --&gt;\n    &lt;img src=&quot;img/5.jpg&quot; /&gt;&lt;!-- left:-2250px; --&gt;\n    &lt;img src=&quot;img/1.jpg&quot; /&gt;&lt;!--left:-2700px; 为了实现无限滚动 --&gt;\n&lt;/div&gt;\n</code></pre><ul>\n<li>在图片1的左边加一个图片5的副本，在图片5的右边加一个图片1的副本。</li>\n<li>我在上段代码中标出了，当left值为多少时，显示哪一张图片。</li>\n<li><p>检测left值，当检测到left值不在[-450px,-2250px]这个范围内时，执行调回操作。具体如下：</p>\n<p>  当left&gt;-450px时，使left=-2250px，跳回第5张<br>  当left&lt;-2250px时，时left=-450px，跳回第1张</p>\n</li>\n<li><p>增加两个图片副本主要是为了用户在视觉上没有发现。</p>\n</li>\n</ul>\n<h4 id=\"4-程序的一些优化\"><a href=\"#4-程序的一些优化\" class=\"headerlink\" title=\"4. 程序的一些优化\"></a>4. 程序的一些优化</h4><p>(1). 考虑到用户在当前图片页，仍然点击对应的标签的情况，可以设置return，跳出当前函数</p>\n<pre><code>for(var i = 0;i &lt; buttons.length;i++)\n{\n    buttons[i].onclick = function(){\n\n        /*优化工作，当当前页面是要显示的页面时，点击对应按钮，不执行下面的语句*/\n        if(this.className == &quot;buttonOn&quot;)\n        {\n            return;//return的意思是，当程序跑到这里时，就会退出当前函数\n        }\n\n        var myIndex = parseInt(this.getAttribute(&quot;index&quot;));\n        var offset = -450 * (myIndex - index);            \n        animate(offset);\n        index = myIndex;\n        showButtons();\n        //debugger;\n    }\n}\n</code></pre><p>(2). 图片的自动播放功能</p>\n<p>这里的图片自动播放功能使用的是js，让imgList的left的值在一定时间内增加或者减少到目标值。</p>\n<p>我想利用css3的一些新的属性来制作轮播的动画。</p>\n<p>css3动画属性：animation</p>\n<pre><code>.img-list{-webkit-animation: slide 8s linear infinite;\n-o-animation: slide 8s linear infinite;\nanimation: slide 8s linear infinite;}\nslide是动画的名字\ninfinite表示动画应该无限次播放\n\n @-webkit-keyframes slide {\n0%,10% {\n    left: -450px;\n}\n 20% ,30%{\n    left: -900px;\n}\n40%,50%{\n    left: -1350px;\n}\n60%,70% {\n    left: -1800px;\n}\n80%,100% {\n    left: -2250px;\n}\n\n}\n</code></pre><p>用animation来实现自动播放时，有一个问题就是，当播放到最后一张，如何平滑地滑到第一张。这个问题还有待思考。</p>\n<p>(3). 图片左右移动也可以使用css3的新属性</p>\n<pre><code>transform:translateX(450px);\n</code></pre><p>(4). 图片过渡效果也可以使用css3的新属性</p>\n<pre><code>transition:left 0.6s;\n</code></pre>","excerpt":"","more":"<p>之前用bootstrap里面的collapse（轮播）插件实现过轮播效果，但是一直只知其然而不知其所以然，于是今天就研究了一下怎么实现和bootstrap轮播插件一样的轮播效果。</p>\n<h3 id=\"一-轮播图的demo\"><a href=\"#一-轮播图的demo\" class=\"headerlink\" title=\"一. 轮播图的demo\"></a>一. 轮播图的demo</h3><p>轮播图demo地址<br><a href=\"http://panpanfish.com/myDemo/collapse.html\" title=\"轮播图效果\">http://panpanfish.com/myDemo/collapse.html</a></p>\n<p>轮播图的代码地址<br><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html\" title=\"轮播图的代码地址\">https://github.com/panpan040828/myDemo/blob/gh-pages/collapse.html</a></p>\n<h3 id=\"二-轮播图的原理\"><a href=\"#二-轮播图的原理\" class=\"headerlink\" title=\"二. 轮播图的原理\"></a>二. 轮播图的原理</h3><p>先上一段HTML代码</p>\n<pre><code>&lt;div class=&quot;container&quot; id=&quot;container&quot; &gt;\n    &lt;div class=&quot;img-list&quot; id=&quot;imgList&quot; style=&quot;left:-450px;&quot;&gt;            \n        &lt;img src=&quot;img/1.jpg&quot; /&gt;\n        &lt;img src=&quot;img/2.jpg&quot; /&gt;\n        &lt;img src=&quot;img/3.jpg&quot; /&gt;\n        &lt;img src=&quot;img/4.jpg&quot; /&gt;\n        &lt;img src=&quot;img/5.jpg&quot; /&gt;        \n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>id为container的容器可以看成是轮播的框，给container设定一定的宽度，并且设置overflow:hidden;</p>\n<pre><code>.container{position:relative;\n    width:450px;\n    height:300px;\n    overflow:hidden;\n}\n</code></pre><p>id为imgList的div里面是需要轮播的图片（图片一排显示）</p>\n<pre><code>.img-list{position:absolute;\n    z-index:1;\n    width:3150px;/*很重要，让图片连续显示*/   \n}\n.img-list img {float:left;\n                width:450px;\n                height:300px;\n}\n</code></pre><p><strong>轮播的过程可以想象成，把imgList的div向左移动的过程，每次改变left值，可以实现在container里面显示不同的图片。</strong></p>\n<p><strong>小圆点标签控制图片播放</strong> 和 <strong>左右箭头控制图片播放</strong>，都是基于改变imgList的left值。</p>\n<p><strong>图片自动播放</strong>功能是采用定时器，定时触发右箭头点击事件</p>\n<h3 id=\"三-实现过程中用到的知识点\"><a href=\"#三-实现过程中用到的知识点\" class=\"headerlink\" title=\"三. 实现过程中用到的知识点\"></a>三. 实现过程中用到的知识点</h3><h4 id=\"1-DOM操作\"><a href=\"#1-DOM操作\" class=\"headerlink\" title=\"1. DOM操作\"></a>1. DOM操作</h4><pre><code>document.getElementById(&quot;container&quot;)；//由id获取dom节点\n\ndocument.getElementById(&quot;buttons&quot;).getElementsByTagName(&quot;span&quot;);//由标签名获取dom节点\n</code></pre><h4 id=\"2-定时器\"><a href=\"#2-定时器\" class=\"headerlink\" title=\"2. 定时器\"></a>2. 定时器</h4><p><strong>setTimeout</strong></p>\n<pre><code>setTimeout(code,time);  表示在时间time之后执行code里面的代码\n\nsetTimeout只执行code一次，如果想多次调用，可以让code自身再次调用setTimeout(一种递归的思想)\n</code></pre><p>在这个例子中，让图片缓慢向左移动的函数go里面使用到了setTimeout</p>\n<p><strong>setInterval</strong></p>\n<pre><code>setInterval(code,interval); 表示每隔interval时间调用一次code\n\nsetInterval会执行code无数次，直到取消了这个定时器为止\n</code></pre><p>在这个例子中，就是使用setInterval这个函数来制作图片自动播放这个功能。</p>\n<p><strong>clearTimeout</strong></p>\n<pre><code>clearTimeout(定时器的名称); 取消定时执行的事件操作\n</code></pre><p>eg：</p>\n<pre><code>function autoPlay(){\n        timer = setInterval(function(){\n            next.onclick();\n\n        },interval);\n    }\n\n    function stop(){\n        clearTimeout(timer);//取消timer，图片不再自动播放\n    }\n</code></pre><h3 id=\"3-实现图片可以向两边循环滚动\"><a href=\"#3-实现图片可以向两边循环滚动\" class=\"headerlink\" title=\"3. 实现图片可以向两边循环滚动\"></a>3. 实现图片可以向两边循环滚动</h3><p>在二的轮播图的原理中，我讲到轮播图可以看成是imgList向左移，或者向右移，那么假设一种情况，当移到最左边（第一张图片），或者最右边（第二张图片）时，如果还想循环播放图片，应该怎么办？</p>\n<p>这就是图片的无限循环播放问题</p>\n<p>这里的解决方案是：</p>\n<pre><code>&lt;div class=&quot;img-list&quot; id=&quot;imgList&quot; style=&quot;left:-450px;&quot;&gt;\n    &lt;img src=&quot;img/5.jpg&quot; /&gt;&lt;!-- left:0px;为了实现无限滚动 --&gt;\n    &lt;img src=&quot;img/1.jpg&quot; /&gt;&lt;!-- left:-450px; --&gt;\n    &lt;img src=&quot;img/2.jpg&quot; /&gt;&lt;!-- left:-900px; --&gt;\n    &lt;img src=&quot;img/3.jpg&quot; /&gt;&lt;!-- left:-1350px; --&gt;\n    &lt;img src=&quot;img/4.jpg&quot; /&gt;&lt;!-- left:-1800px; --&gt;\n    &lt;img src=&quot;img/5.jpg&quot; /&gt;&lt;!-- left:-2250px; --&gt;\n    &lt;img src=&quot;img/1.jpg&quot; /&gt;&lt;!--left:-2700px; 为了实现无限滚动 --&gt;\n&lt;/div&gt;\n</code></pre><ul>\n<li>在图片1的左边加一个图片5的副本，在图片5的右边加一个图片1的副本。</li>\n<li>我在上段代码中标出了，当left值为多少时，显示哪一张图片。</li>\n<li><p>检测left值，当检测到left值不在[-450px,-2250px]这个范围内时，执行调回操作。具体如下：</p>\n<p>  当left&gt;-450px时，使left=-2250px，跳回第5张<br>  当left&lt;-2250px时，时left=-450px，跳回第1张</p>\n</li>\n<li><p>增加两个图片副本主要是为了用户在视觉上没有发现。</p>\n</li>\n</ul>\n<h4 id=\"4-程序的一些优化\"><a href=\"#4-程序的一些优化\" class=\"headerlink\" title=\"4. 程序的一些优化\"></a>4. 程序的一些优化</h4><p>(1). 考虑到用户在当前图片页，仍然点击对应的标签的情况，可以设置return，跳出当前函数</p>\n<pre><code>for(var i = 0;i &lt; buttons.length;i++)\n{\n    buttons[i].onclick = function(){\n\n        /*优化工作，当当前页面是要显示的页面时，点击对应按钮，不执行下面的语句*/\n        if(this.className == &quot;buttonOn&quot;)\n        {\n            return;//return的意思是，当程序跑到这里时，就会退出当前函数\n        }\n\n        var myIndex = parseInt(this.getAttribute(&quot;index&quot;));\n        var offset = -450 * (myIndex - index);            \n        animate(offset);\n        index = myIndex;\n        showButtons();\n        //debugger;\n    }\n}\n</code></pre><p>(2). 图片的自动播放功能</p>\n<p>这里的图片自动播放功能使用的是js，让imgList的left的值在一定时间内增加或者减少到目标值。</p>\n<p>我想利用css3的一些新的属性来制作轮播的动画。</p>\n<p>css3动画属性：animation</p>\n<pre><code>.img-list{-webkit-animation: slide 8s linear infinite;\n-o-animation: slide 8s linear infinite;\nanimation: slide 8s linear infinite;}\nslide是动画的名字\ninfinite表示动画应该无限次播放\n\n @-webkit-keyframes slide {\n0%,10% {\n    left: -450px;\n}\n 20% ,30%{\n    left: -900px;\n}\n40%,50%{\n    left: -1350px;\n}\n60%,70% {\n    left: -1800px;\n}\n80%,100% {\n    left: -2250px;\n}\n\n}\n</code></pre><p>用animation来实现自动播放时，有一个问题就是，当播放到最后一张，如何平滑地滑到第一张。这个问题还有待思考。</p>\n<p>(3). 图片左右移动也可以使用css3的新属性</p>\n<pre><code>transform:translateX(450px);\n</code></pre><p>(4). 图片过渡效果也可以使用css3的新属性</p>\n<pre><code>transition:left 0.6s;\n</code></pre>"},{"layout":"post","title":"万年历插件","date":"2016-04-18T16:00:00.000Z","description":null,"demo":"万年历","_content":"\n这个demo是一个日历查询的控件，兼容移动端和PC端（PC端支持chrome/QQ浏览器/搜狗浏览器/IE9及以上），由于时间有限，只测了一小部分的浏览器。\n\n### 一. 万年历demo地址\n\n万年历demo地址\n[http://panpanfish.com/myDemo/calendar.html](http://panpanfish.com/myDemo/calendar.html \"万年历效果\")\n\n万年历的代码地址\n[https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html](https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html \"万年历的代码地址\")\n\n### 二. 万年历的功能\n\n**PC端：**\n1. 显示当前年、月、日、星期、北京时间、农历24节气、基本的国际节假日、2016年假日安排；\n1. 通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期、该年生肖、该天星座、农历年月日的天干地支、该天宜忌事项；\n1. 通过假日名称来查询节假日安排；\n1. 点击“返回今天”能够回到当前日期。\n\n**移动端(隐藏了一部分功能)：**\n1. 显示当前年、月、日、北京时间、农历24节气、基本的国际节假日、2016年假日安排；\n1. 通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期；\n1. 通过假日名称来查询节假日安排；\n\n#### 1. 每个功能的实现思路\n\n**(1) 显示当前年、月、日、星期**\n\n  创建一个Date对象，分别通过Date对象的getFullYear()、getMonth()、getDate()、getDay()来获取当前的年、月、日、星期。\n\n**(2) 显示北京时间**\n\n  创建一个Date对象，分别通过Date对象的getHours()、getMinutes()、getSeconds()来获取当前的时、分、秒。并以1000毫秒为一个周期来调用这些函数。\n\n**(3) 通过年、月、日来查询对应的农历日期**\n\n  基本原则：1900年1月31日为农历1900年的正月初一，利用农历和公历经过的总的时间相等这个原则，来推断查询日期的农历日期。\n\n  计算当前时间到1900年1月31日的时间差，利用Date.UTC()函数，这个函数返回的是毫秒数\n\n  时间差 =( Date.UTC(当前时间)-Date.UTC(1900年1月31日) )/每一天的毫秒数\n\n  农历日期简介：农历分为大小月，大月30天，小月29天，大约每19年加7个闰月，才能保证和公历的天数对应。\n\n  农历每年是否有闰月，每个月的对应天数都保存在lunarInfo这个数组里面。日期信息lunarInfo数组中，后四位代表这一年是否有闰月，以及润几月；若后四位为1111，则代表前一年的闰月为大月（30天）。\n\n   **农历年份的推算：**\n\n  利用查询的年月日距离1900年1月31日的天数依次减去农历每一年的天数，当差值为负数时跳出循环，可得到对应的农历年份。\n\n   **农历月份的推算：**\n    \n  利用当前日期当年已经过去了的天数依次减去这一年每个农历月的天数，当差值为负数时跳出循环，可得到对应的农历月份。（在循环的过程中要注意判断是否为闰月）\n\n   **农历日期的推算：**\n\n   当月过去了的日期即为对应的农历日期。\n\n**(4) 24节气判断规则**\n\n   每个公历月有两个节气，节气的信息存在数组solarTerm中，数组termInfo存放的是节气日期的定气常数（各个节气到小寒的分钟数）。\n\n   1900年小寒是1月6日2时5分，通过计算每一年的小寒距离1900年小寒的分钟数，来判断每一年小寒在哪一天，然后再根据节气日期的气定常数来判断每一年的其余的节气在哪一天。\n\n**(5) 判断某一天是否为基本的国际节假日**\n\n   国际节假日分为公历节日、农历节日、非公历农历节日（如母亲节：5月的第二个星期天）。公历节日的信息存放在CalFestival数组里面，农历节日的信息存放在LunarFestival数组里面，非公历农历节日信息放在OtherFestival数组里面。\n\n   通过判断要显示的这一天是否与数组中对应的信息一致，来决定是否显示节假日。\n\n**(6) 通过年份来查询对应的生肖**\n\n   12生肖信息存放在SXLibrary这个数组中。1900年是鼠年，通过当前输入的年份与1900年的差值除以12的余数，即可得到年份对应的生肖。\n\n**(7) 通过月份、日期来查询星座**\n\n   星座是根据阳历日期来的，星座信息放在XZLibrary这个数组中。通过输入的月份和、日期判断是否在各个星座的区间内，得出对应的星座。\n\n**(8)\t农历年、月、日的天干地支**\n\n   天干地支信息分别放在GLibrary、ZLibrary这两个数组中。\n\n   **年份的干支计算：**\n\n    天干 = （年份 – 3）%10\n    地支 = （年份 – 3）%12\n\n   **月份的干支计算：**\n\n   若遇甲或己的年份 ，正月是丙寅；遇上乙或庚之年，正月为戊寅；遇上丙或辛之年，正月为庚寅；遇上丁或壬之年，正月为壬寅；遇上戊或癸之年，正月为甲寅。依照正月之干支，其余月份按干支数组中的顺序推算即可。\n\n   **日期的干支计算：**\n\n  G =  4 *（世纪数 - 1）+ [（世纪数 - 1） / 4] + 5 *（年份后两位） + [年份后两位/ 4] + [3 * (月份 + 1) / 5] + 日期 - 3 \n  Z =  8（世纪数 - 1） + [（世纪数 - 1） / 4] + 5（年份后两位）+ [（年份后两位） / 4] + [3 * (月份 + 1) / 5] + 日期 + 7 + i    (奇数月i=0，偶数月i=6)\n  天干 = G%10\n  地支 = Z%12\n\n**(9) 2016年假日安排**\n\n  将2016年放假信息（假期截止日期和假期天数）存放在holidayPlan数组里，通过输入的月份和日期与数组中日期进行比较的，来对应显示是否是假期，若是假期，需要显示几天。\n\n  通过选择select框里面的假期来动态调用checkHolidayPlan()函数，显示当前所选假期的日期。\n\n**(10) 该天宜、忌事项**\n\n  由于没有找到对应的计算方式，于是自己制定了一个规则。\n\n  随机产生宜事项、忌事项的个数，然后通过该天的农历日期在gBLibrary中查找。\n\n**(11) 返回今天**\n\n  给“返回今天”按钮添加点击事件，点击按钮之后，让年份和月份的select的selectedIndex都指向今天的年份和月份。\n\n**(12) 根据年、月选择框实现月份的查询**\n\n  将年份、月份select框的selectedIndex值传给显示月份信息的函数displayTable(year,month)。\n\n\n### 三. 实现过程中的遇到的问题\n\n#### 1. 兼容性问题\n\n 手机端隐藏了一部分功能。\n\n**由于时间有限，PC端（不支持IE8及以下的浏览器）只调整了万年历在IE9下的兼容性问题，如下所示：**\n\n**(1) 由于布局中使用的是flex box，IE9不支持flexbox的一些属性。**\n\n在IE9中采用的是display:table;和display:table-cell；来代替flexbox布局，用border-spacing:5px  0px;代替margin值。\n最终布局在IE9中也展示良好。\n\n(2)\t由于在PC端，点击相应的日期，右边的信息模块也会跟着变化，\n\njs中用到了**event.currentTarget**属性，IE9也不支持这个属性\n在IE中使用**event.srcElement**来代替**event.currentTarget**，有一个问题是，event.srcElement获取的是当前触发事件的元素，可能不是我们期望的元素，因此需要添加一个判断，event.srcElement获取的是否是我们需要的元素。\n\n程序如下：\n\n/*点击每一天显示右边的信息栏*/\n\tfunction clickBox(boxObj,x,year,month){\n\t\tboxObj[x].onclick = function(){\n\t\t\tvar box = event.currentTarget ? event.currentTarget : event.srcElement;//解决IE9下没有currentTarget这个属性的问题\n\t\t\twhile(box.nodeName!=\"TD\")\n\t\t\t{\n\t\t\t\tbox = box.parentNode;  \n\t\t\t}\n\t\t    var targetDay = parseInt(box.firstChild.innerHTML);\n\t\t\n\t\t    var dayClick = new oneDayAll(year,month,targetDay);\n\t\t    displayRDayInfo(year,month,targetDay,dayClick.week);\n\t\t}\n\t}\n\n之前实现时，思路是给每一个box绑定一个onclick事件，但是后来发现，无论点击哪一个box，显示的都是最后一个方块的基本信息，这是一个闭包的问题，后来将i作为参数传进函数里，让闭包按照想要的方式运行了；这里可以使用事件委托机制。\n\n#### 2. 其他问题\n\n(1) 如何用js获取当前系统时间\n\n**Date()对象**\n\n自动获得当前日期和时间：\n\n\tvar timeNow = new Date();\n\n获得当前时间的年份：\n\n\ttimeNow.getFullYear();\n\n获得当前时间的月份：\n\n\ttimeNow.getMonth();//注意：月份是从0开始的\n\n获得当前时间的星期：\n\n\ttimeNow.getDay();//注意：0表示星期天\n\n获得当前时间的日期：\n\n\ttimeNow.getDate();\n\n获得当前时间的小时数：\n\n\ttimeNow.getHours();\n\n获得当前时间的分钟数：\n\t\n\ttimeNow.getMinutes();\n\n获得当前时间的秒数：\n\n\ttimeNow.getSeconds();\n\n如何显示当前北京时间：\n\n\t定义一个计时器，每隔1000毫秒调用一次获得当前系统时间的函数\n\n\t/*获取当前时间的函数*/\n\tfunction getTimeNow() {\n\t\t\t\t\n\tvar today = new Date(); //创建一个日期对象，新创建的对象自动获取当前系统的时间\t\n\tvar ThourNum, TminuteNum, TsecondNum;\n\tThourNum = today.getHours(); //得到当前小时\n\tTminuteNum = today.getMinutes(); //得到当前分钟\n\tTsecondNum = today.getSeconds(); //得到当前秒钟\t\t\t\t\t\t\t\n\tdisplayBjTime(ThourNum,TminuteNum,TsecondNum);//这是自己定义的一个以一定格式显示时间的函数\n\t\t\t\t\n\t}\n\twindow.setInterval(\"getTimeNow();\", 1000);//每隔一秒钟调用一次getTimeNow函数\n\n上面讲的都是如何获得当前系统时间，其实Date()对象也可以自己创建日期对象。\n\n\tvar someDate = new Date(2016,3,19);//基于本地时间创建日期对象\n\n\tvar someDate = new Date(Date.UTC(2016,3,19));//基于GMT时间创建日期对象\n\n(2) 不同进制数之间的转化\n\n**多进制转化为十进制**\n\neg: 二进制数11 转化为 十进制\n\n\tparseInt(\"11\",2); //3\n\n**十进制数转化为多进制**\n\neg: 十进制数4 转化为 二进制 \n\n\t(4).toString(2); //100\n\n(3) 位的操作\n\n\t~ 按位非\n\n\t& 按位与\n\n\t| 按位或\n\n\t^ 按位异或\n\n\t<< 左移\n\n\t>> 右移(有符号)\n\n\t>>右移(无符号)\n\n使用位操作写的一个函数getbit()\n\n\t/*得到m的二进制的右边数第n+1位（为0或者1）*/\n\tfunction getBit(m,n){\n\t\treturn (m >> n) & 1;\n\t}\n\n(4) this作为构造函数\n\n所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象\n\n\tfunction test(){\n\t　　　　\tthis.x = 1;\n\t　　}\n\t　　var o = new test();\n\t　　alert(o.x); // 1\n\n(5) eval()函数的使用\n\neval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\n\n\t<script type=\"text/javascript\">\n\t\n\t\teval(\"x=10;y=20;document.write(x*y)\");\n\t\t\n\t\tdocument.write(eval(\"2+2\"));\n\t\t\n\t\tvar x=10\n\t\tdocument.write(eval(x+17));\n\t\n\t</script>\n\n(6) 一些小的知识点\n\nselect框的每个可选值，都有一个selectedIndex属性，从0开始\n\n实现div hover之后加边框效果，出现抖动问题，可以首先给div加一个白色的边框占位。\n\n\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式\n\n移动端的问题：\n\n\t移动端需要加上\n\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n\twidth - viewport的宽度 \n\theight - viewport的高度\n\tinitial-scale - 初始的缩放比例\n\tminimum-scale - 允许用户缩放到的最小比例\n\tmaximum-scale - 允许用户缩放到的最大比例\n\tuser-scalable - 用户是否可以手动缩放\n\n   css中的1px并不等于设备的1px\n\n    css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。\n\t\n\t移动设备的屏幕像素密度越高，在同样大小的屏幕上，像素越多，这时，一个css像素是不等于一个物理像素的。\n\n    移动端中用户缩放也会引起css中px的变化，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。\n\n    在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。\n\n\tcss中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。但是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题。\n\n\n\n\n\n\n\n","source":"_posts/2016-04-19-万年历.md","raw":"---\nlayout: post\ntitle: 万年历插件\ndate: 2016-04-19\ncategories: Demo\ntags: [javaScript]\ndescription: \ndemo: 万年历\n---\n\n这个demo是一个日历查询的控件，兼容移动端和PC端（PC端支持chrome/QQ浏览器/搜狗浏览器/IE9及以上），由于时间有限，只测了一小部分的浏览器。\n\n### 一. 万年历demo地址\n\n万年历demo地址\n[http://panpanfish.com/myDemo/calendar.html](http://panpanfish.com/myDemo/calendar.html \"万年历效果\")\n\n万年历的代码地址\n[https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html](https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html \"万年历的代码地址\")\n\n### 二. 万年历的功能\n\n**PC端：**\n1. 显示当前年、月、日、星期、北京时间、农历24节气、基本的国际节假日、2016年假日安排；\n1. 通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期、该年生肖、该天星座、农历年月日的天干地支、该天宜忌事项；\n1. 通过假日名称来查询节假日安排；\n1. 点击“返回今天”能够回到当前日期。\n\n**移动端(隐藏了一部分功能)：**\n1. 显示当前年、月、日、北京时间、农历24节气、基本的国际节假日、2016年假日安排；\n1. 通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期；\n1. 通过假日名称来查询节假日安排；\n\n#### 1. 每个功能的实现思路\n\n**(1) 显示当前年、月、日、星期**\n\n  创建一个Date对象，分别通过Date对象的getFullYear()、getMonth()、getDate()、getDay()来获取当前的年、月、日、星期。\n\n**(2) 显示北京时间**\n\n  创建一个Date对象，分别通过Date对象的getHours()、getMinutes()、getSeconds()来获取当前的时、分、秒。并以1000毫秒为一个周期来调用这些函数。\n\n**(3) 通过年、月、日来查询对应的农历日期**\n\n  基本原则：1900年1月31日为农历1900年的正月初一，利用农历和公历经过的总的时间相等这个原则，来推断查询日期的农历日期。\n\n  计算当前时间到1900年1月31日的时间差，利用Date.UTC()函数，这个函数返回的是毫秒数\n\n  时间差 =( Date.UTC(当前时间)-Date.UTC(1900年1月31日) )/每一天的毫秒数\n\n  农历日期简介：农历分为大小月，大月30天，小月29天，大约每19年加7个闰月，才能保证和公历的天数对应。\n\n  农历每年是否有闰月，每个月的对应天数都保存在lunarInfo这个数组里面。日期信息lunarInfo数组中，后四位代表这一年是否有闰月，以及润几月；若后四位为1111，则代表前一年的闰月为大月（30天）。\n\n   **农历年份的推算：**\n\n  利用查询的年月日距离1900年1月31日的天数依次减去农历每一年的天数，当差值为负数时跳出循环，可得到对应的农历年份。\n\n   **农历月份的推算：**\n    \n  利用当前日期当年已经过去了的天数依次减去这一年每个农历月的天数，当差值为负数时跳出循环，可得到对应的农历月份。（在循环的过程中要注意判断是否为闰月）\n\n   **农历日期的推算：**\n\n   当月过去了的日期即为对应的农历日期。\n\n**(4) 24节气判断规则**\n\n   每个公历月有两个节气，节气的信息存在数组solarTerm中，数组termInfo存放的是节气日期的定气常数（各个节气到小寒的分钟数）。\n\n   1900年小寒是1月6日2时5分，通过计算每一年的小寒距离1900年小寒的分钟数，来判断每一年小寒在哪一天，然后再根据节气日期的气定常数来判断每一年的其余的节气在哪一天。\n\n**(5) 判断某一天是否为基本的国际节假日**\n\n   国际节假日分为公历节日、农历节日、非公历农历节日（如母亲节：5月的第二个星期天）。公历节日的信息存放在CalFestival数组里面，农历节日的信息存放在LunarFestival数组里面，非公历农历节日信息放在OtherFestival数组里面。\n\n   通过判断要显示的这一天是否与数组中对应的信息一致，来决定是否显示节假日。\n\n**(6) 通过年份来查询对应的生肖**\n\n   12生肖信息存放在SXLibrary这个数组中。1900年是鼠年，通过当前输入的年份与1900年的差值除以12的余数，即可得到年份对应的生肖。\n\n**(7) 通过月份、日期来查询星座**\n\n   星座是根据阳历日期来的，星座信息放在XZLibrary这个数组中。通过输入的月份和、日期判断是否在各个星座的区间内，得出对应的星座。\n\n**(8)\t农历年、月、日的天干地支**\n\n   天干地支信息分别放在GLibrary、ZLibrary这两个数组中。\n\n   **年份的干支计算：**\n\n    天干 = （年份 – 3）%10\n    地支 = （年份 – 3）%12\n\n   **月份的干支计算：**\n\n   若遇甲或己的年份 ，正月是丙寅；遇上乙或庚之年，正月为戊寅；遇上丙或辛之年，正月为庚寅；遇上丁或壬之年，正月为壬寅；遇上戊或癸之年，正月为甲寅。依照正月之干支，其余月份按干支数组中的顺序推算即可。\n\n   **日期的干支计算：**\n\n  G =  4 *（世纪数 - 1）+ [（世纪数 - 1） / 4] + 5 *（年份后两位） + [年份后两位/ 4] + [3 * (月份 + 1) / 5] + 日期 - 3 \n  Z =  8（世纪数 - 1） + [（世纪数 - 1） / 4] + 5（年份后两位）+ [（年份后两位） / 4] + [3 * (月份 + 1) / 5] + 日期 + 7 + i    (奇数月i=0，偶数月i=6)\n  天干 = G%10\n  地支 = Z%12\n\n**(9) 2016年假日安排**\n\n  将2016年放假信息（假期截止日期和假期天数）存放在holidayPlan数组里，通过输入的月份和日期与数组中日期进行比较的，来对应显示是否是假期，若是假期，需要显示几天。\n\n  通过选择select框里面的假期来动态调用checkHolidayPlan()函数，显示当前所选假期的日期。\n\n**(10) 该天宜、忌事项**\n\n  由于没有找到对应的计算方式，于是自己制定了一个规则。\n\n  随机产生宜事项、忌事项的个数，然后通过该天的农历日期在gBLibrary中查找。\n\n**(11) 返回今天**\n\n  给“返回今天”按钮添加点击事件，点击按钮之后，让年份和月份的select的selectedIndex都指向今天的年份和月份。\n\n**(12) 根据年、月选择框实现月份的查询**\n\n  将年份、月份select框的selectedIndex值传给显示月份信息的函数displayTable(year,month)。\n\n\n### 三. 实现过程中的遇到的问题\n\n#### 1. 兼容性问题\n\n 手机端隐藏了一部分功能。\n\n**由于时间有限，PC端（不支持IE8及以下的浏览器）只调整了万年历在IE9下的兼容性问题，如下所示：**\n\n**(1) 由于布局中使用的是flex box，IE9不支持flexbox的一些属性。**\n\n在IE9中采用的是display:table;和display:table-cell；来代替flexbox布局，用border-spacing:5px  0px;代替margin值。\n最终布局在IE9中也展示良好。\n\n(2)\t由于在PC端，点击相应的日期，右边的信息模块也会跟着变化，\n\njs中用到了**event.currentTarget**属性，IE9也不支持这个属性\n在IE中使用**event.srcElement**来代替**event.currentTarget**，有一个问题是，event.srcElement获取的是当前触发事件的元素，可能不是我们期望的元素，因此需要添加一个判断，event.srcElement获取的是否是我们需要的元素。\n\n程序如下：\n\n/*点击每一天显示右边的信息栏*/\n\tfunction clickBox(boxObj,x,year,month){\n\t\tboxObj[x].onclick = function(){\n\t\t\tvar box = event.currentTarget ? event.currentTarget : event.srcElement;//解决IE9下没有currentTarget这个属性的问题\n\t\t\twhile(box.nodeName!=\"TD\")\n\t\t\t{\n\t\t\t\tbox = box.parentNode;  \n\t\t\t}\n\t\t    var targetDay = parseInt(box.firstChild.innerHTML);\n\t\t\n\t\t    var dayClick = new oneDayAll(year,month,targetDay);\n\t\t    displayRDayInfo(year,month,targetDay,dayClick.week);\n\t\t}\n\t}\n\n之前实现时，思路是给每一个box绑定一个onclick事件，但是后来发现，无论点击哪一个box，显示的都是最后一个方块的基本信息，这是一个闭包的问题，后来将i作为参数传进函数里，让闭包按照想要的方式运行了；这里可以使用事件委托机制。\n\n#### 2. 其他问题\n\n(1) 如何用js获取当前系统时间\n\n**Date()对象**\n\n自动获得当前日期和时间：\n\n\tvar timeNow = new Date();\n\n获得当前时间的年份：\n\n\ttimeNow.getFullYear();\n\n获得当前时间的月份：\n\n\ttimeNow.getMonth();//注意：月份是从0开始的\n\n获得当前时间的星期：\n\n\ttimeNow.getDay();//注意：0表示星期天\n\n获得当前时间的日期：\n\n\ttimeNow.getDate();\n\n获得当前时间的小时数：\n\n\ttimeNow.getHours();\n\n获得当前时间的分钟数：\n\t\n\ttimeNow.getMinutes();\n\n获得当前时间的秒数：\n\n\ttimeNow.getSeconds();\n\n如何显示当前北京时间：\n\n\t定义一个计时器，每隔1000毫秒调用一次获得当前系统时间的函数\n\n\t/*获取当前时间的函数*/\n\tfunction getTimeNow() {\n\t\t\t\t\n\tvar today = new Date(); //创建一个日期对象，新创建的对象自动获取当前系统的时间\t\n\tvar ThourNum, TminuteNum, TsecondNum;\n\tThourNum = today.getHours(); //得到当前小时\n\tTminuteNum = today.getMinutes(); //得到当前分钟\n\tTsecondNum = today.getSeconds(); //得到当前秒钟\t\t\t\t\t\t\t\n\tdisplayBjTime(ThourNum,TminuteNum,TsecondNum);//这是自己定义的一个以一定格式显示时间的函数\n\t\t\t\t\n\t}\n\twindow.setInterval(\"getTimeNow();\", 1000);//每隔一秒钟调用一次getTimeNow函数\n\n上面讲的都是如何获得当前系统时间，其实Date()对象也可以自己创建日期对象。\n\n\tvar someDate = new Date(2016,3,19);//基于本地时间创建日期对象\n\n\tvar someDate = new Date(Date.UTC(2016,3,19));//基于GMT时间创建日期对象\n\n(2) 不同进制数之间的转化\n\n**多进制转化为十进制**\n\neg: 二进制数11 转化为 十进制\n\n\tparseInt(\"11\",2); //3\n\n**十进制数转化为多进制**\n\neg: 十进制数4 转化为 二进制 \n\n\t(4).toString(2); //100\n\n(3) 位的操作\n\n\t~ 按位非\n\n\t& 按位与\n\n\t| 按位或\n\n\t^ 按位异或\n\n\t<< 左移\n\n\t>> 右移(有符号)\n\n\t>>右移(无符号)\n\n使用位操作写的一个函数getbit()\n\n\t/*得到m的二进制的右边数第n+1位（为0或者1）*/\n\tfunction getBit(m,n){\n\t\treturn (m >> n) & 1;\n\t}\n\n(4) this作为构造函数\n\n所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象\n\n\tfunction test(){\n\t　　　　\tthis.x = 1;\n\t　　}\n\t　　var o = new test();\n\t　　alert(o.x); // 1\n\n(5) eval()函数的使用\n\neval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\n\n\t<script type=\"text/javascript\">\n\t\n\t\teval(\"x=10;y=20;document.write(x*y)\");\n\t\t\n\t\tdocument.write(eval(\"2+2\"));\n\t\t\n\t\tvar x=10\n\t\tdocument.write(eval(x+17));\n\t\n\t</script>\n\n(6) 一些小的知识点\n\nselect框的每个可选值，都有一个selectedIndex属性，从0开始\n\n实现div hover之后加边框效果，出现抖动问题，可以首先给div加一个白色的边框占位。\n\n\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式\n\n移动端的问题：\n\n\t移动端需要加上\n\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n\twidth - viewport的宽度 \n\theight - viewport的高度\n\tinitial-scale - 初始的缩放比例\n\tminimum-scale - 允许用户缩放到的最小比例\n\tmaximum-scale - 允许用户缩放到的最大比例\n\tuser-scalable - 用户是否可以手动缩放\n\n   css中的1px并不等于设备的1px\n\n    css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。\n\t\n\t移动设备的屏幕像素密度越高，在同样大小的屏幕上，像素越多，这时，一个css像素是不等于一个物理像素的。\n\n    移动端中用户缩放也会引起css中px的变化，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。\n\n    在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。\n\n\tcss中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。但是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题。\n\n\n\n\n\n\n\n","slug":"2016-04-19-万年历","published":1,"updated":"2016-08-11T07:26:32.000Z","comments":1,"photos":[],"link":"","_id":"cj035oce9002yd5u8g4jd6alx","content":"<p>这个demo是一个日历查询的控件，兼容移动端和PC端（PC端支持chrome/QQ浏览器/搜狗浏览器/IE9及以上），由于时间有限，只测了一小部分的浏览器。</p>\n<h3 id=\"一-万年历demo地址\"><a href=\"#一-万年历demo地址\" class=\"headerlink\" title=\"一. 万年历demo地址\"></a>一. 万年历demo地址</h3><p>万年历demo地址<br><a href=\"http://panpanfish.com/myDemo/calendar.html\" title=\"万年历效果\">http://panpanfish.com/myDemo/calendar.html</a></p>\n<p>万年历的代码地址<br><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html\" title=\"万年历的代码地址\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html</a></p>\n<h3 id=\"二-万年历的功能\"><a href=\"#二-万年历的功能\" class=\"headerlink\" title=\"二. 万年历的功能\"></a>二. 万年历的功能</h3><p><strong>PC端：</strong></p>\n<ol>\n<li>显示当前年、月、日、星期、北京时间、农历24节气、基本的国际节假日、2016年假日安排；</li>\n<li>通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期、该年生肖、该天星座、农历年月日的天干地支、该天宜忌事项；</li>\n<li>通过假日名称来查询节假日安排；</li>\n<li>点击“返回今天”能够回到当前日期。</li>\n</ol>\n<p><strong>移动端(隐藏了一部分功能)：</strong></p>\n<ol>\n<li>显示当前年、月、日、北京时间、农历24节气、基本的国际节假日、2016年假日安排；</li>\n<li>通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期；</li>\n<li>通过假日名称来查询节假日安排；</li>\n</ol>\n<h4 id=\"1-每个功能的实现思路\"><a href=\"#1-每个功能的实现思路\" class=\"headerlink\" title=\"1. 每个功能的实现思路\"></a>1. 每个功能的实现思路</h4><p><strong>(1) 显示当前年、月、日、星期</strong></p>\n<p>  创建一个Date对象，分别通过Date对象的getFullYear()、getMonth()、getDate()、getDay()来获取当前的年、月、日、星期。</p>\n<p><strong>(2) 显示北京时间</strong></p>\n<p>  创建一个Date对象，分别通过Date对象的getHours()、getMinutes()、getSeconds()来获取当前的时、分、秒。并以1000毫秒为一个周期来调用这些函数。</p>\n<p><strong>(3) 通过年、月、日来查询对应的农历日期</strong></p>\n<p>  基本原则：1900年1月31日为农历1900年的正月初一，利用农历和公历经过的总的时间相等这个原则，来推断查询日期的农历日期。</p>\n<p>  计算当前时间到1900年1月31日的时间差，利用Date.UTC()函数，这个函数返回的是毫秒数</p>\n<p>  时间差 =( Date.UTC(当前时间)-Date.UTC(1900年1月31日) )/每一天的毫秒数</p>\n<p>  农历日期简介：农历分为大小月，大月30天，小月29天，大约每19年加7个闰月，才能保证和公历的天数对应。</p>\n<p>  农历每年是否有闰月，每个月的对应天数都保存在lunarInfo这个数组里面。日期信息lunarInfo数组中，后四位代表这一年是否有闰月，以及润几月；若后四位为1111，则代表前一年的闰月为大月（30天）。</p>\n<p>   <strong>农历年份的推算：</strong></p>\n<p>  利用查询的年月日距离1900年1月31日的天数依次减去农历每一年的天数，当差值为负数时跳出循环，可得到对应的农历年份。</p>\n<p>   <strong>农历月份的推算：</strong></p>\n<p>  利用当前日期当年已经过去了的天数依次减去这一年每个农历月的天数，当差值为负数时跳出循环，可得到对应的农历月份。（在循环的过程中要注意判断是否为闰月）</p>\n<p>   <strong>农历日期的推算：</strong></p>\n<p>   当月过去了的日期即为对应的农历日期。</p>\n<p><strong>(4) 24节气判断规则</strong></p>\n<p>   每个公历月有两个节气，节气的信息存在数组solarTerm中，数组termInfo存放的是节气日期的定气常数（各个节气到小寒的分钟数）。</p>\n<p>   1900年小寒是1月6日2时5分，通过计算每一年的小寒距离1900年小寒的分钟数，来判断每一年小寒在哪一天，然后再根据节气日期的气定常数来判断每一年的其余的节气在哪一天。</p>\n<p><strong>(5) 判断某一天是否为基本的国际节假日</strong></p>\n<p>   国际节假日分为公历节日、农历节日、非公历农历节日（如母亲节：5月的第二个星期天）。公历节日的信息存放在CalFestival数组里面，农历节日的信息存放在LunarFestival数组里面，非公历农历节日信息放在OtherFestival数组里面。</p>\n<p>   通过判断要显示的这一天是否与数组中对应的信息一致，来决定是否显示节假日。</p>\n<p><strong>(6) 通过年份来查询对应的生肖</strong></p>\n<p>   12生肖信息存放在SXLibrary这个数组中。1900年是鼠年，通过当前输入的年份与1900年的差值除以12的余数，即可得到年份对应的生肖。</p>\n<p><strong>(7) 通过月份、日期来查询星座</strong></p>\n<p>   星座是根据阳历日期来的，星座信息放在XZLibrary这个数组中。通过输入的月份和、日期判断是否在各个星座的区间内，得出对应的星座。</p>\n<p><strong>(8)    农历年、月、日的天干地支</strong></p>\n<p>   天干地支信息分别放在GLibrary、ZLibrary这两个数组中。</p>\n<p>   <strong>年份的干支计算：</strong></p>\n<pre><code>天干 = （年份 – 3）%10\n地支 = （年份 – 3）%12\n</code></pre><p>   <strong>月份的干支计算：</strong></p>\n<p>   若遇甲或己的年份 ，正月是丙寅；遇上乙或庚之年，正月为戊寅；遇上丙或辛之年，正月为庚寅；遇上丁或壬之年，正月为壬寅；遇上戊或癸之年，正月为甲寅。依照正月之干支，其余月份按干支数组中的顺序推算即可。</p>\n<p>   <strong>日期的干支计算：</strong></p>\n<p>  G =  4 <em>（世纪数 - 1）+ [（世纪数 - 1） / 4] + 5 </em>（年份后两位） + [年份后两位/ 4] + [3 <em> (月份 + 1) / 5] + 日期 - 3<br>  Z =  8（世纪数 - 1） + [（世纪数 - 1） / 4] + 5（年份后两位）+ [（年份后两位） / 4] + [3 </em> (月份 + 1) / 5] + 日期 + 7 + i    (奇数月i=0，偶数月i=6)<br>  天干 = G%10<br>  地支 = Z%12</p>\n<p><strong>(9) 2016年假日安排</strong></p>\n<p>  将2016年放假信息（假期截止日期和假期天数）存放在holidayPlan数组里，通过输入的月份和日期与数组中日期进行比较的，来对应显示是否是假期，若是假期，需要显示几天。</p>\n<p>  通过选择select框里面的假期来动态调用checkHolidayPlan()函数，显示当前所选假期的日期。</p>\n<p><strong>(10) 该天宜、忌事项</strong></p>\n<p>  由于没有找到对应的计算方式，于是自己制定了一个规则。</p>\n<p>  随机产生宜事项、忌事项的个数，然后通过该天的农历日期在gBLibrary中查找。</p>\n<p><strong>(11) 返回今天</strong></p>\n<p>  给“返回今天”按钮添加点击事件，点击按钮之后，让年份和月份的select的selectedIndex都指向今天的年份和月份。</p>\n<p><strong>(12) 根据年、月选择框实现月份的查询</strong></p>\n<p>  将年份、月份select框的selectedIndex值传给显示月份信息的函数displayTable(year,month)。</p>\n<h3 id=\"三-实现过程中的遇到的问题\"><a href=\"#三-实现过程中的遇到的问题\" class=\"headerlink\" title=\"三. 实现过程中的遇到的问题\"></a>三. 实现过程中的遇到的问题</h3><h4 id=\"1-兼容性问题\"><a href=\"#1-兼容性问题\" class=\"headerlink\" title=\"1. 兼容性问题\"></a>1. 兼容性问题</h4><p> 手机端隐藏了一部分功能。</p>\n<p><strong>由于时间有限，PC端（不支持IE8及以下的浏览器）只调整了万年历在IE9下的兼容性问题，如下所示：</strong></p>\n<p><strong>(1) 由于布局中使用的是flex box，IE9不支持flexbox的一些属性。</strong></p>\n<p>在IE9中采用的是display:table;和display:table-cell；来代替flexbox布局，用border-spacing:5px  0px;代替margin值。<br>最终布局在IE9中也展示良好。</p>\n<p>(2)    由于在PC端，点击相应的日期，右边的信息模块也会跟着变化，</p>\n<p>js中用到了<strong>event.currentTarget</strong>属性，IE9也不支持这个属性<br>在IE中使用<strong>event.srcElement</strong>来代替<strong>event.currentTarget</strong>，有一个问题是，event.srcElement获取的是当前触发事件的元素，可能不是我们期望的元素，因此需要添加一个判断，event.srcElement获取的是否是我们需要的元素。</p>\n<p>程序如下：</p>\n<p>/<em>点击每一天显示右边的信息栏</em>/<br>    function clickBox(boxObj,x,year,month){<br>        boxObj[x].onclick = function(){<br>            var box = event.currentTarget ? event.currentTarget : event.srcElement;//解决IE9下没有currentTarget这个属性的问题<br>            while(box.nodeName!=”TD”)<br>            {<br>                box = box.parentNode;<br>            }<br>            var targetDay = parseInt(box.firstChild.innerHTML);</p>\n<pre><code>        var dayClick = new oneDayAll(year,month,targetDay);\n        displayRDayInfo(year,month,targetDay,dayClick.week);\n    }\n}\n</code></pre><p>之前实现时，思路是给每一个box绑定一个onclick事件，但是后来发现，无论点击哪一个box，显示的都是最后一个方块的基本信息，这是一个闭包的问题，后来将i作为参数传进函数里，让闭包按照想要的方式运行了；这里可以使用事件委托机制。</p>\n<h4 id=\"2-其他问题\"><a href=\"#2-其他问题\" class=\"headerlink\" title=\"2. 其他问题\"></a>2. 其他问题</h4><p>(1) 如何用js获取当前系统时间</p>\n<p><strong>Date()对象</strong></p>\n<p>自动获得当前日期和时间：</p>\n<pre><code>var timeNow = new Date();\n</code></pre><p>获得当前时间的年份：</p>\n<pre><code>timeNow.getFullYear();\n</code></pre><p>获得当前时间的月份：</p>\n<pre><code>timeNow.getMonth();//注意：月份是从0开始的\n</code></pre><p>获得当前时间的星期：</p>\n<pre><code>timeNow.getDay();//注意：0表示星期天\n</code></pre><p>获得当前时间的日期：</p>\n<pre><code>timeNow.getDate();\n</code></pre><p>获得当前时间的小时数：</p>\n<pre><code>timeNow.getHours();\n</code></pre><p>获得当前时间的分钟数：</p>\n<pre><code>timeNow.getMinutes();\n</code></pre><p>获得当前时间的秒数：</p>\n<pre><code>timeNow.getSeconds();\n</code></pre><p>如何显示当前北京时间：</p>\n<pre><code>定义一个计时器，每隔1000毫秒调用一次获得当前系统时间的函数\n\n/*获取当前时间的函数*/\nfunction getTimeNow() {\n\nvar today = new Date(); //创建一个日期对象，新创建的对象自动获取当前系统的时间    \nvar ThourNum, TminuteNum, TsecondNum;\nThourNum = today.getHours(); //得到当前小时\nTminuteNum = today.getMinutes(); //得到当前分钟\nTsecondNum = today.getSeconds(); //得到当前秒钟                            \ndisplayBjTime(ThourNum,TminuteNum,TsecondNum);//这是自己定义的一个以一定格式显示时间的函数\n\n}\nwindow.setInterval(&quot;getTimeNow();&quot;, 1000);//每隔一秒钟调用一次getTimeNow函数\n</code></pre><p>上面讲的都是如何获得当前系统时间，其实Date()对象也可以自己创建日期对象。</p>\n<pre><code>var someDate = new Date(2016,3,19);//基于本地时间创建日期对象\n\nvar someDate = new Date(Date.UTC(2016,3,19));//基于GMT时间创建日期对象\n</code></pre><p>(2) 不同进制数之间的转化</p>\n<p><strong>多进制转化为十进制</strong></p>\n<p>eg: 二进制数11 转化为 十进制</p>\n<pre><code>parseInt(&quot;11&quot;,2); //3\n</code></pre><p><strong>十进制数转化为多进制</strong></p>\n<p>eg: 十进制数4 转化为 二进制 </p>\n<pre><code>(4).toString(2); //100\n</code></pre><p>(3) 位的操作</p>\n<pre><code>~ 按位非\n\n&amp; 按位与\n\n| 按位或\n\n^ 按位异或\n\n&lt;&lt; 左移\n\n&gt;&gt; 右移(有符号)\n\n&gt;&gt;右移(无符号)\n</code></pre><p>使用位操作写的一个函数getbit()</p>\n<pre><code>/*得到m的二进制的右边数第n+1位（为0或者1）*/\nfunction getBit(m,n){\n    return (m &gt;&gt; n) &amp; 1;\n}\n</code></pre><p>(4) this作为构造函数</p>\n<p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象</p>\n<pre><code>function test(){\n　　　　    this.x = 1;\n　　}\n　　var o = new test();\n　　alert(o.x); // 1\n</code></pre><p>(5) eval()函数的使用</p>\n<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n\n    eval(&quot;x=10;y=20;document.write(x*y)&quot;);\n\n    document.write(eval(&quot;2+2&quot;));\n\n    var x=10\n    document.write(eval(x+17));\n\n&lt;/script&gt;\n</code></pre><p>(6) 一些小的知识点</p>\n<p>select框的每个可选值，都有一个selectedIndex属性，从0开始</p>\n<p>实现div hover之后加边框效果，出现抖动问题，可以首先给div加一个白色的边框占位。</p>\n<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式\n</code></pre><p>移动端的问题：</p>\n<pre><code>移动端需要加上\n\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n\nwidth - viewport的宽度 \nheight - viewport的高度\ninitial-scale - 初始的缩放比例\nminimum-scale - 允许用户缩放到的最小比例\nmaximum-scale - 允许用户缩放到的最大比例\nuser-scalable - 用户是否可以手动缩放\n</code></pre><p>   css中的1px并不等于设备的1px</p>\n<pre><code>css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。\n\n移动设备的屏幕像素密度越高，在同样大小的屏幕上，像素越多，这时，一个css像素是不等于一个物理像素的。\n\n移动端中用户缩放也会引起css中px的变化，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。\n\n在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。\n\ncss中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。但是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题。\n</code></pre>","excerpt":"","more":"<p>这个demo是一个日历查询的控件，兼容移动端和PC端（PC端支持chrome/QQ浏览器/搜狗浏览器/IE9及以上），由于时间有限，只测了一小部分的浏览器。</p>\n<h3 id=\"一-万年历demo地址\"><a href=\"#一-万年历demo地址\" class=\"headerlink\" title=\"一. 万年历demo地址\"></a>一. 万年历demo地址</h3><p>万年历demo地址<br><a href=\"http://panpanfish.com/myDemo/calendar.html\" title=\"万年历效果\">http://panpanfish.com/myDemo/calendar.html</a></p>\n<p>万年历的代码地址<br><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html\" title=\"万年历的代码地址\">https://github.com/panpan040828/myDemo/blob/gh-pages/calendar.html</a></p>\n<h3 id=\"二-万年历的功能\"><a href=\"#二-万年历的功能\" class=\"headerlink\" title=\"二. 万年历的功能\"></a>二. 万年历的功能</h3><p><strong>PC端：</strong></p>\n<ol>\n<li>显示当前年、月、日、星期、北京时间、农历24节气、基本的国际节假日、2016年假日安排；</li>\n<li>通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期、该年生肖、该天星座、农历年月日的天干地支、该天宜忌事项；</li>\n<li>通过假日名称来查询节假日安排；</li>\n<li>点击“返回今天”能够回到当前日期。</li>\n</ol>\n<p><strong>移动端(隐藏了一部分功能)：</strong></p>\n<ol>\n<li>显示当前年、月、日、北京时间、农历24节气、基本的国际节假日、2016年假日安排；</li>\n<li>通过年（1901 ~ 2049）、月、日来查询相应的星期、农历日期；</li>\n<li>通过假日名称来查询节假日安排；</li>\n</ol>\n<h4 id=\"1-每个功能的实现思路\"><a href=\"#1-每个功能的实现思路\" class=\"headerlink\" title=\"1. 每个功能的实现思路\"></a>1. 每个功能的实现思路</h4><p><strong>(1) 显示当前年、月、日、星期</strong></p>\n<p>  创建一个Date对象，分别通过Date对象的getFullYear()、getMonth()、getDate()、getDay()来获取当前的年、月、日、星期。</p>\n<p><strong>(2) 显示北京时间</strong></p>\n<p>  创建一个Date对象，分别通过Date对象的getHours()、getMinutes()、getSeconds()来获取当前的时、分、秒。并以1000毫秒为一个周期来调用这些函数。</p>\n<p><strong>(3) 通过年、月、日来查询对应的农历日期</strong></p>\n<p>  基本原则：1900年1月31日为农历1900年的正月初一，利用农历和公历经过的总的时间相等这个原则，来推断查询日期的农历日期。</p>\n<p>  计算当前时间到1900年1月31日的时间差，利用Date.UTC()函数，这个函数返回的是毫秒数</p>\n<p>  时间差 =( Date.UTC(当前时间)-Date.UTC(1900年1月31日) )/每一天的毫秒数</p>\n<p>  农历日期简介：农历分为大小月，大月30天，小月29天，大约每19年加7个闰月，才能保证和公历的天数对应。</p>\n<p>  农历每年是否有闰月，每个月的对应天数都保存在lunarInfo这个数组里面。日期信息lunarInfo数组中，后四位代表这一年是否有闰月，以及润几月；若后四位为1111，则代表前一年的闰月为大月（30天）。</p>\n<p>   <strong>农历年份的推算：</strong></p>\n<p>  利用查询的年月日距离1900年1月31日的天数依次减去农历每一年的天数，当差值为负数时跳出循环，可得到对应的农历年份。</p>\n<p>   <strong>农历月份的推算：</strong></p>\n<p>  利用当前日期当年已经过去了的天数依次减去这一年每个农历月的天数，当差值为负数时跳出循环，可得到对应的农历月份。（在循环的过程中要注意判断是否为闰月）</p>\n<p>   <strong>农历日期的推算：</strong></p>\n<p>   当月过去了的日期即为对应的农历日期。</p>\n<p><strong>(4) 24节气判断规则</strong></p>\n<p>   每个公历月有两个节气，节气的信息存在数组solarTerm中，数组termInfo存放的是节气日期的定气常数（各个节气到小寒的分钟数）。</p>\n<p>   1900年小寒是1月6日2时5分，通过计算每一年的小寒距离1900年小寒的分钟数，来判断每一年小寒在哪一天，然后再根据节气日期的气定常数来判断每一年的其余的节气在哪一天。</p>\n<p><strong>(5) 判断某一天是否为基本的国际节假日</strong></p>\n<p>   国际节假日分为公历节日、农历节日、非公历农历节日（如母亲节：5月的第二个星期天）。公历节日的信息存放在CalFestival数组里面，农历节日的信息存放在LunarFestival数组里面，非公历农历节日信息放在OtherFestival数组里面。</p>\n<p>   通过判断要显示的这一天是否与数组中对应的信息一致，来决定是否显示节假日。</p>\n<p><strong>(6) 通过年份来查询对应的生肖</strong></p>\n<p>   12生肖信息存放在SXLibrary这个数组中。1900年是鼠年，通过当前输入的年份与1900年的差值除以12的余数，即可得到年份对应的生肖。</p>\n<p><strong>(7) 通过月份、日期来查询星座</strong></p>\n<p>   星座是根据阳历日期来的，星座信息放在XZLibrary这个数组中。通过输入的月份和、日期判断是否在各个星座的区间内，得出对应的星座。</p>\n<p><strong>(8)    农历年、月、日的天干地支</strong></p>\n<p>   天干地支信息分别放在GLibrary、ZLibrary这两个数组中。</p>\n<p>   <strong>年份的干支计算：</strong></p>\n<pre><code>天干 = （年份 – 3）%10\n地支 = （年份 – 3）%12\n</code></pre><p>   <strong>月份的干支计算：</strong></p>\n<p>   若遇甲或己的年份 ，正月是丙寅；遇上乙或庚之年，正月为戊寅；遇上丙或辛之年，正月为庚寅；遇上丁或壬之年，正月为壬寅；遇上戊或癸之年，正月为甲寅。依照正月之干支，其余月份按干支数组中的顺序推算即可。</p>\n<p>   <strong>日期的干支计算：</strong></p>\n<p>  G =  4 <em>（世纪数 - 1）+ [（世纪数 - 1） / 4] + 5 </em>（年份后两位） + [年份后两位/ 4] + [3 <em> (月份 + 1) / 5] + 日期 - 3<br>  Z =  8（世纪数 - 1） + [（世纪数 - 1） / 4] + 5（年份后两位）+ [（年份后两位） / 4] + [3 </em> (月份 + 1) / 5] + 日期 + 7 + i    (奇数月i=0，偶数月i=6)<br>  天干 = G%10<br>  地支 = Z%12</p>\n<p><strong>(9) 2016年假日安排</strong></p>\n<p>  将2016年放假信息（假期截止日期和假期天数）存放在holidayPlan数组里，通过输入的月份和日期与数组中日期进行比较的，来对应显示是否是假期，若是假期，需要显示几天。</p>\n<p>  通过选择select框里面的假期来动态调用checkHolidayPlan()函数，显示当前所选假期的日期。</p>\n<p><strong>(10) 该天宜、忌事项</strong></p>\n<p>  由于没有找到对应的计算方式，于是自己制定了一个规则。</p>\n<p>  随机产生宜事项、忌事项的个数，然后通过该天的农历日期在gBLibrary中查找。</p>\n<p><strong>(11) 返回今天</strong></p>\n<p>  给“返回今天”按钮添加点击事件，点击按钮之后，让年份和月份的select的selectedIndex都指向今天的年份和月份。</p>\n<p><strong>(12) 根据年、月选择框实现月份的查询</strong></p>\n<p>  将年份、月份select框的selectedIndex值传给显示月份信息的函数displayTable(year,month)。</p>\n<h3 id=\"三-实现过程中的遇到的问题\"><a href=\"#三-实现过程中的遇到的问题\" class=\"headerlink\" title=\"三. 实现过程中的遇到的问题\"></a>三. 实现过程中的遇到的问题</h3><h4 id=\"1-兼容性问题\"><a href=\"#1-兼容性问题\" class=\"headerlink\" title=\"1. 兼容性问题\"></a>1. 兼容性问题</h4><p> 手机端隐藏了一部分功能。</p>\n<p><strong>由于时间有限，PC端（不支持IE8及以下的浏览器）只调整了万年历在IE9下的兼容性问题，如下所示：</strong></p>\n<p><strong>(1) 由于布局中使用的是flex box，IE9不支持flexbox的一些属性。</strong></p>\n<p>在IE9中采用的是display:table;和display:table-cell；来代替flexbox布局，用border-spacing:5px  0px;代替margin值。<br>最终布局在IE9中也展示良好。</p>\n<p>(2)    由于在PC端，点击相应的日期，右边的信息模块也会跟着变化，</p>\n<p>js中用到了<strong>event.currentTarget</strong>属性，IE9也不支持这个属性<br>在IE中使用<strong>event.srcElement</strong>来代替<strong>event.currentTarget</strong>，有一个问题是，event.srcElement获取的是当前触发事件的元素，可能不是我们期望的元素，因此需要添加一个判断，event.srcElement获取的是否是我们需要的元素。</p>\n<p>程序如下：</p>\n<p>/<em>点击每一天显示右边的信息栏</em>/<br>    function clickBox(boxObj,x,year,month){<br>        boxObj[x].onclick = function(){<br>            var box = event.currentTarget ? event.currentTarget : event.srcElement;//解决IE9下没有currentTarget这个属性的问题<br>            while(box.nodeName!=”TD”)<br>            {<br>                box = box.parentNode;<br>            }<br>            var targetDay = parseInt(box.firstChild.innerHTML);</p>\n<pre><code>        var dayClick = new oneDayAll(year,month,targetDay);\n        displayRDayInfo(year,month,targetDay,dayClick.week);\n    }\n}\n</code></pre><p>之前实现时，思路是给每一个box绑定一个onclick事件，但是后来发现，无论点击哪一个box，显示的都是最后一个方块的基本信息，这是一个闭包的问题，后来将i作为参数传进函数里，让闭包按照想要的方式运行了；这里可以使用事件委托机制。</p>\n<h4 id=\"2-其他问题\"><a href=\"#2-其他问题\" class=\"headerlink\" title=\"2. 其他问题\"></a>2. 其他问题</h4><p>(1) 如何用js获取当前系统时间</p>\n<p><strong>Date()对象</strong></p>\n<p>自动获得当前日期和时间：</p>\n<pre><code>var timeNow = new Date();\n</code></pre><p>获得当前时间的年份：</p>\n<pre><code>timeNow.getFullYear();\n</code></pre><p>获得当前时间的月份：</p>\n<pre><code>timeNow.getMonth();//注意：月份是从0开始的\n</code></pre><p>获得当前时间的星期：</p>\n<pre><code>timeNow.getDay();//注意：0表示星期天\n</code></pre><p>获得当前时间的日期：</p>\n<pre><code>timeNow.getDate();\n</code></pre><p>获得当前时间的小时数：</p>\n<pre><code>timeNow.getHours();\n</code></pre><p>获得当前时间的分钟数：</p>\n<pre><code>timeNow.getMinutes();\n</code></pre><p>获得当前时间的秒数：</p>\n<pre><code>timeNow.getSeconds();\n</code></pre><p>如何显示当前北京时间：</p>\n<pre><code>定义一个计时器，每隔1000毫秒调用一次获得当前系统时间的函数\n\n/*获取当前时间的函数*/\nfunction getTimeNow() {\n\nvar today = new Date(); //创建一个日期对象，新创建的对象自动获取当前系统的时间    \nvar ThourNum, TminuteNum, TsecondNum;\nThourNum = today.getHours(); //得到当前小时\nTminuteNum = today.getMinutes(); //得到当前分钟\nTsecondNum = today.getSeconds(); //得到当前秒钟                            \ndisplayBjTime(ThourNum,TminuteNum,TsecondNum);//这是自己定义的一个以一定格式显示时间的函数\n\n}\nwindow.setInterval(&quot;getTimeNow();&quot;, 1000);//每隔一秒钟调用一次getTimeNow函数\n</code></pre><p>上面讲的都是如何获得当前系统时间，其实Date()对象也可以自己创建日期对象。</p>\n<pre><code>var someDate = new Date(2016,3,19);//基于本地时间创建日期对象\n\nvar someDate = new Date(Date.UTC(2016,3,19));//基于GMT时间创建日期对象\n</code></pre><p>(2) 不同进制数之间的转化</p>\n<p><strong>多进制转化为十进制</strong></p>\n<p>eg: 二进制数11 转化为 十进制</p>\n<pre><code>parseInt(&quot;11&quot;,2); //3\n</code></pre><p><strong>十进制数转化为多进制</strong></p>\n<p>eg: 十进制数4 转化为 二进制 </p>\n<pre><code>(4).toString(2); //100\n</code></pre><p>(3) 位的操作</p>\n<pre><code>~ 按位非\n\n&amp; 按位与\n\n| 按位或\n\n^ 按位异或\n\n&lt;&lt; 左移\n\n&gt;&gt; 右移(有符号)\n\n&gt;&gt;右移(无符号)\n</code></pre><p>使用位操作写的一个函数getbit()</p>\n<pre><code>/*得到m的二进制的右边数第n+1位（为0或者1）*/\nfunction getBit(m,n){\n    return (m &gt;&gt; n) &amp; 1;\n}\n</code></pre><p>(4) this作为构造函数</p>\n<p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象</p>\n<pre><code>function test(){\n　　　　    this.x = 1;\n　　}\n　　var o = new test();\n　　alert(o.x); // 1\n</code></pre><p>(5) eval()函数的使用</p>\n<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n\n    eval(&quot;x=10;y=20;document.write(x*y)&quot;);\n\n    document.write(eval(&quot;2+2&quot;));\n\n    var x=10\n    document.write(eval(x+17));\n\n&lt;/script&gt;\n</code></pre><p>(6) 一些小的知识点</p>\n<p>select框的每个可选值，都有一个selectedIndex属性，从0开始</p>\n<p>实现div hover之后加边框效果，出现抖动问题，可以首先给div加一个白色的边框占位。</p>\n<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式\n</code></pre><p>移动端的问题：</p>\n<pre><code>移动端需要加上\n\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n\nwidth - viewport的宽度 \nheight - viewport的高度\ninitial-scale - 初始的缩放比例\nminimum-scale - 允许用户缩放到的最小比例\nmaximum-scale - 允许用户缩放到的最大比例\nuser-scalable - 用户是否可以手动缩放\n</code></pre><p>   css中的1px并不等于设备的1px</p>\n<pre><code>css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。\n\n移动设备的屏幕像素密度越高，在同样大小的屏幕上，像素越多，这时，一个css像素是不等于一个物理像素的。\n\n移动端中用户缩放也会引起css中px的变化，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。\n\n在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。\n\ncss中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。但是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题。\n</code></pre>"},{"layout":"post","title":"寻路算法","date":"2016-04-21T16:00:00.000Z","description":null,"_content":"\n最近在做百度前端技术学院第二阶段的《听指令的小方块》这个任务时，遇到了要写一个寻路算法，于是便研究了一下。\n\n寻路算法指的是已知起点A、终点B，在不穿过障碍物的情况下，找到由A到B的最短路径。\n\n传统的寻路算法一般是按照单元格来划分地图，寻路算法包括A* 、递归、非递归、广度优先、深度优先、使用堆栈等。这篇博客介绍的是A*算法。\n\n### 一. A* 算法的原理\n\n首先，我们需要用到一个公式：\n\n\tF = G + H\n\tF为从起点经过该点的到终点总路程\n\tG为从起点到该点的路程，称为“已走路程”->不需要考虑障碍物，可沿斜方移动\n\tH为从该点到终点的路程，称为“预计路程”->不需要考虑障碍物，只考虑水平、垂直移动\n\nA* 算法是从起点开始，然后检测每一个节点，直到找到终点。\n\n我们需要两个列表：**开启列表**和**关闭列表**。\n\n**开启列表：**每检测一个节点，将节点放到**开启列表**，将该节点周围的节点（不包括障碍物、已关闭的节点）放到**开启列表**中，将A存到父节点中；\n\n**关闭列表：**检测完了之后，把检测完了的节点放到**关闭列表**。\n\nhttp://www.cnblogs.com/technology/archive/2011/05/26/2058842.html\n\n每检测一个节点时，需要计算开启列表中的所有节点的F值，选取一个F值最小的节点，作为下一个检测节点，开启其周围的节点。\n\n若周围的节点已经存在在开启列表中，计算新的G值（经过前面两点到此点的值），若新G值更低，计算F；若新G值更高，则不做计算。\n\n对每一个节点都做这个操作，直到找到终点为止。\n\n路径：沿着父节点进行运动，就是最短路径。\n\n    把起始格添加到 \"开启列表\" \n    do \n    { \n       寻找开启列表中F值最低的格子, 我们称它为当前格. \n       把它切换到关闭列表. \n       对当前格相邻的8格中的每一个 \n      if (它不可通过 || 已经在 \"关闭列表\" 中) \n      { \n    \t\t什么也不做. \n      } \n      if (它不在开启列表中) \n      { \n    \t把它添加进 \"开启列表\", 把当前格作为这一格的父节点, 计算这一格的 FGH \n     \t if (它已经在开启列表中) \n      \t { \n    \t\tif (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) \n    \t\t{ \n    \t\t\t把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. \n   \t\t\t} \n    \t } \n\t\twhile( 目标格已经在 \"开启列表\", 这时候路径被找到) \n    \t如果开启列表已经空了, 说明路径不存在.\n\n\t最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.\n\n### 二. 使用寻路算法做的一个小游戏\n\ndemo地址：[http://panpanfish.com/myDemo/task3-46.html](http://panpanfish.com/myDemo/task3-46.html)\n\n代码地址：\n[https://github.com/panpan040828/myDemo/blob/master/task3-46.html](https://github.com/panpan040828/myDemo/blob/master/task3-46.html \"王牌特工的代码地址\")\n\n\n\n\n\n\n\n","source":"_posts/2016-04-22-寻路算法.md","raw":"---\nlayout: post\ntitle: 寻路算法\ndate: 2016-04-22\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n最近在做百度前端技术学院第二阶段的《听指令的小方块》这个任务时，遇到了要写一个寻路算法，于是便研究了一下。\n\n寻路算法指的是已知起点A、终点B，在不穿过障碍物的情况下，找到由A到B的最短路径。\n\n传统的寻路算法一般是按照单元格来划分地图，寻路算法包括A* 、递归、非递归、广度优先、深度优先、使用堆栈等。这篇博客介绍的是A*算法。\n\n### 一. A* 算法的原理\n\n首先，我们需要用到一个公式：\n\n\tF = G + H\n\tF为从起点经过该点的到终点总路程\n\tG为从起点到该点的路程，称为“已走路程”->不需要考虑障碍物，可沿斜方移动\n\tH为从该点到终点的路程，称为“预计路程”->不需要考虑障碍物，只考虑水平、垂直移动\n\nA* 算法是从起点开始，然后检测每一个节点，直到找到终点。\n\n我们需要两个列表：**开启列表**和**关闭列表**。\n\n**开启列表：**每检测一个节点，将节点放到**开启列表**，将该节点周围的节点（不包括障碍物、已关闭的节点）放到**开启列表**中，将A存到父节点中；\n\n**关闭列表：**检测完了之后，把检测完了的节点放到**关闭列表**。\n\nhttp://www.cnblogs.com/technology/archive/2011/05/26/2058842.html\n\n每检测一个节点时，需要计算开启列表中的所有节点的F值，选取一个F值最小的节点，作为下一个检测节点，开启其周围的节点。\n\n若周围的节点已经存在在开启列表中，计算新的G值（经过前面两点到此点的值），若新G值更低，计算F；若新G值更高，则不做计算。\n\n对每一个节点都做这个操作，直到找到终点为止。\n\n路径：沿着父节点进行运动，就是最短路径。\n\n    把起始格添加到 \"开启列表\" \n    do \n    { \n       寻找开启列表中F值最低的格子, 我们称它为当前格. \n       把它切换到关闭列表. \n       对当前格相邻的8格中的每一个 \n      if (它不可通过 || 已经在 \"关闭列表\" 中) \n      { \n    \t\t什么也不做. \n      } \n      if (它不在开启列表中) \n      { \n    \t把它添加进 \"开启列表\", 把当前格作为这一格的父节点, 计算这一格的 FGH \n     \t if (它已经在开启列表中) \n      \t { \n    \t\tif (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) \n    \t\t{ \n    \t\t\t把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. \n   \t\t\t} \n    \t } \n\t\twhile( 目标格已经在 \"开启列表\", 这时候路径被找到) \n    \t如果开启列表已经空了, 说明路径不存在.\n\n\t最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.\n\n### 二. 使用寻路算法做的一个小游戏\n\ndemo地址：[http://panpanfish.com/myDemo/task3-46.html](http://panpanfish.com/myDemo/task3-46.html)\n\n代码地址：\n[https://github.com/panpan040828/myDemo/blob/master/task3-46.html](https://github.com/panpan040828/myDemo/blob/master/task3-46.html \"王牌特工的代码地址\")\n\n\n\n\n\n\n\n","slug":"2016-04-22-寻路算法","published":1,"updated":"2016-05-27T03:10:32.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocec0033d5u8x50qxgyq","content":"<p>最近在做百度前端技术学院第二阶段的《听指令的小方块》这个任务时，遇到了要写一个寻路算法，于是便研究了一下。</p>\n<p>寻路算法指的是已知起点A、终点B，在不穿过障碍物的情况下，找到由A到B的最短路径。</p>\n<p>传统的寻路算法一般是按照单元格来划分地图，寻路算法包括A<em> 、递归、非递归、广度优先、深度优先、使用堆栈等。这篇博客介绍的是A</em>算法。</p>\n<h3 id=\"一-A-算法的原理\"><a href=\"#一-A-算法的原理\" class=\"headerlink\" title=\"一. A* 算法的原理\"></a>一. A* 算法的原理</h3><p>首先，我们需要用到一个公式：</p>\n<pre><code>F = G + H\nF为从起点经过该点的到终点总路程\nG为从起点到该点的路程，称为“已走路程”-&gt;不需要考虑障碍物，可沿斜方移动\nH为从该点到终点的路程，称为“预计路程”-&gt;不需要考虑障碍物，只考虑水平、垂直移动\n</code></pre><p>A* 算法是从起点开始，然后检测每一个节点，直到找到终点。</p>\n<p>我们需要两个列表：<strong>开启列表</strong>和<strong>关闭列表</strong>。</p>\n<p><strong>开启列表：</strong>每检测一个节点，将节点放到<strong>开启列表</strong>，将该节点周围的节点（不包括障碍物、已关闭的节点）放到<strong>开启列表</strong>中，将A存到父节点中；</p>\n<p><strong>关闭列表：</strong>检测完了之后，把检测完了的节点放到<strong>关闭列表</strong>。</p>\n<p><a href=\"http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html</a></p>\n<p>每检测一个节点时，需要计算开启列表中的所有节点的F值，选取一个F值最小的节点，作为下一个检测节点，开启其周围的节点。</p>\n<p>若周围的节点已经存在在开启列表中，计算新的G值（经过前面两点到此点的值），若新G值更低，计算F；若新G值更高，则不做计算。</p>\n<p>对每一个节点都做这个操作，直到找到终点为止。</p>\n<p>路径：沿着父节点进行运动，就是最短路径。</p>\n<pre><code>把起始格添加到 &quot;开启列表&quot; \ndo \n{ \n   寻找开启列表中F值最低的格子, 我们称它为当前格. \n   把它切换到关闭列表. \n   对当前格相邻的8格中的每一个 \n  if (它不可通过 || 已经在 &quot;关闭列表&quot; 中) \n  { \n        什么也不做. \n  } \n  if (它不在开启列表中) \n  { \n    把它添加进 &quot;开启列表&quot;, 把当前格作为这一格的父节点, 计算这一格的 FGH \n      if (它已经在开启列表中) \n       { \n        if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) \n        { \n            把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. \n           } \n     } \n    while( 目标格已经在 &quot;开启列表&quot;, 这时候路径被找到) \n    如果开启列表已经空了, 说明路径不存在.\n\n最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.\n</code></pre><h3 id=\"二-使用寻路算法做的一个小游戏\"><a href=\"#二-使用寻路算法做的一个小游戏\" class=\"headerlink\" title=\"二. 使用寻路算法做的一个小游戏\"></a>二. 使用寻路算法做的一个小游戏</h3><p>demo地址：<a href=\"http://panpanfish.com/myDemo/task3-46.html\">http://panpanfish.com/myDemo/task3-46.html</a></p>\n<p>代码地址：<br><a href=\"https://github.com/panpan040828/myDemo/blob/master/task3-46.html\" title=\"王牌特工的代码地址\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/master/task3-46.html</a></p>\n","excerpt":"","more":"<p>最近在做百度前端技术学院第二阶段的《听指令的小方块》这个任务时，遇到了要写一个寻路算法，于是便研究了一下。</p>\n<p>寻路算法指的是已知起点A、终点B，在不穿过障碍物的情况下，找到由A到B的最短路径。</p>\n<p>传统的寻路算法一般是按照单元格来划分地图，寻路算法包括A<em> 、递归、非递归、广度优先、深度优先、使用堆栈等。这篇博客介绍的是A</em>算法。</p>\n<h3 id=\"一-A-算法的原理\"><a href=\"#一-A-算法的原理\" class=\"headerlink\" title=\"一. A* 算法的原理\"></a>一. A* 算法的原理</h3><p>首先，我们需要用到一个公式：</p>\n<pre><code>F = G + H\nF为从起点经过该点的到终点总路程\nG为从起点到该点的路程，称为“已走路程”-&gt;不需要考虑障碍物，可沿斜方移动\nH为从该点到终点的路程，称为“预计路程”-&gt;不需要考虑障碍物，只考虑水平、垂直移动\n</code></pre><p>A* 算法是从起点开始，然后检测每一个节点，直到找到终点。</p>\n<p>我们需要两个列表：<strong>开启列表</strong>和<strong>关闭列表</strong>。</p>\n<p><strong>开启列表：</strong>每检测一个节点，将节点放到<strong>开启列表</strong>，将该节点周围的节点（不包括障碍物、已关闭的节点）放到<strong>开启列表</strong>中，将A存到父节点中；</p>\n<p><strong>关闭列表：</strong>检测完了之后，把检测完了的节点放到<strong>关闭列表</strong>。</p>\n<p><a href=\"http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html\">http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html</a></p>\n<p>每检测一个节点时，需要计算开启列表中的所有节点的F值，选取一个F值最小的节点，作为下一个检测节点，开启其周围的节点。</p>\n<p>若周围的节点已经存在在开启列表中，计算新的G值（经过前面两点到此点的值），若新G值更低，计算F；若新G值更高，则不做计算。</p>\n<p>对每一个节点都做这个操作，直到找到终点为止。</p>\n<p>路径：沿着父节点进行运动，就是最短路径。</p>\n<pre><code>把起始格添加到 &quot;开启列表&quot; \ndo \n{ \n   寻找开启列表中F值最低的格子, 我们称它为当前格. \n   把它切换到关闭列表. \n   对当前格相邻的8格中的每一个 \n  if (它不可通过 || 已经在 &quot;关闭列表&quot; 中) \n  { \n        什么也不做. \n  } \n  if (它不在开启列表中) \n  { \n    把它添加进 &quot;开启列表&quot;, 把当前格作为这一格的父节点, 计算这一格的 FGH \n      if (它已经在开启列表中) \n       { \n        if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) \n        { \n            把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. \n           } \n     } \n    while( 目标格已经在 &quot;开启列表&quot;, 这时候路径被找到) \n    如果开启列表已经空了, 说明路径不存在.\n\n最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.\n</code></pre><h3 id=\"二-使用寻路算法做的一个小游戏\"><a href=\"#二-使用寻路算法做的一个小游戏\" class=\"headerlink\" title=\"二. 使用寻路算法做的一个小游戏\"></a>二. 使用寻路算法做的一个小游戏</h3><p>demo地址：<a href=\"http://panpanfish.com/myDemo/task3-46.html\">http://panpanfish.com/myDemo/task3-46.html</a></p>\n<p>代码地址：<br><a href=\"https://github.com/panpan040828/myDemo/blob/master/task3-46.html\" title=\"王牌特工的代码地址\">https://github.com/panpan040828/myDemo/blob/master/task3-46.html</a></p>\n"},{"layout":"post","title":"js中对数组的一些操作","date":"2016-04-22T16:00:00.000Z","description":null,"_content":"数组是在js中用得很多的一种类型，这篇博客是对js中数组的一些操作方法的总结。\n\n### 一. js中的数组的特点\n\n**js中的数组类型，与其他语言的不同之处有两点：**\n\n1. 数组中的每一项可以保存任何类型的数据\n\n2. 数组的大小可以动态调整（随着数组中数据的添加而动态增长）\n\n### 二. js中的数组的创建\n\nvar myArr = new Array(3);\n\nvar myArr = new Array(\"1\",\"2\");\n\nvar myArr = [];\n\nvar myArr = [1,2];\n\n**二维数组的创建：**\n\n我经常使用的一个方法如下\n\n\tvar myArr = [];//首先创建一个一维数组\n\tfor(var i=0;i<10;i++)\n\t{\n\t\tmyArr[i] = new Array(10);//创建的数组中的每一项都是一个数组\n\t}\n\t这样就得到了一个10X10的数组\n\n### 三.js中数组的操作\n\n#### 1. myArr.length 获得数组的长度、或者给数组指定长度\n\n\tmyArr.length = 4；//数组长度为4\n\n#### 2. 检测是否为数组(两种方法)\n\n\tmyArr instanceof Array\n\tArray.isArray(myArr)\n\n#### 3. 将数组转换为字符串 toString()、toLcaleString()、join()\n\ntoString()、toLcaleString():数组中每项以逗号连接\n\njoin(\"?\"):数组中的每项以?连接（可以自定义分隔符号），若不传参数，默认用逗号连接\n\n\tvar colors = [1,2,3];\n\tcolors.toString();// 1,2,3\n\tcolors.join(\"|\");// 1|2|3\n\n#### 4. 数组中增加或者删除项的操作 push()、pop()、shift()、splice()、concat()、slice()、\n\n**push()、pop()、shift()、unshift()这几个方法是在原数组上操作**\n\n    var myArr = [\"1\",\"2\",\"3\"];\n    \n    myArr.push(\"4\"); //数组末尾添加一项\n    [\"1\",\"2\",\"3\",\"4\"]，或多项\n    //注意：push 方法的返回值是新增的那一项\n    myArr.pop(); //删除数组的最后一项,并返回移除项 4\n\tmyArr.unshift();//数组的最前面添加一项 或 多项 但传入的只能是参数，不能是数组\n    myArr.shift();//删除数组的第一项,并返回移除项 4\n    \n**splice()**从数组中间位置添加或删除元素\n\n这个方法是在原数组上操作，并返回删除的数组\n\n    删除功能：splice(start,要删除的项数)\n    插入功能：splice(start,0，\"4\")\n    替换功能：splice(start,1，\"4\")\n\n**concat()、slice()**\n\n这两个方法都是会生成一个新的数组，而不是在原数组上操作\n\n    var myArr = [\"1\",\"2\",\"3\"];\n    var myArr2 = myArr.concat(\"4\");// myArr2 = [\"1\",\"2\",\"3\",\"4\"]首先复制原数组，然后在复制的数组末尾添加一项或多项\n    var myArr3 = myArr.slice(1,2);// myArr3 = [\"2\"]\n    \n    slice(start,end)返回起始位置到终止位置(但不包括终止位置)的项，组成一个新的数组；若只有起始位置，则一直取到数组末尾\n\n<font color=\"red\">注意：由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值</font>\n\n    由于数组是复杂的数据类型，是引用类型，因此将一个数组赋值给另外一个数组时，是按引用进行传递。\n    \n    eg:\n    \n    var a = [1,2,3];\n    var b = a;\n    b.push(4);\n    console.log(a);//[1,2,3,4]，a也发生了变化\n    console.log(b);//[1,2,3,4]\n    \n    利用slice()或者concat()让数组实现传值\n    var a = [1,2,3];\n    var b = a.slice();\n    var c = a.concat();\n    \n    b.push(4);\n    c.push(5);\n    console.log(a);//[1,2,3]\n    console.log(b);//[1,2,3,4]\n    console.log(c);//[1,2,3,5]\n\n#### 5. 数组中元素的位置 sort()、reverse()\n\n\tmyArr.sort();//会将数组的元素进行排序(按照字符串进行排序)，是直接将原数组进行排序。\n\n\tsort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。\n\neg:\n\n    var values=[0,1,5,10,15]\n    values.sort();\n    alert(values);\n    \n    结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n\n**给sort()传入一个比较函数，可以按照数值大小进行排序**\n\n\t    values.sort(compare);\n    \n    \tcompare为比较函数\n    \n    \tfunction compare(value1,value2)\n    \t{\n    \t\tif(value1 < value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 = value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 > value2)\n    \t\t{return 1;}\n    \t}\n    \n    \t**比较函数返回参数解释：**\n    \t- 若为正数：第一个参数位于第二个参数之后\n    \t- 若为0：两个参数相等\n    \t- 若为负数：第一个参数位于第二个参数之前\n    \n    \t所以上面举例的比较函数是升序排列的比较函数\n\n\t\t简化的比较函数\n\n\t\t升序排列的比较函数 function compare(a,b){return a-b}\n\n\t\t降序排列的比较函数 function compare(a,b){return b-a}\n\n**reverse()**方法，反转数组项的顺序\n\n#### 6. 数组中的元素的位置 indexOf()、lastIndexOf()\n\n传入的参数在数组中是否存在，如果存在，返回下标，不存在，返回－1\n\nindexOf()：从数组的第一项开始查找\n\nlastIndexOf():从数组的最后一项开始查找\n\n\tvar myArr = ['a','b','c','d'];\n\talert(myArr.indexOf('b'));//1\n\talert(myArr.lastIndexOf('c'));//2\n\n#### 7. 数组中的迭代方法\n\n- every()\n- some()\n- filter()\n- map()\n- forEach()\n\n(1) every()用于检测数组是否**每一项**都满足某个条件，如果是，则返回true;否则返回false\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.every(function(item,index,array){\n    \t\treturn (item >= 1);\n    \n    });//numRes为true\n\n(2) some()用于检测数组中是否有一项满足某个条件，如果是，则返回true;否则返回false\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.some(function(item,index,array){\n    \t\treturn (item >= 5);\n    \n    });//numRes为true\n\n(3) filter()用于选出数组中满足某个条件的项，并形成一个新的数组\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.filter(function(item,index,array){\n    \t\treturn (item >= 3);\n    \n    });//numRes为[3,4,5]\n\n(4) map()用于将数组中的每一项都做一个操作，并形成一个新的数组\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.map(function(item,index,array){\n    \t\treturn (item + 3);\n    \n    });//numRes为[4,5,6,7,8]\n\n(5) forEach()用于将数组中的每一项都做一个操作（原数组发生了改变）\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    num.forEach(function(item,index,array){\n    \t\treturn (item + 3);\n    \n    });//num为[4,5,6,7,8]\n\n#### 8. 数组中的归并方法 reduce()、reduceRight()\n\n将数组中的每一项进行迭代，最终返回一个值；两者的区别是迭代的方向不同，**reduce()是从数组的第一项开始，reduceRight()是从数组的最后一项开始**。\n\nreduce(\"回调函数\",\"初始值\");\n\n一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素\n\neg:\n    \n    var num = [1,2,3,4,5];\n    \n    var numRes = num.reduce(function(prev,cur,index,array){\n    \n    return prev + cur;\n    \n    })//numRes为15\n\n### 四. js合并数组的几种方法\n\n**1. 使用concat**\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    var c = a1.concat(a2);//c = [0,1,2,3,4];\n\n缺点：会生成一个新的数组，当两个数组的元素个数较多时，会占用很多内存\n\n**2. 循环插入**\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    \n    for(var i=0;i<a2.length;i++)\n    {\n    \ta1.push(a2[i]);\n    }\n    \n    a1则为合并后的数组\n\n缺点：当a2数组很大时，for循环需要遍历很多次\n\n**3. reduce()和reduceRight()方法**\n\nreduce()是数组归并的方法\n\nreduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    \n    //给prev传入了初始值，那么prev则是指的是a1\n    a1 = a2.reduce(function(prev,next){\n    \tprev.push(next);\n    \treturn prev;\n    },a1)\n\n\t//a1 = [0,1,2,3,4];\n\n一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素\n\nreduceRight()与reduce()同理，只是从数组的右边开始归并\n\n缺点：需要对每个数组元素执行函数调用\n\n**4. push.apply**\n\n**(1) js中的apply()和call()的用法**\n\n**apply:应用某一对象的一个方法，用另一个对象替换当前对象。**\n\n**apply(obj,参数数组)**\n\n    <script type=\"text/javascript\">\n\t      /*定义一个人类*/\n\t      function Person(name,age)\n\t      {\n\t\t      this.name=name;\n\t\t      this.age=age;\n\t      }\n\t      /*定义一个学生类*/\n\t      functionStudent(name,age,grade)\n\t      {\n\t\t      Person.apply(this,arguments);\n\t\t      this.grade=grade;\n\t      }\n\t      //创建一个学生类\n\t      var student=new Student(\"qian\",21,\"一年级\");\n\t      //测试\n\t      alert(\"name:\"+student.name+\"\\n\"+\"age:\"+student.age+\"\\n\"+\"grade:\"+student.grade);\n\t      //大家可以看到测试结果name:qian  age:21  grade:一年级\n\t      //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.\n     </script>\n\n**call:与apply的作用一样，只是参数列表不一样**\n\n**call(obj,参数1,参数2...)**\n\n    将上一段的Person.apply(this,arguments) 变成 Person.call(this,name,age)\n\n**(2) apply的作用**\n\n**<font color=\"red\">当一个数组作为参数传入一个函数时，使用apply可以将数组解析为一个一个的参数</font>**\n\n**(3) 使用apply将数组合并**\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    a1.push(a2);//结果是a1=[0,1,2,[3,4]]，并不是我们需要的结果\n    \n    我们需要将a2这数组拆成一个个元素，然后push进入a1\n    \n    因此可以采用apply方法\n    \n    Array.prototype.push.apply(a1,a2);//使用a1调用push方法，并将a2数组拆成一个个参数传进去,a1=[0,1,2,3,4]\n    \n    Array.prototype.unshift.aplly(a2,a1);//a2=[0,1,2,3,4]\n\n**aplly的其他使用**\n\n    Math.max 可以实现得到数组中最大的一项\n    \n    因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组\n    \n    但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项(apply会将一个数组装换为一个参数接一个参数的传递给方法)\n    \n    这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去\n\n缺点：如果a2很大，就会出现内存溢出的情况\n\n**(4) 使用ES6的扩展操作符spread operator `...`**\n\nES6是javascript的下一个版本，ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。\n\nES6的扩展操作符的作用和apply类似\n\n    a1.push(...a2)\n    a2.unshift(...a1)","source":"_posts/2016-04-23-js中对数组的一些操作.md","raw":"---\nlayout: post\ntitle: js中对数组的一些操作\ndate: 2016-04-23\ncategories: javaScript\ntags: [javaScript,数组]\ndescription: \n---\n数组是在js中用得很多的一种类型，这篇博客是对js中数组的一些操作方法的总结。\n\n### 一. js中的数组的特点\n\n**js中的数组类型，与其他语言的不同之处有两点：**\n\n1. 数组中的每一项可以保存任何类型的数据\n\n2. 数组的大小可以动态调整（随着数组中数据的添加而动态增长）\n\n### 二. js中的数组的创建\n\nvar myArr = new Array(3);\n\nvar myArr = new Array(\"1\",\"2\");\n\nvar myArr = [];\n\nvar myArr = [1,2];\n\n**二维数组的创建：**\n\n我经常使用的一个方法如下\n\n\tvar myArr = [];//首先创建一个一维数组\n\tfor(var i=0;i<10;i++)\n\t{\n\t\tmyArr[i] = new Array(10);//创建的数组中的每一项都是一个数组\n\t}\n\t这样就得到了一个10X10的数组\n\n### 三.js中数组的操作\n\n#### 1. myArr.length 获得数组的长度、或者给数组指定长度\n\n\tmyArr.length = 4；//数组长度为4\n\n#### 2. 检测是否为数组(两种方法)\n\n\tmyArr instanceof Array\n\tArray.isArray(myArr)\n\n#### 3. 将数组转换为字符串 toString()、toLcaleString()、join()\n\ntoString()、toLcaleString():数组中每项以逗号连接\n\njoin(\"?\"):数组中的每项以?连接（可以自定义分隔符号），若不传参数，默认用逗号连接\n\n\tvar colors = [1,2,3];\n\tcolors.toString();// 1,2,3\n\tcolors.join(\"|\");// 1|2|3\n\n#### 4. 数组中增加或者删除项的操作 push()、pop()、shift()、splice()、concat()、slice()、\n\n**push()、pop()、shift()、unshift()这几个方法是在原数组上操作**\n\n    var myArr = [\"1\",\"2\",\"3\"];\n    \n    myArr.push(\"4\"); //数组末尾添加一项\n    [\"1\",\"2\",\"3\",\"4\"]，或多项\n    //注意：push 方法的返回值是新增的那一项\n    myArr.pop(); //删除数组的最后一项,并返回移除项 4\n\tmyArr.unshift();//数组的最前面添加一项 或 多项 但传入的只能是参数，不能是数组\n    myArr.shift();//删除数组的第一项,并返回移除项 4\n    \n**splice()**从数组中间位置添加或删除元素\n\n这个方法是在原数组上操作，并返回删除的数组\n\n    删除功能：splice(start,要删除的项数)\n    插入功能：splice(start,0，\"4\")\n    替换功能：splice(start,1，\"4\")\n\n**concat()、slice()**\n\n这两个方法都是会生成一个新的数组，而不是在原数组上操作\n\n    var myArr = [\"1\",\"2\",\"3\"];\n    var myArr2 = myArr.concat(\"4\");// myArr2 = [\"1\",\"2\",\"3\",\"4\"]首先复制原数组，然后在复制的数组末尾添加一项或多项\n    var myArr3 = myArr.slice(1,2);// myArr3 = [\"2\"]\n    \n    slice(start,end)返回起始位置到终止位置(但不包括终止位置)的项，组成一个新的数组；若只有起始位置，则一直取到数组末尾\n\n<font color=\"red\">注意：由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值</font>\n\n    由于数组是复杂的数据类型，是引用类型，因此将一个数组赋值给另外一个数组时，是按引用进行传递。\n    \n    eg:\n    \n    var a = [1,2,3];\n    var b = a;\n    b.push(4);\n    console.log(a);//[1,2,3,4]，a也发生了变化\n    console.log(b);//[1,2,3,4]\n    \n    利用slice()或者concat()让数组实现传值\n    var a = [1,2,3];\n    var b = a.slice();\n    var c = a.concat();\n    \n    b.push(4);\n    c.push(5);\n    console.log(a);//[1,2,3]\n    console.log(b);//[1,2,3,4]\n    console.log(c);//[1,2,3,5]\n\n#### 5. 数组中元素的位置 sort()、reverse()\n\n\tmyArr.sort();//会将数组的元素进行排序(按照字符串进行排序)，是直接将原数组进行排序。\n\n\tsort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。\n\neg:\n\n    var values=[0,1,5,10,15]\n    values.sort();\n    alert(values);\n    \n    结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n\n**给sort()传入一个比较函数，可以按照数值大小进行排序**\n\n\t    values.sort(compare);\n    \n    \tcompare为比较函数\n    \n    \tfunction compare(value1,value2)\n    \t{\n    \t\tif(value1 < value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 = value2)\n    \t\t{return -1;}\n    \n    \t\tif(value1 > value2)\n    \t\t{return 1;}\n    \t}\n    \n    \t**比较函数返回参数解释：**\n    \t- 若为正数：第一个参数位于第二个参数之后\n    \t- 若为0：两个参数相等\n    \t- 若为负数：第一个参数位于第二个参数之前\n    \n    \t所以上面举例的比较函数是升序排列的比较函数\n\n\t\t简化的比较函数\n\n\t\t升序排列的比较函数 function compare(a,b){return a-b}\n\n\t\t降序排列的比较函数 function compare(a,b){return b-a}\n\n**reverse()**方法，反转数组项的顺序\n\n#### 6. 数组中的元素的位置 indexOf()、lastIndexOf()\n\n传入的参数在数组中是否存在，如果存在，返回下标，不存在，返回－1\n\nindexOf()：从数组的第一项开始查找\n\nlastIndexOf():从数组的最后一项开始查找\n\n\tvar myArr = ['a','b','c','d'];\n\talert(myArr.indexOf('b'));//1\n\talert(myArr.lastIndexOf('c'));//2\n\n#### 7. 数组中的迭代方法\n\n- every()\n- some()\n- filter()\n- map()\n- forEach()\n\n(1) every()用于检测数组是否**每一项**都满足某个条件，如果是，则返回true;否则返回false\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.every(function(item,index,array){\n    \t\treturn (item >= 1);\n    \n    });//numRes为true\n\n(2) some()用于检测数组中是否有一项满足某个条件，如果是，则返回true;否则返回false\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.some(function(item,index,array){\n    \t\treturn (item >= 5);\n    \n    });//numRes为true\n\n(3) filter()用于选出数组中满足某个条件的项，并形成一个新的数组\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.filter(function(item,index,array){\n    \t\treturn (item >= 3);\n    \n    });//numRes为[3,4,5]\n\n(4) map()用于将数组中的每一项都做一个操作，并形成一个新的数组\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    var numRes = num.map(function(item,index,array){\n    \t\treturn (item + 3);\n    \n    });//numRes为[4,5,6,7,8]\n\n(5) forEach()用于将数组中的每一项都做一个操作（原数组发生了改变）\n\neg:\n\n    var num = [1,2,3,4,5];\n    \n    num.forEach(function(item,index,array){\n    \t\treturn (item + 3);\n    \n    });//num为[4,5,6,7,8]\n\n#### 8. 数组中的归并方法 reduce()、reduceRight()\n\n将数组中的每一项进行迭代，最终返回一个值；两者的区别是迭代的方向不同，**reduce()是从数组的第一项开始，reduceRight()是从数组的最后一项开始**。\n\nreduce(\"回调函数\",\"初始值\");\n\n一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素\n\neg:\n    \n    var num = [1,2,3,4,5];\n    \n    var numRes = num.reduce(function(prev,cur,index,array){\n    \n    return prev + cur;\n    \n    })//numRes为15\n\n### 四. js合并数组的几种方法\n\n**1. 使用concat**\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    var c = a1.concat(a2);//c = [0,1,2,3,4];\n\n缺点：会生成一个新的数组，当两个数组的元素个数较多时，会占用很多内存\n\n**2. 循环插入**\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    \n    for(var i=0;i<a2.length;i++)\n    {\n    \ta1.push(a2[i]);\n    }\n    \n    a1则为合并后的数组\n\n缺点：当a2数组很大时，for循环需要遍历很多次\n\n**3. reduce()和reduceRight()方法**\n\nreduce()是数组归并的方法\n\nreduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    \n    //给prev传入了初始值，那么prev则是指的是a1\n    a1 = a2.reduce(function(prev,next){\n    \tprev.push(next);\n    \treturn prev;\n    },a1)\n\n\t//a1 = [0,1,2,3,4];\n\n一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素\n\nreduceRight()与reduce()同理，只是从数组的右边开始归并\n\n缺点：需要对每个数组元素执行函数调用\n\n**4. push.apply**\n\n**(1) js中的apply()和call()的用法**\n\n**apply:应用某一对象的一个方法，用另一个对象替换当前对象。**\n\n**apply(obj,参数数组)**\n\n    <script type=\"text/javascript\">\n\t      /*定义一个人类*/\n\t      function Person(name,age)\n\t      {\n\t\t      this.name=name;\n\t\t      this.age=age;\n\t      }\n\t      /*定义一个学生类*/\n\t      functionStudent(name,age,grade)\n\t      {\n\t\t      Person.apply(this,arguments);\n\t\t      this.grade=grade;\n\t      }\n\t      //创建一个学生类\n\t      var student=new Student(\"qian\",21,\"一年级\");\n\t      //测试\n\t      alert(\"name:\"+student.name+\"\\n\"+\"age:\"+student.age+\"\\n\"+\"grade:\"+student.grade);\n\t      //大家可以看到测试结果name:qian  age:21  grade:一年级\n\t      //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.\n     </script>\n\n**call:与apply的作用一样，只是参数列表不一样**\n\n**call(obj,参数1,参数2...)**\n\n    将上一段的Person.apply(this,arguments) 变成 Person.call(this,name,age)\n\n**(2) apply的作用**\n\n**<font color=\"red\">当一个数组作为参数传入一个函数时，使用apply可以将数组解析为一个一个的参数</font>**\n\n**(3) 使用apply将数组合并**\n\n    var a1 = [0,1,2];\n    var a2 = [3,4];\n    a1.push(a2);//结果是a1=[0,1,2,[3,4]]，并不是我们需要的结果\n    \n    我们需要将a2这数组拆成一个个元素，然后push进入a1\n    \n    因此可以采用apply方法\n    \n    Array.prototype.push.apply(a1,a2);//使用a1调用push方法，并将a2数组拆成一个个参数传进去,a1=[0,1,2,3,4]\n    \n    Array.prototype.unshift.aplly(a2,a1);//a2=[0,1,2,3,4]\n\n**aplly的其他使用**\n\n    Math.max 可以实现得到数组中最大的一项\n    \n    因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组\n    \n    但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项(apply会将一个数组装换为一个参数接一个参数的传递给方法)\n    \n    这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去\n\n缺点：如果a2很大，就会出现内存溢出的情况\n\n**(4) 使用ES6的扩展操作符spread operator `...`**\n\nES6是javascript的下一个版本，ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。\n\nES6的扩展操作符的作用和apply类似\n\n    a1.push(...a2)\n    a2.unshift(...a1)","slug":"2016-04-23-js中对数组的一些操作","published":1,"updated":"2016-08-28T08:26:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035oced0036d5u8grb836b5","content":"<p>数组是在js中用得很多的一种类型，这篇博客是对js中数组的一些操作方法的总结。</p>\n<h3 id=\"一-js中的数组的特点\"><a href=\"#一-js中的数组的特点\" class=\"headerlink\" title=\"一. js中的数组的特点\"></a>一. js中的数组的特点</h3><p><strong>js中的数组类型，与其他语言的不同之处有两点：</strong></p>\n<ol>\n<li><p>数组中的每一项可以保存任何类型的数据</p>\n</li>\n<li><p>数组的大小可以动态调整（随着数组中数据的添加而动态增长）</p>\n</li>\n</ol>\n<h3 id=\"二-js中的数组的创建\"><a href=\"#二-js中的数组的创建\" class=\"headerlink\" title=\"二. js中的数组的创建\"></a>二. js中的数组的创建</h3><p>var myArr = new Array(3);</p>\n<p>var myArr = new Array(“1”,”2”);</p>\n<p>var myArr = [];</p>\n<p>var myArr = [1,2];</p>\n<p><strong>二维数组的创建：</strong></p>\n<p>我经常使用的一个方法如下</p>\n<pre><code>var myArr = [];//首先创建一个一维数组\nfor(var i=0;i&lt;10;i++)\n{\n    myArr[i] = new Array(10);//创建的数组中的每一项都是一个数组\n}\n这样就得到了一个10X10的数组\n</code></pre><h3 id=\"三-js中数组的操作\"><a href=\"#三-js中数组的操作\" class=\"headerlink\" title=\"三.js中数组的操作\"></a>三.js中数组的操作</h3><h4 id=\"1-myArr-length-获得数组的长度、或者给数组指定长度\"><a href=\"#1-myArr-length-获得数组的长度、或者给数组指定长度\" class=\"headerlink\" title=\"1. myArr.length 获得数组的长度、或者给数组指定长度\"></a>1. myArr.length 获得数组的长度、或者给数组指定长度</h4><pre><code>myArr.length = 4；//数组长度为4\n</code></pre><h4 id=\"2-检测是否为数组-两种方法\"><a href=\"#2-检测是否为数组-两种方法\" class=\"headerlink\" title=\"2. 检测是否为数组(两种方法)\"></a>2. 检测是否为数组(两种方法)</h4><pre><code>myArr instanceof Array\nArray.isArray(myArr)\n</code></pre><h4 id=\"3-将数组转换为字符串-toString-、toLcaleString-、join\"><a href=\"#3-将数组转换为字符串-toString-、toLcaleString-、join\" class=\"headerlink\" title=\"3. 将数组转换为字符串 toString()、toLcaleString()、join()\"></a>3. 将数组转换为字符串 toString()、toLcaleString()、join()</h4><p>toString()、toLcaleString():数组中每项以逗号连接</p>\n<p>join(“?”):数组中的每项以?连接（可以自定义分隔符号），若不传参数，默认用逗号连接</p>\n<pre><code>var colors = [1,2,3];\ncolors.toString();// 1,2,3\ncolors.join(&quot;|&quot;);// 1|2|3\n</code></pre><h4 id=\"4-数组中增加或者删除项的操作-push-、pop-、shift-、splice-、concat-、slice-、\"><a href=\"#4-数组中增加或者删除项的操作-push-、pop-、shift-、splice-、concat-、slice-、\" class=\"headerlink\" title=\"4. 数组中增加或者删除项的操作 push()、pop()、shift()、splice()、concat()、slice()、\"></a>4. 数组中增加或者删除项的操作 push()、pop()、shift()、splice()、concat()、slice()、</h4><p><strong>push()、pop()、shift()、unshift()这几个方法是在原数组上操作</strong></p>\n<pre><code>var myArr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];\n\nmyArr.push(&quot;4&quot;); //数组末尾添加一项\n[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]，或多项\n//注意：push 方法的返回值是新增的那一项\nmyArr.pop(); //删除数组的最后一项,并返回移除项 4\nmyArr.unshift();//数组的最前面添加一项 或 多项 但传入的只能是参数，不能是数组\nmyArr.shift();//删除数组的第一项,并返回移除项 4\n</code></pre><p><strong>splice()</strong>从数组中间位置添加或删除元素</p>\n<p>这个方法是在原数组上操作，并返回删除的数组</p>\n<pre><code>删除功能：splice(start,要删除的项数)\n插入功能：splice(start,0，&quot;4&quot;)\n替换功能：splice(start,1，&quot;4&quot;)\n</code></pre><p><strong>concat()、slice()</strong></p>\n<p>这两个方法都是会生成一个新的数组，而不是在原数组上操作</p>\n<pre><code>var myArr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];\nvar myArr2 = myArr.concat(&quot;4&quot;);// myArr2 = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]首先复制原数组，然后在复制的数组末尾添加一项或多项\nvar myArr3 = myArr.slice(1,2);// myArr3 = [&quot;2&quot;]\n\nslice(start,end)返回起始位置到终止位置(但不包括终止位置)的项，组成一个新的数组；若只有起始位置，则一直取到数组末尾\n</code></pre><font color=\"red\">注意：由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值</font>\n\n<pre><code>由于数组是复杂的数据类型，是引用类型，因此将一个数组赋值给另外一个数组时，是按引用进行传递。\n\neg:\n\nvar a = [1,2,3];\nvar b = a;\nb.push(4);\nconsole.log(a);//[1,2,3,4]，a也发生了变化\nconsole.log(b);//[1,2,3,4]\n\n利用slice()或者concat()让数组实现传值\nvar a = [1,2,3];\nvar b = a.slice();\nvar c = a.concat();\n\nb.push(4);\nc.push(5);\nconsole.log(a);//[1,2,3]\nconsole.log(b);//[1,2,3,4]\nconsole.log(c);//[1,2,3,5]\n</code></pre><h4 id=\"5-数组中元素的位置-sort-、reverse\"><a href=\"#5-数组中元素的位置-sort-、reverse\" class=\"headerlink\" title=\"5. 数组中元素的位置 sort()、reverse()\"></a>5. 数组中元素的位置 sort()、reverse()</h4><pre><code>myArr.sort();//会将数组的元素进行排序(按照字符串进行排序)，是直接将原数组进行排序。\n\nsort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。\n</code></pre><p>eg:</p>\n<pre><code>var values=[0,1,5,10,15]\nvalues.sort();\nalert(values);\n\n结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n</code></pre><p><strong>给sort()传入一个比较函数，可以按照数值大小进行排序</strong></p>\n<pre><code>values.sort(compare);\n\ncompare为比较函数\n\nfunction compare(value1,value2)\n{\n    if(value1 &lt; value2)\n    {return -1;}\n\n    if(value1 = value2)\n    {return -1;}\n\n    if(value1 &gt; value2)\n    {return 1;}\n}\n\n**比较函数返回参数解释：**\n- 若为正数：第一个参数位于第二个参数之后\n- 若为0：两个参数相等\n- 若为负数：第一个参数位于第二个参数之前\n\n所以上面举例的比较函数是升序排列的比较函数\n\n简化的比较函数\n\n升序排列的比较函数 function compare(a,b){return a-b}\n\n降序排列的比较函数 function compare(a,b){return b-a}\n</code></pre><p><strong>reverse()</strong>方法，反转数组项的顺序</p>\n<h4 id=\"6-数组中的元素的位置-indexOf-、lastIndexOf\"><a href=\"#6-数组中的元素的位置-indexOf-、lastIndexOf\" class=\"headerlink\" title=\"6. 数组中的元素的位置 indexOf()、lastIndexOf()\"></a>6. 数组中的元素的位置 indexOf()、lastIndexOf()</h4><p>传入的参数在数组中是否存在，如果存在，返回下标，不存在，返回－1</p>\n<p>indexOf()：从数组的第一项开始查找</p>\n<p>lastIndexOf():从数组的最后一项开始查找</p>\n<pre><code>var myArr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];\nalert(myArr.indexOf(&apos;b&apos;));//1\nalert(myArr.lastIndexOf(&apos;c&apos;));//2\n</code></pre><h4 id=\"7-数组中的迭代方法\"><a href=\"#7-数组中的迭代方法\" class=\"headerlink\" title=\"7. 数组中的迭代方法\"></a>7. 数组中的迭代方法</h4><ul>\n<li>every()</li>\n<li>some()</li>\n<li>filter()</li>\n<li>map()</li>\n<li>forEach()</li>\n</ul>\n<p>(1) every()用于检测数组是否<strong>每一项</strong>都满足某个条件，如果是，则返回true;否则返回false</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.every(function(item,index,array){\n        return (item &gt;= 1);\n\n});//numRes为true\n</code></pre><p>(2) some()用于检测数组中是否有一项满足某个条件，如果是，则返回true;否则返回false</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.some(function(item,index,array){\n        return (item &gt;= 5);\n\n});//numRes为true\n</code></pre><p>(3) filter()用于选出数组中满足某个条件的项，并形成一个新的数组</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.filter(function(item,index,array){\n        return (item &gt;= 3);\n\n});//numRes为[3,4,5]\n</code></pre><p>(4) map()用于将数组中的每一项都做一个操作，并形成一个新的数组</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.map(function(item,index,array){\n        return (item + 3);\n\n});//numRes为[4,5,6,7,8]\n</code></pre><p>(5) forEach()用于将数组中的每一项都做一个操作（原数组发生了改变）</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nnum.forEach(function(item,index,array){\n        return (item + 3);\n\n});//num为[4,5,6,7,8]\n</code></pre><h4 id=\"8-数组中的归并方法-reduce-、reduceRight\"><a href=\"#8-数组中的归并方法-reduce-、reduceRight\" class=\"headerlink\" title=\"8. 数组中的归并方法 reduce()、reduceRight()\"></a>8. 数组中的归并方法 reduce()、reduceRight()</h4><p>将数组中的每一项进行迭代，最终返回一个值；两者的区别是迭代的方向不同，<strong>reduce()是从数组的第一项开始，reduceRight()是从数组的最后一项开始</strong>。</p>\n<p>reduce(“回调函数”,”初始值”);</p>\n<p>一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.reduce(function(prev,cur,index,array){\n\nreturn prev + cur;\n\n})//numRes为15\n</code></pre><h3 id=\"四-js合并数组的几种方法\"><a href=\"#四-js合并数组的几种方法\" class=\"headerlink\" title=\"四. js合并数组的几种方法\"></a>四. js合并数组的几种方法</h3><p><strong>1. 使用concat</strong></p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\nvar c = a1.concat(a2);//c = [0,1,2,3,4];\n</code></pre><p>缺点：会生成一个新的数组，当两个数组的元素个数较多时，会占用很多内存</p>\n<p><strong>2. 循环插入</strong></p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\n\nfor(var i=0;i&lt;a2.length;i++)\n{\n    a1.push(a2[i]);\n}\n\na1则为合并后的数组\n</code></pre><p>缺点：当a2数组很大时，for循环需要遍历很多次</p>\n<p><strong>3. reduce()和reduceRight()方法</strong></p>\n<p>reduce()是数组归并的方法</p>\n<p>reduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值</p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\n\n//给prev传入了初始值，那么prev则是指的是a1\na1 = a2.reduce(function(prev,next){\n    prev.push(next);\n    return prev;\n},a1)\n\n//a1 = [0,1,2,3,4];\n</code></pre><p>一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素</p>\n<p>reduceRight()与reduce()同理，只是从数组的右边开始归并</p>\n<p>缺点：需要对每个数组元素执行函数调用</p>\n<p><strong>4. push.apply</strong></p>\n<p><strong>(1) js中的apply()和call()的用法</strong></p>\n<p><strong>apply:应用某一对象的一个方法，用另一个对象替换当前对象。</strong></p>\n<p><strong>apply(obj,参数数组)</strong></p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n      /*定义一个人类*/\n      function Person(name,age)\n      {\n          this.name=name;\n          this.age=age;\n      }\n      /*定义一个学生类*/\n      functionStudent(name,age,grade)\n      {\n          Person.apply(this,arguments);\n          this.grade=grade;\n      }\n      //创建一个学生类\n      var student=new Student(&quot;qian&quot;,21,&quot;一年级&quot;);\n      //测试\n      alert(&quot;name:&quot;+student.name+&quot;\\n&quot;+&quot;age:&quot;+student.age+&quot;\\n&quot;+&quot;grade:&quot;+student.grade);\n      //大家可以看到测试结果name:qian  age:21  grade:一年级\n      //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.\n &lt;/script&gt;\n</code></pre><p><strong>call:与apply的作用一样，只是参数列表不一样</strong></p>\n<p><strong>call(obj,参数1,参数2…)</strong></p>\n<pre><code>将上一段的Person.apply(this,arguments) 变成 Person.call(this,name,age)\n</code></pre><p><strong>(2) apply的作用</strong></p>\n<p><strong><font color=\"red\">当一个数组作为参数传入一个函数时，使用apply可以将数组解析为一个一个的参数</font></strong></p>\n<p><strong>(3) 使用apply将数组合并</strong></p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\na1.push(a2);//结果是a1=[0,1,2,[3,4]]，并不是我们需要的结果\n\n我们需要将a2这数组拆成一个个元素，然后push进入a1\n\n因此可以采用apply方法\n\nArray.prototype.push.apply(a1,a2);//使用a1调用push方法，并将a2数组拆成一个个参数传进去,a1=[0,1,2,3,4]\n\nArray.prototype.unshift.aplly(a2,a1);//a2=[0,1,2,3,4]\n</code></pre><p><strong>aplly的其他使用</strong></p>\n<pre><code>Math.max 可以实现得到数组中最大的一项\n\n因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组\n\n但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项(apply会将一个数组装换为一个参数接一个参数的传递给方法)\n\n这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去\n</code></pre><p>缺点：如果a2很大，就会出现内存溢出的情况</p>\n<p><strong>(4) 使用ES6的扩展操作符spread operator <code>...</code></strong></p>\n<p>ES6是javascript的下一个版本，ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。</p>\n<p>ES6的扩展操作符的作用和apply类似</p>\n<pre><code>a1.push(...a2)\na2.unshift(...a1)\n</code></pre>","excerpt":"","more":"<p>数组是在js中用得很多的一种类型，这篇博客是对js中数组的一些操作方法的总结。</p>\n<h3 id=\"一-js中的数组的特点\"><a href=\"#一-js中的数组的特点\" class=\"headerlink\" title=\"一. js中的数组的特点\"></a>一. js中的数组的特点</h3><p><strong>js中的数组类型，与其他语言的不同之处有两点：</strong></p>\n<ol>\n<li><p>数组中的每一项可以保存任何类型的数据</p>\n</li>\n<li><p>数组的大小可以动态调整（随着数组中数据的添加而动态增长）</p>\n</li>\n</ol>\n<h3 id=\"二-js中的数组的创建\"><a href=\"#二-js中的数组的创建\" class=\"headerlink\" title=\"二. js中的数组的创建\"></a>二. js中的数组的创建</h3><p>var myArr = new Array(3);</p>\n<p>var myArr = new Array(“1”,”2”);</p>\n<p>var myArr = [];</p>\n<p>var myArr = [1,2];</p>\n<p><strong>二维数组的创建：</strong></p>\n<p>我经常使用的一个方法如下</p>\n<pre><code>var myArr = [];//首先创建一个一维数组\nfor(var i=0;i&lt;10;i++)\n{\n    myArr[i] = new Array(10);//创建的数组中的每一项都是一个数组\n}\n这样就得到了一个10X10的数组\n</code></pre><h3 id=\"三-js中数组的操作\"><a href=\"#三-js中数组的操作\" class=\"headerlink\" title=\"三.js中数组的操作\"></a>三.js中数组的操作</h3><h4 id=\"1-myArr-length-获得数组的长度、或者给数组指定长度\"><a href=\"#1-myArr-length-获得数组的长度、或者给数组指定长度\" class=\"headerlink\" title=\"1. myArr.length 获得数组的长度、或者给数组指定长度\"></a>1. myArr.length 获得数组的长度、或者给数组指定长度</h4><pre><code>myArr.length = 4；//数组长度为4\n</code></pre><h4 id=\"2-检测是否为数组-两种方法\"><a href=\"#2-检测是否为数组-两种方法\" class=\"headerlink\" title=\"2. 检测是否为数组(两种方法)\"></a>2. 检测是否为数组(两种方法)</h4><pre><code>myArr instanceof Array\nArray.isArray(myArr)\n</code></pre><h4 id=\"3-将数组转换为字符串-toString-、toLcaleString-、join\"><a href=\"#3-将数组转换为字符串-toString-、toLcaleString-、join\" class=\"headerlink\" title=\"3. 将数组转换为字符串 toString()、toLcaleString()、join()\"></a>3. 将数组转换为字符串 toString()、toLcaleString()、join()</h4><p>toString()、toLcaleString():数组中每项以逗号连接</p>\n<p>join(“?”):数组中的每项以?连接（可以自定义分隔符号），若不传参数，默认用逗号连接</p>\n<pre><code>var colors = [1,2,3];\ncolors.toString();// 1,2,3\ncolors.join(&quot;|&quot;);// 1|2|3\n</code></pre><h4 id=\"4-数组中增加或者删除项的操作-push-、pop-、shift-、splice-、concat-、slice-、\"><a href=\"#4-数组中增加或者删除项的操作-push-、pop-、shift-、splice-、concat-、slice-、\" class=\"headerlink\" title=\"4. 数组中增加或者删除项的操作 push()、pop()、shift()、splice()、concat()、slice()、\"></a>4. 数组中增加或者删除项的操作 push()、pop()、shift()、splice()、concat()、slice()、</h4><p><strong>push()、pop()、shift()、unshift()这几个方法是在原数组上操作</strong></p>\n<pre><code>var myArr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];\n\nmyArr.push(&quot;4&quot;); //数组末尾添加一项\n[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]，或多项\n//注意：push 方法的返回值是新增的那一项\nmyArr.pop(); //删除数组的最后一项,并返回移除项 4\nmyArr.unshift();//数组的最前面添加一项 或 多项 但传入的只能是参数，不能是数组\nmyArr.shift();//删除数组的第一项,并返回移除项 4\n</code></pre><p><strong>splice()</strong>从数组中间位置添加或删除元素</p>\n<p>这个方法是在原数组上操作，并返回删除的数组</p>\n<pre><code>删除功能：splice(start,要删除的项数)\n插入功能：splice(start,0，&quot;4&quot;)\n替换功能：splice(start,1，&quot;4&quot;)\n</code></pre><p><strong>concat()、slice()</strong></p>\n<p>这两个方法都是会生成一个新的数组，而不是在原数组上操作</p>\n<pre><code>var myArr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];\nvar myArr2 = myArr.concat(&quot;4&quot;);// myArr2 = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]首先复制原数组，然后在复制的数组末尾添加一项或多项\nvar myArr3 = myArr.slice(1,2);// myArr3 = [&quot;2&quot;]\n\nslice(start,end)返回起始位置到终止位置(但不包括终止位置)的项，组成一个新的数组；若只有起始位置，则一直取到数组末尾\n</code></pre><font color=\"red\">注意：由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值</font>\n\n<pre><code>由于数组是复杂的数据类型，是引用类型，因此将一个数组赋值给另外一个数组时，是按引用进行传递。\n\neg:\n\nvar a = [1,2,3];\nvar b = a;\nb.push(4);\nconsole.log(a);//[1,2,3,4]，a也发生了变化\nconsole.log(b);//[1,2,3,4]\n\n利用slice()或者concat()让数组实现传值\nvar a = [1,2,3];\nvar b = a.slice();\nvar c = a.concat();\n\nb.push(4);\nc.push(5);\nconsole.log(a);//[1,2,3]\nconsole.log(b);//[1,2,3,4]\nconsole.log(c);//[1,2,3,5]\n</code></pre><h4 id=\"5-数组中元素的位置-sort-、reverse\"><a href=\"#5-数组中元素的位置-sort-、reverse\" class=\"headerlink\" title=\"5. 数组中元素的位置 sort()、reverse()\"></a>5. 数组中元素的位置 sort()、reverse()</h4><pre><code>myArr.sort();//会将数组的元素进行排序(按照字符串进行排序)，是直接将原数组进行排序。\n\nsort()方法会调用数组中每一项的toString()方法，然后比较得到的字符串，来确定如何排序。\n</code></pre><p>eg:</p>\n<pre><code>var values=[0,1,5,10,15]\nvalues.sort();\nalert(values);\n\n结果是：0，1，10，15，5 //不是对数值进行排序，而是对数字转换成的字符的编码顺序进行排序\n</code></pre><p><strong>给sort()传入一个比较函数，可以按照数值大小进行排序</strong></p>\n<pre><code>values.sort(compare);\n\ncompare为比较函数\n\nfunction compare(value1,value2)\n{\n    if(value1 &lt; value2)\n    {return -1;}\n\n    if(value1 = value2)\n    {return -1;}\n\n    if(value1 &gt; value2)\n    {return 1;}\n}\n\n**比较函数返回参数解释：**\n- 若为正数：第一个参数位于第二个参数之后\n- 若为0：两个参数相等\n- 若为负数：第一个参数位于第二个参数之前\n\n所以上面举例的比较函数是升序排列的比较函数\n\n简化的比较函数\n\n升序排列的比较函数 function compare(a,b){return a-b}\n\n降序排列的比较函数 function compare(a,b){return b-a}\n</code></pre><p><strong>reverse()</strong>方法，反转数组项的顺序</p>\n<h4 id=\"6-数组中的元素的位置-indexOf-、lastIndexOf\"><a href=\"#6-数组中的元素的位置-indexOf-、lastIndexOf\" class=\"headerlink\" title=\"6. 数组中的元素的位置 indexOf()、lastIndexOf()\"></a>6. 数组中的元素的位置 indexOf()、lastIndexOf()</h4><p>传入的参数在数组中是否存在，如果存在，返回下标，不存在，返回－1</p>\n<p>indexOf()：从数组的第一项开始查找</p>\n<p>lastIndexOf():从数组的最后一项开始查找</p>\n<pre><code>var myArr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];\nalert(myArr.indexOf(&apos;b&apos;));//1\nalert(myArr.lastIndexOf(&apos;c&apos;));//2\n</code></pre><h4 id=\"7-数组中的迭代方法\"><a href=\"#7-数组中的迭代方法\" class=\"headerlink\" title=\"7. 数组中的迭代方法\"></a>7. 数组中的迭代方法</h4><ul>\n<li>every()</li>\n<li>some()</li>\n<li>filter()</li>\n<li>map()</li>\n<li>forEach()</li>\n</ul>\n<p>(1) every()用于检测数组是否<strong>每一项</strong>都满足某个条件，如果是，则返回true;否则返回false</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.every(function(item,index,array){\n        return (item &gt;= 1);\n\n});//numRes为true\n</code></pre><p>(2) some()用于检测数组中是否有一项满足某个条件，如果是，则返回true;否则返回false</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.some(function(item,index,array){\n        return (item &gt;= 5);\n\n});//numRes为true\n</code></pre><p>(3) filter()用于选出数组中满足某个条件的项，并形成一个新的数组</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.filter(function(item,index,array){\n        return (item &gt;= 3);\n\n});//numRes为[3,4,5]\n</code></pre><p>(4) map()用于将数组中的每一项都做一个操作，并形成一个新的数组</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.map(function(item,index,array){\n        return (item + 3);\n\n});//numRes为[4,5,6,7,8]\n</code></pre><p>(5) forEach()用于将数组中的每一项都做一个操作（原数组发生了改变）</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nnum.forEach(function(item,index,array){\n        return (item + 3);\n\n});//num为[4,5,6,7,8]\n</code></pre><h4 id=\"8-数组中的归并方法-reduce-、reduceRight\"><a href=\"#8-数组中的归并方法-reduce-、reduceRight\" class=\"headerlink\" title=\"8. 数组中的归并方法 reduce()、reduceRight()\"></a>8. 数组中的归并方法 reduce()、reduceRight()</h4><p>将数组中的每一项进行迭代，最终返回一个值；两者的区别是迭代的方向不同，<strong>reduce()是从数组的第一项开始，reduceRight()是从数组的最后一项开始</strong>。</p>\n<p>reduce(“回调函数”,”初始值”);</p>\n<p>一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素</p>\n<p>eg:</p>\n<pre><code>var num = [1,2,3,4,5];\n\nvar numRes = num.reduce(function(prev,cur,index,array){\n\nreturn prev + cur;\n\n})//numRes为15\n</code></pre><h3 id=\"四-js合并数组的几种方法\"><a href=\"#四-js合并数组的几种方法\" class=\"headerlink\" title=\"四. js合并数组的几种方法\"></a>四. js合并数组的几种方法</h3><p><strong>1. 使用concat</strong></p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\nvar c = a1.concat(a2);//c = [0,1,2,3,4];\n</code></pre><p>缺点：会生成一个新的数组，当两个数组的元素个数较多时，会占用很多内存</p>\n<p><strong>2. 循环插入</strong></p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\n\nfor(var i=0;i&lt;a2.length;i++)\n{\n    a1.push(a2[i]);\n}\n\na1则为合并后的数组\n</code></pre><p>缺点：当a2数组很大时，for循环需要遍历很多次</p>\n<p><strong>3. reduce()和reduceRight()方法</strong></p>\n<p>reduce()是数组归并的方法</p>\n<p>reduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值</p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\n\n//给prev传入了初始值，那么prev则是指的是a1\na1 = a2.reduce(function(prev,next){\n    prev.push(next);\n    return prev;\n},a1)\n\n//a1 = [0,1,2,3,4];\n</code></pre><p>一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素</p>\n<p>reduceRight()与reduce()同理，只是从数组的右边开始归并</p>\n<p>缺点：需要对每个数组元素执行函数调用</p>\n<p><strong>4. push.apply</strong></p>\n<p><strong>(1) js中的apply()和call()的用法</strong></p>\n<p><strong>apply:应用某一对象的一个方法，用另一个对象替换当前对象。</strong></p>\n<p><strong>apply(obj,参数数组)</strong></p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n      /*定义一个人类*/\n      function Person(name,age)\n      {\n          this.name=name;\n          this.age=age;\n      }\n      /*定义一个学生类*/\n      functionStudent(name,age,grade)\n      {\n          Person.apply(this,arguments);\n          this.grade=grade;\n      }\n      //创建一个学生类\n      var student=new Student(&quot;qian&quot;,21,&quot;一年级&quot;);\n      //测试\n      alert(&quot;name:&quot;+student.name+&quot;\\n&quot;+&quot;age:&quot;+student.age+&quot;\\n&quot;+&quot;grade:&quot;+student.grade);\n      //大家可以看到测试结果name:qian  age:21  grade:一年级\n      //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.\n &lt;/script&gt;\n</code></pre><p><strong>call:与apply的作用一样，只是参数列表不一样</strong></p>\n<p><strong>call(obj,参数1,参数2…)</strong></p>\n<pre><code>将上一段的Person.apply(this,arguments) 变成 Person.call(this,name,age)\n</code></pre><p><strong>(2) apply的作用</strong></p>\n<p><strong><font color=\"red\">当一个数组作为参数传入一个函数时，使用apply可以将数组解析为一个一个的参数</font></strong></p>\n<p><strong>(3) 使用apply将数组合并</strong></p>\n<pre><code>var a1 = [0,1,2];\nvar a2 = [3,4];\na1.push(a2);//结果是a1=[0,1,2,[3,4]]，并不是我们需要的结果\n\n我们需要将a2这数组拆成一个个元素，然后push进入a1\n\n因此可以采用apply方法\n\nArray.prototype.push.apply(a1,a2);//使用a1调用push方法，并将a2数组拆成一个个参数传进去,a1=[0,1,2,3,4]\n\nArray.prototype.unshift.aplly(a2,a1);//a2=[0,1,2,3,4]\n</code></pre><p><strong>aplly的其他使用</strong></p>\n<pre><code>Math.max 可以实现得到数组中最大的一项\n\n因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组\n\n但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项(apply会将一个数组装换为一个参数接一个参数的传递给方法)\n\n这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去\n</code></pre><p>缺点：如果a2很大，就会出现内存溢出的情况</p>\n<p><strong>(4) 使用ES6的扩展操作符spread operator <code>...</code></strong></p>\n<p>ES6是javascript的下一个版本，ES6中包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。</p>\n<p>ES6的扩展操作符的作用和apply类似</p>\n<pre><code>a1.push(...a2)\na2.unshift(...a1)\n</code></pre>"},{"layout":"post","title":"js中的string类型","date":"2016-04-22T16:00:00.000Z","description":null,"_content":"这篇博客是对js中对字符串的一些操作方法的总结。\n\n### 一. js中的string类型\n\nstring类型是字符串的对象包装类型（与字符串对应的引用类型）\n\n\tvar stringObj = new String(\"Hi\");\n\n### 二. js中对字符串的一些操作\n\n#### 1. 创建字符串\n\n\tvar myStr = \"Hi\";\n\n#### 2. myStr.length 获得字符串的长度\n\tvar myStr = \"Hi\";\n\talert(myStr.length)；//字符串长度为2\n\n#### 3. 将字符串转换成数组 split()\n\nsplit()以**特定的分隔符将字符串分割**成多个子字符串，并将结果存在一个数组中。\n\n\teg:\n\n\tvar myStr = \"car,mar\";\n\tvar myRes = myStr.split(\",\");//myRes=[\"car\",\"mar\"]\n\n#### 4. 对字符串的操作\n\n##### 拼接字符串 +号操作符、concat()\n\n用+号用得比较多\n\nconcat()会生成一个**新的字符串**\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.concat(\"!\");\n\talert(myRes);//\"Hello!\"\n\n##### 截取字符串 slice()、substr()、substring()、\n\n这三个方法也不会修改原字符串，会生成一个**新的字符串**\n\n**slice(a,b)**\n\na为截取的起始位置，b为截取的结束位置+1\n\nb可以省略，若省略，则一直截取到字符串末尾\n\n    var myStr1 = \"Hello\";\n\tvar myRes = myStr.slice(1,3);\n\talert(myRes);//\"el\"\n\n若a,b为负值，则slice(a,b) = slice(a+字符串长度，b+字符串长度)\n\n**substring(a,b)**\n\na为截取的起始位置，b为截取的结束位置+1\n\nb可以省略，若省略，则一直截取到字符串末尾\n\n    var myStr1 = \"Hello\";\n\tvar myRes = myStr.substring(1,3);\n\talert(myRes);//\"el\"\n\n若a,b为负值，则substring会将为负值的参数转化为0\n\n**substr(a,b)**\n\na为截取的起始位置，b为截取的长度\n\nb可以省略，若省略，则一直截取到字符串末尾\n\n    var myStr1 = \"Hello\";\n\tvar myRes = myStr.substr(1,3);\n\talert(myRes);//\"ell\"\n\n若a,b为负值，则substr会将a加上字符串的长度，将b转化为0\n\n#### 5. 字符串中字符的位置 \n\n##### 由字符得到位置：indexOf()、lastIndexOf()\n\nindexOf()：从字符串的第一个字符开始查找\n\nlastIndexOf():从字符串的最后一个字符开始查找\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.indexOf(\"l\");//2\n\tvar myRes = myStr.lastIndexOf(\"l\");//3\n\n若有第二个参数，则可从指定位置开始查找\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.indexOf(\"l\"，2);//2\n\tvar myRes = myStr.lastIndexOf(\"l\"，2);//2\n\t\n##### 由位置得到字符 charAt()、charCodeAt() \n\n- charAt()：获得指定位置的字符\n- charCodeAt()：获得指定位置的字符编码\n \n\tvar myStr = \"Hello\";\n\talert(myStr.charAt(1))；// e 字符串的位置以0开始\n\talert(myStr.charCodeAt(1))；//101  字符串的位置以0开始\n\n#### 6. 字符串删除前后空格的方法 trim()\n\n原字符串不变，会生成一个新的字符串\n\n\tvar myStr1 = \" Hello\";\n\tvar myRes = myStr.trim();//\"Hello\"\n\n\t做表单验证时，我们需要验证表单是否为空。\n\t\n\t如果输入空格、缩进等字符，使用input.value == \"\"并不能判断出来（因为空格、缩进也是一个字符）。\n\t\n\t这时，我们就需要将输入字符串的前后空格删掉的`trim()`函数\n\n#### 7. 字符串大小写转换 toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()\n\ntoLocaleLowerCase()、toLocaleUpperCase()是针对地区的实现\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.toLowerCase();//hello\n\tvar myRes = myStr.toUpperCase();//HELLO\n\n#### 8. 字符串的模式匹配match()、replace()、search()\n\nreplace()用于替换指定字符串或者满足正则表达式的字符串，会返回一个新的数组\n\n.replace(reg/str, replacement／function)\n\n- a可以为指定字符串或者正则表达式\n- b可以为字符串、特殊的字符序列、函数\n\n\teg:\n\n\tvar myStr = \"car,mar\";\n\tvar result = myStr.replace(\"ar\",\"\");//\"c,mar\"\n\t\n\n如果第二个参数是函数\n\n**正则表达式中只有一个匹配项时：**函数的参数分别为（模式的匹配项，模式匹配项在字符串中的位置，原始字符串）\n\n**正则表达式中有多个匹配项时：**函数的参数分别为（模式的匹配项，第一个捕获组，...，第n个捕获组，模式匹配项在字符串中的位置，原始字符串）\n\n```\n\teg:\n\n\tdocument.cookie.replace(/(.*?)=(.*?)($|;)\\s?/g, function(_, name, value){\n  \tconsole.log(unescape(name), unescape(value));\n\t});\n\t//name = (.*?)=(.*?)\n\t//unescape() 函数可对通过 escape() 编码的字符串进行解码。\n```\n\t\nmatch()会返回一个数组，数组里面是第一个匹配的字符串，数组只有一项\n\n\teg:\n\n\tvar myStr1 = \"car,mar\";\n\tvar myRes = myStr.match(\"ar\");//myRes[0] = ar\n\tvar myRes = myStr.match(/.ar/);//myRes[0] = car\n\nsearch()返回字符串中第一个匹配项的索引，没有找到，返回-1\n\n\teg:\n\n\tvar myStr1 = \"car,mar\";\n\tvar myRes = myStr.search(\"a\");//1\n\tvar myRes = myStr.search(\"t\");//-1\n\n\n#### 10. localeCompare()\n\n比较两个字符串的在字母表中的先后顺序\n\n\teg:\n\n\tvar myStr = \"car\";\n\tvar myRes = myStr.localeCompare(\"aar\");//1\n\n#### 11. fromCharCode()\n\n将字符编码转换成字符串\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-04-23-js中的string类型.md","raw":"---\nlayout: post\ntitle: js中的string类型\ndate: 2016-04-23\ncategories: javaScript\ntags: [javaScript,字符串]\ndescription: \n---\n这篇博客是对js中对字符串的一些操作方法的总结。\n\n### 一. js中的string类型\n\nstring类型是字符串的对象包装类型（与字符串对应的引用类型）\n\n\tvar stringObj = new String(\"Hi\");\n\n### 二. js中对字符串的一些操作\n\n#### 1. 创建字符串\n\n\tvar myStr = \"Hi\";\n\n#### 2. myStr.length 获得字符串的长度\n\tvar myStr = \"Hi\";\n\talert(myStr.length)；//字符串长度为2\n\n#### 3. 将字符串转换成数组 split()\n\nsplit()以**特定的分隔符将字符串分割**成多个子字符串，并将结果存在一个数组中。\n\n\teg:\n\n\tvar myStr = \"car,mar\";\n\tvar myRes = myStr.split(\",\");//myRes=[\"car\",\"mar\"]\n\n#### 4. 对字符串的操作\n\n##### 拼接字符串 +号操作符、concat()\n\n用+号用得比较多\n\nconcat()会生成一个**新的字符串**\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.concat(\"!\");\n\talert(myRes);//\"Hello!\"\n\n##### 截取字符串 slice()、substr()、substring()、\n\n这三个方法也不会修改原字符串，会生成一个**新的字符串**\n\n**slice(a,b)**\n\na为截取的起始位置，b为截取的结束位置+1\n\nb可以省略，若省略，则一直截取到字符串末尾\n\n    var myStr1 = \"Hello\";\n\tvar myRes = myStr.slice(1,3);\n\talert(myRes);//\"el\"\n\n若a,b为负值，则slice(a,b) = slice(a+字符串长度，b+字符串长度)\n\n**substring(a,b)**\n\na为截取的起始位置，b为截取的结束位置+1\n\nb可以省略，若省略，则一直截取到字符串末尾\n\n    var myStr1 = \"Hello\";\n\tvar myRes = myStr.substring(1,3);\n\talert(myRes);//\"el\"\n\n若a,b为负值，则substring会将为负值的参数转化为0\n\n**substr(a,b)**\n\na为截取的起始位置，b为截取的长度\n\nb可以省略，若省略，则一直截取到字符串末尾\n\n    var myStr1 = \"Hello\";\n\tvar myRes = myStr.substr(1,3);\n\talert(myRes);//\"ell\"\n\n若a,b为负值，则substr会将a加上字符串的长度，将b转化为0\n\n#### 5. 字符串中字符的位置 \n\n##### 由字符得到位置：indexOf()、lastIndexOf()\n\nindexOf()：从字符串的第一个字符开始查找\n\nlastIndexOf():从字符串的最后一个字符开始查找\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.indexOf(\"l\");//2\n\tvar myRes = myStr.lastIndexOf(\"l\");//3\n\n若有第二个参数，则可从指定位置开始查找\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.indexOf(\"l\"，2);//2\n\tvar myRes = myStr.lastIndexOf(\"l\"，2);//2\n\t\n##### 由位置得到字符 charAt()、charCodeAt() \n\n- charAt()：获得指定位置的字符\n- charCodeAt()：获得指定位置的字符编码\n \n\tvar myStr = \"Hello\";\n\talert(myStr.charAt(1))；// e 字符串的位置以0开始\n\talert(myStr.charCodeAt(1))；//101  字符串的位置以0开始\n\n#### 6. 字符串删除前后空格的方法 trim()\n\n原字符串不变，会生成一个新的字符串\n\n\tvar myStr1 = \" Hello\";\n\tvar myRes = myStr.trim();//\"Hello\"\n\n\t做表单验证时，我们需要验证表单是否为空。\n\t\n\t如果输入空格、缩进等字符，使用input.value == \"\"并不能判断出来（因为空格、缩进也是一个字符）。\n\t\n\t这时，我们就需要将输入字符串的前后空格删掉的`trim()`函数\n\n#### 7. 字符串大小写转换 toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()\n\ntoLocaleLowerCase()、toLocaleUpperCase()是针对地区的实现\n\n\tvar myStr1 = \"Hello\";\n\tvar myRes = myStr.toLowerCase();//hello\n\tvar myRes = myStr.toUpperCase();//HELLO\n\n#### 8. 字符串的模式匹配match()、replace()、search()\n\nreplace()用于替换指定字符串或者满足正则表达式的字符串，会返回一个新的数组\n\n.replace(reg/str, replacement／function)\n\n- a可以为指定字符串或者正则表达式\n- b可以为字符串、特殊的字符序列、函数\n\n\teg:\n\n\tvar myStr = \"car,mar\";\n\tvar result = myStr.replace(\"ar\",\"\");//\"c,mar\"\n\t\n\n如果第二个参数是函数\n\n**正则表达式中只有一个匹配项时：**函数的参数分别为（模式的匹配项，模式匹配项在字符串中的位置，原始字符串）\n\n**正则表达式中有多个匹配项时：**函数的参数分别为（模式的匹配项，第一个捕获组，...，第n个捕获组，模式匹配项在字符串中的位置，原始字符串）\n\n```\n\teg:\n\n\tdocument.cookie.replace(/(.*?)=(.*?)($|;)\\s?/g, function(_, name, value){\n  \tconsole.log(unescape(name), unescape(value));\n\t});\n\t//name = (.*?)=(.*?)\n\t//unescape() 函数可对通过 escape() 编码的字符串进行解码。\n```\n\t\nmatch()会返回一个数组，数组里面是第一个匹配的字符串，数组只有一项\n\n\teg:\n\n\tvar myStr1 = \"car,mar\";\n\tvar myRes = myStr.match(\"ar\");//myRes[0] = ar\n\tvar myRes = myStr.match(/.ar/);//myRes[0] = car\n\nsearch()返回字符串中第一个匹配项的索引，没有找到，返回-1\n\n\teg:\n\n\tvar myStr1 = \"car,mar\";\n\tvar myRes = myStr.search(\"a\");//1\n\tvar myRes = myStr.search(\"t\");//-1\n\n\n#### 10. localeCompare()\n\n比较两个字符串的在字母表中的先后顺序\n\n\teg:\n\n\tvar myStr = \"car\";\n\tvar myRes = myStr.localeCompare(\"aar\");//1\n\n#### 11. fromCharCode()\n\n将字符编码转换成字符串\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-04-23-js中的string类型","published":1,"updated":"2016-08-18T05:20:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035oceg003ad5u82cbzagm4","content":"<p>这篇博客是对js中对字符串的一些操作方法的总结。</p>\n<h3 id=\"一-js中的string类型\"><a href=\"#一-js中的string类型\" class=\"headerlink\" title=\"一. js中的string类型\"></a>一. js中的string类型</h3><p>string类型是字符串的对象包装类型（与字符串对应的引用类型）</p>\n<pre><code>var stringObj = new String(&quot;Hi&quot;);\n</code></pre><h3 id=\"二-js中对字符串的一些操作\"><a href=\"#二-js中对字符串的一些操作\" class=\"headerlink\" title=\"二. js中对字符串的一些操作\"></a>二. js中对字符串的一些操作</h3><h4 id=\"1-创建字符串\"><a href=\"#1-创建字符串\" class=\"headerlink\" title=\"1. 创建字符串\"></a>1. 创建字符串</h4><pre><code>var myStr = &quot;Hi&quot;;\n</code></pre><h4 id=\"2-myStr-length-获得字符串的长度\"><a href=\"#2-myStr-length-获得字符串的长度\" class=\"headerlink\" title=\"2. myStr.length 获得字符串的长度\"></a>2. myStr.length 获得字符串的长度</h4><pre><code>var myStr = &quot;Hi&quot;;\nalert(myStr.length)；//字符串长度为2\n</code></pre><h4 id=\"3-将字符串转换成数组-split\"><a href=\"#3-将字符串转换成数组-split\" class=\"headerlink\" title=\"3. 将字符串转换成数组 split()\"></a>3. 将字符串转换成数组 split()</h4><p>split()以<strong>特定的分隔符将字符串分割</strong>成多个子字符串，并将结果存在一个数组中。</p>\n<pre><code>eg:\n\nvar myStr = &quot;car,mar&quot;;\nvar myRes = myStr.split(&quot;,&quot;);//myRes=[&quot;car&quot;,&quot;mar&quot;]\n</code></pre><h4 id=\"4-对字符串的操作\"><a href=\"#4-对字符串的操作\" class=\"headerlink\" title=\"4. 对字符串的操作\"></a>4. 对字符串的操作</h4><h5 id=\"拼接字符串-号操作符、concat\"><a href=\"#拼接字符串-号操作符、concat\" class=\"headerlink\" title=\"拼接字符串 +号操作符、concat()\"></a>拼接字符串 +号操作符、concat()</h5><p>用+号用得比较多</p>\n<p>concat()会生成一个<strong>新的字符串</strong></p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.concat(&quot;!&quot;);\nalert(myRes);//&quot;Hello!&quot;\n</code></pre><h5 id=\"截取字符串-slice-、substr-、substring-、\"><a href=\"#截取字符串-slice-、substr-、substring-、\" class=\"headerlink\" title=\"截取字符串 slice()、substr()、substring()、\"></a>截取字符串 slice()、substr()、substring()、</h5><p>这三个方法也不会修改原字符串，会生成一个<strong>新的字符串</strong></p>\n<p><strong>slice(a,b)</strong></p>\n<p>a为截取的起始位置，b为截取的结束位置+1</p>\n<p>b可以省略，若省略，则一直截取到字符串末尾</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.slice(1,3);\nalert(myRes);//&quot;el&quot;\n</code></pre><p>若a,b为负值，则slice(a,b) = slice(a+字符串长度，b+字符串长度)</p>\n<p><strong>substring(a,b)</strong></p>\n<p>a为截取的起始位置，b为截取的结束位置+1</p>\n<p>b可以省略，若省略，则一直截取到字符串末尾</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.substring(1,3);\nalert(myRes);//&quot;el&quot;\n</code></pre><p>若a,b为负值，则substring会将为负值的参数转化为0</p>\n<p><strong>substr(a,b)</strong></p>\n<p>a为截取的起始位置，b为截取的长度</p>\n<p>b可以省略，若省略，则一直截取到字符串末尾</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.substr(1,3);\nalert(myRes);//&quot;ell&quot;\n</code></pre><p>若a,b为负值，则substr会将a加上字符串的长度，将b转化为0</p>\n<h4 id=\"5-字符串中字符的位置\"><a href=\"#5-字符串中字符的位置\" class=\"headerlink\" title=\"5. 字符串中字符的位置\"></a>5. 字符串中字符的位置</h4><h5 id=\"由字符得到位置：indexOf-、lastIndexOf\"><a href=\"#由字符得到位置：indexOf-、lastIndexOf\" class=\"headerlink\" title=\"由字符得到位置：indexOf()、lastIndexOf()\"></a>由字符得到位置：indexOf()、lastIndexOf()</h5><p>indexOf()：从字符串的第一个字符开始查找</p>\n<p>lastIndexOf():从字符串的最后一个字符开始查找</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.indexOf(&quot;l&quot;);//2\nvar myRes = myStr.lastIndexOf(&quot;l&quot;);//3\n</code></pre><p>若有第二个参数，则可从指定位置开始查找</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.indexOf(&quot;l&quot;，2);//2\nvar myRes = myStr.lastIndexOf(&quot;l&quot;，2);//2\n</code></pre><h5 id=\"由位置得到字符-charAt-、charCodeAt\"><a href=\"#由位置得到字符-charAt-、charCodeAt\" class=\"headerlink\" title=\"由位置得到字符 charAt()、charCodeAt()\"></a>由位置得到字符 charAt()、charCodeAt()</h5><ul>\n<li>charAt()：获得指定位置的字符</li>\n<li><p>charCodeAt()：获得指定位置的字符编码</p>\n<p>  var myStr = “Hello”;<br>  alert(myStr.charAt(1))；// e 字符串的位置以0开始<br>  alert(myStr.charCodeAt(1))；//101  字符串的位置以0开始</p>\n</li>\n</ul>\n<h4 id=\"6-字符串删除前后空格的方法-trim\"><a href=\"#6-字符串删除前后空格的方法-trim\" class=\"headerlink\" title=\"6. 字符串删除前后空格的方法 trim()\"></a>6. 字符串删除前后空格的方法 trim()</h4><p>原字符串不变，会生成一个新的字符串</p>\n<pre><code>var myStr1 = &quot; Hello&quot;;\nvar myRes = myStr.trim();//&quot;Hello&quot;\n\n做表单验证时，我们需要验证表单是否为空。\n\n如果输入空格、缩进等字符，使用input.value == &quot;&quot;并不能判断出来（因为空格、缩进也是一个字符）。\n\n这时，我们就需要将输入字符串的前后空格删掉的`trim()`函数\n</code></pre><h4 id=\"7-字符串大小写转换-toLowerCase-、toUpperCase-、toLocaleLowerCase-、toLocaleUpperCase\"><a href=\"#7-字符串大小写转换-toLowerCase-、toUpperCase-、toLocaleLowerCase-、toLocaleUpperCase\" class=\"headerlink\" title=\"7. 字符串大小写转换 toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()\"></a>7. 字符串大小写转换 toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()</h4><p>toLocaleLowerCase()、toLocaleUpperCase()是针对地区的实现</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.toLowerCase();//hello\nvar myRes = myStr.toUpperCase();//HELLO\n</code></pre><h4 id=\"8-字符串的模式匹配match-、replace-、search\"><a href=\"#8-字符串的模式匹配match-、replace-、search\" class=\"headerlink\" title=\"8. 字符串的模式匹配match()、replace()、search()\"></a>8. 字符串的模式匹配match()、replace()、search()</h4><p>replace()用于替换指定字符串或者满足正则表达式的字符串，会返回一个新的数组</p>\n<p>.replace(reg/str, replacement／function)</p>\n<ul>\n<li>a可以为指定字符串或者正则表达式</li>\n<li><p>b可以为字符串、特殊的字符序列、函数</p>\n<p>  eg:</p>\n<p>  var myStr = “car,mar”;<br>  var result = myStr.replace(“ar”,””);//“c,mar”</p>\n</li>\n</ul>\n<p>如果第二个参数是函数</p>\n<p><strong>正则表达式中只有一个匹配项时：</strong>函数的参数分别为（模式的匹配项，模式匹配项在字符串中的位置，原始字符串）</p>\n<p><strong>正则表达式中有多个匹配项时：</strong>函数的参数分别为（模式的匹配项，第一个捕获组，…，第n个捕获组，模式匹配项在字符串中的位置，原始字符串）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie.replace(<span class=\"regexp\">/(.*?)=(.*?)($|;)\\s?/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_, name, value</span>)</span>&#123;</span><br><span class=\"line\"> \t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">unescape</span>(name), <span class=\"built_in\">unescape</span>(value));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//name = (.*?)=(.*?)</span></span><br><span class=\"line\"><span class=\"comment\">//unescape() 函数可对通过 escape() 编码的字符串进行解码。</span></span><br></pre></td></tr></table></figure>\n<p>match()会返回一个数组，数组里面是第一个匹配的字符串，数组只有一项</p>\n<pre><code>eg:\n\nvar myStr1 = &quot;car,mar&quot;;\nvar myRes = myStr.match(&quot;ar&quot;);//myRes[0] = ar\nvar myRes = myStr.match(/.ar/);//myRes[0] = car\n</code></pre><p>search()返回字符串中第一个匹配项的索引，没有找到，返回-1</p>\n<pre><code>eg:\n\nvar myStr1 = &quot;car,mar&quot;;\nvar myRes = myStr.search(&quot;a&quot;);//1\nvar myRes = myStr.search(&quot;t&quot;);//-1\n</code></pre><h4 id=\"10-localeCompare\"><a href=\"#10-localeCompare\" class=\"headerlink\" title=\"10. localeCompare()\"></a>10. localeCompare()</h4><p>比较两个字符串的在字母表中的先后顺序</p>\n<pre><code>eg:\n\nvar myStr = &quot;car&quot;;\nvar myRes = myStr.localeCompare(&quot;aar&quot;);//1\n</code></pre><h4 id=\"11-fromCharCode\"><a href=\"#11-fromCharCode\" class=\"headerlink\" title=\"11. fromCharCode()\"></a>11. fromCharCode()</h4><p>将字符编码转换成字符串</p>\n","excerpt":"","more":"<p>这篇博客是对js中对字符串的一些操作方法的总结。</p>\n<h3 id=\"一-js中的string类型\"><a href=\"#一-js中的string类型\" class=\"headerlink\" title=\"一. js中的string类型\"></a>一. js中的string类型</h3><p>string类型是字符串的对象包装类型（与字符串对应的引用类型）</p>\n<pre><code>var stringObj = new String(&quot;Hi&quot;);\n</code></pre><h3 id=\"二-js中对字符串的一些操作\"><a href=\"#二-js中对字符串的一些操作\" class=\"headerlink\" title=\"二. js中对字符串的一些操作\"></a>二. js中对字符串的一些操作</h3><h4 id=\"1-创建字符串\"><a href=\"#1-创建字符串\" class=\"headerlink\" title=\"1. 创建字符串\"></a>1. 创建字符串</h4><pre><code>var myStr = &quot;Hi&quot;;\n</code></pre><h4 id=\"2-myStr-length-获得字符串的长度\"><a href=\"#2-myStr-length-获得字符串的长度\" class=\"headerlink\" title=\"2. myStr.length 获得字符串的长度\"></a>2. myStr.length 获得字符串的长度</h4><pre><code>var myStr = &quot;Hi&quot;;\nalert(myStr.length)；//字符串长度为2\n</code></pre><h4 id=\"3-将字符串转换成数组-split\"><a href=\"#3-将字符串转换成数组-split\" class=\"headerlink\" title=\"3. 将字符串转换成数组 split()\"></a>3. 将字符串转换成数组 split()</h4><p>split()以<strong>特定的分隔符将字符串分割</strong>成多个子字符串，并将结果存在一个数组中。</p>\n<pre><code>eg:\n\nvar myStr = &quot;car,mar&quot;;\nvar myRes = myStr.split(&quot;,&quot;);//myRes=[&quot;car&quot;,&quot;mar&quot;]\n</code></pre><h4 id=\"4-对字符串的操作\"><a href=\"#4-对字符串的操作\" class=\"headerlink\" title=\"4. 对字符串的操作\"></a>4. 对字符串的操作</h4><h5 id=\"拼接字符串-号操作符、concat\"><a href=\"#拼接字符串-号操作符、concat\" class=\"headerlink\" title=\"拼接字符串 +号操作符、concat()\"></a>拼接字符串 +号操作符、concat()</h5><p>用+号用得比较多</p>\n<p>concat()会生成一个<strong>新的字符串</strong></p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.concat(&quot;!&quot;);\nalert(myRes);//&quot;Hello!&quot;\n</code></pre><h5 id=\"截取字符串-slice-、substr-、substring-、\"><a href=\"#截取字符串-slice-、substr-、substring-、\" class=\"headerlink\" title=\"截取字符串 slice()、substr()、substring()、\"></a>截取字符串 slice()、substr()、substring()、</h5><p>这三个方法也不会修改原字符串，会生成一个<strong>新的字符串</strong></p>\n<p><strong>slice(a,b)</strong></p>\n<p>a为截取的起始位置，b为截取的结束位置+1</p>\n<p>b可以省略，若省略，则一直截取到字符串末尾</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.slice(1,3);\nalert(myRes);//&quot;el&quot;\n</code></pre><p>若a,b为负值，则slice(a,b) = slice(a+字符串长度，b+字符串长度)</p>\n<p><strong>substring(a,b)</strong></p>\n<p>a为截取的起始位置，b为截取的结束位置+1</p>\n<p>b可以省略，若省略，则一直截取到字符串末尾</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.substring(1,3);\nalert(myRes);//&quot;el&quot;\n</code></pre><p>若a,b为负值，则substring会将为负值的参数转化为0</p>\n<p><strong>substr(a,b)</strong></p>\n<p>a为截取的起始位置，b为截取的长度</p>\n<p>b可以省略，若省略，则一直截取到字符串末尾</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.substr(1,3);\nalert(myRes);//&quot;ell&quot;\n</code></pre><p>若a,b为负值，则substr会将a加上字符串的长度，将b转化为0</p>\n<h4 id=\"5-字符串中字符的位置\"><a href=\"#5-字符串中字符的位置\" class=\"headerlink\" title=\"5. 字符串中字符的位置\"></a>5. 字符串中字符的位置</h4><h5 id=\"由字符得到位置：indexOf-、lastIndexOf\"><a href=\"#由字符得到位置：indexOf-、lastIndexOf\" class=\"headerlink\" title=\"由字符得到位置：indexOf()、lastIndexOf()\"></a>由字符得到位置：indexOf()、lastIndexOf()</h5><p>indexOf()：从字符串的第一个字符开始查找</p>\n<p>lastIndexOf():从字符串的最后一个字符开始查找</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.indexOf(&quot;l&quot;);//2\nvar myRes = myStr.lastIndexOf(&quot;l&quot;);//3\n</code></pre><p>若有第二个参数，则可从指定位置开始查找</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.indexOf(&quot;l&quot;，2);//2\nvar myRes = myStr.lastIndexOf(&quot;l&quot;，2);//2\n</code></pre><h5 id=\"由位置得到字符-charAt-、charCodeAt\"><a href=\"#由位置得到字符-charAt-、charCodeAt\" class=\"headerlink\" title=\"由位置得到字符 charAt()、charCodeAt()\"></a>由位置得到字符 charAt()、charCodeAt()</h5><ul>\n<li>charAt()：获得指定位置的字符</li>\n<li><p>charCodeAt()：获得指定位置的字符编码</p>\n<p>  var myStr = “Hello”;<br>  alert(myStr.charAt(1))；// e 字符串的位置以0开始<br>  alert(myStr.charCodeAt(1))；//101  字符串的位置以0开始</p>\n</li>\n</ul>\n<h4 id=\"6-字符串删除前后空格的方法-trim\"><a href=\"#6-字符串删除前后空格的方法-trim\" class=\"headerlink\" title=\"6. 字符串删除前后空格的方法 trim()\"></a>6. 字符串删除前后空格的方法 trim()</h4><p>原字符串不变，会生成一个新的字符串</p>\n<pre><code>var myStr1 = &quot; Hello&quot;;\nvar myRes = myStr.trim();//&quot;Hello&quot;\n\n做表单验证时，我们需要验证表单是否为空。\n\n如果输入空格、缩进等字符，使用input.value == &quot;&quot;并不能判断出来（因为空格、缩进也是一个字符）。\n\n这时，我们就需要将输入字符串的前后空格删掉的`trim()`函数\n</code></pre><h4 id=\"7-字符串大小写转换-toLowerCase-、toUpperCase-、toLocaleLowerCase-、toLocaleUpperCase\"><a href=\"#7-字符串大小写转换-toLowerCase-、toUpperCase-、toLocaleLowerCase-、toLocaleUpperCase\" class=\"headerlink\" title=\"7. 字符串大小写转换 toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()\"></a>7. 字符串大小写转换 toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()</h4><p>toLocaleLowerCase()、toLocaleUpperCase()是针对地区的实现</p>\n<pre><code>var myStr1 = &quot;Hello&quot;;\nvar myRes = myStr.toLowerCase();//hello\nvar myRes = myStr.toUpperCase();//HELLO\n</code></pre><h4 id=\"8-字符串的模式匹配match-、replace-、search\"><a href=\"#8-字符串的模式匹配match-、replace-、search\" class=\"headerlink\" title=\"8. 字符串的模式匹配match()、replace()、search()\"></a>8. 字符串的模式匹配match()、replace()、search()</h4><p>replace()用于替换指定字符串或者满足正则表达式的字符串，会返回一个新的数组</p>\n<p>.replace(reg/str, replacement／function)</p>\n<ul>\n<li>a可以为指定字符串或者正则表达式</li>\n<li><p>b可以为字符串、特殊的字符序列、函数</p>\n<p>  eg:</p>\n<p>  var myStr = “car,mar”;<br>  var result = myStr.replace(“ar”,””);//“c,mar”</p>\n</li>\n</ul>\n<p>如果第二个参数是函数</p>\n<p><strong>正则表达式中只有一个匹配项时：</strong>函数的参数分别为（模式的匹配项，模式匹配项在字符串中的位置，原始字符串）</p>\n<p><strong>正则表达式中有多个匹配项时：</strong>函数的参数分别为（模式的匹配项，第一个捕获组，…，第n个捕获组，模式匹配项在字符串中的位置，原始字符串）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie.replace(<span class=\"regexp\">/(.*?)=(.*?)($|;)\\s?/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_, name, value</span>)</span>&#123;</span><br><span class=\"line\"> \t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">unescape</span>(name), <span class=\"built_in\">unescape</span>(value));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//name = (.*?)=(.*?)</span></span><br><span class=\"line\"><span class=\"comment\">//unescape() 函数可对通过 escape() 编码的字符串进行解码。</span></span><br></pre></td></tr></table></figure>\n<p>match()会返回一个数组，数组里面是第一个匹配的字符串，数组只有一项</p>\n<pre><code>eg:\n\nvar myStr1 = &quot;car,mar&quot;;\nvar myRes = myStr.match(&quot;ar&quot;);//myRes[0] = ar\nvar myRes = myStr.match(/.ar/);//myRes[0] = car\n</code></pre><p>search()返回字符串中第一个匹配项的索引，没有找到，返回-1</p>\n<pre><code>eg:\n\nvar myStr1 = &quot;car,mar&quot;;\nvar myRes = myStr.search(&quot;a&quot;);//1\nvar myRes = myStr.search(&quot;t&quot;);//-1\n</code></pre><h4 id=\"10-localeCompare\"><a href=\"#10-localeCompare\" class=\"headerlink\" title=\"10. localeCompare()\"></a>10. localeCompare()</h4><p>比较两个字符串的在字母表中的先后顺序</p>\n<pre><code>eg:\n\nvar myStr = &quot;car&quot;;\nvar myRes = myStr.localeCompare(&quot;aar&quot;);//1\n</code></pre><h4 id=\"11-fromCharCode\"><a href=\"#11-fromCharCode\" class=\"headerlink\" title=\"11. fromCharCode()\"></a>11. fromCharCode()</h4><p>将字符编码转换成字符串</p>\n"},{"layout":"post","title":"HTML5游戏开发","date":"2016-04-25T16:00:00.000Z","description":null,"_content":"使用HTML5开发游戏，可以选择canvas和传统的DOM来进行制作。\n\n优缺点：\n\nCanvas的缺点：\n\n1. 没有实现动画的API，你必须依靠定时器和其他事件来更新Canvas\n2. 对文本的渲染支持也是比较差\n3. 由于Canvas里面没有dom节点，当某个元素需要执行交互事件(如click)的时候只能是通过坐标来判断","source":"_posts/2016-04-26-HTML5游戏开发.md","raw":"---\nlayout: post\ntitle: HTML5游戏开发\ndate: 2016-04-26\ncategories: 前端笔记\ntags: [HTML5]\ndescription: \n---\n使用HTML5开发游戏，可以选择canvas和传统的DOM来进行制作。\n\n优缺点：\n\nCanvas的缺点：\n\n1. 没有实现动画的API，你必须依靠定时器和其他事件来更新Canvas\n2. 对文本的渲染支持也是比较差\n3. 由于Canvas里面没有dom节点，当某个元素需要执行交互事件(如click)的时候只能是通过坐标来判断","slug":"2016-04-26-HTML5游戏开发","published":1,"updated":"2016-04-28T13:22:28.000Z","comments":1,"photos":[],"link":"","_id":"cj035oceh003dd5u8fwrg8elu","content":"<p>使用HTML5开发游戏，可以选择canvas和传统的DOM来进行制作。</p>\n<p>优缺点：</p>\n<p>Canvas的缺点：</p>\n<ol>\n<li>没有实现动画的API，你必须依靠定时器和其他事件来更新Canvas</li>\n<li>对文本的渲染支持也是比较差</li>\n<li>由于Canvas里面没有dom节点，当某个元素需要执行交互事件(如click)的时候只能是通过坐标来判断</li>\n</ol>\n","excerpt":"","more":"<p>使用HTML5开发游戏，可以选择canvas和传统的DOM来进行制作。</p>\n<p>优缺点：</p>\n<p>Canvas的缺点：</p>\n<ol>\n<li>没有实现动画的API，你必须依靠定时器和其他事件来更新Canvas</li>\n<li>对文本的渲染支持也是比较差</li>\n<li>由于Canvas里面没有dom节点，当某个元素需要执行交互事件(如click)的时候只能是通过坐标来判断</li>\n</ol>\n"},{"layout":"post","title":"HTML5中的canvas","date":"2016-04-24T16:00:00.000Z","description":null,"_content":"`<canvas>`是HYML5中新增的标签，利用canvas，可以在js内部完成图像的绘制，canvas可以理解成一张画布。\n\n### 一. 使用canvas画图的准备工作\n\n**HTML中**\n\n\t<canvas id=\"myCanvas\"></canvas>\n\n**JS中**\n\n\tvar canvas1 = document.getElementById('myCanvas');//获取canvasDOM节点\n        \n    var ctx1 = canvas1.getContext('2d');//获取此canvas1的上下文，可以理解成获得画布\n\n完成这两步之后，便可在画布上进行绘制\n\n### 二. 使用canvas进行绘制\n\n#### 1. 绘制图形  矩形、线型、三角形等\n\n(1) 矩形\n\ncanvas只支持一种原生图形的绘制:矩形\n\n与矩形有关的三个方法：\n\n- fillRect(startX,startY,width,height)  绘制一个填充的矩形\n- fillStroke(startX,startY,width,height) 绘制一个矩形的边框\n- clearRect(startX,startY,width,height)  清除指定矩形区域\n\n(2) 线型\n\n通过设置路径来画各种线\n\n\t第一步：beginPath();//开始设置路径\n\t第二步：moveTo(x,y);//设置路径的起点（将笔触移动到某个坐标）\n\t第三步：lineTo(x,y);//设置线的终点，从起点到终点画一条直线\n\t\t   arc(x,y,半径,开始的弧度,结束的弧度,旋转的方向)//画圆弧\n\t第四步:fill();//根据画的线型，生成实心图形\n\t      stroke();//根据画的线型，生成轮廓\n\n(3) 三角形\n\n三角形可以通过(2)中的线型生成，其余的几何形状也可以按照同样的方式生成。\n\neg:\n\tvar canvas = document.getElementById('canvas');\n    var ctx = canvas.getContext('2d');\n\n    // 填充三角形\n    ctx.beginPath();\n    ctx.moveTo(25,25);\n    ctx.lineTo(105,25);\n    ctx.lineTo(25,105);\n    ctx.fill();\n\n#### 2. 绘制文本 \n\n(1) 文本\n\n文本有三个属性：font、textAlign、textBaseline\n\nfont = \"bold 14px Arial\"\n\ntextAlign = \"start/end/left/right/center\"\n\ntextBaseline = \"top/hanging/middle/alphabetic/ideographic/bottom/middle\"\n\nfillText(\"文本\",x,y)\n\nstrokeText(\"文本\",x,y)\n\nmeasureText(\"文本\").width 返回指定文本的大小\n\n#### 3. 绘制图像\n\n(1) 获得图像\n\n这里的图像来源可以是一张图片、一个视频帧、另外一个canvas\n\n    var img = new Image();   // 创建一个<img>元素\n    img.onload = function(){ //用load时间来保证不会在加载完毕之前使用这个图片：\n      ctx.drawImage(img,0,0);\n      ctx.beginPath();\n      ctx.moveTo(30,96);\n      ctx.lineTo(70,66);\n      ctx.lineTo(103,76);\n      ctx.lineTo(170,15);\n      ctx.stroke();\n    }\n    img.src = 'myImage.png'; // 设置图片源地址\n\n(2) 将图像画在画布中 drawImage(传入的image元素，x，y，width，height)\n\n#### 4. 设置阴影\n\nshadowColor:阴影颜色\nshadowOffsetX:沿x轴的阴影偏移量\nshadowOffsetY:沿y轴的阴影偏移量\nshadowBlur:阴影模糊的像素数\n\n上述四种属性均为上下文的属性。\n\n#### 5. 设置颜色\n\n(1) 直接设置颜色\n\n- fillStyle = \"color\"  设置填充颜色\n- strokeStyle = \"color\"  设置边框颜色\n- globalAlpha = 透明度\t设置canvas里所有图形的透明度（使用较少）\n\n(2) 使用渐变设置颜色\n\n渐变分为两种：线性渐变、径向渐变\n\n第一步：为图形创建一个渐变对象\n\n    createLinearGradient(startX,startY,endX,endY);//创建线性渐变对象\n    createRadialGradient(x1,y1,r1,x2,y2,r2);//创建径向渐变对象\n\n第二步：给渐变对象添加颜色 addColorStop(position,color)\n\n    var LG1 = ctx.createLinearGradient(0,0,150,150);\n    LG1.addColorStop(0,'white');\n    LG1.addColorStop(1,'black');\n\n第三步：将渐变对象赋给图形的fillStyle、strokeStyle属性\n\n\tctx.fillStyle = LG1;\n\n#### 6. 设置线型样式\n\nlineWidth  设置线条宽度\n\nlineCap   设置线条末端样式 butt，round 和 square\n\nlineJoin  设定线条与线条间接合处的样式 round, bevel 和 miter\n\nmiterLimit 限制当两条线相交时交接处最大长度\n\ngetLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组\n\nsetLineDash() 设置当前虚线样式\n\nlineDashOffset 设置虚线样式的起始偏移量\n\n\n<font color=\"red\">暂时只总结了最最基本的用法，后面的用法以后有时间再整理一下。</font>\n\n### 三. canvas中的width、height与一般style中的width、height的区别\n\n1. **canvas标签的width、height**\n\ncanvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面，绘制图形的坐标也是以canvas的左上角为起点。\n\ncanvas的width、height只能设置数字宽度和高度，不能设置百分比。\n\ncanvas的默认宽度为300px,默认高度为150px\n\n2. **canvas作为html的标签，所以也有style属性中的width、height，style的width和height是canvas在浏览器中被渲染的高度和宽度，也就是在浏览器中看起来的高度**\n\n可以通过设置canvas的style.width、style.height来对canvas画布进行缩放。\n\n例如：\n\n\t<canvas id=\"diagonal1\" style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n    <canvas id=\"diagonal2\" style=\"border:1px solid;width:200px;height:200px;\" width=\"100px\" height=\"100px\"></canvas>\n    <canvas id=\"diagonal3\" style=\"border:1px solid;width:200px;height:200px;\" ></canvas>\n\n\t<script type=\"text/javascript\">\n            function drawDiagonal(id){\n                var canvas=document.getElementById(id);\n                var context=canvas.getContext(\"2d\");\n                context.beginPath();\n                context.moveTo(0,0);\n                context.lineTo(100,100);\n                context.stroke();\n            }\n\n            window.onload=function(){                \n                drawDiagonal(\"diagonal1\");\n                drawDiagonal(\"diagonal2\");\n                drawDiagonal(\"diagonal3\");              \n            }\n    </script>\n\n最终在浏览器中显示的情况如下所示：\n[http://panpanfish.com/myDemo/canvas-width.html](http://panpanfish.com/myDemo/canvas-width.html)\n\ndiagonal1的style.width、style.height比例与画布相等，因此没有什么影响\n\ndiagonal2的style.width、style.height比例与画布比例一致，因此将画布等比例放大了\n\ndiagonal3的style.width、style.height比例与画布比例不一致，因此上面的线的位置发生了变化。遵循的一个原则是，保持相对为置不变：(100,100)在(300,150)的画布上占的位置是x轴1/3，y轴2/3的那个点，当canvas的渲染高度宽度变成了(200,200)时，线的终点变成了(200 * 1/3,200 * 2/3)\n\n### 四. canvas移动端屏幕适配问题\n\n在移动端，可以根据百分比布局来适配canvas画布。\n\n可以根据`document.documentElement.clientWidth`来获取屏幕的宽度，将宽度赋给`canvas.width`（如果画布要满屏的话，其他情况也同理），根据定好的长宽比，算出高度，将高度值赋给`canvas.height`\n\n例如：\n\n\tvar clientWidth = document.documentElement.clientWidth;//获得设备可见区域宽度\n\tcanvas.width = clientWidth;\n\tcanvas.height = clientWidth*800/600;\n\n\t然后在画布相应的位置上画上相应的图形即可\n\n\n\n","source":"_posts/2016-04-25-HTML5中的canvas.md","raw":"---\nlayout: post\ntitle: HTML5中的canvas\ndate: 2016-04-25\ncategories: HTML\ntags: [HTML5]\ndescription: \n---\n`<canvas>`是HYML5中新增的标签，利用canvas，可以在js内部完成图像的绘制，canvas可以理解成一张画布。\n\n### 一. 使用canvas画图的准备工作\n\n**HTML中**\n\n\t<canvas id=\"myCanvas\"></canvas>\n\n**JS中**\n\n\tvar canvas1 = document.getElementById('myCanvas');//获取canvasDOM节点\n        \n    var ctx1 = canvas1.getContext('2d');//获取此canvas1的上下文，可以理解成获得画布\n\n完成这两步之后，便可在画布上进行绘制\n\n### 二. 使用canvas进行绘制\n\n#### 1. 绘制图形  矩形、线型、三角形等\n\n(1) 矩形\n\ncanvas只支持一种原生图形的绘制:矩形\n\n与矩形有关的三个方法：\n\n- fillRect(startX,startY,width,height)  绘制一个填充的矩形\n- fillStroke(startX,startY,width,height) 绘制一个矩形的边框\n- clearRect(startX,startY,width,height)  清除指定矩形区域\n\n(2) 线型\n\n通过设置路径来画各种线\n\n\t第一步：beginPath();//开始设置路径\n\t第二步：moveTo(x,y);//设置路径的起点（将笔触移动到某个坐标）\n\t第三步：lineTo(x,y);//设置线的终点，从起点到终点画一条直线\n\t\t   arc(x,y,半径,开始的弧度,结束的弧度,旋转的方向)//画圆弧\n\t第四步:fill();//根据画的线型，生成实心图形\n\t      stroke();//根据画的线型，生成轮廓\n\n(3) 三角形\n\n三角形可以通过(2)中的线型生成，其余的几何形状也可以按照同样的方式生成。\n\neg:\n\tvar canvas = document.getElementById('canvas');\n    var ctx = canvas.getContext('2d');\n\n    // 填充三角形\n    ctx.beginPath();\n    ctx.moveTo(25,25);\n    ctx.lineTo(105,25);\n    ctx.lineTo(25,105);\n    ctx.fill();\n\n#### 2. 绘制文本 \n\n(1) 文本\n\n文本有三个属性：font、textAlign、textBaseline\n\nfont = \"bold 14px Arial\"\n\ntextAlign = \"start/end/left/right/center\"\n\ntextBaseline = \"top/hanging/middle/alphabetic/ideographic/bottom/middle\"\n\nfillText(\"文本\",x,y)\n\nstrokeText(\"文本\",x,y)\n\nmeasureText(\"文本\").width 返回指定文本的大小\n\n#### 3. 绘制图像\n\n(1) 获得图像\n\n这里的图像来源可以是一张图片、一个视频帧、另外一个canvas\n\n    var img = new Image();   // 创建一个<img>元素\n    img.onload = function(){ //用load时间来保证不会在加载完毕之前使用这个图片：\n      ctx.drawImage(img,0,0);\n      ctx.beginPath();\n      ctx.moveTo(30,96);\n      ctx.lineTo(70,66);\n      ctx.lineTo(103,76);\n      ctx.lineTo(170,15);\n      ctx.stroke();\n    }\n    img.src = 'myImage.png'; // 设置图片源地址\n\n(2) 将图像画在画布中 drawImage(传入的image元素，x，y，width，height)\n\n#### 4. 设置阴影\n\nshadowColor:阴影颜色\nshadowOffsetX:沿x轴的阴影偏移量\nshadowOffsetY:沿y轴的阴影偏移量\nshadowBlur:阴影模糊的像素数\n\n上述四种属性均为上下文的属性。\n\n#### 5. 设置颜色\n\n(1) 直接设置颜色\n\n- fillStyle = \"color\"  设置填充颜色\n- strokeStyle = \"color\"  设置边框颜色\n- globalAlpha = 透明度\t设置canvas里所有图形的透明度（使用较少）\n\n(2) 使用渐变设置颜色\n\n渐变分为两种：线性渐变、径向渐变\n\n第一步：为图形创建一个渐变对象\n\n    createLinearGradient(startX,startY,endX,endY);//创建线性渐变对象\n    createRadialGradient(x1,y1,r1,x2,y2,r2);//创建径向渐变对象\n\n第二步：给渐变对象添加颜色 addColorStop(position,color)\n\n    var LG1 = ctx.createLinearGradient(0,0,150,150);\n    LG1.addColorStop(0,'white');\n    LG1.addColorStop(1,'black');\n\n第三步：将渐变对象赋给图形的fillStyle、strokeStyle属性\n\n\tctx.fillStyle = LG1;\n\n#### 6. 设置线型样式\n\nlineWidth  设置线条宽度\n\nlineCap   设置线条末端样式 butt，round 和 square\n\nlineJoin  设定线条与线条间接合处的样式 round, bevel 和 miter\n\nmiterLimit 限制当两条线相交时交接处最大长度\n\ngetLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组\n\nsetLineDash() 设置当前虚线样式\n\nlineDashOffset 设置虚线样式的起始偏移量\n\n\n<font color=\"red\">暂时只总结了最最基本的用法，后面的用法以后有时间再整理一下。</font>\n\n### 三. canvas中的width、height与一般style中的width、height的区别\n\n1. **canvas标签的width、height**\n\ncanvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面，绘制图形的坐标也是以canvas的左上角为起点。\n\ncanvas的width、height只能设置数字宽度和高度，不能设置百分比。\n\ncanvas的默认宽度为300px,默认高度为150px\n\n2. **canvas作为html的标签，所以也有style属性中的width、height，style的width和height是canvas在浏览器中被渲染的高度和宽度，也就是在浏览器中看起来的高度**\n\n可以通过设置canvas的style.width、style.height来对canvas画布进行缩放。\n\n例如：\n\n\t<canvas id=\"diagonal1\" style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n    <canvas id=\"diagonal2\" style=\"border:1px solid;width:200px;height:200px;\" width=\"100px\" height=\"100px\"></canvas>\n    <canvas id=\"diagonal3\" style=\"border:1px solid;width:200px;height:200px;\" ></canvas>\n\n\t<script type=\"text/javascript\">\n            function drawDiagonal(id){\n                var canvas=document.getElementById(id);\n                var context=canvas.getContext(\"2d\");\n                context.beginPath();\n                context.moveTo(0,0);\n                context.lineTo(100,100);\n                context.stroke();\n            }\n\n            window.onload=function(){                \n                drawDiagonal(\"diagonal1\");\n                drawDiagonal(\"diagonal2\");\n                drawDiagonal(\"diagonal3\");              \n            }\n    </script>\n\n最终在浏览器中显示的情况如下所示：\n[http://panpanfish.com/myDemo/canvas-width.html](http://panpanfish.com/myDemo/canvas-width.html)\n\ndiagonal1的style.width、style.height比例与画布相等，因此没有什么影响\n\ndiagonal2的style.width、style.height比例与画布比例一致，因此将画布等比例放大了\n\ndiagonal3的style.width、style.height比例与画布比例不一致，因此上面的线的位置发生了变化。遵循的一个原则是，保持相对为置不变：(100,100)在(300,150)的画布上占的位置是x轴1/3，y轴2/3的那个点，当canvas的渲染高度宽度变成了(200,200)时，线的终点变成了(200 * 1/3,200 * 2/3)\n\n### 四. canvas移动端屏幕适配问题\n\n在移动端，可以根据百分比布局来适配canvas画布。\n\n可以根据`document.documentElement.clientWidth`来获取屏幕的宽度，将宽度赋给`canvas.width`（如果画布要满屏的话，其他情况也同理），根据定好的长宽比，算出高度，将高度值赋给`canvas.height`\n\n例如：\n\n\tvar clientWidth = document.documentElement.clientWidth;//获得设备可见区域宽度\n\tcanvas.width = clientWidth;\n\tcanvas.height = clientWidth*800/600;\n\n\t然后在画布相应的位置上画上相应的图形即可\n\n\n\n","slug":"2016-04-25-HTML5中的canvas","published":1,"updated":"2016-08-23T06:41:48.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocej003hd5u8fpmyjyql","content":"<p><code>&lt;canvas&gt;</code>是HYML5中新增的标签，利用canvas，可以在js内部完成图像的绘制，canvas可以理解成一张画布。</p>\n<h3 id=\"一-使用canvas画图的准备工作\"><a href=\"#一-使用canvas画图的准备工作\" class=\"headerlink\" title=\"一. 使用canvas画图的准备工作\"></a>一. 使用canvas画图的准备工作</h3><p><strong>HTML中</strong></p>\n<pre><code>&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;\n</code></pre><p><strong>JS中</strong></p>\n<pre><code>var canvas1 = document.getElementById(&apos;myCanvas&apos;);//获取canvasDOM节点\n\nvar ctx1 = canvas1.getContext(&apos;2d&apos;);//获取此canvas1的上下文，可以理解成获得画布\n</code></pre><p>完成这两步之后，便可在画布上进行绘制</p>\n<h3 id=\"二-使用canvas进行绘制\"><a href=\"#二-使用canvas进行绘制\" class=\"headerlink\" title=\"二. 使用canvas进行绘制\"></a>二. 使用canvas进行绘制</h3><h4 id=\"1-绘制图形-矩形、线型、三角形等\"><a href=\"#1-绘制图形-矩形、线型、三角形等\" class=\"headerlink\" title=\"1. 绘制图形  矩形、线型、三角形等\"></a>1. 绘制图形  矩形、线型、三角形等</h4><p>(1) 矩形</p>\n<p>canvas只支持一种原生图形的绘制:矩形</p>\n<p>与矩形有关的三个方法：</p>\n<ul>\n<li>fillRect(startX,startY,width,height)  绘制一个填充的矩形</li>\n<li>fillStroke(startX,startY,width,height) 绘制一个矩形的边框</li>\n<li>clearRect(startX,startY,width,height)  清除指定矩形区域</li>\n</ul>\n<p>(2) 线型</p>\n<p>通过设置路径来画各种线</p>\n<pre><code>第一步：beginPath();//开始设置路径\n第二步：moveTo(x,y);//设置路径的起点（将笔触移动到某个坐标）\n第三步：lineTo(x,y);//设置线的终点，从起点到终点画一条直线\n       arc(x,y,半径,开始的弧度,结束的弧度,旋转的方向)//画圆弧\n第四步:fill();//根据画的线型，生成实心图形\n      stroke();//根据画的线型，生成轮廓\n</code></pre><p>(3) 三角形</p>\n<p>三角形可以通过(2)中的线型生成，其余的几何形状也可以按照同样的方式生成。</p>\n<p>eg:<br>    var canvas = document.getElementById(‘canvas’);<br>    var ctx = canvas.getContext(‘2d’);</p>\n<pre><code>// 填充三角形\nctx.beginPath();\nctx.moveTo(25,25);\nctx.lineTo(105,25);\nctx.lineTo(25,105);\nctx.fill();\n</code></pre><h4 id=\"2-绘制文本\"><a href=\"#2-绘制文本\" class=\"headerlink\" title=\"2. 绘制文本\"></a>2. 绘制文本</h4><p>(1) 文本</p>\n<p>文本有三个属性：font、textAlign、textBaseline</p>\n<p>font = “bold 14px Arial”</p>\n<p>textAlign = “start/end/left/right/center”</p>\n<p>textBaseline = “top/hanging/middle/alphabetic/ideographic/bottom/middle”</p>\n<p>fillText(“文本”,x,y)</p>\n<p>strokeText(“文本”,x,y)</p>\n<p>measureText(“文本”).width 返回指定文本的大小</p>\n<h4 id=\"3-绘制图像\"><a href=\"#3-绘制图像\" class=\"headerlink\" title=\"3. 绘制图像\"></a>3. 绘制图像</h4><p>(1) 获得图像</p>\n<p>这里的图像来源可以是一张图片、一个视频帧、另外一个canvas</p>\n<pre><code>var img = new Image();   // 创建一个&lt;img&gt;元素\nimg.onload = function(){ //用load时间来保证不会在加载完毕之前使用这个图片：\n  ctx.drawImage(img,0,0);\n  ctx.beginPath();\n  ctx.moveTo(30,96);\n  ctx.lineTo(70,66);\n  ctx.lineTo(103,76);\n  ctx.lineTo(170,15);\n  ctx.stroke();\n}\nimg.src = &apos;myImage.png&apos;; // 设置图片源地址\n</code></pre><p>(2) 将图像画在画布中 drawImage(传入的image元素，x，y，width，height)</p>\n<h4 id=\"4-设置阴影\"><a href=\"#4-设置阴影\" class=\"headerlink\" title=\"4. 设置阴影\"></a>4. 设置阴影</h4><p>shadowColor:阴影颜色<br>shadowOffsetX:沿x轴的阴影偏移量<br>shadowOffsetY:沿y轴的阴影偏移量<br>shadowBlur:阴影模糊的像素数</p>\n<p>上述四种属性均为上下文的属性。</p>\n<h4 id=\"5-设置颜色\"><a href=\"#5-设置颜色\" class=\"headerlink\" title=\"5. 设置颜色\"></a>5. 设置颜色</h4><p>(1) 直接设置颜色</p>\n<ul>\n<li>fillStyle = “color”  设置填充颜色</li>\n<li>strokeStyle = “color”  设置边框颜色</li>\n<li>globalAlpha = 透明度    设置canvas里所有图形的透明度（使用较少）</li>\n</ul>\n<p>(2) 使用渐变设置颜色</p>\n<p>渐变分为两种：线性渐变、径向渐变</p>\n<p>第一步：为图形创建一个渐变对象</p>\n<pre><code>createLinearGradient(startX,startY,endX,endY);//创建线性渐变对象\ncreateRadialGradient(x1,y1,r1,x2,y2,r2);//创建径向渐变对象\n</code></pre><p>第二步：给渐变对象添加颜色 addColorStop(position,color)</p>\n<pre><code>var LG1 = ctx.createLinearGradient(0,0,150,150);\nLG1.addColorStop(0,&apos;white&apos;);\nLG1.addColorStop(1,&apos;black&apos;);\n</code></pre><p>第三步：将渐变对象赋给图形的fillStyle、strokeStyle属性</p>\n<pre><code>ctx.fillStyle = LG1;\n</code></pre><h4 id=\"6-设置线型样式\"><a href=\"#6-设置线型样式\" class=\"headerlink\" title=\"6. 设置线型样式\"></a>6. 设置线型样式</h4><p>lineWidth  设置线条宽度</p>\n<p>lineCap   设置线条末端样式 butt，round 和 square</p>\n<p>lineJoin  设定线条与线条间接合处的样式 round, bevel 和 miter</p>\n<p>miterLimit 限制当两条线相交时交接处最大长度</p>\n<p>getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组</p>\n<p>setLineDash() 设置当前虚线样式</p>\n<p>lineDashOffset 设置虚线样式的起始偏移量</p>\n<font color=\"red\">暂时只总结了最最基本的用法，后面的用法以后有时间再整理一下。</font>\n\n<h3 id=\"三-canvas中的width、height与一般style中的width、height的区别\"><a href=\"#三-canvas中的width、height与一般style中的width、height的区别\" class=\"headerlink\" title=\"三. canvas中的width、height与一般style中的width、height的区别\"></a>三. canvas中的width、height与一般style中的width、height的区别</h3><ol>\n<li><strong>canvas标签的width、height</strong></li>\n</ol>\n<p>canvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面，绘制图形的坐标也是以canvas的左上角为起点。</p>\n<p>canvas的width、height只能设置数字宽度和高度，不能设置百分比。</p>\n<p>canvas的默认宽度为300px,默认高度为150px</p>\n<ol>\n<li><strong>canvas作为html的标签，所以也有style属性中的width、height，style的width和height是canvas在浏览器中被渲染的高度和宽度，也就是在浏览器中看起来的高度</strong></li>\n</ol>\n<p>可以通过设置canvas的style.width、style.height来对canvas画布进行缩放。</p>\n<p>例如：</p>\n<pre><code>&lt;canvas id=&quot;diagonal1&quot; style=&quot;border:1px solid;&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;\n&lt;canvas id=&quot;diagonal2&quot; style=&quot;border:1px solid;width:200px;height:200px;&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;\n&lt;canvas id=&quot;diagonal3&quot; style=&quot;border:1px solid;width:200px;height:200px;&quot; &gt;&lt;/canvas&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n        function drawDiagonal(id){\n            var canvas=document.getElementById(id);\n            var context=canvas.getContext(&quot;2d&quot;);\n            context.beginPath();\n            context.moveTo(0,0);\n            context.lineTo(100,100);\n            context.stroke();\n        }\n\n        window.onload=function(){                \n            drawDiagonal(&quot;diagonal1&quot;);\n            drawDiagonal(&quot;diagonal2&quot;);\n            drawDiagonal(&quot;diagonal3&quot;);              \n        }\n&lt;/script&gt;\n</code></pre><p>最终在浏览器中显示的情况如下所示：<br><a href=\"http://panpanfish.com/myDemo/canvas-width.html\">http://panpanfish.com/myDemo/canvas-width.html</a></p>\n<p>diagonal1的style.width、style.height比例与画布相等，因此没有什么影响</p>\n<p>diagonal2的style.width、style.height比例与画布比例一致，因此将画布等比例放大了</p>\n<p>diagonal3的style.width、style.height比例与画布比例不一致，因此上面的线的位置发生了变化。遵循的一个原则是，保持相对为置不变：(100,100)在(300,150)的画布上占的位置是x轴1/3，y轴2/3的那个点，当canvas的渲染高度宽度变成了(200,200)时，线的终点变成了(200 <em> 1/3,200 </em> 2/3)</p>\n<h3 id=\"四-canvas移动端屏幕适配问题\"><a href=\"#四-canvas移动端屏幕适配问题\" class=\"headerlink\" title=\"四. canvas移动端屏幕适配问题\"></a>四. canvas移动端屏幕适配问题</h3><p>在移动端，可以根据百分比布局来适配canvas画布。</p>\n<p>可以根据<code>document.documentElement.clientWidth</code>来获取屏幕的宽度，将宽度赋给<code>canvas.width</code>（如果画布要满屏的话，其他情况也同理），根据定好的长宽比，算出高度，将高度值赋给<code>canvas.height</code></p>\n<p>例如：</p>\n<pre><code>var clientWidth = document.documentElement.clientWidth;//获得设备可见区域宽度\ncanvas.width = clientWidth;\ncanvas.height = clientWidth*800/600;\n\n然后在画布相应的位置上画上相应的图形即可\n</code></pre>","excerpt":"","more":"<p><code>&lt;canvas&gt;</code>是HYML5中新增的标签，利用canvas，可以在js内部完成图像的绘制，canvas可以理解成一张画布。</p>\n<h3 id=\"一-使用canvas画图的准备工作\"><a href=\"#一-使用canvas画图的准备工作\" class=\"headerlink\" title=\"一. 使用canvas画图的准备工作\"></a>一. 使用canvas画图的准备工作</h3><p><strong>HTML中</strong></p>\n<pre><code>&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;\n</code></pre><p><strong>JS中</strong></p>\n<pre><code>var canvas1 = document.getElementById(&apos;myCanvas&apos;);//获取canvasDOM节点\n\nvar ctx1 = canvas1.getContext(&apos;2d&apos;);//获取此canvas1的上下文，可以理解成获得画布\n</code></pre><p>完成这两步之后，便可在画布上进行绘制</p>\n<h3 id=\"二-使用canvas进行绘制\"><a href=\"#二-使用canvas进行绘制\" class=\"headerlink\" title=\"二. 使用canvas进行绘制\"></a>二. 使用canvas进行绘制</h3><h4 id=\"1-绘制图形-矩形、线型、三角形等\"><a href=\"#1-绘制图形-矩形、线型、三角形等\" class=\"headerlink\" title=\"1. 绘制图形  矩形、线型、三角形等\"></a>1. 绘制图形  矩形、线型、三角形等</h4><p>(1) 矩形</p>\n<p>canvas只支持一种原生图形的绘制:矩形</p>\n<p>与矩形有关的三个方法：</p>\n<ul>\n<li>fillRect(startX,startY,width,height)  绘制一个填充的矩形</li>\n<li>fillStroke(startX,startY,width,height) 绘制一个矩形的边框</li>\n<li>clearRect(startX,startY,width,height)  清除指定矩形区域</li>\n</ul>\n<p>(2) 线型</p>\n<p>通过设置路径来画各种线</p>\n<pre><code>第一步：beginPath();//开始设置路径\n第二步：moveTo(x,y);//设置路径的起点（将笔触移动到某个坐标）\n第三步：lineTo(x,y);//设置线的终点，从起点到终点画一条直线\n       arc(x,y,半径,开始的弧度,结束的弧度,旋转的方向)//画圆弧\n第四步:fill();//根据画的线型，生成实心图形\n      stroke();//根据画的线型，生成轮廓\n</code></pre><p>(3) 三角形</p>\n<p>三角形可以通过(2)中的线型生成，其余的几何形状也可以按照同样的方式生成。</p>\n<p>eg:<br>    var canvas = document.getElementById(‘canvas’);<br>    var ctx = canvas.getContext(‘2d’);</p>\n<pre><code>// 填充三角形\nctx.beginPath();\nctx.moveTo(25,25);\nctx.lineTo(105,25);\nctx.lineTo(25,105);\nctx.fill();\n</code></pre><h4 id=\"2-绘制文本\"><a href=\"#2-绘制文本\" class=\"headerlink\" title=\"2. 绘制文本\"></a>2. 绘制文本</h4><p>(1) 文本</p>\n<p>文本有三个属性：font、textAlign、textBaseline</p>\n<p>font = “bold 14px Arial”</p>\n<p>textAlign = “start/end/left/right/center”</p>\n<p>textBaseline = “top/hanging/middle/alphabetic/ideographic/bottom/middle”</p>\n<p>fillText(“文本”,x,y)</p>\n<p>strokeText(“文本”,x,y)</p>\n<p>measureText(“文本”).width 返回指定文本的大小</p>\n<h4 id=\"3-绘制图像\"><a href=\"#3-绘制图像\" class=\"headerlink\" title=\"3. 绘制图像\"></a>3. 绘制图像</h4><p>(1) 获得图像</p>\n<p>这里的图像来源可以是一张图片、一个视频帧、另外一个canvas</p>\n<pre><code>var img = new Image();   // 创建一个&lt;img&gt;元素\nimg.onload = function(){ //用load时间来保证不会在加载完毕之前使用这个图片：\n  ctx.drawImage(img,0,0);\n  ctx.beginPath();\n  ctx.moveTo(30,96);\n  ctx.lineTo(70,66);\n  ctx.lineTo(103,76);\n  ctx.lineTo(170,15);\n  ctx.stroke();\n}\nimg.src = &apos;myImage.png&apos;; // 设置图片源地址\n</code></pre><p>(2) 将图像画在画布中 drawImage(传入的image元素，x，y，width，height)</p>\n<h4 id=\"4-设置阴影\"><a href=\"#4-设置阴影\" class=\"headerlink\" title=\"4. 设置阴影\"></a>4. 设置阴影</h4><p>shadowColor:阴影颜色<br>shadowOffsetX:沿x轴的阴影偏移量<br>shadowOffsetY:沿y轴的阴影偏移量<br>shadowBlur:阴影模糊的像素数</p>\n<p>上述四种属性均为上下文的属性。</p>\n<h4 id=\"5-设置颜色\"><a href=\"#5-设置颜色\" class=\"headerlink\" title=\"5. 设置颜色\"></a>5. 设置颜色</h4><p>(1) 直接设置颜色</p>\n<ul>\n<li>fillStyle = “color”  设置填充颜色</li>\n<li>strokeStyle = “color”  设置边框颜色</li>\n<li>globalAlpha = 透明度    设置canvas里所有图形的透明度（使用较少）</li>\n</ul>\n<p>(2) 使用渐变设置颜色</p>\n<p>渐变分为两种：线性渐变、径向渐变</p>\n<p>第一步：为图形创建一个渐变对象</p>\n<pre><code>createLinearGradient(startX,startY,endX,endY);//创建线性渐变对象\ncreateRadialGradient(x1,y1,r1,x2,y2,r2);//创建径向渐变对象\n</code></pre><p>第二步：给渐变对象添加颜色 addColorStop(position,color)</p>\n<pre><code>var LG1 = ctx.createLinearGradient(0,0,150,150);\nLG1.addColorStop(0,&apos;white&apos;);\nLG1.addColorStop(1,&apos;black&apos;);\n</code></pre><p>第三步：将渐变对象赋给图形的fillStyle、strokeStyle属性</p>\n<pre><code>ctx.fillStyle = LG1;\n</code></pre><h4 id=\"6-设置线型样式\"><a href=\"#6-设置线型样式\" class=\"headerlink\" title=\"6. 设置线型样式\"></a>6. 设置线型样式</h4><p>lineWidth  设置线条宽度</p>\n<p>lineCap   设置线条末端样式 butt，round 和 square</p>\n<p>lineJoin  设定线条与线条间接合处的样式 round, bevel 和 miter</p>\n<p>miterLimit 限制当两条线相交时交接处最大长度</p>\n<p>getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组</p>\n<p>setLineDash() 设置当前虚线样式</p>\n<p>lineDashOffset 设置虚线样式的起始偏移量</p>\n<font color=\"red\">暂时只总结了最最基本的用法，后面的用法以后有时间再整理一下。</font>\n\n<h3 id=\"三-canvas中的width、height与一般style中的width、height的区别\"><a href=\"#三-canvas中的width、height与一般style中的width、height的区别\" class=\"headerlink\" title=\"三. canvas中的width、height与一般style中的width、height的区别\"></a>三. canvas中的width、height与一般style中的width、height的区别</h3><ol>\n<li><strong>canvas标签的width、height</strong></li>\n</ol>\n<p>canvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面，绘制图形的坐标也是以canvas的左上角为起点。</p>\n<p>canvas的width、height只能设置数字宽度和高度，不能设置百分比。</p>\n<p>canvas的默认宽度为300px,默认高度为150px</p>\n<ol>\n<li><strong>canvas作为html的标签，所以也有style属性中的width、height，style的width和height是canvas在浏览器中被渲染的高度和宽度，也就是在浏览器中看起来的高度</strong></li>\n</ol>\n<p>可以通过设置canvas的style.width、style.height来对canvas画布进行缩放。</p>\n<p>例如：</p>\n<pre><code>&lt;canvas id=&quot;diagonal1&quot; style=&quot;border:1px solid;&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;\n&lt;canvas id=&quot;diagonal2&quot; style=&quot;border:1px solid;width:200px;height:200px;&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;&lt;/canvas&gt;\n&lt;canvas id=&quot;diagonal3&quot; style=&quot;border:1px solid;width:200px;height:200px;&quot; &gt;&lt;/canvas&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n        function drawDiagonal(id){\n            var canvas=document.getElementById(id);\n            var context=canvas.getContext(&quot;2d&quot;);\n            context.beginPath();\n            context.moveTo(0,0);\n            context.lineTo(100,100);\n            context.stroke();\n        }\n\n        window.onload=function(){                \n            drawDiagonal(&quot;diagonal1&quot;);\n            drawDiagonal(&quot;diagonal2&quot;);\n            drawDiagonal(&quot;diagonal3&quot;);              \n        }\n&lt;/script&gt;\n</code></pre><p>最终在浏览器中显示的情况如下所示：<br><a href=\"http://panpanfish.com/myDemo/canvas-width.html\">http://panpanfish.com/myDemo/canvas-width.html</a></p>\n<p>diagonal1的style.width、style.height比例与画布相等，因此没有什么影响</p>\n<p>diagonal2的style.width、style.height比例与画布比例一致，因此将画布等比例放大了</p>\n<p>diagonal3的style.width、style.height比例与画布比例不一致，因此上面的线的位置发生了变化。遵循的一个原则是，保持相对为置不变：(100,100)在(300,150)的画布上占的位置是x轴1/3，y轴2/3的那个点，当canvas的渲染高度宽度变成了(200,200)时，线的终点变成了(200 <em> 1/3,200 </em> 2/3)</p>\n<h3 id=\"四-canvas移动端屏幕适配问题\"><a href=\"#四-canvas移动端屏幕适配问题\" class=\"headerlink\" title=\"四. canvas移动端屏幕适配问题\"></a>四. canvas移动端屏幕适配问题</h3><p>在移动端，可以根据百分比布局来适配canvas画布。</p>\n<p>可以根据<code>document.documentElement.clientWidth</code>来获取屏幕的宽度，将宽度赋给<code>canvas.width</code>（如果画布要满屏的话，其他情况也同理），根据定好的长宽比，算出高度，将高度值赋给<code>canvas.height</code></p>\n<p>例如：</p>\n<pre><code>var clientWidth = document.documentElement.clientWidth;//获得设备可见区域宽度\ncanvas.width = clientWidth;\ncanvas.height = clientWidth*800/600;\n\n然后在画布相应的位置上画上相应的图形即可\n</code></pre>"},{"layout":"post","title":"delete","date":"2016-04-27T16:00:00.000Z","description":null,"_content":"\ndelete用来删除一个对象上的属性\n\n```\nx = 42;\nvar y = 43;\n\ndelete x; //隐式声明的全局变量可以被删除，返回true\ndelete y; //显示声明的全局变量不能被删除，返回false\n```\n\n**使用delete删除数组元素**\n\n该元素完全被删除，但是数组长度不会发生变化。\n\n```\nvar arr = ['a','b','c','d'];\ndelete arr[2];\n\nconsole.log(arr.length); //数组长度仍然是4\nconsole.log(2 in arr);  //false，arr[2]已经被完全删除了\n```\n\n数组元素赋值为undefined\n\n```\nvar arr = ['a','b','c','d'];\narr[2] = undefined;\n\nconsole.log(arr.length); //数组长度仍然是4\nconsole.log(2 in arr);  //true，arr[2]没有被删除\n```","source":"_posts/2016-04-28- delete.md","raw":"---\nlayout: post\ntitle: delete\ndate: 2016-04-28\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\ndelete用来删除一个对象上的属性\n\n```\nx = 42;\nvar y = 43;\n\ndelete x; //隐式声明的全局变量可以被删除，返回true\ndelete y; //显示声明的全局变量不能被删除，返回false\n```\n\n**使用delete删除数组元素**\n\n该元素完全被删除，但是数组长度不会发生变化。\n\n```\nvar arr = ['a','b','c','d'];\ndelete arr[2];\n\nconsole.log(arr.length); //数组长度仍然是4\nconsole.log(2 in arr);  //false，arr[2]已经被完全删除了\n```\n\n数组元素赋值为undefined\n\n```\nvar arr = ['a','b','c','d'];\narr[2] = undefined;\n\nconsole.log(arr.length); //数组长度仍然是4\nconsole.log(2 in arr);  //true，arr[2]没有被删除\n```","slug":"2016-04-28- delete","published":1,"updated":"2016-08-29T02:57:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocel003kd5u8hzhri2fw","content":"<p>delete用来删除一个对象上的属性</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">43</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> x; <span class=\"comment\">//隐式声明的全局变量可以被删除，返回true</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> y; <span class=\"comment\">//显示声明的全局变量不能被删除，返回false</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用delete删除数组元素</strong></p>\n<p>该元素完全被删除，但是数组长度不会发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"keyword\">delete</span> arr[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">//数组长度仍然是4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> <span class=\"keyword\">in</span> arr);  <span class=\"comment\">//false，arr[2]已经被完全删除了</span></span><br></pre></td></tr></table></figure>\n<p>数组元素赋值为undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">//数组长度仍然是4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> <span class=\"keyword\">in</span> arr);  <span class=\"comment\">//true，arr[2]没有被删除</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>delete用来删除一个对象上的属性</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">43</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> x; <span class=\"comment\">//隐式声明的全局变量可以被删除，返回true</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> y; <span class=\"comment\">//显示声明的全局变量不能被删除，返回false</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用delete删除数组元素</strong></p>\n<p>该元素完全被删除，但是数组长度不会发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"keyword\">delete</span> arr[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">//数组长度仍然是4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> <span class=\"keyword\">in</span> arr);  <span class=\"comment\">//false，arr[2]已经被完全删除了</span></span><br></pre></td></tr></table></figure>\n<p>数组元素赋值为undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>];</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length); <span class=\"comment\">//数组长度仍然是4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> <span class=\"keyword\">in</span> arr);  <span class=\"comment\">//true，arr[2]没有被删除</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"获得鼠标当前位置——clientX","date":"2016-04-27T16:00:00.000Z","description":null,"_content":"clientX/clientY、pageX/pageY、screenX/screenY的区别\n\n#### 1. clientX、clientY\n\nclientX、clientY是事件event的属性，用于返回鼠标指针相对于浏览器可见页面的水平坐标和垂直坐标。\n\n参照点是：可见内容区域的左上角，参照点会随着滚动条而移动\n\n#### 2. pageX、pageY\n\npageX、pageY也是事件event的属性，用于返回鼠标指针相对于document左上那个点的水平坐标和垂直坐标。\n\n参照点是：网页最上方的左边的那个点，参照点不会随着滚动条而移动\n\n#### 3. screenX、screenY\n\nscreenX、screenY也是事件event的属性，用于返回鼠标指针相对于电脑屏幕左上那个点的水平坐标和垂直坐标。\n\n参照点是：电脑屏幕最上方左边的那个点","source":"_posts/2016-04-28-获取鼠标当前位置.md","raw":"---\nlayout: post\ntitle: 获得鼠标当前位置——clientX\ndate: 2016-04-28\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\nclientX/clientY、pageX/pageY、screenX/screenY的区别\n\n#### 1. clientX、clientY\n\nclientX、clientY是事件event的属性，用于返回鼠标指针相对于浏览器可见页面的水平坐标和垂直坐标。\n\n参照点是：可见内容区域的左上角，参照点会随着滚动条而移动\n\n#### 2. pageX、pageY\n\npageX、pageY也是事件event的属性，用于返回鼠标指针相对于document左上那个点的水平坐标和垂直坐标。\n\n参照点是：网页最上方的左边的那个点，参照点不会随着滚动条而移动\n\n#### 3. screenX、screenY\n\nscreenX、screenY也是事件event的属性，用于返回鼠标指针相对于电脑屏幕左上那个点的水平坐标和垂直坐标。\n\n参照点是：电脑屏幕最上方左边的那个点","slug":"2016-04-28-获取鼠标当前位置","published":1,"updated":"2016-04-28T13:22:40.000Z","comments":1,"photos":[],"link":"","_id":"cj035oceo003pd5u8ak5xj5mb","content":"<p>clientX/clientY、pageX/pageY、screenX/screenY的区别</p>\n<h4 id=\"1-clientX、clientY\"><a href=\"#1-clientX、clientY\" class=\"headerlink\" title=\"1. clientX、clientY\"></a>1. clientX、clientY</h4><p>clientX、clientY是事件event的属性，用于返回鼠标指针相对于浏览器可见页面的水平坐标和垂直坐标。</p>\n<p>参照点是：可见内容区域的左上角，参照点会随着滚动条而移动</p>\n<h4 id=\"2-pageX、pageY\"><a href=\"#2-pageX、pageY\" class=\"headerlink\" title=\"2. pageX、pageY\"></a>2. pageX、pageY</h4><p>pageX、pageY也是事件event的属性，用于返回鼠标指针相对于document左上那个点的水平坐标和垂直坐标。</p>\n<p>参照点是：网页最上方的左边的那个点，参照点不会随着滚动条而移动</p>\n<h4 id=\"3-screenX、screenY\"><a href=\"#3-screenX、screenY\" class=\"headerlink\" title=\"3. screenX、screenY\"></a>3. screenX、screenY</h4><p>screenX、screenY也是事件event的属性，用于返回鼠标指针相对于电脑屏幕左上那个点的水平坐标和垂直坐标。</p>\n<p>参照点是：电脑屏幕最上方左边的那个点</p>\n","excerpt":"","more":"<p>clientX/clientY、pageX/pageY、screenX/screenY的区别</p>\n<h4 id=\"1-clientX、clientY\"><a href=\"#1-clientX、clientY\" class=\"headerlink\" title=\"1. clientX、clientY\"></a>1. clientX、clientY</h4><p>clientX、clientY是事件event的属性，用于返回鼠标指针相对于浏览器可见页面的水平坐标和垂直坐标。</p>\n<p>参照点是：可见内容区域的左上角，参照点会随着滚动条而移动</p>\n<h4 id=\"2-pageX、pageY\"><a href=\"#2-pageX、pageY\" class=\"headerlink\" title=\"2. pageX、pageY\"></a>2. pageX、pageY</h4><p>pageX、pageY也是事件event的属性，用于返回鼠标指针相对于document左上那个点的水平坐标和垂直坐标。</p>\n<p>参照点是：网页最上方的左边的那个点，参照点不会随着滚动条而移动</p>\n<h4 id=\"3-screenX、screenY\"><a href=\"#3-screenX、screenY\" class=\"headerlink\" title=\"3. screenX、screenY\"></a>3. screenX、screenY</h4><p>screenX、screenY也是事件event的属性，用于返回鼠标指针相对于电脑屏幕左上那个点的水平坐标和垂直坐标。</p>\n<p>参照点是：电脑屏幕最上方左边的那个点</p>\n"},{"layout":"post","title":"使用H5和canvas开发的一个小游戏——王牌特工","date":"2016-04-27T16:00:00.000Z","description":null,"_content":"\n这是百度前端技术学院第三阶段的一个任务，用canvas和H5开发一个小游戏。\n\n![王牌特工任务要求](/uploads/post/20160428/task3-46.jpg)\n\n任务demo地址：[http://panpanfish.com/myDemo/spy-game.html](http://panpanfish.com/myDemo/spy-game.html)\n\n任务代码地址：\n[https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html](https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html \"王牌特工代码\")\n\n\n### <font color=\"red\">在这个任务中，用到了以下知识点：</font>\n\n**1. 使用canvas画图**\n\n**2. 寻路算法的实现**\n\n**3. canvas在移动设备上的适配问题**\n\n**4. 获取鼠标位置、获取当前屏幕可见宽度等**\n\n以上四个知识点都分别有相应的博客笔记进行说明。\n\n下面记录的是一些小的知识点：\n\n**1. addEventListener(\"event\",function,useCapture)**\n\n用于给指定元素添加事件\n\n第三个参数useCapture为可选的参数\n\n- useCapture = true;//事件在捕获阶段执行\n- useCapture = false;//事件在冒泡阶段执行（默认）\n\n**2. keyCode 键码值**\n\n键码值指的是键盘上的按键对应的数值，每个按键都有自己对应的数值。（例如：回车键的键码值为13）\n\n在有的浏览器里面不支持event.keyCode，可用下面的方法来调整浏览器的兼容性\n\n     var myKeyCode = (navigator.appname==\"Netscape\")?event.which:event.keyCode;\n\n**3. Date.now()、new Date()都是获取当前的时间**\n\n**4. window.requestAnimationFrame()请求动画帧**\n\n**5. break、continue的区别**\n\n- break:跳出循环，执行循环之后的语句\n\n- continue:跳出本次循环，继续下一次循环\n\n**6. while(1){}循环不会终止，除非循环体中有break**","source":"_posts/2016-04-28-使用H5和canvas开发的一个小游戏——王牌特工.md","raw":"---\nlayout: post\ntitle: 使用H5和canvas开发的一个小游戏——王牌特工\ndate: 2016-04-28\ncategories: Demo\ntags: [HTML5]\ndescription: \n---\n\n这是百度前端技术学院第三阶段的一个任务，用canvas和H5开发一个小游戏。\n\n![王牌特工任务要求](/uploads/post/20160428/task3-46.jpg)\n\n任务demo地址：[http://panpanfish.com/myDemo/spy-game.html](http://panpanfish.com/myDemo/spy-game.html)\n\n任务代码地址：\n[https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html](https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html \"王牌特工代码\")\n\n\n### <font color=\"red\">在这个任务中，用到了以下知识点：</font>\n\n**1. 使用canvas画图**\n\n**2. 寻路算法的实现**\n\n**3. canvas在移动设备上的适配问题**\n\n**4. 获取鼠标位置、获取当前屏幕可见宽度等**\n\n以上四个知识点都分别有相应的博客笔记进行说明。\n\n下面记录的是一些小的知识点：\n\n**1. addEventListener(\"event\",function,useCapture)**\n\n用于给指定元素添加事件\n\n第三个参数useCapture为可选的参数\n\n- useCapture = true;//事件在捕获阶段执行\n- useCapture = false;//事件在冒泡阶段执行（默认）\n\n**2. keyCode 键码值**\n\n键码值指的是键盘上的按键对应的数值，每个按键都有自己对应的数值。（例如：回车键的键码值为13）\n\n在有的浏览器里面不支持event.keyCode，可用下面的方法来调整浏览器的兼容性\n\n     var myKeyCode = (navigator.appname==\"Netscape\")?event.which:event.keyCode;\n\n**3. Date.now()、new Date()都是获取当前的时间**\n\n**4. window.requestAnimationFrame()请求动画帧**\n\n**5. break、continue的区别**\n\n- break:跳出循环，执行循环之后的语句\n\n- continue:跳出本次循环，继续下一次循环\n\n**6. while(1){}循环不会终止，除非循环体中有break**","slug":"2016-04-28-使用H5和canvas开发的一个小游戏——王牌特工","published":1,"updated":"2016-06-13T07:20:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035oces003sd5u8a16lago8","content":"<p>这是百度前端技术学院第三阶段的一个任务，用canvas和H5开发一个小游戏。</p>\n<p><img src=\"/uploads/post/20160428/task3-46.jpg\" alt=\"王牌特工任务要求\"></p>\n<p>任务demo地址：<a href=\"http://panpanfish.com/myDemo/spy-game.html\">http://panpanfish.com/myDemo/spy-game.html</a></p>\n<p>任务代码地址：<br><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html\" title=\"王牌特工代码\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html</a></p>\n<h3 id=\"在这个任务中，用到了以下知识点：\"><a href=\"#在这个任务中，用到了以下知识点：\" class=\"headerlink\" title=\"在这个任务中，用到了以下知识点：\"></a><font color=\"red\">在这个任务中，用到了以下知识点：</font></h3><p><strong>1. 使用canvas画图</strong></p>\n<p><strong>2. 寻路算法的实现</strong></p>\n<p><strong>3. canvas在移动设备上的适配问题</strong></p>\n<p><strong>4. 获取鼠标位置、获取当前屏幕可见宽度等</strong></p>\n<p>以上四个知识点都分别有相应的博客笔记进行说明。</p>\n<p>下面记录的是一些小的知识点：</p>\n<p><strong>1. addEventListener(“event”,function,useCapture)</strong></p>\n<p>用于给指定元素添加事件</p>\n<p>第三个参数useCapture为可选的参数</p>\n<ul>\n<li>useCapture = true;//事件在捕获阶段执行</li>\n<li>useCapture = false;//事件在冒泡阶段执行（默认）</li>\n</ul>\n<p><strong>2. keyCode 键码值</strong></p>\n<p>键码值指的是键盘上的按键对应的数值，每个按键都有自己对应的数值。（例如：回车键的键码值为13）</p>\n<p>在有的浏览器里面不支持event.keyCode，可用下面的方法来调整浏览器的兼容性</p>\n<pre><code>var myKeyCode = (navigator.appname==&quot;Netscape&quot;)?event.which:event.keyCode;\n</code></pre><p><strong>3. Date.now()、new Date()都是获取当前的时间</strong></p>\n<p><strong>4. window.requestAnimationFrame()请求动画帧</strong></p>\n<p><strong>5. break、continue的区别</strong></p>\n<ul>\n<li><p>break:跳出循环，执行循环之后的语句</p>\n</li>\n<li><p>continue:跳出本次循环，继续下一次循环</p>\n</li>\n</ul>\n<p><strong>6. while(1){}循环不会终止，除非循环体中有break</strong></p>\n","excerpt":"","more":"<p>这是百度前端技术学院第三阶段的一个任务，用canvas和H5开发一个小游戏。</p>\n<p><img src=\"/uploads/post/20160428/task3-46.jpg\" alt=\"王牌特工任务要求\"></p>\n<p>任务demo地址：<a href=\"http://panpanfish.com/myDemo/spy-game.html\">http://panpanfish.com/myDemo/spy-game.html</a></p>\n<p>任务代码地址：<br><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html\" title=\"王牌特工代码\">https://github.com/panpan040828/myDemo/blob/gh-pages/spy-game.html</a></p>\n<h3 id=\"在这个任务中，用到了以下知识点：\"><a href=\"#在这个任务中，用到了以下知识点：\" class=\"headerlink\" title=\"在这个任务中，用到了以下知识点：\"></a><font color=\"red\">在这个任务中，用到了以下知识点：</font></h3><p><strong>1. 使用canvas画图</strong></p>\n<p><strong>2. 寻路算法的实现</strong></p>\n<p><strong>3. canvas在移动设备上的适配问题</strong></p>\n<p><strong>4. 获取鼠标位置、获取当前屏幕可见宽度等</strong></p>\n<p>以上四个知识点都分别有相应的博客笔记进行说明。</p>\n<p>下面记录的是一些小的知识点：</p>\n<p><strong>1. addEventListener(“event”,function,useCapture)</strong></p>\n<p>用于给指定元素添加事件</p>\n<p>第三个参数useCapture为可选的参数</p>\n<ul>\n<li>useCapture = true;//事件在捕获阶段执行</li>\n<li>useCapture = false;//事件在冒泡阶段执行（默认）</li>\n</ul>\n<p><strong>2. keyCode 键码值</strong></p>\n<p>键码值指的是键盘上的按键对应的数值，每个按键都有自己对应的数值。（例如：回车键的键码值为13）</p>\n<p>在有的浏览器里面不支持event.keyCode，可用下面的方法来调整浏览器的兼容性</p>\n<pre><code>var myKeyCode = (navigator.appname==&quot;Netscape&quot;)?event.which:event.keyCode;\n</code></pre><p><strong>3. Date.now()、new Date()都是获取当前的时间</strong></p>\n<p><strong>4. window.requestAnimationFrame()请求动画帧</strong></p>\n<p><strong>5. break、continue的区别</strong></p>\n<ul>\n<li><p>break:跳出循环，执行循环之后的语句</p>\n</li>\n<li><p>continue:跳出本次循环，继续下一次循环</p>\n</li>\n</ul>\n<p><strong>6. while(1){}循环不会终止，除非循环体中有break</strong></p>\n"},{"layout":"post","title":"http1.0和http1.1的区别","date":"2016-05-02T16:00:00.000Z","description":null,"_content":"\n### 一. http协议\n\nhttp: Hypertext Transfer Protocol(超文本传输协议)\n\n定义了web客户端如何与服务器对话，以及数据如何从服务器传回客户端。\n\n### 一. http/1.0和http/1.1的区别\n\nhttp/1.1是http/1.0的升级版，增加了一些功能\n\n####  1. 是否持久连接\n\n- http/1.0协议默认使用非持久连接，一个tcp连接只传输一个http请求\n但是在请求头部里添加 `Connection: keep-alive`字段就可以支持长连接。\n\n- http/1.1协议使用持久连接，一个tcp连接可以传输多个http请求和响应，http/1.1默认就支持长连接\n\n这样修改之后的优点：减少了建立和关闭连接的消耗和延迟。\n\n#### 2. 增加了请求头和响应头\n\n- http/1.0不支持Host（主机）请求头字段\n- http/1.1增加了Host、与身份认证／状态管理／cache缓存机制相关的请求头和响应头字段\n","source":"_posts/2016-05-03-http1.0和http1.1的区别.md","raw":"---\nlayout: post\ntitle: http1.0和http1.1的区别\ndate: 2016-05-03\ncategories: http协议\ntags: [http]\ndescription: \n---\n\n### 一. http协议\n\nhttp: Hypertext Transfer Protocol(超文本传输协议)\n\n定义了web客户端如何与服务器对话，以及数据如何从服务器传回客户端。\n\n### 一. http/1.0和http/1.1的区别\n\nhttp/1.1是http/1.0的升级版，增加了一些功能\n\n####  1. 是否持久连接\n\n- http/1.0协议默认使用非持久连接，一个tcp连接只传输一个http请求\n但是在请求头部里添加 `Connection: keep-alive`字段就可以支持长连接。\n\n- http/1.1协议使用持久连接，一个tcp连接可以传输多个http请求和响应，http/1.1默认就支持长连接\n\n这样修改之后的优点：减少了建立和关闭连接的消耗和延迟。\n\n#### 2. 增加了请求头和响应头\n\n- http/1.0不支持Host（主机）请求头字段\n- http/1.1增加了Host、与身份认证／状态管理／cache缓存机制相关的请求头和响应头字段\n","slug":"2016-05-03-http1.0和http1.1的区别","published":1,"updated":"2016-08-21T13:55:52.000Z","comments":1,"photos":[],"link":"","_id":"cj035oceu003vd5u83fc1a177","content":"<h3 id=\"一-http协议\"><a href=\"#一-http协议\" class=\"headerlink\" title=\"一. http协议\"></a>一. http协议</h3><p>http: Hypertext Transfer Protocol(超文本传输协议)</p>\n<p>定义了web客户端如何与服务器对话，以及数据如何从服务器传回客户端。</p>\n<h3 id=\"一-http-1-0和http-1-1的区别\"><a href=\"#一-http-1-0和http-1-1的区别\" class=\"headerlink\" title=\"一. http/1.0和http/1.1的区别\"></a>一. http/1.0和http/1.1的区别</h3><p>http/1.1是http/1.0的升级版，增加了一些功能</p>\n<h4 id=\"1-是否持久连接\"><a href=\"#1-是否持久连接\" class=\"headerlink\" title=\"1. 是否持久连接\"></a>1. 是否持久连接</h4><ul>\n<li><p>http/1.0协议默认使用非持久连接，一个tcp连接只传输一个http请求<br>但是在请求头部里添加 <code>Connection: keep-alive</code>字段就可以支持长连接。</p>\n</li>\n<li><p>http/1.1协议使用持久连接，一个tcp连接可以传输多个http请求和响应，http/1.1默认就支持长连接</p>\n</li>\n</ul>\n<p>这样修改之后的优点：减少了建立和关闭连接的消耗和延迟。</p>\n<h4 id=\"2-增加了请求头和响应头\"><a href=\"#2-增加了请求头和响应头\" class=\"headerlink\" title=\"2. 增加了请求头和响应头\"></a>2. 增加了请求头和响应头</h4><ul>\n<li>http/1.0不支持Host（主机）请求头字段</li>\n<li>http/1.1增加了Host、与身份认证／状态管理／cache缓存机制相关的请求头和响应头字段</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-http协议\"><a href=\"#一-http协议\" class=\"headerlink\" title=\"一. http协议\"></a>一. http协议</h3><p>http: Hypertext Transfer Protocol(超文本传输协议)</p>\n<p>定义了web客户端如何与服务器对话，以及数据如何从服务器传回客户端。</p>\n<h3 id=\"一-http-1-0和http-1-1的区别\"><a href=\"#一-http-1-0和http-1-1的区别\" class=\"headerlink\" title=\"一. http/1.0和http/1.1的区别\"></a>一. http/1.0和http/1.1的区别</h3><p>http/1.1是http/1.0的升级版，增加了一些功能</p>\n<h4 id=\"1-是否持久连接\"><a href=\"#1-是否持久连接\" class=\"headerlink\" title=\"1. 是否持久连接\"></a>1. 是否持久连接</h4><ul>\n<li><p>http/1.0协议默认使用非持久连接，一个tcp连接只传输一个http请求<br>但是在请求头部里添加 <code>Connection: keep-alive</code>字段就可以支持长连接。</p>\n</li>\n<li><p>http/1.1协议使用持久连接，一个tcp连接可以传输多个http请求和响应，http/1.1默认就支持长连接</p>\n</li>\n</ul>\n<p>这样修改之后的优点：减少了建立和关闭连接的消耗和延迟。</p>\n<h4 id=\"2-增加了请求头和响应头\"><a href=\"#2-增加了请求头和响应头\" class=\"headerlink\" title=\"2. 增加了请求头和响应头\"></a>2. 增加了请求头和响应头</h4><ul>\n<li>http/1.0不支持Host（主机）请求头字段</li>\n<li>http/1.1增加了Host、与身份认证／状态管理／cache缓存机制相关的请求头和响应头字段</li>\n</ul>\n"},{"layout":"post","title":"链式调用的原理","date":"2016-04-15T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是链式调用\n\na().b().c()\n\n链式调用也是设计模式中的一种。\n\n**链式调用的好处：**\n\n就是使代码更加简化，增加代码易读性\n\n### 二. 链式调用的原理\n\njQuery里面就支持链式调用\n\n主要是在函数最后加上 return this;返回元素或者对象本身，以支持其可以继续调用对象的其它方法。\n\n举个栗子：\n\n```\n//getName不传入callback\nfunction Person(name) {\n  var _name = name;\n  this.setName = function (name) {\n    _name = name;\n    return this;\n  };\n  this.getName = function () {\n    return _name\n  };\n}\nvar jordan = new Person('jordan1');\nconsole.log(jordan.getName())\nconsole.log(jordan.setName('Meow1').getName());\n\n输出：\njordan1\nMeow1\n\n\n//getName传入callback\nfunction Person(name) {\n  var _name = name;\n  this.setName = function (name) {\n    _name = name;\n    return this;\n  };\n  this.getName = function (callback) {\n    callback.call(this, _name);\n    return this\n  };\n}\n\nvar jordan = new Person('jordan2');\njordan.getName(console.log).setName('Meow2').getName(console.log);\n\n输出：\njordan2\nMeow2\nPerson对象\n\n```","source":"_posts/2016-04-16-链式调用的原理.md","raw":"---\nlayout: post\ntitle: 链式调用的原理\ndate: 2016-04-16\ncategories: javaScript\ntags: [javaScript,链式调用]\ndescription: \n---\n\n### 一. 什么是链式调用\n\na().b().c()\n\n链式调用也是设计模式中的一种。\n\n**链式调用的好处：**\n\n就是使代码更加简化，增加代码易读性\n\n### 二. 链式调用的原理\n\njQuery里面就支持链式调用\n\n主要是在函数最后加上 return this;返回元素或者对象本身，以支持其可以继续调用对象的其它方法。\n\n举个栗子：\n\n```\n//getName不传入callback\nfunction Person(name) {\n  var _name = name;\n  this.setName = function (name) {\n    _name = name;\n    return this;\n  };\n  this.getName = function () {\n    return _name\n  };\n}\nvar jordan = new Person('jordan1');\nconsole.log(jordan.getName())\nconsole.log(jordan.setName('Meow1').getName());\n\n输出：\njordan1\nMeow1\n\n\n//getName传入callback\nfunction Person(name) {\n  var _name = name;\n  this.setName = function (name) {\n    _name = name;\n    return this;\n  };\n  this.getName = function (callback) {\n    callback.call(this, _name);\n    return this\n  };\n}\n\nvar jordan = new Person('jordan2');\njordan.getName(console.log).setName('Meow2').getName(console.log);\n\n输出：\njordan2\nMeow2\nPerson对象\n\n```","slug":"2016-04-16-链式调用的原理","published":1,"updated":"2016-08-19T07:15:50.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocew003zd5u866x9rv0x","content":"<h3 id=\"一-什么是链式调用\"><a href=\"#一-什么是链式调用\" class=\"headerlink\" title=\"一. 什么是链式调用\"></a>一. 什么是链式调用</h3><p>a().b().c()</p>\n<p>链式调用也是设计模式中的一种。</p>\n<p><strong>链式调用的好处：</strong></p>\n<p>就是使代码更加简化，增加代码易读性</p>\n<h3 id=\"二-链式调用的原理\"><a href=\"#二-链式调用的原理\" class=\"headerlink\" title=\"二. 链式调用的原理\"></a>二. 链式调用的原理</h3><p>jQuery里面就支持链式调用</p>\n<p>主要是在函数最后加上 return this;返回元素或者对象本身，以支持其可以继续调用对象的其它方法。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getName不传入callback</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    _name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _name</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jordan = <span class=\"keyword\">new</span> Person(<span class=\"string\">'jordan1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(jordan.getName())</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(jordan.setName(<span class=\"string\">'Meow1'</span>).getName());</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">jordan1</span><br><span class=\"line\">Meow1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//getName传入callback</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    _name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    callback.call(<span class=\"keyword\">this</span>, _name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jordan = <span class=\"keyword\">new</span> Person(<span class=\"string\">'jordan2'</span>);</span><br><span class=\"line\">jordan.getName(<span class=\"built_in\">console</span>.log).setName(<span class=\"string\">'Meow2'</span>).getName(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">jordan2</span><br><span class=\"line\">Meow2</span><br><span class=\"line\">Person对象</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-什么是链式调用\"><a href=\"#一-什么是链式调用\" class=\"headerlink\" title=\"一. 什么是链式调用\"></a>一. 什么是链式调用</h3><p>a().b().c()</p>\n<p>链式调用也是设计模式中的一种。</p>\n<p><strong>链式调用的好处：</strong></p>\n<p>就是使代码更加简化，增加代码易读性</p>\n<h3 id=\"二-链式调用的原理\"><a href=\"#二-链式调用的原理\" class=\"headerlink\" title=\"二. 链式调用的原理\"></a>二. 链式调用的原理</h3><p>jQuery里面就支持链式调用</p>\n<p>主要是在函数最后加上 return this;返回元素或者对象本身，以支持其可以继续调用对象的其它方法。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getName不传入callback</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    _name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _name</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jordan = <span class=\"keyword\">new</span> Person(<span class=\"string\">'jordan1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(jordan.getName())</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(jordan.setName(<span class=\"string\">'Meow1'</span>).getName());</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">jordan1</span><br><span class=\"line\">Meow1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//getName传入callback</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    _name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    callback.call(<span class=\"keyword\">this</span>, _name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jordan = <span class=\"keyword\">new</span> Person(<span class=\"string\">'jordan2'</span>);</span><br><span class=\"line\">jordan.getName(<span class=\"built_in\">console</span>.log).setName(<span class=\"string\">'Meow2'</span>).getName(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">jordan2</span><br><span class=\"line\">Meow2</span><br><span class=\"line\">Person对象</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"HTML5中的新特性","date":"2016-05-04T16:00:00.000Z","description":null,"_content":"### 一.HTML5是什么\n\nHTML5是HTML标准的第5次修订。\n\nHTML5包括：一些新的javascript的API、HTML的一些新的元素、一些新的技术（让web站点和应用更加多样化，功能更强大）\n\nHTML5的目的：将互联网语义化，以便更好地被人类和机器阅读。\n\n### 二. HTML5中的新的特性\n\n#### 1. HTML5中的新元素\n\n**语义化、结构化元素：**\n\n    <section>\n    <article>\n    <nav>\n    <header>\n    <footer>\n    <aside>\n    <hgroup>\n\n**对标签语义化的理解？**\n\n- 去掉样式时，页面结构依然清晰\n- 有利于SEO(提高该网站在搜索引擎结果中排名的位置)\n- 方便其它设备解析\n- 语义化更具可读性\n\n**新的媒体元素**\n\n    <audio>\n    <video>\n\n**新的表单元素**\n\n- `<datalist>`\n- `<keygen>`\n- `<output>` 用于不同类型的输出\n\n`<datalist>`规定输入域的选项列表\n```\n\t<input type=\"url\" list=\"url_list\" name=\"link\" />\n\t<datalist id=\"url_list\">\n\t\t<option label=\"W3School\" value=\"http://www.W3School.com.cn\" />\n\t\t<option label=\"Google\" value=\"http://www.google.com\" />\n\t\t<option label=\"Microsoft\" value=\"http://www.microsoft.com\" />\n\t</datalist>\n```\n\n`<keygen>`提供一种验证用户的可靠方法，提交表单时，会生成2个键，一个私钥，一个公钥。用于验证用户。\n\n**`<canvas>`元素**\n\n**MathML元素**\n\n    <math></math>\n\n#### 2. HTML5中新的javascript的API\n\n**(1) 跨文档消息传递 XDM**\n\n不同域之间的消息传递\n\npostMessage(\"字符串\",\"目标域\")\n\n**(2) 原生拖放**\n\n**拖放事件**\n\n- 针对被拖放的元素：dragstart、drag、dragend\n- 针对放置目标：dragenter、dragover、dragleave/drop\n\n**数据交换dataTransfer**\n\ndataTransfer对象是事件对象event的属性\n\ndataTransfer对象有两个方法：\n\n- setData(\"数据保存类型\"，\"保存的值\")\n- getData(\"数据保存类型\")\n\ndataTransfer对象有两个属性：\n\n- dropEffect：被拖动的元素能够执行哪种放置行为\n- effectAllowed：被拖动的元素允许哪种dropEffect\n\n**元素是否能够被拖动**\n\n属性draggable\n\n详情见另一篇博客：HTML5中的元素的拖放\n\n(3) 音频和视频\n\n- `<video>`\n- `<audio>`\n\n(4) 历史状态管理\n\nHTML5更新了history对象\n\n为history对象新增了2个方法\n\n- pushState()\n- replaceState()\n\n(5) 离线存储localStorage、sessionStorage\n\n(6) web socket\n\n(7) web worker\n\n","source":"_posts/2016-05-05-HTML5中的新特性.md","raw":"---\nlayout: post\ntitle: HTML5中的新特性\ndate: 2016-05-05\ncategories: HTML\ntags: [HTML5]\ndescription: \n---\n### 一.HTML5是什么\n\nHTML5是HTML标准的第5次修订。\n\nHTML5包括：一些新的javascript的API、HTML的一些新的元素、一些新的技术（让web站点和应用更加多样化，功能更强大）\n\nHTML5的目的：将互联网语义化，以便更好地被人类和机器阅读。\n\n### 二. HTML5中的新的特性\n\n#### 1. HTML5中的新元素\n\n**语义化、结构化元素：**\n\n    <section>\n    <article>\n    <nav>\n    <header>\n    <footer>\n    <aside>\n    <hgroup>\n\n**对标签语义化的理解？**\n\n- 去掉样式时，页面结构依然清晰\n- 有利于SEO(提高该网站在搜索引擎结果中排名的位置)\n- 方便其它设备解析\n- 语义化更具可读性\n\n**新的媒体元素**\n\n    <audio>\n    <video>\n\n**新的表单元素**\n\n- `<datalist>`\n- `<keygen>`\n- `<output>` 用于不同类型的输出\n\n`<datalist>`规定输入域的选项列表\n```\n\t<input type=\"url\" list=\"url_list\" name=\"link\" />\n\t<datalist id=\"url_list\">\n\t\t<option label=\"W3School\" value=\"http://www.W3School.com.cn\" />\n\t\t<option label=\"Google\" value=\"http://www.google.com\" />\n\t\t<option label=\"Microsoft\" value=\"http://www.microsoft.com\" />\n\t</datalist>\n```\n\n`<keygen>`提供一种验证用户的可靠方法，提交表单时，会生成2个键，一个私钥，一个公钥。用于验证用户。\n\n**`<canvas>`元素**\n\n**MathML元素**\n\n    <math></math>\n\n#### 2. HTML5中新的javascript的API\n\n**(1) 跨文档消息传递 XDM**\n\n不同域之间的消息传递\n\npostMessage(\"字符串\",\"目标域\")\n\n**(2) 原生拖放**\n\n**拖放事件**\n\n- 针对被拖放的元素：dragstart、drag、dragend\n- 针对放置目标：dragenter、dragover、dragleave/drop\n\n**数据交换dataTransfer**\n\ndataTransfer对象是事件对象event的属性\n\ndataTransfer对象有两个方法：\n\n- setData(\"数据保存类型\"，\"保存的值\")\n- getData(\"数据保存类型\")\n\ndataTransfer对象有两个属性：\n\n- dropEffect：被拖动的元素能够执行哪种放置行为\n- effectAllowed：被拖动的元素允许哪种dropEffect\n\n**元素是否能够被拖动**\n\n属性draggable\n\n详情见另一篇博客：HTML5中的元素的拖放\n\n(3) 音频和视频\n\n- `<video>`\n- `<audio>`\n\n(4) 历史状态管理\n\nHTML5更新了history对象\n\n为history对象新增了2个方法\n\n- pushState()\n- replaceState()\n\n(5) 离线存储localStorage、sessionStorage\n\n(6) web socket\n\n(7) web worker\n\n","slug":"2016-05-05-HTML5中的新特性","published":1,"updated":"2016-09-12T02:56:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocey0043d5u8gr0k8lkd","content":"<h3 id=\"一-HTML5是什么\"><a href=\"#一-HTML5是什么\" class=\"headerlink\" title=\"一.HTML5是什么\"></a>一.HTML5是什么</h3><p>HTML5是HTML标准的第5次修订。</p>\n<p>HTML5包括：一些新的javascript的API、HTML的一些新的元素、一些新的技术（让web站点和应用更加多样化，功能更强大）</p>\n<p>HTML5的目的：将互联网语义化，以便更好地被人类和机器阅读。</p>\n<h3 id=\"二-HTML5中的新的特性\"><a href=\"#二-HTML5中的新的特性\" class=\"headerlink\" title=\"二. HTML5中的新的特性\"></a>二. HTML5中的新的特性</h3><h4 id=\"1-HTML5中的新元素\"><a href=\"#1-HTML5中的新元素\" class=\"headerlink\" title=\"1. HTML5中的新元素\"></a>1. HTML5中的新元素</h4><p><strong>语义化、结构化元素：</strong></p>\n<pre><code>&lt;section&gt;\n&lt;article&gt;\n&lt;nav&gt;\n&lt;header&gt;\n&lt;footer&gt;\n&lt;aside&gt;\n&lt;hgroup&gt;\n</code></pre><p><strong>对标签语义化的理解？</strong></p>\n<ul>\n<li>去掉样式时，页面结构依然清晰</li>\n<li>有利于SEO(提高该网站在搜索引擎结果中排名的位置)</li>\n<li>方便其它设备解析</li>\n<li>语义化更具可读性</li>\n</ul>\n<p><strong>新的媒体元素</strong></p>\n<pre><code>&lt;audio&gt;\n&lt;video&gt;\n</code></pre><p><strong>新的表单元素</strong></p>\n<ul>\n<li><code>&lt;datalist&gt;</code></li>\n<li><code>&lt;keygen&gt;</code></li>\n<li><code>&lt;output&gt;</code> 用于不同类型的输出</li>\n</ul>\n<p><code>&lt;datalist&gt;</code>规定输入域的选项列表<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">list</span>=<span class=\"string\">\"url_list\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"link\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">\"url_list\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">label</span>=<span class=\"string\">\"W3School\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://www.W3School.com.cn\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">label</span>=<span class=\"string\">\"Google\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://www.google.com\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">label</span>=<span class=\"string\">\"Microsoft\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://www.microsoft.com\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;keygen&gt;</code>提供一种验证用户的可靠方法，提交表单时，会生成2个键，一个私钥，一个公钥。用于验证用户。</p>\n<p><strong><code>&lt;canvas&gt;</code>元素</strong></p>\n<p><strong>MathML元素</strong></p>\n<pre><code>&lt;math&gt;&lt;/math&gt;\n</code></pre><h4 id=\"2-HTML5中新的javascript的API\"><a href=\"#2-HTML5中新的javascript的API\" class=\"headerlink\" title=\"2. HTML5中新的javascript的API\"></a>2. HTML5中新的javascript的API</h4><p><strong>(1) 跨文档消息传递 XDM</strong></p>\n<p>不同域之间的消息传递</p>\n<p>postMessage(“字符串”,”目标域”)</p>\n<p><strong>(2) 原生拖放</strong></p>\n<p><strong>拖放事件</strong></p>\n<ul>\n<li>针对被拖放的元素：dragstart、drag、dragend</li>\n<li>针对放置目标：dragenter、dragover、dragleave/drop</li>\n</ul>\n<p><strong>数据交换dataTransfer</strong></p>\n<p>dataTransfer对象是事件对象event的属性</p>\n<p>dataTransfer对象有两个方法：</p>\n<ul>\n<li>setData(“数据保存类型”，”保存的值”)</li>\n<li>getData(“数据保存类型”)</li>\n</ul>\n<p>dataTransfer对象有两个属性：</p>\n<ul>\n<li>dropEffect：被拖动的元素能够执行哪种放置行为</li>\n<li>effectAllowed：被拖动的元素允许哪种dropEffect</li>\n</ul>\n<p><strong>元素是否能够被拖动</strong></p>\n<p>属性draggable</p>\n<p>详情见另一篇博客：HTML5中的元素的拖放</p>\n<p>(3) 音频和视频</p>\n<ul>\n<li><code>&lt;video&gt;</code></li>\n<li><code>&lt;audio&gt;</code></li>\n</ul>\n<p>(4) 历史状态管理</p>\n<p>HTML5更新了history对象</p>\n<p>为history对象新增了2个方法</p>\n<ul>\n<li>pushState()</li>\n<li>replaceState()</li>\n</ul>\n<p>(5) 离线存储localStorage、sessionStorage</p>\n<p>(6) web socket</p>\n<p>(7) web worker</p>\n","excerpt":"","more":"<h3 id=\"一-HTML5是什么\"><a href=\"#一-HTML5是什么\" class=\"headerlink\" title=\"一.HTML5是什么\"></a>一.HTML5是什么</h3><p>HTML5是HTML标准的第5次修订。</p>\n<p>HTML5包括：一些新的javascript的API、HTML的一些新的元素、一些新的技术（让web站点和应用更加多样化，功能更强大）</p>\n<p>HTML5的目的：将互联网语义化，以便更好地被人类和机器阅读。</p>\n<h3 id=\"二-HTML5中的新的特性\"><a href=\"#二-HTML5中的新的特性\" class=\"headerlink\" title=\"二. HTML5中的新的特性\"></a>二. HTML5中的新的特性</h3><h4 id=\"1-HTML5中的新元素\"><a href=\"#1-HTML5中的新元素\" class=\"headerlink\" title=\"1. HTML5中的新元素\"></a>1. HTML5中的新元素</h4><p><strong>语义化、结构化元素：</strong></p>\n<pre><code>&lt;section&gt;\n&lt;article&gt;\n&lt;nav&gt;\n&lt;header&gt;\n&lt;footer&gt;\n&lt;aside&gt;\n&lt;hgroup&gt;\n</code></pre><p><strong>对标签语义化的理解？</strong></p>\n<ul>\n<li>去掉样式时，页面结构依然清晰</li>\n<li>有利于SEO(提高该网站在搜索引擎结果中排名的位置)</li>\n<li>方便其它设备解析</li>\n<li>语义化更具可读性</li>\n</ul>\n<p><strong>新的媒体元素</strong></p>\n<pre><code>&lt;audio&gt;\n&lt;video&gt;\n</code></pre><p><strong>新的表单元素</strong></p>\n<ul>\n<li><code>&lt;datalist&gt;</code></li>\n<li><code>&lt;keygen&gt;</code></li>\n<li><code>&lt;output&gt;</code> 用于不同类型的输出</li>\n</ul>\n<p><code>&lt;datalist&gt;</code>规定输入域的选项列表<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">list</span>=<span class=\"string\">\"url_list\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"link\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">\"url_list\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">label</span>=<span class=\"string\">\"W3School\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://www.W3School.com.cn\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">label</span>=<span class=\"string\">\"Google\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://www.google.com\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">label</span>=<span class=\"string\">\"Microsoft\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://www.microsoft.com\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;keygen&gt;</code>提供一种验证用户的可靠方法，提交表单时，会生成2个键，一个私钥，一个公钥。用于验证用户。</p>\n<p><strong><code>&lt;canvas&gt;</code>元素</strong></p>\n<p><strong>MathML元素</strong></p>\n<pre><code>&lt;math&gt;&lt;/math&gt;\n</code></pre><h4 id=\"2-HTML5中新的javascript的API\"><a href=\"#2-HTML5中新的javascript的API\" class=\"headerlink\" title=\"2. HTML5中新的javascript的API\"></a>2. HTML5中新的javascript的API</h4><p><strong>(1) 跨文档消息传递 XDM</strong></p>\n<p>不同域之间的消息传递</p>\n<p>postMessage(“字符串”,”目标域”)</p>\n<p><strong>(2) 原生拖放</strong></p>\n<p><strong>拖放事件</strong></p>\n<ul>\n<li>针对被拖放的元素：dragstart、drag、dragend</li>\n<li>针对放置目标：dragenter、dragover、dragleave/drop</li>\n</ul>\n<p><strong>数据交换dataTransfer</strong></p>\n<p>dataTransfer对象是事件对象event的属性</p>\n<p>dataTransfer对象有两个方法：</p>\n<ul>\n<li>setData(“数据保存类型”，”保存的值”)</li>\n<li>getData(“数据保存类型”)</li>\n</ul>\n<p>dataTransfer对象有两个属性：</p>\n<ul>\n<li>dropEffect：被拖动的元素能够执行哪种放置行为</li>\n<li>effectAllowed：被拖动的元素允许哪种dropEffect</li>\n</ul>\n<p><strong>元素是否能够被拖动</strong></p>\n<p>属性draggable</p>\n<p>详情见另一篇博客：HTML5中的元素的拖放</p>\n<p>(3) 音频和视频</p>\n<ul>\n<li><code>&lt;video&gt;</code></li>\n<li><code>&lt;audio&gt;</code></li>\n</ul>\n<p>(4) 历史状态管理</p>\n<p>HTML5更新了history对象</p>\n<p>为history对象新增了2个方法</p>\n<ul>\n<li>pushState()</li>\n<li>replaceState()</li>\n</ul>\n<p>(5) 离线存储localStorage、sessionStorage</p>\n<p>(6) web socket</p>\n<p>(7) web worker</p>\n"},{"layout":"post","title":"js中的函数以及闭包","date":"2016-05-04T16:00:00.000Z","description":null,"_content":"### 一.函数的分类\n\n- 具名函数\n- 匿名函数\n\n**注意：所有声明的匿名函数都是一个新函数。**\n\n### 二. 创建函数的方式\n\n函数运行在定义它的作用域中，而不是运行在调用它的作用域中。\n\n#### 1. 声明函数法\n\n最普通最标准的方法\n\n    function myfunc() {}//具名函数\n\n#### 2. 创建函数表达式的方法\n\n创建一个变量，变量等于函数\n\n    var myfunc = function fn1(){}//具名函数，fn1只能在函数内部使用，函数外部应该使用变量名myfunc\n    \n    var myfunc = function (){}//匿名函数\n\n使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；\n\neg:\n\n    上述function fn1(){}内部可以访问myfunc\n\n在对象内部的函数表达式不能访问到，存放当前函数的变量\n\neg:\n\n    var o={\n      fn:function (){\n      console.log(fn);\n      }\n    };\n    o.fn();//ERROR报错\n\n#### 3. Function构造函数\n\n    Function(\"函数体\")//这样创建的是匿名函数\n\n### 三. 函数的执行环境、变量对象、作用域链\n\n**执行环境**定义了变量和函数有权访问的其他数据。\n\n**变量对象**保存了这个执行环境中定义的变量和函数。\n\n**作用域链：**当代码执行时，会给变量对象创建一个作用域链，保证执行环境中的变量和函数有序访问。\n\n示例图如下：\n\n![执行环境、变量对象、作用域链的关系](/uploads/post/demo/scope.jpg)\n\n**内部环境可以通过作用域链访问所有的外部环境，可以逐层向上查看（例如：所有函数都可以访问全局变量），子类或子方法可以访问父类的资源**\n\n**外部环境不能访问内部环境的任何变量和函数。**但通过某些特殊的方式可以。如下所示：\n\n    function f1(){\n    　　　　n=999;\n    　　　　function f2(){\n    　　　　　　alert(n);\n    　　　　}\n    　　　　return f2;\n    　　}\n    　　var result=f1();\n    　　result(); // 999\n\n如上面的代码所示，f2可以访问f1里面的变量n，但是f1不能访问f2里面的函数alert(n)，但是通过`return f2;`之后，f1就可以访问f2里面的函数了。\n\n注意：如果一个变量声明没有用var，那么这个变量就是全局变量。\n\n### 四. 什么是闭包\n\n**什么是闭包：**写在一个函数内部的函数，就叫做闭包。\n\n**闭包的作用：**\n\n- 通过使用闭包（返回一个对闭包的引用），外部环境也可以访问内部环境的变量和方法。\n- 让变量的值始终保持在内存中\n\n**闭包的优点：**\n\n1. 函数内部可以引用函数外部的参数和变量\n2. 不会增加额外的全局变量\n3. 函数内部的变量不会被垃圾回收机制回收\n\n**闭包的缺点：**\n\n1. 内存浪费问题：由于闭包会携带包含它的函数的作用域，所以会比其他函数更占内存。\n\n**代码示例：**\n\n    function out() {  \n      var a = 1;  \n       \n       \tfunction in(){\n      \t\t alert(a++)\n      \t};  \n    \t\t\n    \treturn in;\n     } \n    var test = out();  \n    test();// 1 执行后 a++，，然后a还在~  \n    test();// 2   test()实际上是闭包函数in，一共运行了2次\n    test = null;//a被回收！！ \n\n\t在函数执行完毕后，局部活动对象会被销毁，内存中仅仅只是保存全局作用域。\n\t\n\t但是这个函数out中的局部变量a一直保存在内存中，并没有在out调用后被自动清除。\n\t\n\t是因为in被赋给了一个全局变量test，而out是in的父函数，因此out也始终存在内存当中。\n\n**闭包与变量**\n\n    function myFunc(){\n    \tvar result = new Array();\n    \t\n    \tfor(var i=0;i<10;i++)\n    \t{\n    \t\tresult[i]=function(){\n    \t\t\treturn i;\n    \t\t};\t\n    \t}\n    \treturn result;\n    }\n\n\tvar a=myFunc();//a为一个数组，数组里面的每一项都是一个函数\n\tvar b=a[0]();\n    console.log(b);//10\n\ta中每个函数返回的值都是10，因为闭包的函数都是对myFunc函数中变量i的引用，所以都是返回的i的最终值。\n\n如何返回1，2，3...10\n\n\tfunction myFunc(){\n    \tvar result = new Array();\n    \t\n    \tfor(var i=0;i<10;i++)\n    \t{\n    \t\tresult[i]=function(num){\n    \t\t\treturn num;\n    \t\t}(i);\t\n    \t}\n    \treturn result;\n    }\n","source":"_posts/2016-05-05-js中的函数以及闭包.md","raw":"---\nlayout: post\ntitle: js中的函数以及闭包\ndate: 2016-05-05\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n### 一.函数的分类\n\n- 具名函数\n- 匿名函数\n\n**注意：所有声明的匿名函数都是一个新函数。**\n\n### 二. 创建函数的方式\n\n函数运行在定义它的作用域中，而不是运行在调用它的作用域中。\n\n#### 1. 声明函数法\n\n最普通最标准的方法\n\n    function myfunc() {}//具名函数\n\n#### 2. 创建函数表达式的方法\n\n创建一个变量，变量等于函数\n\n    var myfunc = function fn1(){}//具名函数，fn1只能在函数内部使用，函数外部应该使用变量名myfunc\n    \n    var myfunc = function (){}//匿名函数\n\n使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；\n\neg:\n\n    上述function fn1(){}内部可以访问myfunc\n\n在对象内部的函数表达式不能访问到，存放当前函数的变量\n\neg:\n\n    var o={\n      fn:function (){\n      console.log(fn);\n      }\n    };\n    o.fn();//ERROR报错\n\n#### 3. Function构造函数\n\n    Function(\"函数体\")//这样创建的是匿名函数\n\n### 三. 函数的执行环境、变量对象、作用域链\n\n**执行环境**定义了变量和函数有权访问的其他数据。\n\n**变量对象**保存了这个执行环境中定义的变量和函数。\n\n**作用域链：**当代码执行时，会给变量对象创建一个作用域链，保证执行环境中的变量和函数有序访问。\n\n示例图如下：\n\n![执行环境、变量对象、作用域链的关系](/uploads/post/demo/scope.jpg)\n\n**内部环境可以通过作用域链访问所有的外部环境，可以逐层向上查看（例如：所有函数都可以访问全局变量），子类或子方法可以访问父类的资源**\n\n**外部环境不能访问内部环境的任何变量和函数。**但通过某些特殊的方式可以。如下所示：\n\n    function f1(){\n    　　　　n=999;\n    　　　　function f2(){\n    　　　　　　alert(n);\n    　　　　}\n    　　　　return f2;\n    　　}\n    　　var result=f1();\n    　　result(); // 999\n\n如上面的代码所示，f2可以访问f1里面的变量n，但是f1不能访问f2里面的函数alert(n)，但是通过`return f2;`之后，f1就可以访问f2里面的函数了。\n\n注意：如果一个变量声明没有用var，那么这个变量就是全局变量。\n\n### 四. 什么是闭包\n\n**什么是闭包：**写在一个函数内部的函数，就叫做闭包。\n\n**闭包的作用：**\n\n- 通过使用闭包（返回一个对闭包的引用），外部环境也可以访问内部环境的变量和方法。\n- 让变量的值始终保持在内存中\n\n**闭包的优点：**\n\n1. 函数内部可以引用函数外部的参数和变量\n2. 不会增加额外的全局变量\n3. 函数内部的变量不会被垃圾回收机制回收\n\n**闭包的缺点：**\n\n1. 内存浪费问题：由于闭包会携带包含它的函数的作用域，所以会比其他函数更占内存。\n\n**代码示例：**\n\n    function out() {  \n      var a = 1;  \n       \n       \tfunction in(){\n      \t\t alert(a++)\n      \t};  \n    \t\t\n    \treturn in;\n     } \n    var test = out();  \n    test();// 1 执行后 a++，，然后a还在~  \n    test();// 2   test()实际上是闭包函数in，一共运行了2次\n    test = null;//a被回收！！ \n\n\t在函数执行完毕后，局部活动对象会被销毁，内存中仅仅只是保存全局作用域。\n\t\n\t但是这个函数out中的局部变量a一直保存在内存中，并没有在out调用后被自动清除。\n\t\n\t是因为in被赋给了一个全局变量test，而out是in的父函数，因此out也始终存在内存当中。\n\n**闭包与变量**\n\n    function myFunc(){\n    \tvar result = new Array();\n    \t\n    \tfor(var i=0;i<10;i++)\n    \t{\n    \t\tresult[i]=function(){\n    \t\t\treturn i;\n    \t\t};\t\n    \t}\n    \treturn result;\n    }\n\n\tvar a=myFunc();//a为一个数组，数组里面的每一项都是一个函数\n\tvar b=a[0]();\n    console.log(b);//10\n\ta中每个函数返回的值都是10，因为闭包的函数都是对myFunc函数中变量i的引用，所以都是返回的i的最终值。\n\n如何返回1，2，3...10\n\n\tfunction myFunc(){\n    \tvar result = new Array();\n    \t\n    \tfor(var i=0;i<10;i++)\n    \t{\n    \t\tresult[i]=function(num){\n    \t\t\treturn num;\n    \t\t}(i);\t\n    \t}\n    \treturn result;\n    }\n","slug":"2016-05-05-js中的函数以及闭包","published":1,"updated":"2016-06-11T12:26:50.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocf00047d5u8am7lzoj3","content":"<h3 id=\"一-函数的分类\"><a href=\"#一-函数的分类\" class=\"headerlink\" title=\"一.函数的分类\"></a>一.函数的分类</h3><ul>\n<li>具名函数</li>\n<li>匿名函数</li>\n</ul>\n<p><strong>注意：所有声明的匿名函数都是一个新函数。</strong></p>\n<h3 id=\"二-创建函数的方式\"><a href=\"#二-创建函数的方式\" class=\"headerlink\" title=\"二. 创建函数的方式\"></a>二. 创建函数的方式</h3><p>函数运行在定义它的作用域中，而不是运行在调用它的作用域中。</p>\n<h4 id=\"1-声明函数法\"><a href=\"#1-声明函数法\" class=\"headerlink\" title=\"1. 声明函数法\"></a>1. 声明函数法</h4><p>最普通最标准的方法</p>\n<pre><code>function myfunc() {}//具名函数\n</code></pre><h4 id=\"2-创建函数表达式的方法\"><a href=\"#2-创建函数表达式的方法\" class=\"headerlink\" title=\"2. 创建函数表达式的方法\"></a>2. 创建函数表达式的方法</h4><p>创建一个变量，变量等于函数</p>\n<pre><code>var myfunc = function fn1(){}//具名函数，fn1只能在函数内部使用，函数外部应该使用变量名myfunc\n\nvar myfunc = function (){}//匿名函数\n</code></pre><p>使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；</p>\n<p>eg:</p>\n<pre><code>上述function fn1(){}内部可以访问myfunc\n</code></pre><p>在对象内部的函数表达式不能访问到，存放当前函数的变量</p>\n<p>eg:</p>\n<pre><code>var o={\n  fn:function (){\n  console.log(fn);\n  }\n};\no.fn();//ERROR报错\n</code></pre><h4 id=\"3-Function构造函数\"><a href=\"#3-Function构造函数\" class=\"headerlink\" title=\"3. Function构造函数\"></a>3. Function构造函数</h4><pre><code>Function(&quot;函数体&quot;)//这样创建的是匿名函数\n</code></pre><h3 id=\"三-函数的执行环境、变量对象、作用域链\"><a href=\"#三-函数的执行环境、变量对象、作用域链\" class=\"headerlink\" title=\"三. 函数的执行环境、变量对象、作用域链\"></a>三. 函数的执行环境、变量对象、作用域链</h3><p><strong>执行环境</strong>定义了变量和函数有权访问的其他数据。</p>\n<p><strong>变量对象</strong>保存了这个执行环境中定义的变量和函数。</p>\n<p><strong>作用域链：</strong>当代码执行时，会给变量对象创建一个作用域链，保证执行环境中的变量和函数有序访问。</p>\n<p>示例图如下：</p>\n<p><img src=\"/uploads/post/demo/scope.jpg\" alt=\"执行环境、变量对象、作用域链的关系\"></p>\n<p><strong>内部环境可以通过作用域链访问所有的外部环境，可以逐层向上查看（例如：所有函数都可以访问全局变量），子类或子方法可以访问父类的资源</strong></p>\n<p><strong>外部环境不能访问内部环境的任何变量和函数。</strong>但通过某些特殊的方式可以。如下所示：</p>\n<pre><code>function f1(){\n　　　　n=999;\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n　　　　return f2;\n　　}\n　　var result=f1();\n　　result(); // 999\n</code></pre><p>如上面的代码所示，f2可以访问f1里面的变量n，但是f1不能访问f2里面的函数alert(n)，但是通过<code>return f2;</code>之后，f1就可以访问f2里面的函数了。</p>\n<p>注意：如果一个变量声明没有用var，那么这个变量就是全局变量。</p>\n<h3 id=\"四-什么是闭包\"><a href=\"#四-什么是闭包\" class=\"headerlink\" title=\"四. 什么是闭包\"></a>四. 什么是闭包</h3><p><strong>什么是闭包：</strong>写在一个函数内部的函数，就叫做闭包。</p>\n<p><strong>闭包的作用：</strong></p>\n<ul>\n<li>通过使用闭包（返回一个对闭包的引用），外部环境也可以访问内部环境的变量和方法。</li>\n<li>让变量的值始终保持在内存中</li>\n</ul>\n<p><strong>闭包的优点：</strong></p>\n<ol>\n<li>函数内部可以引用函数外部的参数和变量</li>\n<li>不会增加额外的全局变量</li>\n<li>函数内部的变量不会被垃圾回收机制回收</li>\n</ol>\n<p><strong>闭包的缺点：</strong></p>\n<ol>\n<li>内存浪费问题：由于闭包会携带包含它的函数的作用域，所以会比其他函数更占内存。</li>\n</ol>\n<p><strong>代码示例：</strong></p>\n<pre><code>function out() {  \n  var a = 1;  \n\n       function in(){\n           alert(a++)\n      };  \n\n    return in;\n } \nvar test = out();  \ntest();// 1 执行后 a++，，然后a还在~  \ntest();// 2   test()实际上是闭包函数in，一共运行了2次\ntest = null;//a被回收！！ \n\n在函数执行完毕后，局部活动对象会被销毁，内存中仅仅只是保存全局作用域。\n\n但是这个函数out中的局部变量a一直保存在内存中，并没有在out调用后被自动清除。\n\n是因为in被赋给了一个全局变量test，而out是in的父函数，因此out也始终存在内存当中。\n</code></pre><p><strong>闭包与变量</strong></p>\n<pre><code>function myFunc(){\n    var result = new Array();\n\n    for(var i=0;i&lt;10;i++)\n    {\n        result[i]=function(){\n            return i;\n        };    \n    }\n    return result;\n}\n\nvar a=myFunc();//a为一个数组，数组里面的每一项都是一个函数\nvar b=a[0]();\nconsole.log(b);//10\na中每个函数返回的值都是10，因为闭包的函数都是对myFunc函数中变量i的引用，所以都是返回的i的最终值。\n</code></pre><p>如何返回1，2，3…10</p>\n<pre><code>function myFunc(){\n    var result = new Array();\n\n    for(var i=0;i&lt;10;i++)\n    {\n        result[i]=function(num){\n            return num;\n        }(i);    \n    }\n    return result;\n}\n</code></pre>","excerpt":"","more":"<h3 id=\"一-函数的分类\"><a href=\"#一-函数的分类\" class=\"headerlink\" title=\"一.函数的分类\"></a>一.函数的分类</h3><ul>\n<li>具名函数</li>\n<li>匿名函数</li>\n</ul>\n<p><strong>注意：所有声明的匿名函数都是一个新函数。</strong></p>\n<h3 id=\"二-创建函数的方式\"><a href=\"#二-创建函数的方式\" class=\"headerlink\" title=\"二. 创建函数的方式\"></a>二. 创建函数的方式</h3><p>函数运行在定义它的作用域中，而不是运行在调用它的作用域中。</p>\n<h4 id=\"1-声明函数法\"><a href=\"#1-声明函数法\" class=\"headerlink\" title=\"1. 声明函数法\"></a>1. 声明函数法</h4><p>最普通最标准的方法</p>\n<pre><code>function myfunc() {}//具名函数\n</code></pre><h4 id=\"2-创建函数表达式的方法\"><a href=\"#2-创建函数表达式的方法\" class=\"headerlink\" title=\"2. 创建函数表达式的方法\"></a>2. 创建函数表达式的方法</h4><p>创建一个变量，变量等于函数</p>\n<pre><code>var myfunc = function fn1(){}//具名函数，fn1只能在函数内部使用，函数外部应该使用变量名myfunc\n\nvar myfunc = function (){}//匿名函数\n</code></pre><p>使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；</p>\n<p>eg:</p>\n<pre><code>上述function fn1(){}内部可以访问myfunc\n</code></pre><p>在对象内部的函数表达式不能访问到，存放当前函数的变量</p>\n<p>eg:</p>\n<pre><code>var o={\n  fn:function (){\n  console.log(fn);\n  }\n};\no.fn();//ERROR报错\n</code></pre><h4 id=\"3-Function构造函数\"><a href=\"#3-Function构造函数\" class=\"headerlink\" title=\"3. Function构造函数\"></a>3. Function构造函数</h4><pre><code>Function(&quot;函数体&quot;)//这样创建的是匿名函数\n</code></pre><h3 id=\"三-函数的执行环境、变量对象、作用域链\"><a href=\"#三-函数的执行环境、变量对象、作用域链\" class=\"headerlink\" title=\"三. 函数的执行环境、变量对象、作用域链\"></a>三. 函数的执行环境、变量对象、作用域链</h3><p><strong>执行环境</strong>定义了变量和函数有权访问的其他数据。</p>\n<p><strong>变量对象</strong>保存了这个执行环境中定义的变量和函数。</p>\n<p><strong>作用域链：</strong>当代码执行时，会给变量对象创建一个作用域链，保证执行环境中的变量和函数有序访问。</p>\n<p>示例图如下：</p>\n<p><img src=\"/uploads/post/demo/scope.jpg\" alt=\"执行环境、变量对象、作用域链的关系\"></p>\n<p><strong>内部环境可以通过作用域链访问所有的外部环境，可以逐层向上查看（例如：所有函数都可以访问全局变量），子类或子方法可以访问父类的资源</strong></p>\n<p><strong>外部环境不能访问内部环境的任何变量和函数。</strong>但通过某些特殊的方式可以。如下所示：</p>\n<pre><code>function f1(){\n　　　　n=999;\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n　　　　return f2;\n　　}\n　　var result=f1();\n　　result(); // 999\n</code></pre><p>如上面的代码所示，f2可以访问f1里面的变量n，但是f1不能访问f2里面的函数alert(n)，但是通过<code>return f2;</code>之后，f1就可以访问f2里面的函数了。</p>\n<p>注意：如果一个变量声明没有用var，那么这个变量就是全局变量。</p>\n<h3 id=\"四-什么是闭包\"><a href=\"#四-什么是闭包\" class=\"headerlink\" title=\"四. 什么是闭包\"></a>四. 什么是闭包</h3><p><strong>什么是闭包：</strong>写在一个函数内部的函数，就叫做闭包。</p>\n<p><strong>闭包的作用：</strong></p>\n<ul>\n<li>通过使用闭包（返回一个对闭包的引用），外部环境也可以访问内部环境的变量和方法。</li>\n<li>让变量的值始终保持在内存中</li>\n</ul>\n<p><strong>闭包的优点：</strong></p>\n<ol>\n<li>函数内部可以引用函数外部的参数和变量</li>\n<li>不会增加额外的全局变量</li>\n<li>函数内部的变量不会被垃圾回收机制回收</li>\n</ol>\n<p><strong>闭包的缺点：</strong></p>\n<ol>\n<li>内存浪费问题：由于闭包会携带包含它的函数的作用域，所以会比其他函数更占内存。</li>\n</ol>\n<p><strong>代码示例：</strong></p>\n<pre><code>function out() {  \n  var a = 1;  \n\n       function in(){\n           alert(a++)\n      };  \n\n    return in;\n } \nvar test = out();  \ntest();// 1 执行后 a++，，然后a还在~  \ntest();// 2   test()实际上是闭包函数in，一共运行了2次\ntest = null;//a被回收！！ \n\n在函数执行完毕后，局部活动对象会被销毁，内存中仅仅只是保存全局作用域。\n\n但是这个函数out中的局部变量a一直保存在内存中，并没有在out调用后被自动清除。\n\n是因为in被赋给了一个全局变量test，而out是in的父函数，因此out也始终存在内存当中。\n</code></pre><p><strong>闭包与变量</strong></p>\n<pre><code>function myFunc(){\n    var result = new Array();\n\n    for(var i=0;i&lt;10;i++)\n    {\n        result[i]=function(){\n            return i;\n        };    \n    }\n    return result;\n}\n\nvar a=myFunc();//a为一个数组，数组里面的每一项都是一个函数\nvar b=a[0]();\nconsole.log(b);//10\na中每个函数返回的值都是10，因为闭包的函数都是对myFunc函数中变量i的引用，所以都是返回的i的最终值。\n</code></pre><p>如何返回1，2，3…10</p>\n<pre><code>function myFunc(){\n    var result = new Array();\n\n    for(var i=0;i&lt;10;i++)\n    {\n        result[i]=function(num){\n            return num;\n        }(i);    \n    }\n    return result;\n}\n</code></pre>"},{"layout":"post","title":"Ajax跨域问题","date":"2016-04-21T16:00:00.000Z","description":null,"_content":"### 一. Ajax跨域问题\n\n**跨域**：只要协议、域名、端口有一个不同，就被当做不同的域。\n\n**ajax跨域**：利用ajax技术请求不同域名上的数据。\n\n#### 1. 什么是同源策略\n\n**同源策略**是由Netscape提出的一个著名的**安全策略**，现在所有的可支持javascript的**浏览器**都会使用这个策略。\n\nA网页设置的 Cookie，B网页不能打开，除非这两个网页\"同源\"。\n\n**同源策略的作用**：防止其他网页对本网页的非法篡改。\n\n**同源**指的是：协议、域名、端口都相同。\n\n### 二. 跨域的方法\n\n#### 1. 跨域资源共享（CORS）\n\nCORS（Cross-Origin Resource Sharing）跨域资源共享，定义了在访问跨域资源时，浏览器与服务器应该如何沟通。\n\n注意：跨域资源共享的请求默认都是不包含cookie信息\n\n**思想：**\n\n使用**自定义的HTTP头部**让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。\n\n在request的请求头部中添加一个origin\n\n`eg: origin: http://www.ooooo.net`\n\n服务器在response的请求头部中设置Access-Control-Allow-Origin\n\n`eg: Access-Control-Allow-Origin: 设置和请求头部中的origin中相同的地址`\n\n如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。\n\n**CORS在浏览器中的实现：**\n\n**（1）IE中的CORS**\n\n使用XDR对象 XDomainRequest\n\nXDR对象和XHR类似，但是其open(请求方法, url)方法只接收两个参数，XDR的所有请求都是异步的。\n\n**（2）其它浏览器中的CORS**\n\n直接使用XHR对象\n\nopen(请求方法, url, 是否发送异步请求)方法的url传入**绝对的url**就可以实现跨域资源共享\n\n**（3）跨浏览器的CORS**\n\n```\nfunction createCORSRequest(method, url) {\n\tvar xhr = new XMLHttpRequest();\n\t//检测XHR是否支持跨域请求\n\tif('withCredentials' in xhr) {\n\t\n\t\txhr.open(method,url,true);\n\t\t\n\t} else if(typeof XDomainRequest != 'undefined') {\n\t\n\t\tvar xdr = new XDomainRequest();\n\t\txdr.open(method,url);\n\t\t\n\t} else {\n\t\n\t\txhr = null;\n\t\t\n\t}\n}\n\nvar request = createCORSRequest('get', 'http://....');\nif(request) {\n\trequest.onload = function() {\n\t\t//对request.responseText进行处理\n\t};\n\trequest.send();\n}\n```\n\n#### 2. 利用`<script>、<img>`标签的src\n\n<font color=\"red\">**解决方法**：</font>\n\nWeb页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如`<script>`、`<img>`、`<iframe>`）\n\n`<script>、<img>`标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。\n\n```\n\n\t<script type=\"text/javascript\">\n\t\tfunction addScriptTag(src) {\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.setAttribute(\"type\", \"text/javascript\");\n \t\t\tscript.src = src;\n \t\t\tdocument.body.appendChild(script);\n \t\t}\n\t\t\n\t\t//调用加载ScrptTag函数\n \t\twindow.onload =function(){\n\n\t\t\t//搜索apple，将自定义的回调函数名result传入callback参数中             \n\t\t\taddScriptTag(\"http://ajax.googleapis.com/ajax/services/search/web?v=1.0&q=apple&callback=result\");\n \t\t}\n \t\t\n\t\t//自定义的回调函数result\t\n\t\tfunction result(data) {\n \t\t\t//我们就简单的获取apple搜索结果的第一条记录中url数据    \n \t\t\talert(data.responseData.results[0].unescapedUrl);\n\t\t\talert(data.responseData.results[0].cacheUrl);\n\t\t}\n\t</script>\n```\n\n#### 3. 使用jsonp(json with padding 填充式json)\n\n- json是一种数据交换格式\n- Jsonp是一种非官方跨域数据交互协议\n\n> JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法\n\n**客户端：**在**跨域的url请求**中指定**回调函数**，回调函数是接收到响应时页面执行的函数。\n\n `http://域名/json/?callback=handle`\n \n**服务器端：**会将请求的json数据作为回调函数的参数，并调用回调函数。\n\n `eg: handle({\"name\":\"xiaoming\"})`\n\njsonp包括两个部分：回调函数、数据\n\njsonp跨域的原理也是利用script标签的src属性：\n\n```\n\n\t//客户端的代码\n\tfunction handle(response) {\n\t\tconsole.log(response.city + response.name);\n\t}\n\n\tvar script = document.createElement('script');\n\tscript.src = 'http://域名/json/remote.js?callback=handle';\n\tdocument.body.insertBefore(script,documen.body.firstChild);\n\n\t//服务器返回的代码remote.js\n\thandle({\"name\":\"xiaoming\"})\n```\n\njs文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。\n\n所以jsonp是需要服务器端的页面进行相应的配合的。\n\n**jsonp的优点：**简单适用，老式浏览器全部支持，服务器改造非常小。\n\n**jsonp的缺点：**只能发送get请求\n\n#### 4. 使用服务器代理的方式\n\n浏览器请求同源服务器，再由后者请求外部服务\n\n#### 5. Web Socket\n\n是一个不受同源策略限制的通信协议\n\n### 三. XSS跨站脚本攻击\n\n#### 1.什么是xss\n\nxss的全称是：cross site scripting，跨站脚本\n\n攻击者通过向要攻击的网站中插入一些恶意的html、js代码，来达到攻击其他用户的目的。\n\n攻击者使被攻击者在浏览器中执行脚本后，收集来自被攻击者的数据（如cookie或其他敏感信息）。\n\n避免xss的方法：将用户提交的内容进行过滤。\n\n#### 2. 什么是CSRF\n\nCSRF:  跨站请求伪造，是在用户不知情的情况下，冒充其身份发起了一个请求。\n\n盗取用户cookie，伪造用户请求\n\nHttpOnly 属性可以阻止通过javascript访问cookie\n\n要完成一次CSRF攻击，受害者必须依次完成两个步骤：\n\n1.登录受信任网站A，并在本地生成Cookie。\n2.在不登出A的情况下，访问危险网站B。\n\nxss是实现CSRF的一种方式。\n\n避免CSRF的方法：在请求中加入随机数，让钓鱼网站无法正常伪造请求。\n\n\n\n\n","source":"_posts/2016-05-06-Ajax跨域问题.md","raw":"---\nlayout: post\ntitle: Ajax跨域问题\ndate: 2016-04-22\ncategories: http协议\ntags: [http]\ndescription: \n---\n### 一. Ajax跨域问题\n\n**跨域**：只要协议、域名、端口有一个不同，就被当做不同的域。\n\n**ajax跨域**：利用ajax技术请求不同域名上的数据。\n\n#### 1. 什么是同源策略\n\n**同源策略**是由Netscape提出的一个著名的**安全策略**，现在所有的可支持javascript的**浏览器**都会使用这个策略。\n\nA网页设置的 Cookie，B网页不能打开，除非这两个网页\"同源\"。\n\n**同源策略的作用**：防止其他网页对本网页的非法篡改。\n\n**同源**指的是：协议、域名、端口都相同。\n\n### 二. 跨域的方法\n\n#### 1. 跨域资源共享（CORS）\n\nCORS（Cross-Origin Resource Sharing）跨域资源共享，定义了在访问跨域资源时，浏览器与服务器应该如何沟通。\n\n注意：跨域资源共享的请求默认都是不包含cookie信息\n\n**思想：**\n\n使用**自定义的HTTP头部**让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。\n\n在request的请求头部中添加一个origin\n\n`eg: origin: http://www.ooooo.net`\n\n服务器在response的请求头部中设置Access-Control-Allow-Origin\n\n`eg: Access-Control-Allow-Origin: 设置和请求头部中的origin中相同的地址`\n\n如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。\n\n**CORS在浏览器中的实现：**\n\n**（1）IE中的CORS**\n\n使用XDR对象 XDomainRequest\n\nXDR对象和XHR类似，但是其open(请求方法, url)方法只接收两个参数，XDR的所有请求都是异步的。\n\n**（2）其它浏览器中的CORS**\n\n直接使用XHR对象\n\nopen(请求方法, url, 是否发送异步请求)方法的url传入**绝对的url**就可以实现跨域资源共享\n\n**（3）跨浏览器的CORS**\n\n```\nfunction createCORSRequest(method, url) {\n\tvar xhr = new XMLHttpRequest();\n\t//检测XHR是否支持跨域请求\n\tif('withCredentials' in xhr) {\n\t\n\t\txhr.open(method,url,true);\n\t\t\n\t} else if(typeof XDomainRequest != 'undefined') {\n\t\n\t\tvar xdr = new XDomainRequest();\n\t\txdr.open(method,url);\n\t\t\n\t} else {\n\t\n\t\txhr = null;\n\t\t\n\t}\n}\n\nvar request = createCORSRequest('get', 'http://....');\nif(request) {\n\trequest.onload = function() {\n\t\t//对request.responseText进行处理\n\t};\n\trequest.send();\n}\n```\n\n#### 2. 利用`<script>、<img>`标签的src\n\n<font color=\"red\">**解决方法**：</font>\n\nWeb页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如`<script>`、`<img>`、`<iframe>`）\n\n`<script>、<img>`标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。\n\n```\n\n\t<script type=\"text/javascript\">\n\t\tfunction addScriptTag(src) {\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.setAttribute(\"type\", \"text/javascript\");\n \t\t\tscript.src = src;\n \t\t\tdocument.body.appendChild(script);\n \t\t}\n\t\t\n\t\t//调用加载ScrptTag函数\n \t\twindow.onload =function(){\n\n\t\t\t//搜索apple，将自定义的回调函数名result传入callback参数中             \n\t\t\taddScriptTag(\"http://ajax.googleapis.com/ajax/services/search/web?v=1.0&q=apple&callback=result\");\n \t\t}\n \t\t\n\t\t//自定义的回调函数result\t\n\t\tfunction result(data) {\n \t\t\t//我们就简单的获取apple搜索结果的第一条记录中url数据    \n \t\t\talert(data.responseData.results[0].unescapedUrl);\n\t\t\talert(data.responseData.results[0].cacheUrl);\n\t\t}\n\t</script>\n```\n\n#### 3. 使用jsonp(json with padding 填充式json)\n\n- json是一种数据交换格式\n- Jsonp是一种非官方跨域数据交互协议\n\n> JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法\n\n**客户端：**在**跨域的url请求**中指定**回调函数**，回调函数是接收到响应时页面执行的函数。\n\n `http://域名/json/?callback=handle`\n \n**服务器端：**会将请求的json数据作为回调函数的参数，并调用回调函数。\n\n `eg: handle({\"name\":\"xiaoming\"})`\n\njsonp包括两个部分：回调函数、数据\n\njsonp跨域的原理也是利用script标签的src属性：\n\n```\n\n\t//客户端的代码\n\tfunction handle(response) {\n\t\tconsole.log(response.city + response.name);\n\t}\n\n\tvar script = document.createElement('script');\n\tscript.src = 'http://域名/json/remote.js?callback=handle';\n\tdocument.body.insertBefore(script,documen.body.firstChild);\n\n\t//服务器返回的代码remote.js\n\thandle({\"name\":\"xiaoming\"})\n```\n\njs文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。\n\n所以jsonp是需要服务器端的页面进行相应的配合的。\n\n**jsonp的优点：**简单适用，老式浏览器全部支持，服务器改造非常小。\n\n**jsonp的缺点：**只能发送get请求\n\n#### 4. 使用服务器代理的方式\n\n浏览器请求同源服务器，再由后者请求外部服务\n\n#### 5. Web Socket\n\n是一个不受同源策略限制的通信协议\n\n### 三. XSS跨站脚本攻击\n\n#### 1.什么是xss\n\nxss的全称是：cross site scripting，跨站脚本\n\n攻击者通过向要攻击的网站中插入一些恶意的html、js代码，来达到攻击其他用户的目的。\n\n攻击者使被攻击者在浏览器中执行脚本后，收集来自被攻击者的数据（如cookie或其他敏感信息）。\n\n避免xss的方法：将用户提交的内容进行过滤。\n\n#### 2. 什么是CSRF\n\nCSRF:  跨站请求伪造，是在用户不知情的情况下，冒充其身份发起了一个请求。\n\n盗取用户cookie，伪造用户请求\n\nHttpOnly 属性可以阻止通过javascript访问cookie\n\n要完成一次CSRF攻击，受害者必须依次完成两个步骤：\n\n1.登录受信任网站A，并在本地生成Cookie。\n2.在不登出A的情况下，访问危险网站B。\n\nxss是实现CSRF的一种方式。\n\n避免CSRF的方法：在请求中加入随机数，让钓鱼网站无法正常伪造请求。\n\n\n\n\n","slug":"2016-05-06-Ajax跨域问题","published":1,"updated":"2016-10-15T14:22:08.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocf2004ad5u82p9ye0xp","content":"<h3 id=\"一-Ajax跨域问题\"><a href=\"#一-Ajax跨域问题\" class=\"headerlink\" title=\"一. Ajax跨域问题\"></a>一. Ajax跨域问题</h3><p><strong>跨域</strong>：只要协议、域名、端口有一个不同，就被当做不同的域。</p>\n<p><strong>ajax跨域</strong>：利用ajax技术请求不同域名上的数据。</p>\n<h4 id=\"1-什么是同源策略\"><a href=\"#1-什么是同源策略\" class=\"headerlink\" title=\"1. 什么是同源策略\"></a>1. 什么是同源策略</h4><p><strong>同源策略</strong>是由Netscape提出的一个著名的<strong>安全策略</strong>，现在所有的可支持javascript的<strong>浏览器</strong>都会使用这个策略。</p>\n<p>A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。</p>\n<p><strong>同源策略的作用</strong>：防止其他网页对本网页的非法篡改。</p>\n<p><strong>同源</strong>指的是：协议、域名、端口都相同。</p>\n<h3 id=\"二-跨域的方法\"><a href=\"#二-跨域的方法\" class=\"headerlink\" title=\"二. 跨域的方法\"></a>二. 跨域的方法</h3><h4 id=\"1-跨域资源共享（CORS）\"><a href=\"#1-跨域资源共享（CORS）\" class=\"headerlink\" title=\"1. 跨域资源共享（CORS）\"></a>1. 跨域资源共享（CORS）</h4><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了在访问跨域资源时，浏览器与服务器应该如何沟通。</p>\n<p>注意：跨域资源共享的请求默认都是不包含cookie信息</p>\n<p><strong>思想：</strong></p>\n<p>使用<strong>自定义的HTTP头部</strong>让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>\n<p>在request的请求头部中添加一个origin</p>\n<p><code>eg: origin: http://www.ooooo.net</code></p>\n<p>服务器在response的请求头部中设置Access-Control-Allow-Origin</p>\n<p><code>eg: Access-Control-Allow-Origin: 设置和请求头部中的origin中相同的地址</code></p>\n<p>如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<p><strong>CORS在浏览器中的实现：</strong></p>\n<p><strong>（1）IE中的CORS</strong></p>\n<p>使用XDR对象 XDomainRequest</p>\n<p>XDR对象和XHR类似，但是其open(请求方法, url)方法只接收两个参数，XDR的所有请求都是异步的。</p>\n<p><strong>（2）其它浏览器中的CORS</strong></p>\n<p>直接使用XHR对象</p>\n<p>open(请求方法, url, 是否发送异步请求)方法的url传入<strong>绝对的url</strong>就可以实现跨域资源共享</p>\n<p><strong>（3）跨浏览器的CORS</strong></p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCORSRequest</span>(<span class=\"params\">method, url</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t<span class=\"comment\">//检测XHR是否支持跨域请求</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"string\">'withCredentials'</span> <span class=\"keyword\">in</span> xhr) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\txhr.open(method,<span class=\"built_in\">url</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> XDomainRequest != <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">var</span> xdr = <span class=\"keyword\">new</span> XDomainRequest();</span><br><span class=\"line\">\t\txdr.open(method,<span class=\"built_in\">url</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125; <span class=\"title\">else</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\txhr = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> request = createCORSRequest(<span class=\"string\">'get'</span>, <span class=\"string\">'http://....'</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(request) &#123;</span><br><span class=\"line\">\trequest.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//对request.responseText进行处理</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trequest.send();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-利用-lt-script-gt-、-lt-img-gt-标签的src\"><a href=\"#2-利用-lt-script-gt-、-lt-img-gt-标签的src\" class=\"headerlink\" title=\"2. 利用&lt;script&gt;、&lt;img&gt;标签的src\"></a>2. 利用<code>&lt;script&gt;、&lt;img&gt;</code>标签的src</h4><font color=\"red\"><strong>解决方法</strong>：</font>\n\n<p>Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>）</p>\n<p><code>&lt;script&gt;、&lt;img&gt;</code>标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addScriptTag</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">\t\t\tscript.setAttribute(<span class=\"string\">\"type\"</span>, <span class=\"string\">\"text/javascript\"</span>);</span><br><span class=\"line\">\t\t\tscript.src = src;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">document</span>.body.appendChild(script);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//调用加载ScrptTag函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">window</span>.onload =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//搜索apple，将自定义的回调函数名result传入callback参数中             </span></span><br><span class=\"line\">\t\taddScriptTag(<span class=\"string\">\"http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//自定义的回调函数result\t</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">result</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//我们就简单的获取apple搜索结果的第一条记录中url数据    </span></span><br><span class=\"line\">\t\t\talert(data.responseData.results[<span class=\"number\">0</span>].unescapedUrl);</span><br><span class=\"line\">\t\talert(data.responseData.results[<span class=\"number\">0</span>].cacheUrl);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-使用jsonp-json-with-padding-填充式json\"><a href=\"#3-使用jsonp-json-with-padding-填充式json\" class=\"headerlink\" title=\"3. 使用jsonp(json with padding 填充式json)\"></a>3. 使用jsonp(json with padding 填充式json)</h4><ul>\n<li>json是一种数据交换格式</li>\n<li>Jsonp是一种非官方跨域数据交互协议</li>\n</ul>\n<blockquote>\n<p>JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法</p>\n</blockquote>\n<p><strong>客户端：</strong>在<strong>跨域的url请求</strong>中指定<strong>回调函数</strong>，回调函数是接收到响应时页面执行的函数。</p>\n<p> <code>http://域名/json/?callback=handle</code></p>\n<p><strong>服务器端：</strong>会将请求的json数据作为回调函数的参数，并调用回调函数。</p>\n<p> <code>eg: handle({&quot;name&quot;:&quot;xiaoming&quot;})</code></p>\n<p>jsonp包括两个部分：回调函数、数据</p>\n<p>jsonp跨域的原理也是利用script标签的src属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//客户端的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(response.city + response.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">script.src = <span class=\"string\">'http://域名/json/remote.js?callback=handle'</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.insertBefore(script,documen.body.firstChild);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//服务器返回的代码remote.js</span></span><br><span class=\"line\">handle(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaoming\"</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>\n<p>所以jsonp是需要服务器端的页面进行相应的配合的。</p>\n<p><strong>jsonp的优点：</strong>简单适用，老式浏览器全部支持，服务器改造非常小。</p>\n<p><strong>jsonp的缺点：</strong>只能发送get请求</p>\n<h4 id=\"4-使用服务器代理的方式\"><a href=\"#4-使用服务器代理的方式\" class=\"headerlink\" title=\"4. 使用服务器代理的方式\"></a>4. 使用服务器代理的方式</h4><p>浏览器请求同源服务器，再由后者请求外部服务</p>\n<h4 id=\"5-Web-Socket\"><a href=\"#5-Web-Socket\" class=\"headerlink\" title=\"5. Web Socket\"></a>5. Web Socket</h4><p>是一个不受同源策略限制的通信协议</p>\n<h3 id=\"三-XSS跨站脚本攻击\"><a href=\"#三-XSS跨站脚本攻击\" class=\"headerlink\" title=\"三. XSS跨站脚本攻击\"></a>三. XSS跨站脚本攻击</h3><h4 id=\"1-什么是xss\"><a href=\"#1-什么是xss\" class=\"headerlink\" title=\"1.什么是xss\"></a>1.什么是xss</h4><p>xss的全称是：cross site scripting，跨站脚本</p>\n<p>攻击者通过向要攻击的网站中插入一些恶意的html、js代码，来达到攻击其他用户的目的。</p>\n<p>攻击者使被攻击者在浏览器中执行脚本后，收集来自被攻击者的数据（如cookie或其他敏感信息）。</p>\n<p>避免xss的方法：将用户提交的内容进行过滤。</p>\n<h4 id=\"2-什么是CSRF\"><a href=\"#2-什么是CSRF\" class=\"headerlink\" title=\"2. 什么是CSRF\"></a>2. 什么是CSRF</h4><p>CSRF:  跨站请求伪造，是在用户不知情的情况下，冒充其身份发起了一个请求。</p>\n<p>盗取用户cookie，伪造用户请求</p>\n<p>HttpOnly 属性可以阻止通过javascript访问cookie</p>\n<p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p>\n<p>1.登录受信任网站A，并在本地生成Cookie。<br>2.在不登出A的情况下，访问危险网站B。</p>\n<p>xss是实现CSRF的一种方式。</p>\n<p>避免CSRF的方法：在请求中加入随机数，让钓鱼网站无法正常伪造请求。</p>\n","excerpt":"","more":"<h3 id=\"一-Ajax跨域问题\"><a href=\"#一-Ajax跨域问题\" class=\"headerlink\" title=\"一. Ajax跨域问题\"></a>一. Ajax跨域问题</h3><p><strong>跨域</strong>：只要协议、域名、端口有一个不同，就被当做不同的域。</p>\n<p><strong>ajax跨域</strong>：利用ajax技术请求不同域名上的数据。</p>\n<h4 id=\"1-什么是同源策略\"><a href=\"#1-什么是同源策略\" class=\"headerlink\" title=\"1. 什么是同源策略\"></a>1. 什么是同源策略</h4><p><strong>同源策略</strong>是由Netscape提出的一个著名的<strong>安全策略</strong>，现在所有的可支持javascript的<strong>浏览器</strong>都会使用这个策略。</p>\n<p>A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。</p>\n<p><strong>同源策略的作用</strong>：防止其他网页对本网页的非法篡改。</p>\n<p><strong>同源</strong>指的是：协议、域名、端口都相同。</p>\n<h3 id=\"二-跨域的方法\"><a href=\"#二-跨域的方法\" class=\"headerlink\" title=\"二. 跨域的方法\"></a>二. 跨域的方法</h3><h4 id=\"1-跨域资源共享（CORS）\"><a href=\"#1-跨域资源共享（CORS）\" class=\"headerlink\" title=\"1. 跨域资源共享（CORS）\"></a>1. 跨域资源共享（CORS）</h4><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了在访问跨域资源时，浏览器与服务器应该如何沟通。</p>\n<p>注意：跨域资源共享的请求默认都是不包含cookie信息</p>\n<p><strong>思想：</strong></p>\n<p>使用<strong>自定义的HTTP头部</strong>让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>\n<p>在request的请求头部中添加一个origin</p>\n<p><code>eg: origin: http://www.ooooo.net</code></p>\n<p>服务器在response的请求头部中设置Access-Control-Allow-Origin</p>\n<p><code>eg: Access-Control-Allow-Origin: 设置和请求头部中的origin中相同的地址</code></p>\n<p>如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<p><strong>CORS在浏览器中的实现：</strong></p>\n<p><strong>（1）IE中的CORS</strong></p>\n<p>使用XDR对象 XDomainRequest</p>\n<p>XDR对象和XHR类似，但是其open(请求方法, url)方法只接收两个参数，XDR的所有请求都是异步的。</p>\n<p><strong>（2）其它浏览器中的CORS</strong></p>\n<p>直接使用XHR对象</p>\n<p>open(请求方法, url, 是否发送异步请求)方法的url传入<strong>绝对的url</strong>就可以实现跨域资源共享</p>\n<p><strong>（3）跨浏览器的CORS</strong></p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCORSRequest</span>(<span class=\"params\">method, url</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t<span class=\"comment\">//检测XHR是否支持跨域请求</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"string\">'withCredentials'</span> <span class=\"keyword\">in</span> xhr) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\txhr.open(method,<span class=\"built_in\">url</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> XDomainRequest != <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">var</span> xdr = <span class=\"keyword\">new</span> XDomainRequest();</span><br><span class=\"line\">\t\txdr.open(method,<span class=\"built_in\">url</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125; <span class=\"title\">else</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\txhr = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> request = createCORSRequest(<span class=\"string\">'get'</span>, <span class=\"string\">'http://....'</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(request) &#123;</span><br><span class=\"line\">\trequest.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//对request.responseText进行处理</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trequest.send();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-利用-lt-script-gt-、-lt-img-gt-标签的src\"><a href=\"#2-利用-lt-script-gt-、-lt-img-gt-标签的src\" class=\"headerlink\" title=\"2. 利用&lt;script&gt;、&lt;img&gt;标签的src\"></a>2. 利用<code>&lt;script&gt;、&lt;img&gt;</code>标签的src</h4><font color=\"red\"><strong>解决方法</strong>：</font>\n\n<p>Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>）</p>\n<p><code>&lt;script&gt;、&lt;img&gt;</code>标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addScriptTag</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">\t\t\tscript.setAttribute(<span class=\"string\">\"type\"</span>, <span class=\"string\">\"text/javascript\"</span>);</span><br><span class=\"line\">\t\t\tscript.src = src;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">document</span>.body.appendChild(script);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//调用加载ScrptTag函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">window</span>.onload =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//搜索apple，将自定义的回调函数名result传入callback参数中             </span></span><br><span class=\"line\">\t\taddScriptTag(<span class=\"string\">\"http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//自定义的回调函数result\t</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">result</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//我们就简单的获取apple搜索结果的第一条记录中url数据    </span></span><br><span class=\"line\">\t\t\talert(data.responseData.results[<span class=\"number\">0</span>].unescapedUrl);</span><br><span class=\"line\">\t\talert(data.responseData.results[<span class=\"number\">0</span>].cacheUrl);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-使用jsonp-json-with-padding-填充式json\"><a href=\"#3-使用jsonp-json-with-padding-填充式json\" class=\"headerlink\" title=\"3. 使用jsonp(json with padding 填充式json)\"></a>3. 使用jsonp(json with padding 填充式json)</h4><ul>\n<li>json是一种数据交换格式</li>\n<li>Jsonp是一种非官方跨域数据交互协议</li>\n</ul>\n<blockquote>\n<p>JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法</p>\n</blockquote>\n<p><strong>客户端：</strong>在<strong>跨域的url请求</strong>中指定<strong>回调函数</strong>，回调函数是接收到响应时页面执行的函数。</p>\n<p> <code>http://域名/json/?callback=handle</code></p>\n<p><strong>服务器端：</strong>会将请求的json数据作为回调函数的参数，并调用回调函数。</p>\n<p> <code>eg: handle({&quot;name&quot;:&quot;xiaoming&quot;})</code></p>\n<p>jsonp包括两个部分：回调函数、数据</p>\n<p>jsonp跨域的原理也是利用script标签的src属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//客户端的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(response.city + response.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">script.src = <span class=\"string\">'http://域名/json/remote.js?callback=handle'</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.insertBefore(script,documen.body.firstChild);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//服务器返回的代码remote.js</span></span><br><span class=\"line\">handle(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaoming\"</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>\n<p>所以jsonp是需要服务器端的页面进行相应的配合的。</p>\n<p><strong>jsonp的优点：</strong>简单适用，老式浏览器全部支持，服务器改造非常小。</p>\n<p><strong>jsonp的缺点：</strong>只能发送get请求</p>\n<h4 id=\"4-使用服务器代理的方式\"><a href=\"#4-使用服务器代理的方式\" class=\"headerlink\" title=\"4. 使用服务器代理的方式\"></a>4. 使用服务器代理的方式</h4><p>浏览器请求同源服务器，再由后者请求外部服务</p>\n<h4 id=\"5-Web-Socket\"><a href=\"#5-Web-Socket\" class=\"headerlink\" title=\"5. Web Socket\"></a>5. Web Socket</h4><p>是一个不受同源策略限制的通信协议</p>\n<h3 id=\"三-XSS跨站脚本攻击\"><a href=\"#三-XSS跨站脚本攻击\" class=\"headerlink\" title=\"三. XSS跨站脚本攻击\"></a>三. XSS跨站脚本攻击</h3><h4 id=\"1-什么是xss\"><a href=\"#1-什么是xss\" class=\"headerlink\" title=\"1.什么是xss\"></a>1.什么是xss</h4><p>xss的全称是：cross site scripting，跨站脚本</p>\n<p>攻击者通过向要攻击的网站中插入一些恶意的html、js代码，来达到攻击其他用户的目的。</p>\n<p>攻击者使被攻击者在浏览器中执行脚本后，收集来自被攻击者的数据（如cookie或其他敏感信息）。</p>\n<p>避免xss的方法：将用户提交的内容进行过滤。</p>\n<h4 id=\"2-什么是CSRF\"><a href=\"#2-什么是CSRF\" class=\"headerlink\" title=\"2. 什么是CSRF\"></a>2. 什么是CSRF</h4><p>CSRF:  跨站请求伪造，是在用户不知情的情况下，冒充其身份发起了一个请求。</p>\n<p>盗取用户cookie，伪造用户请求</p>\n<p>HttpOnly 属性可以阻止通过javascript访问cookie</p>\n<p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p>\n<p>1.登录受信任网站A，并在本地生成Cookie。<br>2.在不登出A的情况下，访问危险网站B。</p>\n<p>xss是实现CSRF的一种方式。</p>\n<p>避免CSRF的方法：在请求中加入随机数，让钓鱼网站无法正常伪造请求。</p>\n"},{"layout":"post","title":"window对象","date":"2016-05-04T16:00:00.000Z","description":null,"_content":"\nECMAScript中定义的Global对象：在浏览器中是指的window对象，在nodejs中指的是Global对象。\n\n### 一. window对象\n\n#### 1. window对象表示窗口，是浏览器的一个实例。\n\n**窗口位置**\n\n- window.screenLeft/screenX 窗口距离屏幕左边的距离\n- window.screenTop/screenY  窗口距离屏幕顶部的距离\n- window.moveTo() 移动窗口位置到...\n- window.moveBy() 移动窗口位置的绝对值\n\n窗口大小\n\nwindow.innerWidth/innerHeight\n\n\n\n#### 2. 作为window对象属性的几个对象\n\n- location对象\n- navigator对象\n- screen对象\n- history对象\n\n### 二. document对象\n\n#### 1. document对象表示整个HTML页面\n\ndocument对象也是window对象的一个属性\n\n\n","source":"_posts/2016-05-05-window对象和事件对象.md","raw":"---\nlayout: post\ntitle: window对象\ndate: 2016-05-05\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\nECMAScript中定义的Global对象：在浏览器中是指的window对象，在nodejs中指的是Global对象。\n\n### 一. window对象\n\n#### 1. window对象表示窗口，是浏览器的一个实例。\n\n**窗口位置**\n\n- window.screenLeft/screenX 窗口距离屏幕左边的距离\n- window.screenTop/screenY  窗口距离屏幕顶部的距离\n- window.moveTo() 移动窗口位置到...\n- window.moveBy() 移动窗口位置的绝对值\n\n窗口大小\n\nwindow.innerWidth/innerHeight\n\n\n\n#### 2. 作为window对象属性的几个对象\n\n- location对象\n- navigator对象\n- screen对象\n- history对象\n\n### 二. document对象\n\n#### 1. document对象表示整个HTML页面\n\ndocument对象也是window对象的一个属性\n\n\n","slug":"2016-05-05-window对象和事件对象","published":1,"updated":"2016-09-10T08:01:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocf4004ed5u8d60x2m9f","content":"<p>ECMAScript中定义的Global对象：在浏览器中是指的window对象，在nodejs中指的是Global对象。</p>\n<h3 id=\"一-window对象\"><a href=\"#一-window对象\" class=\"headerlink\" title=\"一. window对象\"></a>一. window对象</h3><h4 id=\"1-window对象表示窗口，是浏览器的一个实例。\"><a href=\"#1-window对象表示窗口，是浏览器的一个实例。\" class=\"headerlink\" title=\"1. window对象表示窗口，是浏览器的一个实例。\"></a>1. window对象表示窗口，是浏览器的一个实例。</h4><p><strong>窗口位置</strong></p>\n<ul>\n<li>window.screenLeft/screenX 窗口距离屏幕左边的距离</li>\n<li>window.screenTop/screenY  窗口距离屏幕顶部的距离</li>\n<li>window.moveTo() 移动窗口位置到…</li>\n<li>window.moveBy() 移动窗口位置的绝对值</li>\n</ul>\n<p>窗口大小</p>\n<p>window.innerWidth/innerHeight</p>\n<h4 id=\"2-作为window对象属性的几个对象\"><a href=\"#2-作为window对象属性的几个对象\" class=\"headerlink\" title=\"2. 作为window对象属性的几个对象\"></a>2. 作为window对象属性的几个对象</h4><ul>\n<li>location对象</li>\n<li>navigator对象</li>\n<li>screen对象</li>\n<li>history对象</li>\n</ul>\n<h3 id=\"二-document对象\"><a href=\"#二-document对象\" class=\"headerlink\" title=\"二. document对象\"></a>二. document对象</h3><h4 id=\"1-document对象表示整个HTML页面\"><a href=\"#1-document对象表示整个HTML页面\" class=\"headerlink\" title=\"1. document对象表示整个HTML页面\"></a>1. document对象表示整个HTML页面</h4><p>document对象也是window对象的一个属性</p>\n","excerpt":"","more":"<p>ECMAScript中定义的Global对象：在浏览器中是指的window对象，在nodejs中指的是Global对象。</p>\n<h3 id=\"一-window对象\"><a href=\"#一-window对象\" class=\"headerlink\" title=\"一. window对象\"></a>一. window对象</h3><h4 id=\"1-window对象表示窗口，是浏览器的一个实例。\"><a href=\"#1-window对象表示窗口，是浏览器的一个实例。\" class=\"headerlink\" title=\"1. window对象表示窗口，是浏览器的一个实例。\"></a>1. window对象表示窗口，是浏览器的一个实例。</h4><p><strong>窗口位置</strong></p>\n<ul>\n<li>window.screenLeft/screenX 窗口距离屏幕左边的距离</li>\n<li>window.screenTop/screenY  窗口距离屏幕顶部的距离</li>\n<li>window.moveTo() 移动窗口位置到…</li>\n<li>window.moveBy() 移动窗口位置的绝对值</li>\n</ul>\n<p>窗口大小</p>\n<p>window.innerWidth/innerHeight</p>\n<h4 id=\"2-作为window对象属性的几个对象\"><a href=\"#2-作为window对象属性的几个对象\" class=\"headerlink\" title=\"2. 作为window对象属性的几个对象\"></a>2. 作为window对象属性的几个对象</h4><ul>\n<li>location对象</li>\n<li>navigator对象</li>\n<li>screen对象</li>\n<li>history对象</li>\n</ul>\n<h3 id=\"二-document对象\"><a href=\"#二-document对象\" class=\"headerlink\" title=\"二. document对象\"></a>二. document对象</h3><h4 id=\"1-document对象表示整个HTML页面\"><a href=\"#1-document对象表示整个HTML页面\" class=\"headerlink\" title=\"1. document对象表示整个HTML页面\"></a>1. document对象表示整个HTML页面</h4><p>document对象也是window对象的一个属性</p>\n"},{"layout":"post","title":"BFC","date":"2016-05-05T16:00:00.000Z","description":null,"_content":"### 一. BFC\n\n#### 1. 什么是BFC\n\nhtml里面元素分为块级元素、内联元素\n\nFormatting Context指的是页面中的一块渲染区域，并有一套渲染规则\n\n    与块级元素对应的Formatting Context\n    BFC = Block Formatting Context 块级格式化上下文\n    \n    与内联元素对应的Formatting Context  \n    IFC \n\nBFC是一个独立的渲染区域\n\n    BFC布局规则：\n    \n    1. **内部**的Box会在垂直方向，一个接一个地放置。\n    2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n    3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n    4. BFC的区域不会与float box重叠。(可通过这一规则，写自适应两栏布局)\n    5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n    6. 计算BFC的高度时，浮动元素也参与计算。(可通过这一规则使浮动的元素撑开父元素——清除内部浮动)\n\n#### 2. 哪些元素会生成BFC\n\n    根元素\n    float属性不为none (float的属性值为left或者right)\n    position为absolute或fixed\n    display为inline-block, table-cell, table-caption, flex, inline-flex\n    overflow不为visible(overflow为hidden、scroll、auto)\n\n#### 3. BFC布局的使用\n\n(1) 自适应两栏布局\n\n(2) 清除内部浮动\n\n上面两个问题都是布局中常用到的问题，详情见对应的两篇博客。\n\n\n","source":"_posts/2016-05-06-BFC.md","raw":"---\nlayout: post\ntitle: BFC\ndate: 2016-05-06\ncategories: 前端笔记\ntags: [css]\ndescription: \n---\n### 一. BFC\n\n#### 1. 什么是BFC\n\nhtml里面元素分为块级元素、内联元素\n\nFormatting Context指的是页面中的一块渲染区域，并有一套渲染规则\n\n    与块级元素对应的Formatting Context\n    BFC = Block Formatting Context 块级格式化上下文\n    \n    与内联元素对应的Formatting Context  \n    IFC \n\nBFC是一个独立的渲染区域\n\n    BFC布局规则：\n    \n    1. **内部**的Box会在垂直方向，一个接一个地放置。\n    2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n    3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n    4. BFC的区域不会与float box重叠。(可通过这一规则，写自适应两栏布局)\n    5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n    6. 计算BFC的高度时，浮动元素也参与计算。(可通过这一规则使浮动的元素撑开父元素——清除内部浮动)\n\n#### 2. 哪些元素会生成BFC\n\n    根元素\n    float属性不为none (float的属性值为left或者right)\n    position为absolute或fixed\n    display为inline-block, table-cell, table-caption, flex, inline-flex\n    overflow不为visible(overflow为hidden、scroll、auto)\n\n#### 3. BFC布局的使用\n\n(1) 自适应两栏布局\n\n(2) 清除内部浮动\n\n上面两个问题都是布局中常用到的问题，详情见对应的两篇博客。\n\n\n","slug":"2016-05-06-BFC","published":1,"updated":"2016-07-03T13:50:18.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocf6004hd5u820wy1t8o","content":"<h3 id=\"一-BFC\"><a href=\"#一-BFC\" class=\"headerlink\" title=\"一. BFC\"></a>一. BFC</h3><h4 id=\"1-什么是BFC\"><a href=\"#1-什么是BFC\" class=\"headerlink\" title=\"1. 什么是BFC\"></a>1. 什么是BFC</h4><p>html里面元素分为块级元素、内联元素</p>\n<p>Formatting Context指的是页面中的一块渲染区域，并有一套渲染规则</p>\n<pre><code>与块级元素对应的Formatting Context\nBFC = Block Formatting Context 块级格式化上下文\n\n与内联元素对应的Formatting Context  \nIFC \n</code></pre><p>BFC是一个独立的渲染区域</p>\n<pre><code>BFC布局规则：\n\n1. **内部**的Box会在垂直方向，一个接一个地放置。\n2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n4. BFC的区域不会与float box重叠。(可通过这一规则，写自适应两栏布局)\n5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n6. 计算BFC的高度时，浮动元素也参与计算。(可通过这一规则使浮动的元素撑开父元素——清除内部浮动)\n</code></pre><h4 id=\"2-哪些元素会生成BFC\"><a href=\"#2-哪些元素会生成BFC\" class=\"headerlink\" title=\"2. 哪些元素会生成BFC\"></a>2. 哪些元素会生成BFC</h4><pre><code>根元素\nfloat属性不为none (float的属性值为left或者right)\nposition为absolute或fixed\ndisplay为inline-block, table-cell, table-caption, flex, inline-flex\noverflow不为visible(overflow为hidden、scroll、auto)\n</code></pre><h4 id=\"3-BFC布局的使用\"><a href=\"#3-BFC布局的使用\" class=\"headerlink\" title=\"3. BFC布局的使用\"></a>3. BFC布局的使用</h4><p>(1) 自适应两栏布局</p>\n<p>(2) 清除内部浮动</p>\n<p>上面两个问题都是布局中常用到的问题，详情见对应的两篇博客。</p>\n","excerpt":"","more":"<h3 id=\"一-BFC\"><a href=\"#一-BFC\" class=\"headerlink\" title=\"一. BFC\"></a>一. BFC</h3><h4 id=\"1-什么是BFC\"><a href=\"#1-什么是BFC\" class=\"headerlink\" title=\"1. 什么是BFC\"></a>1. 什么是BFC</h4><p>html里面元素分为块级元素、内联元素</p>\n<p>Formatting Context指的是页面中的一块渲染区域，并有一套渲染规则</p>\n<pre><code>与块级元素对应的Formatting Context\nBFC = Block Formatting Context 块级格式化上下文\n\n与内联元素对应的Formatting Context  \nIFC \n</code></pre><p>BFC是一个独立的渲染区域</p>\n<pre><code>BFC布局规则：\n\n1. **内部**的Box会在垂直方向，一个接一个地放置。\n2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n4. BFC的区域不会与float box重叠。(可通过这一规则，写自适应两栏布局)\n5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n6. 计算BFC的高度时，浮动元素也参与计算。(可通过这一规则使浮动的元素撑开父元素——清除内部浮动)\n</code></pre><h4 id=\"2-哪些元素会生成BFC\"><a href=\"#2-哪些元素会生成BFC\" class=\"headerlink\" title=\"2. 哪些元素会生成BFC\"></a>2. 哪些元素会生成BFC</h4><pre><code>根元素\nfloat属性不为none (float的属性值为left或者right)\nposition为absolute或fixed\ndisplay为inline-block, table-cell, table-caption, flex, inline-flex\noverflow不为visible(overflow为hidden、scroll、auto)\n</code></pre><h4 id=\"3-BFC布局的使用\"><a href=\"#3-BFC布局的使用\" class=\"headerlink\" title=\"3. BFC布局的使用\"></a>3. BFC布局的使用</h4><p>(1) 自适应两栏布局</p>\n<p>(2) 清除内部浮动</p>\n<p>上面两个问题都是布局中常用到的问题，详情见对应的两篇博客。</p>\n"},{"layout":"post","title":"垂直居中和水平居中","date":"2016-05-05T16:00:00.000Z","description":null,"_content":"\n关于垂直居中和水平居中的方法有很多，我下面只是总结了几个。\n\n### 一. 垂直居中\n\n#### 1. 利用css3的新属性transform:translate(x,y)\n\n首先将div绝对定位，然后设置top:50%;left:50%;\n然后设置transform:translate(-50%,-50%)\n\n\t<div class=\"content\">Content goes here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\t\n\t\theight:240px;\n\t\twidth:200px;\n\n\t\ttop:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n\t\tleft:50%;\n\n\t\ttransform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n\t}\n\n\n#### 2. 设置div绝对定位，并且设置margin:auto;\n\n    <div id=\"content\">Content here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\ttop:0;\n\t\tbottom:0;\n\t\tleft:0;\n\t\tright:0;\n\t\tmargin:auto;\n\t\theight:240px;\n\t\twidth:70%;\n\t}\n\n注意：这种方法必须设定`div`的宽和高，若要使**div垂直居中**，必须设定`top:0;bottom:0;`若要使**div水平居中**，必须设定`left:0;right:0;`\n\n#### 3. 设置div绝对定位，并且设置top:50%;margin-top\n\n\t<div class=\"content\">Content goes here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\ttop:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\t\theight:240px;\n\t\tmargin-top:-120px; /*内容与盒子顶部的距离为盒子高度的一半*/\n\t}\n\n#### 4. 使用表格的 vertical-align property 属性\n\n    <div id=\"wrapper\">\n      <div id=\"cell\">\n\t    <div class=\"content\">\n\t      Content goes here\n\t    </div>\n      </div>\n    </div>\n    \n    #wrapper {display:table;}\n    #cell {display:table-cell; vertical-align:middle;}\n\n**vertical-align属性**只有父元素为`<td>`、`<th>`时才有作用，这里是通过将**display**类型变成**table-cell**，激活了veritical-align属性。\n\n#### 5. 行内元素垂直居中\n\n    height = line-height\n\n#### 6. 文本、图片、块级元素垂直居中\n\n给父元素设定`margin-top = margin-bottom`\n\n个人觉得最好的方法是第一种，但是可能需要考虑兼容性的问题。\n\n### 二. 水平居中\n\n#### 1. 文本，图片等行内元素的水平居中\n\n    text-align:center;\n\n#### 2. 确定宽度的div水平居中\n\n    margin-left:auto;\n    margin-right:auto;\n    postion:absolute;\n    left:0;\n    right:0;\n\n#### 3. 不确定宽度的div水平居中————方法一\n\n首先将div绝对定位，然后设置left:50%;\n然后设置transform:translateX(-50%);\n\n\t<div class=\"content\">Content goes here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\t\n\t\theight:240px;\n\t\twidth:200px;\n\n\t\ttop:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n\t\tleft:50%;\n\n\t\ttransform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n\t}\n\n#### 4. 不确定宽度的div水平居中————方法二\n\n外层div设定：float属性;position:relative;left:50%;\n\n内层div设定:position:relative;right:50%;\n\n```js\n\t.wrap {\n\t\tposition:relative;\n\t\tleft:50%;\n\t\tfloat:left;\n\t}\n\t.inside {\t\t\n\t\tposition:relative;\n\t\tright:50%;\n\t\theight:50px;\n\t\tbackground:red;\n\t}\n\t\n\t<div class=\"wrap\">\n      <div class=\"inside\">lallala</div>\n    </div>\n```","source":"_posts/2016-05-06-垂直居中和水平居中.md","raw":"---\nlayout: post\ntitle: 垂直居中和水平居中\ndate: 2016-05-06\ncategories: CSS\ntags: [css]\ndescription: \n---\n\n关于垂直居中和水平居中的方法有很多，我下面只是总结了几个。\n\n### 一. 垂直居中\n\n#### 1. 利用css3的新属性transform:translate(x,y)\n\n首先将div绝对定位，然后设置top:50%;left:50%;\n然后设置transform:translate(-50%,-50%)\n\n\t<div class=\"content\">Content goes here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\t\n\t\theight:240px;\n\t\twidth:200px;\n\n\t\ttop:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n\t\tleft:50%;\n\n\t\ttransform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n\t}\n\n\n#### 2. 设置div绝对定位，并且设置margin:auto;\n\n    <div id=\"content\">Content here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\ttop:0;\n\t\tbottom:0;\n\t\tleft:0;\n\t\tright:0;\n\t\tmargin:auto;\n\t\theight:240px;\n\t\twidth:70%;\n\t}\n\n注意：这种方法必须设定`div`的宽和高，若要使**div垂直居中**，必须设定`top:0;bottom:0;`若要使**div水平居中**，必须设定`left:0;right:0;`\n\n#### 3. 设置div绝对定位，并且设置top:50%;margin-top\n\n\t<div class=\"content\">Content goes here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\ttop:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\t\theight:240px;\n\t\tmargin-top:-120px; /*内容与盒子顶部的距离为盒子高度的一半*/\n\t}\n\n#### 4. 使用表格的 vertical-align property 属性\n\n    <div id=\"wrapper\">\n      <div id=\"cell\">\n\t    <div class=\"content\">\n\t      Content goes here\n\t    </div>\n      </div>\n    </div>\n    \n    #wrapper {display:table;}\n    #cell {display:table-cell; vertical-align:middle;}\n\n**vertical-align属性**只有父元素为`<td>`、`<th>`时才有作用，这里是通过将**display**类型变成**table-cell**，激活了veritical-align属性。\n\n#### 5. 行内元素垂直居中\n\n    height = line-height\n\n#### 6. 文本、图片、块级元素垂直居中\n\n给父元素设定`margin-top = margin-bottom`\n\n个人觉得最好的方法是第一种，但是可能需要考虑兼容性的问题。\n\n### 二. 水平居中\n\n#### 1. 文本，图片等行内元素的水平居中\n\n    text-align:center;\n\n#### 2. 确定宽度的div水平居中\n\n    margin-left:auto;\n    margin-right:auto;\n    postion:absolute;\n    left:0;\n    right:0;\n\n#### 3. 不确定宽度的div水平居中————方法一\n\n首先将div绝对定位，然后设置left:50%;\n然后设置transform:translateX(-50%);\n\n\t<div class=\"content\">Content goes here</div>\n\n\t#content {\n\t\tposition:absolute;\n\t\t\n\t\theight:240px;\n\t\twidth:200px;\n\n\t\ttop:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n\t\tleft:50%;\n\n\t\ttransform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n\t}\n\n#### 4. 不确定宽度的div水平居中————方法二\n\n外层div设定：float属性;position:relative;left:50%;\n\n内层div设定:position:relative;right:50%;\n\n```js\n\t.wrap {\n\t\tposition:relative;\n\t\tleft:50%;\n\t\tfloat:left;\n\t}\n\t.inside {\t\t\n\t\tposition:relative;\n\t\tright:50%;\n\t\theight:50px;\n\t\tbackground:red;\n\t}\n\t\n\t<div class=\"wrap\">\n      <div class=\"inside\">lallala</div>\n    </div>\n```","slug":"2016-05-06-垂直居中和水平居中","published":1,"updated":"2016-09-07T03:05:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfb004ld5u8yie4m75o","content":"<p>关于垂直居中和水平居中的方法有很多，我下面只是总结了几个。</p>\n<h3 id=\"一-垂直居中\"><a href=\"#一-垂直居中\" class=\"headerlink\" title=\"一. 垂直居中\"></a>一. 垂直居中</h3><h4 id=\"1-利用css3的新属性transform-translate-x-y\"><a href=\"#1-利用css3的新属性transform-translate-x-y\" class=\"headerlink\" title=\"1. 利用css3的新属性transform:translate(x,y)\"></a>1. 利用css3的新属性transform:translate(x,y)</h4><p>首先将div绝对定位，然后设置top:50%;left:50%;<br>然后设置transform:translate(-50%,-50%)</p>\n<pre><code>&lt;div class=&quot;content&quot;&gt;Content goes here&lt;/div&gt;\n\n#content {\n    position:absolute;\n\n    height:240px;\n    width:200px;\n\n    top:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n    left:50%;\n\n    transform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n}\n</code></pre><h4 id=\"2-设置div绝对定位，并且设置margin-auto\"><a href=\"#2-设置div绝对定位，并且设置margin-auto\" class=\"headerlink\" title=\"2. 设置div绝对定位，并且设置margin:auto;\"></a>2. 设置div绝对定位，并且设置margin:auto;</h4><pre><code>&lt;div id=&quot;content&quot;&gt;Content here&lt;/div&gt;\n\n#content {\n    position:absolute;\n    top:0;\n    bottom:0;\n    left:0;\n    right:0;\n    margin:auto;\n    height:240px;\n    width:70%;\n}\n</code></pre><p>注意：这种方法必须设定<code>div</code>的宽和高，若要使<strong>div垂直居中</strong>，必须设定<code>top:0;bottom:0;</code>若要使<strong>div水平居中</strong>，必须设定<code>left:0;right:0;</code></p>\n<h4 id=\"3-设置div绝对定位，并且设置top-50-margin-top\"><a href=\"#3-设置div绝对定位，并且设置top-50-margin-top\" class=\"headerlink\" title=\"3. 设置div绝对定位，并且设置top:50%;margin-top\"></a>3. 设置div绝对定位，并且设置top:50%;margin-top</h4><pre><code>&lt;div class=&quot;content&quot;&gt;Content goes here&lt;/div&gt;\n\n#content {\n    position:absolute;\n    top:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n    height:240px;\n    margin-top:-120px; /*内容与盒子顶部的距离为盒子高度的一半*/\n}\n</code></pre><h4 id=\"4-使用表格的-vertical-align-property-属性\"><a href=\"#4-使用表格的-vertical-align-property-属性\" class=\"headerlink\" title=\"4. 使用表格的 vertical-align property 属性\"></a>4. 使用表格的 vertical-align property 属性</h4><pre><code>&lt;div id=&quot;wrapper&quot;&gt;\n  &lt;div id=&quot;cell&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;\n      Content goes here\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n#wrapper {display:table;}\n#cell {display:table-cell; vertical-align:middle;}\n</code></pre><p><strong>vertical-align属性</strong>只有父元素为<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>时才有作用，这里是通过将<strong>display</strong>类型变成<strong>table-cell</strong>，激活了veritical-align属性。</p>\n<h4 id=\"5-行内元素垂直居中\"><a href=\"#5-行内元素垂直居中\" class=\"headerlink\" title=\"5. 行内元素垂直居中\"></a>5. 行内元素垂直居中</h4><pre><code>height = line-height\n</code></pre><h4 id=\"6-文本、图片、块级元素垂直居中\"><a href=\"#6-文本、图片、块级元素垂直居中\" class=\"headerlink\" title=\"6. 文本、图片、块级元素垂直居中\"></a>6. 文本、图片、块级元素垂直居中</h4><p>给父元素设定<code>margin-top = margin-bottom</code></p>\n<p>个人觉得最好的方法是第一种，但是可能需要考虑兼容性的问题。</p>\n<h3 id=\"二-水平居中\"><a href=\"#二-水平居中\" class=\"headerlink\" title=\"二. 水平居中\"></a>二. 水平居中</h3><h4 id=\"1-文本，图片等行内元素的水平居中\"><a href=\"#1-文本，图片等行内元素的水平居中\" class=\"headerlink\" title=\"1. 文本，图片等行内元素的水平居中\"></a>1. 文本，图片等行内元素的水平居中</h4><pre><code>text-align:center;\n</code></pre><h4 id=\"2-确定宽度的div水平居中\"><a href=\"#2-确定宽度的div水平居中\" class=\"headerlink\" title=\"2. 确定宽度的div水平居中\"></a>2. 确定宽度的div水平居中</h4><pre><code>margin-left:auto;\nmargin-right:auto;\npostion:absolute;\nleft:0;\nright:0;\n</code></pre><h4 id=\"3-不确定宽度的div水平居中————方法一\"><a href=\"#3-不确定宽度的div水平居中————方法一\" class=\"headerlink\" title=\"3. 不确定宽度的div水平居中————方法一\"></a>3. 不确定宽度的div水平居中————方法一</h4><p>首先将div绝对定位，然后设置left:50%;<br>然后设置transform:translateX(-50%);</p>\n<pre><code>&lt;div class=&quot;content&quot;&gt;Content goes here&lt;/div&gt;\n\n#content {\n    position:absolute;\n\n    height:240px;\n    width:200px;\n\n    top:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n    left:50%;\n\n    transform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n}\n</code></pre><h4 id=\"4-不确定宽度的div水平居中————方法二\"><a href=\"#4-不确定宽度的div水平居中————方法二\" class=\"headerlink\" title=\"4. 不确定宽度的div水平居中————方法二\"></a>4. 不确定宽度的div水平居中————方法二</h4><p>外层div设定：float属性;position:relative;left:50%;</p>\n<p>内层div设定:position:relative;right:50%;</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.wrap &#123;</span><br><span class=\"line\">\tposition:relative;</span><br><span class=\"line\">\tleft:<span class=\"number\">50</span>%;</span><br><span class=\"line\">\tfloat:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.inside &#123;\t\t</span><br><span class=\"line\">\tposition:relative;</span><br><span class=\"line\">\tright:<span class=\"number\">50</span>%;</span><br><span class=\"line\">\theight:<span class=\"number\">50</span>px;</span><br><span class=\"line\">\tbackground:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"wrap\"</span>&gt;</span><br><span class=\"line\">     <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inside\"</span>&gt;</span>lallala<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">   &lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>关于垂直居中和水平居中的方法有很多，我下面只是总结了几个。</p>\n<h3 id=\"一-垂直居中\"><a href=\"#一-垂直居中\" class=\"headerlink\" title=\"一. 垂直居中\"></a>一. 垂直居中</h3><h4 id=\"1-利用css3的新属性transform-translate-x-y\"><a href=\"#1-利用css3的新属性transform-translate-x-y\" class=\"headerlink\" title=\"1. 利用css3的新属性transform:translate(x,y)\"></a>1. 利用css3的新属性transform:translate(x,y)</h4><p>首先将div绝对定位，然后设置top:50%;left:50%;<br>然后设置transform:translate(-50%,-50%)</p>\n<pre><code>&lt;div class=&quot;content&quot;&gt;Content goes here&lt;/div&gt;\n\n#content {\n    position:absolute;\n\n    height:240px;\n    width:200px;\n\n    top:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n    left:50%;\n\n    transform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n}\n</code></pre><h4 id=\"2-设置div绝对定位，并且设置margin-auto\"><a href=\"#2-设置div绝对定位，并且设置margin-auto\" class=\"headerlink\" title=\"2. 设置div绝对定位，并且设置margin:auto;\"></a>2. 设置div绝对定位，并且设置margin:auto;</h4><pre><code>&lt;div id=&quot;content&quot;&gt;Content here&lt;/div&gt;\n\n#content {\n    position:absolute;\n    top:0;\n    bottom:0;\n    left:0;\n    right:0;\n    margin:auto;\n    height:240px;\n    width:70%;\n}\n</code></pre><p>注意：这种方法必须设定<code>div</code>的宽和高，若要使<strong>div垂直居中</strong>，必须设定<code>top:0;bottom:0;</code>若要使<strong>div水平居中</strong>，必须设定<code>left:0;right:0;</code></p>\n<h4 id=\"3-设置div绝对定位，并且设置top-50-margin-top\"><a href=\"#3-设置div绝对定位，并且设置top-50-margin-top\" class=\"headerlink\" title=\"3. 设置div绝对定位，并且设置top:50%;margin-top\"></a>3. 设置div绝对定位，并且设置top:50%;margin-top</h4><pre><code>&lt;div class=&quot;content&quot;&gt;Content goes here&lt;/div&gt;\n\n#content {\n    position:absolute;\n    top:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n    height:240px;\n    margin-top:-120px; /*内容与盒子顶部的距离为盒子高度的一半*/\n}\n</code></pre><h4 id=\"4-使用表格的-vertical-align-property-属性\"><a href=\"#4-使用表格的-vertical-align-property-属性\" class=\"headerlink\" title=\"4. 使用表格的 vertical-align property 属性\"></a>4. 使用表格的 vertical-align property 属性</h4><pre><code>&lt;div id=&quot;wrapper&quot;&gt;\n  &lt;div id=&quot;cell&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;\n      Content goes here\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n#wrapper {display:table;}\n#cell {display:table-cell; vertical-align:middle;}\n</code></pre><p><strong>vertical-align属性</strong>只有父元素为<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>时才有作用，这里是通过将<strong>display</strong>类型变成<strong>table-cell</strong>，激活了veritical-align属性。</p>\n<h4 id=\"5-行内元素垂直居中\"><a href=\"#5-行内元素垂直居中\" class=\"headerlink\" title=\"5. 行内元素垂直居中\"></a>5. 行内元素垂直居中</h4><pre><code>height = line-height\n</code></pre><h4 id=\"6-文本、图片、块级元素垂直居中\"><a href=\"#6-文本、图片、块级元素垂直居中\" class=\"headerlink\" title=\"6. 文本、图片、块级元素垂直居中\"></a>6. 文本、图片、块级元素垂直居中</h4><p>给父元素设定<code>margin-top = margin-bottom</code></p>\n<p>个人觉得最好的方法是第一种，但是可能需要考虑兼容性的问题。</p>\n<h3 id=\"二-水平居中\"><a href=\"#二-水平居中\" class=\"headerlink\" title=\"二. 水平居中\"></a>二. 水平居中</h3><h4 id=\"1-文本，图片等行内元素的水平居中\"><a href=\"#1-文本，图片等行内元素的水平居中\" class=\"headerlink\" title=\"1. 文本，图片等行内元素的水平居中\"></a>1. 文本，图片等行内元素的水平居中</h4><pre><code>text-align:center;\n</code></pre><h4 id=\"2-确定宽度的div水平居中\"><a href=\"#2-确定宽度的div水平居中\" class=\"headerlink\" title=\"2. 确定宽度的div水平居中\"></a>2. 确定宽度的div水平居中</h4><pre><code>margin-left:auto;\nmargin-right:auto;\npostion:absolute;\nleft:0;\nright:0;\n</code></pre><h4 id=\"3-不确定宽度的div水平居中————方法一\"><a href=\"#3-不确定宽度的div水平居中————方法一\" class=\"headerlink\" title=\"3. 不确定宽度的div水平居中————方法一\"></a>3. 不确定宽度的div水平居中————方法一</h4><p>首先将div绝对定位，然后设置left:50%;<br>然后设置transform:translateX(-50%);</p>\n<pre><code>&lt;div class=&quot;content&quot;&gt;Content goes here&lt;/div&gt;\n\n#content {\n    position:absolute;\n\n    height:240px;\n    width:200px;\n\n    top:50%;  /*指的是div与顶部的距离为浏览器高度的一半*/\n\n    left:50%;\n\n    transform:translate(-50%,-50%);//这里是想对于div自身的百分比，进行x轴，y轴的变换\n}\n</code></pre><h4 id=\"4-不确定宽度的div水平居中————方法二\"><a href=\"#4-不确定宽度的div水平居中————方法二\" class=\"headerlink\" title=\"4. 不确定宽度的div水平居中————方法二\"></a>4. 不确定宽度的div水平居中————方法二</h4><p>外层div设定：float属性;position:relative;left:50%;</p>\n<p>内层div设定:position:relative;right:50%;</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.wrap &#123;</span><br><span class=\"line\">\tposition:relative;</span><br><span class=\"line\">\tleft:<span class=\"number\">50</span>%;</span><br><span class=\"line\">\tfloat:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.inside &#123;\t\t</span><br><span class=\"line\">\tposition:relative;</span><br><span class=\"line\">\tright:<span class=\"number\">50</span>%;</span><br><span class=\"line\">\theight:<span class=\"number\">50</span>px;</span><br><span class=\"line\">\tbackground:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"wrap\"</span>&gt;</span><br><span class=\"line\">     <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inside\"</span>&gt;</span>lallala<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">   &lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"css中的display和position","date":"2016-05-05T16:00:00.000Z","description":null,"_content":"### 一. display的取值\n\n- none\t\n- block\t\n- inline\t\n- inline-block\n\n**块级元素：**`<div>`、`<p>`、`<form>`、`<ul>`、`<ol>`、`<li>`\n\n**行内元素：**`<span>`、`<strong>`、`<em>`\n\n块级元素和行内元素的区别：\n\n1. 块级元素会单独占一行；行内元素不会单独占一行\n2. 块级元素可以设置width、height属性；行内元素不能设置width、height属性\n3. 块级元素可以设置margin、padding属性；行内元素水平方向的margin、padding有效果，垂直方向没有\n\n**display:none和 visibility:hidden的区别\n**\n\n- display:none 元素在视图中不占据空间\n- visibility:hidden 元素在视图中保留占位\n\n注意：display:none的元素也会被加载\n\n\n### 二. position的取值\n\n- inherit：继承其父元素的定位\n- static：默认值，没有定位\n- absolute：绝对定位\n- relative：相对定位\n- fixed\n\n**absolute：**若其父元素有absolute/relative/fixed定位，那么相对于父元素进行定位；若没有，则相对于body进行定位\n\n**relative：**相对于本身的位置进行定位\n\n**fixed：**相对于浏览器窗口进行定位\n\n**脱离文档流：**absolute、fixed、float\n\n设置absolute和float都会让元素的display变成**inline-block**\n\nz-index属性：\n\n- 若元素position:static，那么文档流后面的元素会覆盖掉前面的\n- 若元素设置了定位，那么z-index越大，元素会在越上方\n\n默认情况下，所有元素都是在z-index：0这一层的，这就是文档流。\n\n\n\n\n\n","source":"_posts/2016-05-06-CSS中的display和position.md","raw":"---\nlayout: post\ntitle: css中的display和position\ndate: 2016-05-06\ncategories: CSS\ntags: [css]\ndescription: \n---\n### 一. display的取值\n\n- none\t\n- block\t\n- inline\t\n- inline-block\n\n**块级元素：**`<div>`、`<p>`、`<form>`、`<ul>`、`<ol>`、`<li>`\n\n**行内元素：**`<span>`、`<strong>`、`<em>`\n\n块级元素和行内元素的区别：\n\n1. 块级元素会单独占一行；行内元素不会单独占一行\n2. 块级元素可以设置width、height属性；行内元素不能设置width、height属性\n3. 块级元素可以设置margin、padding属性；行内元素水平方向的margin、padding有效果，垂直方向没有\n\n**display:none和 visibility:hidden的区别\n**\n\n- display:none 元素在视图中不占据空间\n- visibility:hidden 元素在视图中保留占位\n\n注意：display:none的元素也会被加载\n\n\n### 二. position的取值\n\n- inherit：继承其父元素的定位\n- static：默认值，没有定位\n- absolute：绝对定位\n- relative：相对定位\n- fixed\n\n**absolute：**若其父元素有absolute/relative/fixed定位，那么相对于父元素进行定位；若没有，则相对于body进行定位\n\n**relative：**相对于本身的位置进行定位\n\n**fixed：**相对于浏览器窗口进行定位\n\n**脱离文档流：**absolute、fixed、float\n\n设置absolute和float都会让元素的display变成**inline-block**\n\nz-index属性：\n\n- 若元素position:static，那么文档流后面的元素会覆盖掉前面的\n- 若元素设置了定位，那么z-index越大，元素会在越上方\n\n默认情况下，所有元素都是在z-index：0这一层的，这就是文档流。\n\n\n\n\n\n","slug":"2016-05-06-CSS中的display和position","published":1,"updated":"2016-08-11T03:01:16.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfd004od5u89axwv2st","content":"<h3 id=\"一-display的取值\"><a href=\"#一-display的取值\" class=\"headerlink\" title=\"一. display的取值\"></a>一. display的取值</h3><ul>\n<li>none    </li>\n<li>block    </li>\n<li>inline    </li>\n<li>inline-block</li>\n</ul>\n<p><strong>块级元素：</strong><code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></p>\n<p><strong>行内元素：</strong><code>&lt;span&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code></p>\n<p>块级元素和行内元素的区别：</p>\n<ol>\n<li>块级元素会单独占一行；行内元素不会单独占一行</li>\n<li>块级元素可以设置width、height属性；行内元素不能设置width、height属性</li>\n<li>块级元素可以设置margin、padding属性；行内元素水平方向的margin、padding有效果，垂直方向没有</li>\n</ol>\n<p><strong>display:none和 visibility:hidden的区别\n</strong></p>\n<ul>\n<li>display:none 元素在视图中不占据空间</li>\n<li>visibility:hidden 元素在视图中保留占位</li>\n</ul>\n<p>注意：display:none的元素也会被加载</p>\n<h3 id=\"二-position的取值\"><a href=\"#二-position的取值\" class=\"headerlink\" title=\"二. position的取值\"></a>二. position的取值</h3><ul>\n<li>inherit：继承其父元素的定位</li>\n<li>static：默认值，没有定位</li>\n<li>absolute：绝对定位</li>\n<li>relative：相对定位</li>\n<li>fixed</li>\n</ul>\n<p><strong>absolute：</strong>若其父元素有absolute/relative/fixed定位，那么相对于父元素进行定位；若没有，则相对于body进行定位</p>\n<p><strong>relative：</strong>相对于本身的位置进行定位</p>\n<p><strong>fixed：</strong>相对于浏览器窗口进行定位</p>\n<p><strong>脱离文档流：</strong>absolute、fixed、float</p>\n<p>设置absolute和float都会让元素的display变成<strong>inline-block</strong></p>\n<p>z-index属性：</p>\n<ul>\n<li>若元素position:static，那么文档流后面的元素会覆盖掉前面的</li>\n<li>若元素设置了定位，那么z-index越大，元素会在越上方</li>\n</ul>\n<p>默认情况下，所有元素都是在z-index：0这一层的，这就是文档流。</p>\n","excerpt":"","more":"<h3 id=\"一-display的取值\"><a href=\"#一-display的取值\" class=\"headerlink\" title=\"一. display的取值\"></a>一. display的取值</h3><ul>\n<li>none    </li>\n<li>block    </li>\n<li>inline    </li>\n<li>inline-block</li>\n</ul>\n<p><strong>块级元素：</strong><code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></p>\n<p><strong>行内元素：</strong><code>&lt;span&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code></p>\n<p>块级元素和行内元素的区别：</p>\n<ol>\n<li>块级元素会单独占一行；行内元素不会单独占一行</li>\n<li>块级元素可以设置width、height属性；行内元素不能设置width、height属性</li>\n<li>块级元素可以设置margin、padding属性；行内元素水平方向的margin、padding有效果，垂直方向没有</li>\n</ol>\n<p><strong>display:none和 visibility:hidden的区别\n</strong></p>\n<ul>\n<li>display:none 元素在视图中不占据空间</li>\n<li>visibility:hidden 元素在视图中保留占位</li>\n</ul>\n<p>注意：display:none的元素也会被加载</p>\n<h3 id=\"二-position的取值\"><a href=\"#二-position的取值\" class=\"headerlink\" title=\"二. position的取值\"></a>二. position的取值</h3><ul>\n<li>inherit：继承其父元素的定位</li>\n<li>static：默认值，没有定位</li>\n<li>absolute：绝对定位</li>\n<li>relative：相对定位</li>\n<li>fixed</li>\n</ul>\n<p><strong>absolute：</strong>若其父元素有absolute/relative/fixed定位，那么相对于父元素进行定位；若没有，则相对于body进行定位</p>\n<p><strong>relative：</strong>相对于本身的位置进行定位</p>\n<p><strong>fixed：</strong>相对于浏览器窗口进行定位</p>\n<p><strong>脱离文档流：</strong>absolute、fixed、float</p>\n<p>设置absolute和float都会让元素的display变成<strong>inline-block</strong></p>\n<p>z-index属性：</p>\n<ul>\n<li>若元素position:static，那么文档流后面的元素会覆盖掉前面的</li>\n<li>若元素设置了定位，那么z-index越大，元素会在越上方</li>\n</ul>\n<p>默认情况下，所有元素都是在z-index：0这一层的，这就是文档流。</p>\n"},{"layout":"post","title":"js中创建对象的方式","date":"2016-05-05T16:00:00.000Z","description":null,"_content":"### 一. 什么是对象\n\n对象可以看成是一组**无序的名值对**。\n\n### 二. js中的几种创建对象的方式\n\njs创建对象的方式实际上和软件工程中的**设计模式**有一定的关系。\n\n- 对象字面量\n- 工厂模式\n- 构造函数模式\n- 原型模式\n- 组合模式\n\n#### 1. 对象字面量\n\n```\n    person={\n\t\tfirstname:\"Mark\",\n\t\tlastname:\"Yun\",\n\t\tage:25,\n\t\teyecolor:\"black\"\n\t};\n```\n\n#### 2. 工厂模式\n\n工厂模式与构造函数模式不同之处：\n\n不使用new调用函数，函数内部显式的返回一个对象\n\n```\n\tfunction person(name,age,job){\n\t\tvar obj = new Object();\n\t\tobj.name = name;\n\t\tobj.age = age;\n\t\tobj.job = job;\n\t\treturn obj;\n\t}\n\n\tvar myperson1 = person(\"xiaoming\",11,\"student\");\n\tvar myperson2 = person(\"xiaohong\",12,\"student\");\n```\n\n与之相对应的有一种设计模式叫做**工厂模式**，可以理解为：\n\n将person看成一个工厂函数，每次调用这个函数都会返回一个3个属性的一个对象。\n\n**工厂模式的缺点：**没有解决对象识别的问题，如何知道某个对象属于哪一个类型。\n\n#### 3. 构造函数模式\n\n```\n\tfunction Person(name,age,job){\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.job = job;\n\t\tthis.sayName = function(){alert(this.name)};\n\t}\n\t\n\tvar myperson1 = new Person(\"xiaoming\",11,\"student\");\n\tvar myperson2 = new Person(\"xiaohong\",12,\"student\");\n```\n\n使用构造函数，可以创建某个特定类型的对象，例如： `var myObj = new Object();`\n\n注意：构造函数首字母始终以大写字母开头。\n\n构造函数模式的缺点：通过构造函数创建的两个对象myperson1和myperson2各自都有一个sayName方法（**不同实例上的同名函数是不相等的**），完成同一个任务，创建2个函数实在是太浪费了。\n\n    console.log(myperson2.sayName == myperson1.sayName);//false\n    \n**通过new方法调用构造函数：**\n\n- 如果函数没有显示地return表达式，那么就会隐式地返回this；\n- 如果函数显示地return的是对象，那么返回的是对象\n- 如果函数显示地return的不是对象，那么还是会隐式地返回this\n\n#### 4. 原型模式\n\n每个函数都有一个prototype属性，指向原型对象，这个原型对象是通过这个构造函数创建的所有实例的原型。\n\n原型模式的优点：所有对象实例共享原型的属性和方法。  \n\n或者\n\n```js\n\tfunction Person(){};\n\n\tPerson.prototype = {\n\t\tname: \"xiaoming\",\n\t\tage: 12,\n\t\tjob: \"student\",\n\t\tnumber: [1,2,3]\n\t}\n\n\tvar myperson = new Person();\n\tmyperson.number.push(4);\n\tconsole.log(Person.prototype.number); //[1,2,3,4]\n```\n\n原型模式的问题：所有实例都会取得相同的属性值；修改实例的属性中的**引用类型**\n也会修改了原型中相应的属性值。\n\n举个栗子:\n\n```js\nfunction Person(){}\n\nPerson.prototype = {\n\tconstructor: Person,\n\tname: [\"xiaoming\"]\n}\n\nvar myperson1 = new Person();\nvar myperson2 = new Person();\n\nmyperson1.name.push(\"xiaohong\");//会修改原型中的name\nconsole.log(myperson2.name);//[\"xiaoming\",\"xiaohong\"]\n```\n\n#### 5. 组合使用构造函数模式和原型模式\n\n    用原型定义方法和共享的属性\n    \n    用构造函数定义每个实例自己的属性和方法\n\n举个栗子：\n\n```js\nfunction Person(name,age,job){\n\tthis.name = name;\n\tthis.job = job;\n\tthis.age = age;\n\tthis.friends = [\"1\",\"2\"];\n}\n   \nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function(){\n\t\talert(this.name);\n\t}\n}\n\nvar myperson1 = new Person(\"ming\",11,\"student\");\nvar myperson2 = new Person(\"hong\",12,\"student\");\n\nmyperson1.friends.push(\"3\");\nconsole.log(myperson1.friends);\nconsole.log(myperson2.friends);\n```\n\n","source":"_posts/2016-05-06-js中创建对象的方式.md","raw":"---\nlayout: post\ntitle: js中创建对象的方式\ndate: 2016-05-06\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n### 一. 什么是对象\n\n对象可以看成是一组**无序的名值对**。\n\n### 二. js中的几种创建对象的方式\n\njs创建对象的方式实际上和软件工程中的**设计模式**有一定的关系。\n\n- 对象字面量\n- 工厂模式\n- 构造函数模式\n- 原型模式\n- 组合模式\n\n#### 1. 对象字面量\n\n```\n    person={\n\t\tfirstname:\"Mark\",\n\t\tlastname:\"Yun\",\n\t\tage:25,\n\t\teyecolor:\"black\"\n\t};\n```\n\n#### 2. 工厂模式\n\n工厂模式与构造函数模式不同之处：\n\n不使用new调用函数，函数内部显式的返回一个对象\n\n```\n\tfunction person(name,age,job){\n\t\tvar obj = new Object();\n\t\tobj.name = name;\n\t\tobj.age = age;\n\t\tobj.job = job;\n\t\treturn obj;\n\t}\n\n\tvar myperson1 = person(\"xiaoming\",11,\"student\");\n\tvar myperson2 = person(\"xiaohong\",12,\"student\");\n```\n\n与之相对应的有一种设计模式叫做**工厂模式**，可以理解为：\n\n将person看成一个工厂函数，每次调用这个函数都会返回一个3个属性的一个对象。\n\n**工厂模式的缺点：**没有解决对象识别的问题，如何知道某个对象属于哪一个类型。\n\n#### 3. 构造函数模式\n\n```\n\tfunction Person(name,age,job){\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.job = job;\n\t\tthis.sayName = function(){alert(this.name)};\n\t}\n\t\n\tvar myperson1 = new Person(\"xiaoming\",11,\"student\");\n\tvar myperson2 = new Person(\"xiaohong\",12,\"student\");\n```\n\n使用构造函数，可以创建某个特定类型的对象，例如： `var myObj = new Object();`\n\n注意：构造函数首字母始终以大写字母开头。\n\n构造函数模式的缺点：通过构造函数创建的两个对象myperson1和myperson2各自都有一个sayName方法（**不同实例上的同名函数是不相等的**），完成同一个任务，创建2个函数实在是太浪费了。\n\n    console.log(myperson2.sayName == myperson1.sayName);//false\n    \n**通过new方法调用构造函数：**\n\n- 如果函数没有显示地return表达式，那么就会隐式地返回this；\n- 如果函数显示地return的是对象，那么返回的是对象\n- 如果函数显示地return的不是对象，那么还是会隐式地返回this\n\n#### 4. 原型模式\n\n每个函数都有一个prototype属性，指向原型对象，这个原型对象是通过这个构造函数创建的所有实例的原型。\n\n原型模式的优点：所有对象实例共享原型的属性和方法。  \n\n或者\n\n```js\n\tfunction Person(){};\n\n\tPerson.prototype = {\n\t\tname: \"xiaoming\",\n\t\tage: 12,\n\t\tjob: \"student\",\n\t\tnumber: [1,2,3]\n\t}\n\n\tvar myperson = new Person();\n\tmyperson.number.push(4);\n\tconsole.log(Person.prototype.number); //[1,2,3,4]\n```\n\n原型模式的问题：所有实例都会取得相同的属性值；修改实例的属性中的**引用类型**\n也会修改了原型中相应的属性值。\n\n举个栗子:\n\n```js\nfunction Person(){}\n\nPerson.prototype = {\n\tconstructor: Person,\n\tname: [\"xiaoming\"]\n}\n\nvar myperson1 = new Person();\nvar myperson2 = new Person();\n\nmyperson1.name.push(\"xiaohong\");//会修改原型中的name\nconsole.log(myperson2.name);//[\"xiaoming\",\"xiaohong\"]\n```\n\n#### 5. 组合使用构造函数模式和原型模式\n\n    用原型定义方法和共享的属性\n    \n    用构造函数定义每个实例自己的属性和方法\n\n举个栗子：\n\n```js\nfunction Person(name,age,job){\n\tthis.name = name;\n\tthis.job = job;\n\tthis.age = age;\n\tthis.friends = [\"1\",\"2\"];\n}\n   \nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function(){\n\t\talert(this.name);\n\t}\n}\n\nvar myperson1 = new Person(\"ming\",11,\"student\");\nvar myperson2 = new Person(\"hong\",12,\"student\");\n\nmyperson1.friends.push(\"3\");\nconsole.log(myperson1.friends);\nconsole.log(myperson2.friends);\n```\n\n","slug":"2016-05-06-js中创建对象的方式","published":1,"updated":"2016-09-18T02:36:56.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocff004sd5u8wp4fto2s","content":"<h3 id=\"一-什么是对象\"><a href=\"#一-什么是对象\" class=\"headerlink\" title=\"一. 什么是对象\"></a>一. 什么是对象</h3><p>对象可以看成是一组<strong>无序的名值对</strong>。</p>\n<h3 id=\"二-js中的几种创建对象的方式\"><a href=\"#二-js中的几种创建对象的方式\" class=\"headerlink\" title=\"二. js中的几种创建对象的方式\"></a>二. js中的几种创建对象的方式</h3><p>js创建对象的方式实际上和软件工程中的<strong>设计模式</strong>有一定的关系。</p>\n<ul>\n<li>对象字面量</li>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>组合模式</li>\n</ul>\n<h4 id=\"1-对象字面量\"><a href=\"#1-对象字面量\" class=\"headerlink\" title=\"1. 对象字面量\"></a>1. 对象字面量</h4><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   person=&#123;</span><br><span class=\"line\"><span class=\"symbol\">\tfirstname:</span><span class=\"string\">\"Mark\"</span>,</span><br><span class=\"line\"><span class=\"symbol\">\tlastname:</span><span class=\"string\">\"Yun\"</span>,</span><br><span class=\"line\"><span class=\"symbol\">\tage:</span><span class=\"number\">25</span>,</span><br><span class=\"line\"><span class=\"symbol\">\teyecolor:</span><span class=\"string\">\"black\"</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2. 工厂模式\"></a>2. 工厂模式</h4><p>工厂模式与构造函数模式不同之处：</p>\n<p>不使用new调用函数，函数内部显式的返回一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">name,age,job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">\tobj.name = name;</span><br><span class=\"line\">\tobj.age = age;</span><br><span class=\"line\">\tobj.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson1 = person(<span class=\"string\">\"xiaoming\"</span>,<span class=\"number\">11</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson2 = person(<span class=\"string\">\"xiaohong\"</span>,<span class=\"number\">12</span>,<span class=\"string\">\"student\"</span>);</span><br></pre></td></tr></table></figure>\n<p>与之相对应的有一种设计模式叫做<strong>工厂模式</strong>，可以理解为：</p>\n<p>将person看成一个工厂函数，每次调用这个函数都会返回一个3个属性的一个对象。</p>\n<p><strong>工厂模式的缺点：</strong>没有解决对象识别的问题，如何知道某个对象属于哪一个类型。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3. 构造函数模式\"></a>3. 构造函数模式</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">(name,age,job)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;alert(<span class=\"keyword\">this</span>.name)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"xiaoming\"</span>,<span class=\"number\">11</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"xiaohong\"</span>,<span class=\"number\">12</span>,<span class=\"string\">\"student\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用构造函数，可以创建某个特定类型的对象，例如： <code>var myObj = new Object();</code></p>\n<p>注意：构造函数首字母始终以大写字母开头。</p>\n<p>构造函数模式的缺点：通过构造函数创建的两个对象myperson1和myperson2各自都有一个sayName方法（<strong>不同实例上的同名函数是不相等的</strong>），完成同一个任务，创建2个函数实在是太浪费了。</p>\n<pre><code>console.log(myperson2.sayName == myperson1.sayName);//false\n</code></pre><p><strong>通过new方法调用构造函数：</strong></p>\n<ul>\n<li>如果函数没有显示地return表达式，那么就会隐式地返回this；</li>\n<li>如果函数显示地return的是对象，那么返回的是对象</li>\n<li>如果函数显示地return的不是对象，那么还是会隐式地返回this</li>\n</ul>\n<h4 id=\"4-原型模式\"><a href=\"#4-原型模式\" class=\"headerlink\" title=\"4. 原型模式\"></a>4. 原型模式</h4><p>每个函数都有一个prototype属性，指向原型对象，这个原型对象是通过这个构造函数创建的所有实例的原型。</p>\n<p>原型模式的优点：所有对象实例共享原型的属性和方法。  </p>\n<p>或者</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">\"xiaoming\"</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">12</span>,</span><br><span class=\"line\">\tjob: <span class=\"string\">\"student\"</span>,</span><br><span class=\"line\">\tnumber: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">myperson.number.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.number); <span class=\"comment\">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>原型模式的问题：所有实例都会取得相同的属性值；修改实例的属性中的<strong>引用类型</strong><br>也会修改了原型中相应的属性值。</p>\n<p>举个栗子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">\tname: [\"xiaoming\"]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myperson1 = new Person();</span><br><span class=\"line\">var myperson2 = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">myperson1.name.push(\"xiaohong\");//会修改原型中的name</span><br><span class=\"line\">console.log(myperson2.name);//[\"xiaoming\",\"xiaohong\"]</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-组合使用构造函数模式和原型模式\"><a href=\"#5-组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"5. 组合使用构造函数模式和原型模式\"></a>5. 组合使用构造函数模式和原型模式</h4><pre><code>用原型定义方法和共享的属性\n\n用构造函数定义每个实例自己的属性和方法\n</code></pre><p>举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age,job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.friends = [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">\tsayName: function()&#123;</span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"ming\"</span>,<span class=\"number\">11</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"hong\"</span>,<span class=\"number\">12</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">myperson1.friends.push(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myperson1.friends);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myperson2.friends);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-什么是对象\"><a href=\"#一-什么是对象\" class=\"headerlink\" title=\"一. 什么是对象\"></a>一. 什么是对象</h3><p>对象可以看成是一组<strong>无序的名值对</strong>。</p>\n<h3 id=\"二-js中的几种创建对象的方式\"><a href=\"#二-js中的几种创建对象的方式\" class=\"headerlink\" title=\"二. js中的几种创建对象的方式\"></a>二. js中的几种创建对象的方式</h3><p>js创建对象的方式实际上和软件工程中的<strong>设计模式</strong>有一定的关系。</p>\n<ul>\n<li>对象字面量</li>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>组合模式</li>\n</ul>\n<h4 id=\"1-对象字面量\"><a href=\"#1-对象字面量\" class=\"headerlink\" title=\"1. 对象字面量\"></a>1. 对象字面量</h4><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   person=&#123;</span><br><span class=\"line\"><span class=\"symbol\">\tfirstname:</span><span class=\"string\">\"Mark\"</span>,</span><br><span class=\"line\"><span class=\"symbol\">\tlastname:</span><span class=\"string\">\"Yun\"</span>,</span><br><span class=\"line\"><span class=\"symbol\">\tage:</span><span class=\"number\">25</span>,</span><br><span class=\"line\"><span class=\"symbol\">\teyecolor:</span><span class=\"string\">\"black\"</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2. 工厂模式\"></a>2. 工厂模式</h4><p>工厂模式与构造函数模式不同之处：</p>\n<p>不使用new调用函数，函数内部显式的返回一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">name,age,job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">\tobj.name = name;</span><br><span class=\"line\">\tobj.age = age;</span><br><span class=\"line\">\tobj.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson1 = person(<span class=\"string\">\"xiaoming\"</span>,<span class=\"number\">11</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson2 = person(<span class=\"string\">\"xiaohong\"</span>,<span class=\"number\">12</span>,<span class=\"string\">\"student\"</span>);</span><br></pre></td></tr></table></figure>\n<p>与之相对应的有一种设计模式叫做<strong>工厂模式</strong>，可以理解为：</p>\n<p>将person看成一个工厂函数，每次调用这个函数都会返回一个3个属性的一个对象。</p>\n<p><strong>工厂模式的缺点：</strong>没有解决对象识别的问题，如何知道某个对象属于哪一个类型。</p>\n<h4 id=\"3-构造函数模式\"><a href=\"#3-构造函数模式\" class=\"headerlink\" title=\"3. 构造函数模式\"></a>3. 构造函数模式</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">(name,age,job)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;alert(<span class=\"keyword\">this</span>.name)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"xiaoming\"</span>,<span class=\"number\">11</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"xiaohong\"</span>,<span class=\"number\">12</span>,<span class=\"string\">\"student\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用构造函数，可以创建某个特定类型的对象，例如： <code>var myObj = new Object();</code></p>\n<p>注意：构造函数首字母始终以大写字母开头。</p>\n<p>构造函数模式的缺点：通过构造函数创建的两个对象myperson1和myperson2各自都有一个sayName方法（<strong>不同实例上的同名函数是不相等的</strong>），完成同一个任务，创建2个函数实在是太浪费了。</p>\n<pre><code>console.log(myperson2.sayName == myperson1.sayName);//false\n</code></pre><p><strong>通过new方法调用构造函数：</strong></p>\n<ul>\n<li>如果函数没有显示地return表达式，那么就会隐式地返回this；</li>\n<li>如果函数显示地return的是对象，那么返回的是对象</li>\n<li>如果函数显示地return的不是对象，那么还是会隐式地返回this</li>\n</ul>\n<h4 id=\"4-原型模式\"><a href=\"#4-原型模式\" class=\"headerlink\" title=\"4. 原型模式\"></a>4. 原型模式</h4><p>每个函数都有一个prototype属性，指向原型对象，这个原型对象是通过这个构造函数创建的所有实例的原型。</p>\n<p>原型模式的优点：所有对象实例共享原型的属性和方法。  </p>\n<p>或者</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">\"xiaoming\"</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">12</span>,</span><br><span class=\"line\">\tjob: <span class=\"string\">\"student\"</span>,</span><br><span class=\"line\">\tnumber: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">myperson.number.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.number); <span class=\"comment\">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>原型模式的问题：所有实例都会取得相同的属性值；修改实例的属性中的<strong>引用类型</strong><br>也会修改了原型中相应的属性值。</p>\n<p>举个栗子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">\tname: [\"xiaoming\"]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myperson1 = new Person();</span><br><span class=\"line\">var myperson2 = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">myperson1.name.push(\"xiaohong\");//会修改原型中的name</span><br><span class=\"line\">console.log(myperson2.name);//[\"xiaoming\",\"xiaohong\"]</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-组合使用构造函数模式和原型模式\"><a href=\"#5-组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"5. 组合使用构造函数模式和原型模式\"></a>5. 组合使用构造函数模式和原型模式</h4><pre><code>用原型定义方法和共享的属性\n\n用构造函数定义每个实例自己的属性和方法\n</code></pre><p>举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age,job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.friends = [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">\tsayName: function()&#123;</span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"ming\"</span>,<span class=\"number\">11</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myperson2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"hong\"</span>,<span class=\"number\">12</span>,<span class=\"string\">\"student\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">myperson1.friends.push(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myperson1.friends);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myperson2.friends);</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"自适应两栏布局","date":"2016-05-05T16:00:00.000Z","description":null,"_content":"### 一. 一栏浮动，另一栏设置margin\n\n    <style>\n\t    body {\n\t\t    width: 300px;\n\t    }\n\t     \n\t    .aside {\n\t\t    width: 100px;\n\t\t    height: 150px;\t\t    \n\t\t    background: #f66;\n\n\t\t\tfloat: left;//\n\t    }\n\t     \n\t    .main {\n\t\t    height: 200px;\n\t\t    background: #fcc;\n\n\t\t\tmargin-left:110px;\n\t    }\n    </style>\n    <body>\n\t    <div class=\"aside\"></div>\n\t    <div class=\"main\"></div>\n    </body>\n\n### 二. 一栏绝对定位，另一栏设置margin\n\n    <style>\n\t    body {\n\t\t    width: 300px;\n\t    }\n\t     \n\t    .aside {\n\t\t    width: 100px;\n\t\t    height: 150px;\t\t    \n\t\t    background: #f66;\n\n\t\t\tposition: absolute;//\n\t    }\n\t     \n\t    .main {\n\t\t    height: 200px;\n\t\t    background: #fcc;\n\n\t\t\tmargin-left:110px;\n\t    }\n    </style>\n    <body>\n\t    <div class=\"aside\"></div>\n\t    <div class=\"main\"></div>\n    </body>\n\n一、二的原理是一样的，都是利用div的流体特性，这两种方法的缺点是：要知道浮动或者绝对定位的那一栏的宽度。\n\n### 三. 利用BFC布局\n\n\t<style>\n\t    body {\n\t\t    width: 300px;\n\t    }\n\t     \n\t    .aside {\n\t\t    width: 100px;\n\t\t    height: 150px;\t\t    \n\t\t    background: #f66;\n\n\t\t\tfloat:left;\n\t\t\tmargin-right:10px;\n\t    }\n\t     \n\t    .main {\n\t\t    height: 200px;\n\t\t    background: #fcc;\n\n\t\t\toverflow:auto/hidden;\n\t    }\n    </style>\n    <body>\n\t    <div class=\"aside\"></div>\n\t    <div class=\"main\"></div>\n    </body>\n\n由于BFC不会和设置了float的元素重叠，因此可以把main的div生成BFC，\n\n    这里适用的生成BFC的方法有：\n    \n    overflow:auto/hidden\n    display:table-cell/inline-box/flex/inline-flex\n\n这里利用了BFC特性之后，可以不用知道左侧栏的宽度，也可以实现两栏布局\n\n\n","source":"_posts/2016-05-06-自适应两栏布局.md","raw":"---\nlayout: post\ntitle: 自适应两栏布局\ndate: 2016-05-06\ncategories: 前端笔记\ntags: [css]\ndescription: \n---\n### 一. 一栏浮动，另一栏设置margin\n\n    <style>\n\t    body {\n\t\t    width: 300px;\n\t    }\n\t     \n\t    .aside {\n\t\t    width: 100px;\n\t\t    height: 150px;\t\t    \n\t\t    background: #f66;\n\n\t\t\tfloat: left;//\n\t    }\n\t     \n\t    .main {\n\t\t    height: 200px;\n\t\t    background: #fcc;\n\n\t\t\tmargin-left:110px;\n\t    }\n    </style>\n    <body>\n\t    <div class=\"aside\"></div>\n\t    <div class=\"main\"></div>\n    </body>\n\n### 二. 一栏绝对定位，另一栏设置margin\n\n    <style>\n\t    body {\n\t\t    width: 300px;\n\t    }\n\t     \n\t    .aside {\n\t\t    width: 100px;\n\t\t    height: 150px;\t\t    \n\t\t    background: #f66;\n\n\t\t\tposition: absolute;//\n\t    }\n\t     \n\t    .main {\n\t\t    height: 200px;\n\t\t    background: #fcc;\n\n\t\t\tmargin-left:110px;\n\t    }\n    </style>\n    <body>\n\t    <div class=\"aside\"></div>\n\t    <div class=\"main\"></div>\n    </body>\n\n一、二的原理是一样的，都是利用div的流体特性，这两种方法的缺点是：要知道浮动或者绝对定位的那一栏的宽度。\n\n### 三. 利用BFC布局\n\n\t<style>\n\t    body {\n\t\t    width: 300px;\n\t    }\n\t     \n\t    .aside {\n\t\t    width: 100px;\n\t\t    height: 150px;\t\t    \n\t\t    background: #f66;\n\n\t\t\tfloat:left;\n\t\t\tmargin-right:10px;\n\t    }\n\t     \n\t    .main {\n\t\t    height: 200px;\n\t\t    background: #fcc;\n\n\t\t\toverflow:auto/hidden;\n\t    }\n    </style>\n    <body>\n\t    <div class=\"aside\"></div>\n\t    <div class=\"main\"></div>\n    </body>\n\n由于BFC不会和设置了float的元素重叠，因此可以把main的div生成BFC，\n\n    这里适用的生成BFC的方法有：\n    \n    overflow:auto/hidden\n    display:table-cell/inline-box/flex/inline-flex\n\n这里利用了BFC特性之后，可以不用知道左侧栏的宽度，也可以实现两栏布局\n\n\n","slug":"2016-05-06-自适应两栏布局","published":1,"updated":"2016-07-03T13:50:06.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfh004vd5u8rdnu5ibv","content":"<h3 id=\"一-一栏浮动，另一栏设置margin\"><a href=\"#一-一栏浮动，另一栏设置margin\" class=\"headerlink\" title=\"一. 一栏浮动，另一栏设置margin\"></a>一. 一栏浮动，另一栏设置margin</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;            \n        background: #f66;\n\n        float: left;//\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n\n        margin-left:110px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><h3 id=\"二-一栏绝对定位，另一栏设置margin\"><a href=\"#二-一栏绝对定位，另一栏设置margin\" class=\"headerlink\" title=\"二. 一栏绝对定位，另一栏设置margin\"></a>二. 一栏绝对定位，另一栏设置margin</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;            \n        background: #f66;\n\n        position: absolute;//\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n\n        margin-left:110px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>一、二的原理是一样的，都是利用div的流体特性，这两种方法的缺点是：要知道浮动或者绝对定位的那一栏的宽度。</p>\n<h3 id=\"三-利用BFC布局\"><a href=\"#三-利用BFC布局\" class=\"headerlink\" title=\"三. 利用BFC布局\"></a>三. 利用BFC布局</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;            \n        background: #f66;\n\n        float:left;\n        margin-right:10px;\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n\n        overflow:auto/hidden;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>由于BFC不会和设置了float的元素重叠，因此可以把main的div生成BFC，</p>\n<pre><code>这里适用的生成BFC的方法有：\n\noverflow:auto/hidden\ndisplay:table-cell/inline-box/flex/inline-flex\n</code></pre><p>这里利用了BFC特性之后，可以不用知道左侧栏的宽度，也可以实现两栏布局</p>\n","excerpt":"","more":"<h3 id=\"一-一栏浮动，另一栏设置margin\"><a href=\"#一-一栏浮动，另一栏设置margin\" class=\"headerlink\" title=\"一. 一栏浮动，另一栏设置margin\"></a>一. 一栏浮动，另一栏设置margin</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;            \n        background: #f66;\n\n        float: left;//\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n\n        margin-left:110px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><h3 id=\"二-一栏绝对定位，另一栏设置margin\"><a href=\"#二-一栏绝对定位，另一栏设置margin\" class=\"headerlink\" title=\"二. 一栏绝对定位，另一栏设置margin\"></a>二. 一栏绝对定位，另一栏设置margin</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;            \n        background: #f66;\n\n        position: absolute;//\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n\n        margin-left:110px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>一、二的原理是一样的，都是利用div的流体特性，这两种方法的缺点是：要知道浮动或者绝对定位的那一栏的宽度。</p>\n<h3 id=\"三-利用BFC布局\"><a href=\"#三-利用BFC布局\" class=\"headerlink\" title=\"三. 利用BFC布局\"></a>三. 利用BFC布局</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;            \n        background: #f66;\n\n        float:left;\n        margin-right:10px;\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n\n        overflow:auto/hidden;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p>由于BFC不会和设置了float的元素重叠，因此可以把main的div生成BFC，</p>\n<pre><code>这里适用的生成BFC的方法有：\n\noverflow:auto/hidden\ndisplay:table-cell/inline-box/flex/inline-flex\n</code></pre><p>这里利用了BFC特性之后，可以不用知道左侧栏的宽度，也可以实现两栏布局</p>\n"},{"layout":"post","title":"js中的关键字in","date":"2016-05-07T16:00:00.000Z","description":null,"_content":"\n#### 1. 关键字 in 的作用\n\n- 判断变量是否为对象的属性\n- 判断变量是否为数组的索引\n\n其实上面两种很好理解，由于数组是一组有序的名值对，对象是一组无序的名值对，对象的属性也可以类比为数组的索引。\n\n格式： 变量 in 对象\n\n(1) 判断变量是否为对象的属性\n\n    eg:\n    \n    var myObj = {\n      name:\"hello\",\n      age:22\n    };\n    \n    alert(\"name\" in myObj);//true\n    alert(\"hello\" in myObj);//false\n    \n- in不能辨别出对象自身的属性和原型链上的属性\n- hasOwnProperty 可以判断一个对象是否包含自定义属性而不是原型链上的属性\n\n```\n// 修改Object.prototype\nObject.prototype.bar = 1; \nvar foo = {goo: undefined};\n\nfoo.bar; // 1\n'bar' in foo; // true\n\nfoo.hasOwnProperty('bar'); // false\nfoo.hasOwnProperty('goo'); // true\n```\n\n(2) 判断变量是否为数组的索引\n\n    eg:\n    \n    var myArr = [\"a\",\"b\",\"c\"];\n    \n    alert(1 in myArr);//true\n    alert(\"b\" in myArr);//false\n\n#### 2. for-in语句\n\n是一种精准的迭代语句，用来**枚举**对象的属性\n\n(1) 枚举对象的属性\n\n\tvar myObj = {\n      name:\"hello\",\n      age:22\n    };\n\n\tfor(var attr in myObj)\n\t{\n\t\tconsole.log(attr);//name age\n\t}\n\t\n\tfor-in会遍历对象原型链上的所有属性\n\n(2) 枚举数组的元素\n\n\tvar myArr = [\"a\",\"b\",\"c\"];\n\n\tfor(var i in myArr)\n\t{\n\t\tconsole.log(myArr[i]);//name age\n\t}\n\n注意： 这里的i是字符串，而不是数字\n    \n\n\n","source":"_posts/2016-05-08-js中的关键字in.md","raw":"---\nlayout: post\ntitle: js中的关键字in\ndate: 2016-05-08\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\n#### 1. 关键字 in 的作用\n\n- 判断变量是否为对象的属性\n- 判断变量是否为数组的索引\n\n其实上面两种很好理解，由于数组是一组有序的名值对，对象是一组无序的名值对，对象的属性也可以类比为数组的索引。\n\n格式： 变量 in 对象\n\n(1) 判断变量是否为对象的属性\n\n    eg:\n    \n    var myObj = {\n      name:\"hello\",\n      age:22\n    };\n    \n    alert(\"name\" in myObj);//true\n    alert(\"hello\" in myObj);//false\n    \n- in不能辨别出对象自身的属性和原型链上的属性\n- hasOwnProperty 可以判断一个对象是否包含自定义属性而不是原型链上的属性\n\n```\n// 修改Object.prototype\nObject.prototype.bar = 1; \nvar foo = {goo: undefined};\n\nfoo.bar; // 1\n'bar' in foo; // true\n\nfoo.hasOwnProperty('bar'); // false\nfoo.hasOwnProperty('goo'); // true\n```\n\n(2) 判断变量是否为数组的索引\n\n    eg:\n    \n    var myArr = [\"a\",\"b\",\"c\"];\n    \n    alert(1 in myArr);//true\n    alert(\"b\" in myArr);//false\n\n#### 2. for-in语句\n\n是一种精准的迭代语句，用来**枚举**对象的属性\n\n(1) 枚举对象的属性\n\n\tvar myObj = {\n      name:\"hello\",\n      age:22\n    };\n\n\tfor(var attr in myObj)\n\t{\n\t\tconsole.log(attr);//name age\n\t}\n\t\n\tfor-in会遍历对象原型链上的所有属性\n\n(2) 枚举数组的元素\n\n\tvar myArr = [\"a\",\"b\",\"c\"];\n\n\tfor(var i in myArr)\n\t{\n\t\tconsole.log(myArr[i]);//name age\n\t}\n\n注意： 这里的i是字符串，而不是数字\n    \n\n\n","slug":"2016-05-08-js中的关键字in","published":1,"updated":"2016-08-22T10:21:24.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfk004zd5u8apc8ahcr","content":"<h4 id=\"1-关键字-in-的作用\"><a href=\"#1-关键字-in-的作用\" class=\"headerlink\" title=\"1. 关键字 in 的作用\"></a>1. 关键字 in 的作用</h4><ul>\n<li>判断变量是否为对象的属性</li>\n<li>判断变量是否为数组的索引</li>\n</ul>\n<p>其实上面两种很好理解，由于数组是一组有序的名值对，对象是一组无序的名值对，对象的属性也可以类比为数组的索引。</p>\n<p>格式： 变量 in 对象</p>\n<p>(1) 判断变量是否为对象的属性</p>\n<pre><code>eg:\n\nvar myObj = {\n  name:&quot;hello&quot;,\n  age:22\n};\n\nalert(&quot;name&quot; in myObj);//true\nalert(&quot;hello&quot; in myObj);//false\n</code></pre><ul>\n<li>in不能辨别出对象自身的属性和原型链上的属性</li>\n<li>hasOwnProperty 可以判断一个对象是否包含自定义属性而不是原型链上的属性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.bar = <span class=\"number\">1</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;goo: <span class=\"literal\">undefined</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"string\">'bar'</span> <span class=\"keyword\">in</span> foo; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'bar'</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'goo'</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>(2) 判断变量是否为数组的索引</p>\n<pre><code>eg:\n\nvar myArr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];\n\nalert(1 in myArr);//true\nalert(&quot;b&quot; in myArr);//false\n</code></pre><h4 id=\"2-for-in语句\"><a href=\"#2-for-in语句\" class=\"headerlink\" title=\"2. for-in语句\"></a>2. for-in语句</h4><p>是一种精准的迭代语句，用来<strong>枚举</strong>对象的属性</p>\n<p>(1) 枚举对象的属性</p>\n<pre><code>var myObj = {\n  name:&quot;hello&quot;,\n  age:22\n};\n\nfor(var attr in myObj)\n{\n    console.log(attr);//name age\n}\n\nfor-in会遍历对象原型链上的所有属性\n</code></pre><p>(2) 枚举数组的元素</p>\n<pre><code>var myArr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];\n\nfor(var i in myArr)\n{\n    console.log(myArr[i]);//name age\n}\n</code></pre><p>注意： 这里的i是字符串，而不是数字</p>\n","excerpt":"","more":"<h4 id=\"1-关键字-in-的作用\"><a href=\"#1-关键字-in-的作用\" class=\"headerlink\" title=\"1. 关键字 in 的作用\"></a>1. 关键字 in 的作用</h4><ul>\n<li>判断变量是否为对象的属性</li>\n<li>判断变量是否为数组的索引</li>\n</ul>\n<p>其实上面两种很好理解，由于数组是一组有序的名值对，对象是一组无序的名值对，对象的属性也可以类比为数组的索引。</p>\n<p>格式： 变量 in 对象</p>\n<p>(1) 判断变量是否为对象的属性</p>\n<pre><code>eg:\n\nvar myObj = {\n  name:&quot;hello&quot;,\n  age:22\n};\n\nalert(&quot;name&quot; in myObj);//true\nalert(&quot;hello&quot; in myObj);//false\n</code></pre><ul>\n<li>in不能辨别出对象自身的属性和原型链上的属性</li>\n<li>hasOwnProperty 可以判断一个对象是否包含自定义属性而不是原型链上的属性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.bar = <span class=\"number\">1</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;goo: <span class=\"literal\">undefined</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"string\">'bar'</span> <span class=\"keyword\">in</span> foo; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'bar'</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'goo'</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>(2) 判断变量是否为数组的索引</p>\n<pre><code>eg:\n\nvar myArr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];\n\nalert(1 in myArr);//true\nalert(&quot;b&quot; in myArr);//false\n</code></pre><h4 id=\"2-for-in语句\"><a href=\"#2-for-in语句\" class=\"headerlink\" title=\"2. for-in语句\"></a>2. for-in语句</h4><p>是一种精准的迭代语句，用来<strong>枚举</strong>对象的属性</p>\n<p>(1) 枚举对象的属性</p>\n<pre><code>var myObj = {\n  name:&quot;hello&quot;,\n  age:22\n};\n\nfor(var attr in myObj)\n{\n    console.log(attr);//name age\n}\n\nfor-in会遍历对象原型链上的所有属性\n</code></pre><p>(2) 枚举数组的元素</p>\n<pre><code>var myArr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];\n\nfor(var i in myArr)\n{\n    console.log(myArr[i]);//name age\n}\n</code></pre><p>注意： 这里的i是字符串，而不是数字</p>\n"},{"layout":"post","title":"前端性能优化的经验","date":"2016-05-08T16:00:00.000Z","description":null,"_content":"\n## 主要分为以下7个方面进行优化\n\n雅虎35条：\n[https://developer.yahoo.com/performance/rules.html](https://developer.yahoo.com/performance/rules.html)\n\n- 内容\n- 服务端\n- cookie\n- CSS\n- JavaScript\n- Images\n- Mobile\n\n### 一. 网页内容（9条）\n\n####  1. 减少http请求的次数\n\n(1)捆绑文件，减少文件请求的次数\n\n- 将多个js文件捆绑成一个文件\n- 将多个CSS文件捆绑成一个文件\n\n**需要规划静态资源文件，把相对不变的合并在一起，把频繁变易的分隔开。**\n\n(2) CSS Sprites:将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置\n\n**CSS Sprites优点：**减少http请求，减轻服务器压力\n\n**CSS Sprites缺点：**只能将background-image图片合成一张；需要对图片计算坐标和精准的定位。\n\n使用CSS3的一些效果代替图片。\n\n#### 2. 缓存Ajax返回的数据\n\n**（1）浏览器缓存：使用Expire和Cache-Control**\n\nExpire和Cache-Control的介绍见这里：http://www.path8.net/tn/archives/2745\n\n这是设置浏览器缓存用的。注意，如果你设置了较长时间的缓存，那么每次修改组件内容时，也需要一并修改组件名字，否则浏览器不会重新发起请求。这就是为什么我们看到的许多js和css文件都带着hash戳或者时间戳。\n\n**（2）304协同缓存：配置ETag**\n\n后端可以在响应报文中添加Etag这一项，那么当浏览器下次请求同样的资源时，会携带If-None-Match条目。假如Etag没有发生变化，服务器可以返回304 Not Modified状态码，无须重新下载资源。\n\nEtag指的是版本标识符，由服务端配置。\n\n例如：\n\n    响应报文：\n    \n      HTTP/1.1 200 OK   \n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n      ETag: \"10c24bc-4ab-457e1c1f\"   \n      Content-Length: 12195\n\n    下一次的请求报文 ：\n    \n      GET /i/yahoo.gif HTTP/1.1   \n      Host: us.yimg.com   \n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n      If-None-Match: \"10c24bc-4ab-457e1c1f\"  \n      \n    再次响应的报文：\n     \n      HTTP/1.1 304 Not Modified\n\n这件事一般交由你用的服务器（比如Nginx）去做\n\n#### 3. 减少DOM元素的数量\n\n过多的DOM元素会拖慢js执行的速度\n\n#### 4. 避免404\n\n#### 5. 预加载组件\n\n#### 6. 延迟加载组件\n\n5，6都是为了拆分初始化负载\n\n#### 7. 减少DNS查找\n\n#### 8. 跨域分离组件\n\n#### 9. 尽量少用iframe\n\n### 二. 服务器（7条）\n\n#### 1. 使用CDN（Content Delivery Network）内容分发网络（加速静态资源的访问）\n\n一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。\n\n一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。\n\n#### 2. 尽量使用GET请求\n\nGET方法耗时较短\n\n浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。\n\n#### 3. 服务器启用Gzip压缩\n\n在发送的请求中添加：\n\n\tGET /index.html HTTP/1.1\n\tAccept-Encoding: gzip\n\n服务器接收到这个请求后，就会返回压缩后的数据\n\n你可以gzip一切，除了图片和pdf，因为这些文件一般都是压缩过了的，使用gzip甚至可能会增大文件大小。\n\n#### 4. 避免图片src的属性为空\n\n#### 5. 尽早清空缓存区\n\n#### 6. 配置Etag\n\n#### 7. 在请求头中添加Expires或者Cache-Control\n\n6、7其实就是一中的缓存ajax返回的数据\n\n### 三. Cookie（2条）\n\n#### 1. 减小Cookie的大小\n\n由于Cookie是用来标识服务器的特有信息，一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递\n\n#### 2. 把组件放在不含cookie的域下\n\n### 四. CSS（6条）\n\n#### 1. 将CSS样式表置顶\n\n将css文件放在head中\n\n原因：浏览器解析代码是从上到下的。如果把css放在底部，当网速慢时，html代码加载完成后而css没加载完的话，会导致页面没有样式而难以阅读，所以先加载css样式能让页面正常显示。\n\n加载和解析css不会阻塞页面。\n\n#### 2. 合并多个css文件\n\n减少http请求次数\n\n#### 3. 压缩css文件\n\n- 去掉不必要的空格、回车\n- 给一些样式添加前缀（解决兼容性）\n- 抽取出共同的样式？\n\n#### 4. 把css放到外面\n\n#### 5. 避免使用滤镜\n\n#### 6. 避免使用@import\n\n### 五. JavaScript的相关性能优化（6条）\n\n#### 1. 将脚本置底\n\n**JavaScript代码的加载和执行**会阻塞页面的解析渲染以及其他资源的下载。\n\n如果**放在head里面**，当加载多个js时，就会阻塞页面渲染而出现白屏，用户体验会很差。\n\n所以将脚本放在</body>之前，等其他部分加载好了，再加载脚本。\n\n#### 2. 把脚本放在外面\n \n#### 3. 合并多个script标签\n\n合并多个js文件来减少HTTP请求的次数,减少三次握手的次数和多余的HTTP头传输,降低响应时间提高用户体验。\n\n#### 4. 去除重复的脚本\n\n#### 5. 减少对dom的操作\n\n尽量减少回流（reflow）和重绘（repaint）\n\n#### 6. 使用无阻塞加载js的方法\n\n- 使用script标签的defer和async属性\n- 使用动态创建的script标签来加载执行js代码\n- 使用XHR对象加载js代码并注入页面\n\n#### 7. 压缩js\n\n- 保证每句话的结尾用\";\"\n- 去掉注释、空格\n- if else用{}包好\n- 变量命名的优化\n\n### 六. 图片的相关性能优化（4条）\n\n#### 1. 压缩图片\n\n#### 2. 使用css sprite技术\n\n将多个小图标放在一张图片上，减少http请求，将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置\n\n**优点：**\n\n- 减少网页的http请求\n- 减少图片的字节：3张图片合并成1张图片的字节总是小于这3张图片的字节总和\n- 不需要对每一个小元素进行命名\n\n#### 3. iconfont矢量图标库\n\nicon图片过多的情况下，考虑使用iconfont技术\n\n#### 4. 不要用HTML缩放图片\n\n\n    多个CSS样式表是不会同时加载的，但是所有的样式表都加载完了之后，再一起解析，加载css不会阻塞页面。\n    \n    多个js也是不会同时加载的，如果没有设定一些特殊的属性的情形下，一般是加载完了直接执行。\n    \n    多个图片是可以同时加载的，加载图片也不会阻塞页面\n\n### 七. 移动端（2条）\n\n#### 1. 保证所有组件都小于25k\n\n#### 2. 把组件打包到一个复合文档里\n    \n## 编写高效的js\n\n上面的几点都不是在写代码的过程中的优化\n\n#### 1. 管理作用域 ———— 使用局部变量，尽量少使用全局变量\n\n局部变量是js中读写最快的标识符\n\n因为局部变量一般都在作用域链的活动对象中，在作用域链的顶部。\n\n标识符在作用域链中的位置越靠上，存取的速度就越快。\n\n例子：\n\n```\n//不好的写法\nfunction createChildFor(id) {\n\tvar element = document.getElementById('id'),\n\tnewElement = document.createElement('div');\n\n\telement.appendChild(newElement);\n}\n\n//好的写法\n//使用局部变量缓存全局变量document\nfunction createChildFor(id) {\n\tvar doc = document,\n\telement = doc.getElementById('id'),\n\tnewElement = doc.createElement('div');\n\n\telement.appendChild(newElement);\n}\n```\n\n#### 2. 存取读取数据的方式 ———— 将频繁需要读取的值存储在局部变量中\n\n举个栗子：\n\n```\n//不好的写法\nfunction process(data) {\n\tif(data.length > 0) {\n\t\tfor(var i = 0; i < data.length; i++) {\n\t\t\t...\n\t\t}\n\t}\n}\n\n//好的写法\nfunction process(data) {\n\t\n\t//将数组的长度存到一个局部变量中\n\tvar len = data.length;\n\tif(len > 0) {\n\t\tfor(var i = 0; i < len; i++) {\n\t\t\t...\n\t\t}\n\t}\n}\n```\n\n#### 3. if语句和switch语句\n\n使用if语句的情况：2个之内的离散值需要判断；有区间范围\n\n使用switch语句的情况：10个离散值需要判断\n\n使用数组查询？？？？\n\n#### 4. 快速循环\n\nfor / while / do ... while\n\n用局部变量缓存数组的长度\n\n将循环递减到0，而不是增加到总长度\n\n#### 5. 使用定时器\n\n使用setTimeout进行数组分块处理\n\n\n**使用setTimeout进行函数节流**\n\nhttp://panpanfish.com/2016/05/16/2016-05-16-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/\n\n#### 6. 减少对dom的操作\n\n使用DocumentFragment优化多次append\n\n使用一次innerHTML赋值代替构建dom元素\n\n#### 7. 减少重绘和回流\n\n利用className代替style\n\n为动画的元素使之脱离文档流\n\n#### 8. 使用事件代理\n\n#### 9. 尽量少使用eval函数\n","source":"_posts/2016-05-08-前端性能优化的经验.md","raw":"---\nlayout: post\ntitle: 前端性能优化的经验\ndate: 2016-05-09\ncategories: 性能优化\ntags: [性能优化]\ndescription: \n---\n\n## 主要分为以下7个方面进行优化\n\n雅虎35条：\n[https://developer.yahoo.com/performance/rules.html](https://developer.yahoo.com/performance/rules.html)\n\n- 内容\n- 服务端\n- cookie\n- CSS\n- JavaScript\n- Images\n- Mobile\n\n### 一. 网页内容（9条）\n\n####  1. 减少http请求的次数\n\n(1)捆绑文件，减少文件请求的次数\n\n- 将多个js文件捆绑成一个文件\n- 将多个CSS文件捆绑成一个文件\n\n**需要规划静态资源文件，把相对不变的合并在一起，把频繁变易的分隔开。**\n\n(2) CSS Sprites:将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置\n\n**CSS Sprites优点：**减少http请求，减轻服务器压力\n\n**CSS Sprites缺点：**只能将background-image图片合成一张；需要对图片计算坐标和精准的定位。\n\n使用CSS3的一些效果代替图片。\n\n#### 2. 缓存Ajax返回的数据\n\n**（1）浏览器缓存：使用Expire和Cache-Control**\n\nExpire和Cache-Control的介绍见这里：http://www.path8.net/tn/archives/2745\n\n这是设置浏览器缓存用的。注意，如果你设置了较长时间的缓存，那么每次修改组件内容时，也需要一并修改组件名字，否则浏览器不会重新发起请求。这就是为什么我们看到的许多js和css文件都带着hash戳或者时间戳。\n\n**（2）304协同缓存：配置ETag**\n\n后端可以在响应报文中添加Etag这一项，那么当浏览器下次请求同样的资源时，会携带If-None-Match条目。假如Etag没有发生变化，服务器可以返回304 Not Modified状态码，无须重新下载资源。\n\nEtag指的是版本标识符，由服务端配置。\n\n例如：\n\n    响应报文：\n    \n      HTTP/1.1 200 OK   \n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n      ETag: \"10c24bc-4ab-457e1c1f\"   \n      Content-Length: 12195\n\n    下一次的请求报文 ：\n    \n      GET /i/yahoo.gif HTTP/1.1   \n      Host: us.yimg.com   \n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n      If-None-Match: \"10c24bc-4ab-457e1c1f\"  \n      \n    再次响应的报文：\n     \n      HTTP/1.1 304 Not Modified\n\n这件事一般交由你用的服务器（比如Nginx）去做\n\n#### 3. 减少DOM元素的数量\n\n过多的DOM元素会拖慢js执行的速度\n\n#### 4. 避免404\n\n#### 5. 预加载组件\n\n#### 6. 延迟加载组件\n\n5，6都是为了拆分初始化负载\n\n#### 7. 减少DNS查找\n\n#### 8. 跨域分离组件\n\n#### 9. 尽量少用iframe\n\n### 二. 服务器（7条）\n\n#### 1. 使用CDN（Content Delivery Network）内容分发网络（加速静态资源的访问）\n\n一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。\n\n一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。\n\n#### 2. 尽量使用GET请求\n\nGET方法耗时较短\n\n浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。\n\n#### 3. 服务器启用Gzip压缩\n\n在发送的请求中添加：\n\n\tGET /index.html HTTP/1.1\n\tAccept-Encoding: gzip\n\n服务器接收到这个请求后，就会返回压缩后的数据\n\n你可以gzip一切，除了图片和pdf，因为这些文件一般都是压缩过了的，使用gzip甚至可能会增大文件大小。\n\n#### 4. 避免图片src的属性为空\n\n#### 5. 尽早清空缓存区\n\n#### 6. 配置Etag\n\n#### 7. 在请求头中添加Expires或者Cache-Control\n\n6、7其实就是一中的缓存ajax返回的数据\n\n### 三. Cookie（2条）\n\n#### 1. 减小Cookie的大小\n\n由于Cookie是用来标识服务器的特有信息，一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递\n\n#### 2. 把组件放在不含cookie的域下\n\n### 四. CSS（6条）\n\n#### 1. 将CSS样式表置顶\n\n将css文件放在head中\n\n原因：浏览器解析代码是从上到下的。如果把css放在底部，当网速慢时，html代码加载完成后而css没加载完的话，会导致页面没有样式而难以阅读，所以先加载css样式能让页面正常显示。\n\n加载和解析css不会阻塞页面。\n\n#### 2. 合并多个css文件\n\n减少http请求次数\n\n#### 3. 压缩css文件\n\n- 去掉不必要的空格、回车\n- 给一些样式添加前缀（解决兼容性）\n- 抽取出共同的样式？\n\n#### 4. 把css放到外面\n\n#### 5. 避免使用滤镜\n\n#### 6. 避免使用@import\n\n### 五. JavaScript的相关性能优化（6条）\n\n#### 1. 将脚本置底\n\n**JavaScript代码的加载和执行**会阻塞页面的解析渲染以及其他资源的下载。\n\n如果**放在head里面**，当加载多个js时，就会阻塞页面渲染而出现白屏，用户体验会很差。\n\n所以将脚本放在</body>之前，等其他部分加载好了，再加载脚本。\n\n#### 2. 把脚本放在外面\n \n#### 3. 合并多个script标签\n\n合并多个js文件来减少HTTP请求的次数,减少三次握手的次数和多余的HTTP头传输,降低响应时间提高用户体验。\n\n#### 4. 去除重复的脚本\n\n#### 5. 减少对dom的操作\n\n尽量减少回流（reflow）和重绘（repaint）\n\n#### 6. 使用无阻塞加载js的方法\n\n- 使用script标签的defer和async属性\n- 使用动态创建的script标签来加载执行js代码\n- 使用XHR对象加载js代码并注入页面\n\n#### 7. 压缩js\n\n- 保证每句话的结尾用\";\"\n- 去掉注释、空格\n- if else用{}包好\n- 变量命名的优化\n\n### 六. 图片的相关性能优化（4条）\n\n#### 1. 压缩图片\n\n#### 2. 使用css sprite技术\n\n将多个小图标放在一张图片上，减少http请求，将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置\n\n**优点：**\n\n- 减少网页的http请求\n- 减少图片的字节：3张图片合并成1张图片的字节总是小于这3张图片的字节总和\n- 不需要对每一个小元素进行命名\n\n#### 3. iconfont矢量图标库\n\nicon图片过多的情况下，考虑使用iconfont技术\n\n#### 4. 不要用HTML缩放图片\n\n\n    多个CSS样式表是不会同时加载的，但是所有的样式表都加载完了之后，再一起解析，加载css不会阻塞页面。\n    \n    多个js也是不会同时加载的，如果没有设定一些特殊的属性的情形下，一般是加载完了直接执行。\n    \n    多个图片是可以同时加载的，加载图片也不会阻塞页面\n\n### 七. 移动端（2条）\n\n#### 1. 保证所有组件都小于25k\n\n#### 2. 把组件打包到一个复合文档里\n    \n## 编写高效的js\n\n上面的几点都不是在写代码的过程中的优化\n\n#### 1. 管理作用域 ———— 使用局部变量，尽量少使用全局变量\n\n局部变量是js中读写最快的标识符\n\n因为局部变量一般都在作用域链的活动对象中，在作用域链的顶部。\n\n标识符在作用域链中的位置越靠上，存取的速度就越快。\n\n例子：\n\n```\n//不好的写法\nfunction createChildFor(id) {\n\tvar element = document.getElementById('id'),\n\tnewElement = document.createElement('div');\n\n\telement.appendChild(newElement);\n}\n\n//好的写法\n//使用局部变量缓存全局变量document\nfunction createChildFor(id) {\n\tvar doc = document,\n\telement = doc.getElementById('id'),\n\tnewElement = doc.createElement('div');\n\n\telement.appendChild(newElement);\n}\n```\n\n#### 2. 存取读取数据的方式 ———— 将频繁需要读取的值存储在局部变量中\n\n举个栗子：\n\n```\n//不好的写法\nfunction process(data) {\n\tif(data.length > 0) {\n\t\tfor(var i = 0; i < data.length; i++) {\n\t\t\t...\n\t\t}\n\t}\n}\n\n//好的写法\nfunction process(data) {\n\t\n\t//将数组的长度存到一个局部变量中\n\tvar len = data.length;\n\tif(len > 0) {\n\t\tfor(var i = 0; i < len; i++) {\n\t\t\t...\n\t\t}\n\t}\n}\n```\n\n#### 3. if语句和switch语句\n\n使用if语句的情况：2个之内的离散值需要判断；有区间范围\n\n使用switch语句的情况：10个离散值需要判断\n\n使用数组查询？？？？\n\n#### 4. 快速循环\n\nfor / while / do ... while\n\n用局部变量缓存数组的长度\n\n将循环递减到0，而不是增加到总长度\n\n#### 5. 使用定时器\n\n使用setTimeout进行数组分块处理\n\n\n**使用setTimeout进行函数节流**\n\nhttp://panpanfish.com/2016/05/16/2016-05-16-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/\n\n#### 6. 减少对dom的操作\n\n使用DocumentFragment优化多次append\n\n使用一次innerHTML赋值代替构建dom元素\n\n#### 7. 减少重绘和回流\n\n利用className代替style\n\n为动画的元素使之脱离文档流\n\n#### 8. 使用事件代理\n\n#### 9. 尽量少使用eval函数\n","slug":"2016-05-08-前端性能优化的经验","published":1,"updated":"2016-09-13T03:19:24.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfm0052d5u85efh5ic1","content":"<h2 id=\"主要分为以下7个方面进行优化\"><a href=\"#主要分为以下7个方面进行优化\" class=\"headerlink\" title=\"主要分为以下7个方面进行优化\"></a>主要分为以下7个方面进行优化</h2><p>雅虎35条：<br><a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"external\">https://developer.yahoo.com/performance/rules.html</a></p>\n<ul>\n<li>内容</li>\n<li>服务端</li>\n<li>cookie</li>\n<li>CSS</li>\n<li>JavaScript</li>\n<li>Images</li>\n<li>Mobile</li>\n</ul>\n<h3 id=\"一-网页内容（9条）\"><a href=\"#一-网页内容（9条）\" class=\"headerlink\" title=\"一. 网页内容（9条）\"></a>一. 网页内容（9条）</h3><h4 id=\"1-减少http请求的次数\"><a href=\"#1-减少http请求的次数\" class=\"headerlink\" title=\"1. 减少http请求的次数\"></a>1. 减少http请求的次数</h4><p>(1)捆绑文件，减少文件请求的次数</p>\n<ul>\n<li>将多个js文件捆绑成一个文件</li>\n<li>将多个CSS文件捆绑成一个文件</li>\n</ul>\n<p><strong>需要规划静态资源文件，把相对不变的合并在一起，把频繁变易的分隔开。</strong></p>\n<p>(2) CSS Sprites:将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置</p>\n<p><strong>CSS Sprites优点：</strong>减少http请求，减轻服务器压力</p>\n<p><strong>CSS Sprites缺点：</strong>只能将background-image图片合成一张；需要对图片计算坐标和精准的定位。</p>\n<p>使用CSS3的一些效果代替图片。</p>\n<h4 id=\"2-缓存Ajax返回的数据\"><a href=\"#2-缓存Ajax返回的数据\" class=\"headerlink\" title=\"2. 缓存Ajax返回的数据\"></a>2. 缓存Ajax返回的数据</h4><p><strong>（1）浏览器缓存：使用Expire和Cache-Control</strong></p>\n<p>Expire和Cache-Control的介绍见这里：<a href=\"http://www.path8.net/tn/archives/2745\" target=\"_blank\" rel=\"external\">http://www.path8.net/tn/archives/2745</a></p>\n<p>这是设置浏览器缓存用的。注意，如果你设置了较长时间的缓存，那么每次修改组件内容时，也需要一并修改组件名字，否则浏览器不会重新发起请求。这就是为什么我们看到的许多js和css文件都带着hash戳或者时间戳。</p>\n<p><strong>（2）304协同缓存：配置ETag</strong></p>\n<p>后端可以在响应报文中添加Etag这一项，那么当浏览器下次请求同样的资源时，会携带If-None-Match条目。假如Etag没有发生变化，服务器可以返回304 Not Modified状态码，无须重新下载资源。</p>\n<p>Etag指的是版本标识符，由服务端配置。</p>\n<p>例如：</p>\n<pre><code>响应报文：\n\n  HTTP/1.1 200 OK   \n  Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n  ETag: &quot;10c24bc-4ab-457e1c1f&quot;   \n  Content-Length: 12195\n\n下一次的请求报文 ：\n\n  GET /i/yahoo.gif HTTP/1.1   \n  Host: us.yimg.com   \n  If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n  If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;  \n\n再次响应的报文：\n\n  HTTP/1.1 304 Not Modified\n</code></pre><p>这件事一般交由你用的服务器（比如Nginx）去做</p>\n<h4 id=\"3-减少DOM元素的数量\"><a href=\"#3-减少DOM元素的数量\" class=\"headerlink\" title=\"3. 减少DOM元素的数量\"></a>3. 减少DOM元素的数量</h4><p>过多的DOM元素会拖慢js执行的速度</p>\n<h4 id=\"4-避免404\"><a href=\"#4-避免404\" class=\"headerlink\" title=\"4. 避免404\"></a>4. 避免404</h4><h4 id=\"5-预加载组件\"><a href=\"#5-预加载组件\" class=\"headerlink\" title=\"5. 预加载组件\"></a>5. 预加载组件</h4><h4 id=\"6-延迟加载组件\"><a href=\"#6-延迟加载组件\" class=\"headerlink\" title=\"6. 延迟加载组件\"></a>6. 延迟加载组件</h4><p>5，6都是为了拆分初始化负载</p>\n<h4 id=\"7-减少DNS查找\"><a href=\"#7-减少DNS查找\" class=\"headerlink\" title=\"7. 减少DNS查找\"></a>7. 减少DNS查找</h4><h4 id=\"8-跨域分离组件\"><a href=\"#8-跨域分离组件\" class=\"headerlink\" title=\"8. 跨域分离组件\"></a>8. 跨域分离组件</h4><h4 id=\"9-尽量少用iframe\"><a href=\"#9-尽量少用iframe\" class=\"headerlink\" title=\"9. 尽量少用iframe\"></a>9. 尽量少用iframe</h4><h3 id=\"二-服务器（7条）\"><a href=\"#二-服务器（7条）\" class=\"headerlink\" title=\"二. 服务器（7条）\"></a>二. 服务器（7条）</h3><h4 id=\"1-使用CDN（Content-Delivery-Network）内容分发网络（加速静态资源的访问）\"><a href=\"#1-使用CDN（Content-Delivery-Network）内容分发网络（加速静态资源的访问）\" class=\"headerlink\" title=\"1. 使用CDN（Content Delivery Network）内容分发网络（加速静态资源的访问）\"></a>1. 使用CDN（Content Delivery Network）内容分发网络（加速静态资源的访问）</h4><p>一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。</p>\n<p>一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。</p>\n<h4 id=\"2-尽量使用GET请求\"><a href=\"#2-尽量使用GET请求\" class=\"headerlink\" title=\"2. 尽量使用GET请求\"></a>2. 尽量使用GET请求</h4><p>GET方法耗时较短</p>\n<p>浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。</p>\n<h4 id=\"3-服务器启用Gzip压缩\"><a href=\"#3-服务器启用Gzip压缩\" class=\"headerlink\" title=\"3. 服务器启用Gzip压缩\"></a>3. 服务器启用Gzip压缩</h4><p>在发送的请求中添加：</p>\n<pre><code>GET /index.html HTTP/1.1\nAccept-Encoding: gzip\n</code></pre><p>服务器接收到这个请求后，就会返回压缩后的数据</p>\n<p>你可以gzip一切，除了图片和pdf，因为这些文件一般都是压缩过了的，使用gzip甚至可能会增大文件大小。</p>\n<h4 id=\"4-避免图片src的属性为空\"><a href=\"#4-避免图片src的属性为空\" class=\"headerlink\" title=\"4. 避免图片src的属性为空\"></a>4. 避免图片src的属性为空</h4><h4 id=\"5-尽早清空缓存区\"><a href=\"#5-尽早清空缓存区\" class=\"headerlink\" title=\"5. 尽早清空缓存区\"></a>5. 尽早清空缓存区</h4><h4 id=\"6-配置Etag\"><a href=\"#6-配置Etag\" class=\"headerlink\" title=\"6. 配置Etag\"></a>6. 配置Etag</h4><h4 id=\"7-在请求头中添加Expires或者Cache-Control\"><a href=\"#7-在请求头中添加Expires或者Cache-Control\" class=\"headerlink\" title=\"7. 在请求头中添加Expires或者Cache-Control\"></a>7. 在请求头中添加Expires或者Cache-Control</h4><p>6、7其实就是一中的缓存ajax返回的数据</p>\n<h3 id=\"三-Cookie（2条）\"><a href=\"#三-Cookie（2条）\" class=\"headerlink\" title=\"三. Cookie（2条）\"></a>三. Cookie（2条）</h3><h4 id=\"1-减小Cookie的大小\"><a href=\"#1-减小Cookie的大小\" class=\"headerlink\" title=\"1. 减小Cookie的大小\"></a>1. 减小Cookie的大小</h4><p>由于Cookie是用来标识服务器的特有信息，一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递</p>\n<h4 id=\"2-把组件放在不含cookie的域下\"><a href=\"#2-把组件放在不含cookie的域下\" class=\"headerlink\" title=\"2. 把组件放在不含cookie的域下\"></a>2. 把组件放在不含cookie的域下</h4><h3 id=\"四-CSS（6条）\"><a href=\"#四-CSS（6条）\" class=\"headerlink\" title=\"四. CSS（6条）\"></a>四. CSS（6条）</h3><h4 id=\"1-将CSS样式表置顶\"><a href=\"#1-将CSS样式表置顶\" class=\"headerlink\" title=\"1. 将CSS样式表置顶\"></a>1. 将CSS样式表置顶</h4><p>将css文件放在head中</p>\n<p>原因：浏览器解析代码是从上到下的。如果把css放在底部，当网速慢时，html代码加载完成后而css没加载完的话，会导致页面没有样式而难以阅读，所以先加载css样式能让页面正常显示。</p>\n<p>加载和解析css不会阻塞页面。</p>\n<h4 id=\"2-合并多个css文件\"><a href=\"#2-合并多个css文件\" class=\"headerlink\" title=\"2. 合并多个css文件\"></a>2. 合并多个css文件</h4><p>减少http请求次数</p>\n<h4 id=\"3-压缩css文件\"><a href=\"#3-压缩css文件\" class=\"headerlink\" title=\"3. 压缩css文件\"></a>3. 压缩css文件</h4><ul>\n<li>去掉不必要的空格、回车</li>\n<li>给一些样式添加前缀（解决兼容性）</li>\n<li>抽取出共同的样式？</li>\n</ul>\n<h4 id=\"4-把css放到外面\"><a href=\"#4-把css放到外面\" class=\"headerlink\" title=\"4. 把css放到外面\"></a>4. 把css放到外面</h4><h4 id=\"5-避免使用滤镜\"><a href=\"#5-避免使用滤镜\" class=\"headerlink\" title=\"5. 避免使用滤镜\"></a>5. 避免使用滤镜</h4><h4 id=\"6-避免使用-import\"><a href=\"#6-避免使用-import\" class=\"headerlink\" title=\"6. 避免使用@import\"></a>6. 避免使用@import</h4><h3 id=\"五-JavaScript的相关性能优化（6条）\"><a href=\"#五-JavaScript的相关性能优化（6条）\" class=\"headerlink\" title=\"五. JavaScript的相关性能优化（6条）\"></a>五. JavaScript的相关性能优化（6条）</h3><h4 id=\"1-将脚本置底\"><a href=\"#1-将脚本置底\" class=\"headerlink\" title=\"1. 将脚本置底\"></a>1. 将脚本置底</h4><p><strong>JavaScript代码的加载和执行</strong>会阻塞页面的解析渲染以及其他资源的下载。</p>\n<p>如果<strong>放在head里面</strong>，当加载多个js时，就会阻塞页面渲染而出现白屏，用户体验会很差。</p>\n<p>所以将脚本放在之前，等其他部分加载好了，再加载脚本。</p>\n<h4 id=\"2-把脚本放在外面\"><a href=\"#2-把脚本放在外面\" class=\"headerlink\" title=\"2. 把脚本放在外面\"></a>2. 把脚本放在外面</h4><h4 id=\"3-合并多个script标签\"><a href=\"#3-合并多个script标签\" class=\"headerlink\" title=\"3. 合并多个script标签\"></a>3. 合并多个script标签</h4><p>合并多个js文件来减少HTTP请求的次数,减少三次握手的次数和多余的HTTP头传输,降低响应时间提高用户体验。</p>\n<h4 id=\"4-去除重复的脚本\"><a href=\"#4-去除重复的脚本\" class=\"headerlink\" title=\"4. 去除重复的脚本\"></a>4. 去除重复的脚本</h4><h4 id=\"5-减少对dom的操作\"><a href=\"#5-减少对dom的操作\" class=\"headerlink\" title=\"5. 减少对dom的操作\"></a>5. 减少对dom的操作</h4><p>尽量减少回流（reflow）和重绘（repaint）</p>\n<h4 id=\"6-使用无阻塞加载js的方法\"><a href=\"#6-使用无阻塞加载js的方法\" class=\"headerlink\" title=\"6. 使用无阻塞加载js的方法\"></a>6. 使用无阻塞加载js的方法</h4><ul>\n<li>使用script标签的defer和async属性</li>\n<li>使用动态创建的script标签来加载执行js代码</li>\n<li>使用XHR对象加载js代码并注入页面</li>\n</ul>\n<h4 id=\"7-压缩js\"><a href=\"#7-压缩js\" class=\"headerlink\" title=\"7. 压缩js\"></a>7. 压缩js</h4><ul>\n<li>保证每句话的结尾用”;”</li>\n<li>去掉注释、空格</li>\n<li>if else用{}包好</li>\n<li>变量命名的优化</li>\n</ul>\n<h3 id=\"六-图片的相关性能优化（4条）\"><a href=\"#六-图片的相关性能优化（4条）\" class=\"headerlink\" title=\"六. 图片的相关性能优化（4条）\"></a>六. 图片的相关性能优化（4条）</h3><h4 id=\"1-压缩图片\"><a href=\"#1-压缩图片\" class=\"headerlink\" title=\"1. 压缩图片\"></a>1. 压缩图片</h4><h4 id=\"2-使用css-sprite技术\"><a href=\"#2-使用css-sprite技术\" class=\"headerlink\" title=\"2. 使用css sprite技术\"></a>2. 使用css sprite技术</h4><p>将多个小图标放在一张图片上，减少http请求，将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>减少网页的http请求</li>\n<li>减少图片的字节：3张图片合并成1张图片的字节总是小于这3张图片的字节总和</li>\n<li>不需要对每一个小元素进行命名</li>\n</ul>\n<h4 id=\"3-iconfont矢量图标库\"><a href=\"#3-iconfont矢量图标库\" class=\"headerlink\" title=\"3. iconfont矢量图标库\"></a>3. iconfont矢量图标库</h4><p>icon图片过多的情况下，考虑使用iconfont技术</p>\n<h4 id=\"4-不要用HTML缩放图片\"><a href=\"#4-不要用HTML缩放图片\" class=\"headerlink\" title=\"4. 不要用HTML缩放图片\"></a>4. 不要用HTML缩放图片</h4><pre><code>多个CSS样式表是不会同时加载的，但是所有的样式表都加载完了之后，再一起解析，加载css不会阻塞页面。\n\n多个js也是不会同时加载的，如果没有设定一些特殊的属性的情形下，一般是加载完了直接执行。\n\n多个图片是可以同时加载的，加载图片也不会阻塞页面\n</code></pre><h3 id=\"七-移动端（2条）\"><a href=\"#七-移动端（2条）\" class=\"headerlink\" title=\"七. 移动端（2条）\"></a>七. 移动端（2条）</h3><h4 id=\"1-保证所有组件都小于25k\"><a href=\"#1-保证所有组件都小于25k\" class=\"headerlink\" title=\"1. 保证所有组件都小于25k\"></a>1. 保证所有组件都小于25k</h4><h4 id=\"2-把组件打包到一个复合文档里\"><a href=\"#2-把组件打包到一个复合文档里\" class=\"headerlink\" title=\"2. 把组件打包到一个复合文档里\"></a>2. 把组件打包到一个复合文档里</h4><h2 id=\"编写高效的js\"><a href=\"#编写高效的js\" class=\"headerlink\" title=\"编写高效的js\"></a>编写高效的js</h2><p>上面的几点都不是在写代码的过程中的优化</p>\n<h4 id=\"1-管理作用域-————-使用局部变量，尽量少使用全局变量\"><a href=\"#1-管理作用域-————-使用局部变量，尽量少使用全局变量\" class=\"headerlink\" title=\"1. 管理作用域 ———— 使用局部变量，尽量少使用全局变量\"></a>1. 管理作用域 ———— 使用局部变量，尽量少使用全局变量</h4><p>局部变量是js中读写最快的标识符</p>\n<p>因为局部变量一般都在作用域链的活动对象中，在作用域链的顶部。</p>\n<p>标识符在作用域链中的位置越靠上，存取的速度就越快。</p>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不好的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createChildFor</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>),</span><br><span class=\"line\">\tnewElement = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\telement.appendChild(newElement);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//好的写法</span></span><br><span class=\"line\"><span class=\"comment\">//使用局部变量缓存全局变量document</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createChildFor</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> doc = <span class=\"built_in\">document</span>,</span><br><span class=\"line\">\telement = doc.getElementById(<span class=\"string\">'id'</span>),</span><br><span class=\"line\">\tnewElement = doc.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\telement.appendChild(newElement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-存取读取数据的方式-————-将频繁需要读取的值存储在局部变量中\"><a href=\"#2-存取读取数据的方式-————-将频繁需要读取的值存储在局部变量中\" class=\"headerlink\" title=\"2. 存取读取数据的方式 ———— 将频繁需要读取的值存储在局部变量中\"></a>2. 存取读取数据的方式 ———— 将频繁需要读取的值存储在局部变量中</h4><p>举个栗子：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不好的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(data.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//好的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的长度存到一个局部变量中</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> len = data.length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-if语句和switch语句\"><a href=\"#3-if语句和switch语句\" class=\"headerlink\" title=\"3. if语句和switch语句\"></a>3. if语句和switch语句</h4><p>使用if语句的情况：2个之内的离散值需要判断；有区间范围</p>\n<p>使用switch语句的情况：10个离散值需要判断</p>\n<p>使用数组查询？？？？</p>\n<h4 id=\"4-快速循环\"><a href=\"#4-快速循环\" class=\"headerlink\" title=\"4. 快速循环\"></a>4. 快速循环</h4><p>for / while / do … while</p>\n<p>用局部变量缓存数组的长度</p>\n<p>将循环递减到0，而不是增加到总长度</p>\n<h4 id=\"5-使用定时器\"><a href=\"#5-使用定时器\" class=\"headerlink\" title=\"5. 使用定时器\"></a>5. 使用定时器</h4><p>使用setTimeout进行数组分块处理</p>\n<p><strong>使用setTimeout进行函数节流</strong></p>\n<p><a href=\"http://panpanfish.com/2016/05/16/2016-05-16-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/\">http://panpanfish.com/2016/05/16/2016-05-16-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</a></p>\n<h4 id=\"6-减少对dom的操作\"><a href=\"#6-减少对dom的操作\" class=\"headerlink\" title=\"6. 减少对dom的操作\"></a>6. 减少对dom的操作</h4><p>使用DocumentFragment优化多次append</p>\n<p>使用一次innerHTML赋值代替构建dom元素</p>\n<h4 id=\"7-减少重绘和回流\"><a href=\"#7-减少重绘和回流\" class=\"headerlink\" title=\"7. 减少重绘和回流\"></a>7. 减少重绘和回流</h4><p>利用className代替style</p>\n<p>为动画的元素使之脱离文档流</p>\n<h4 id=\"8-使用事件代理\"><a href=\"#8-使用事件代理\" class=\"headerlink\" title=\"8. 使用事件代理\"></a>8. 使用事件代理</h4><h4 id=\"9-尽量少使用eval函数\"><a href=\"#9-尽量少使用eval函数\" class=\"headerlink\" title=\"9. 尽量少使用eval函数\"></a>9. 尽量少使用eval函数</h4>","excerpt":"","more":"<h2 id=\"主要分为以下7个方面进行优化\"><a href=\"#主要分为以下7个方面进行优化\" class=\"headerlink\" title=\"主要分为以下7个方面进行优化\"></a>主要分为以下7个方面进行优化</h2><p>雅虎35条：<br><a href=\"https://developer.yahoo.com/performance/rules.html\">https://developer.yahoo.com/performance/rules.html</a></p>\n<ul>\n<li>内容</li>\n<li>服务端</li>\n<li>cookie</li>\n<li>CSS</li>\n<li>JavaScript</li>\n<li>Images</li>\n<li>Mobile</li>\n</ul>\n<h3 id=\"一-网页内容（9条）\"><a href=\"#一-网页内容（9条）\" class=\"headerlink\" title=\"一. 网页内容（9条）\"></a>一. 网页内容（9条）</h3><h4 id=\"1-减少http请求的次数\"><a href=\"#1-减少http请求的次数\" class=\"headerlink\" title=\"1. 减少http请求的次数\"></a>1. 减少http请求的次数</h4><p>(1)捆绑文件，减少文件请求的次数</p>\n<ul>\n<li>将多个js文件捆绑成一个文件</li>\n<li>将多个CSS文件捆绑成一个文件</li>\n</ul>\n<p><strong>需要规划静态资源文件，把相对不变的合并在一起，把频繁变易的分隔开。</strong></p>\n<p>(2) CSS Sprites:将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置</p>\n<p><strong>CSS Sprites优点：</strong>减少http请求，减轻服务器压力</p>\n<p><strong>CSS Sprites缺点：</strong>只能将background-image图片合成一张；需要对图片计算坐标和精准的定位。</p>\n<p>使用CSS3的一些效果代替图片。</p>\n<h4 id=\"2-缓存Ajax返回的数据\"><a href=\"#2-缓存Ajax返回的数据\" class=\"headerlink\" title=\"2. 缓存Ajax返回的数据\"></a>2. 缓存Ajax返回的数据</h4><p><strong>（1）浏览器缓存：使用Expire和Cache-Control</strong></p>\n<p>Expire和Cache-Control的介绍见这里：<a href=\"http://www.path8.net/tn/archives/2745\">http://www.path8.net/tn/archives/2745</a></p>\n<p>这是设置浏览器缓存用的。注意，如果你设置了较长时间的缓存，那么每次修改组件内容时，也需要一并修改组件名字，否则浏览器不会重新发起请求。这就是为什么我们看到的许多js和css文件都带着hash戳或者时间戳。</p>\n<p><strong>（2）304协同缓存：配置ETag</strong></p>\n<p>后端可以在响应报文中添加Etag这一项，那么当浏览器下次请求同样的资源时，会携带If-None-Match条目。假如Etag没有发生变化，服务器可以返回304 Not Modified状态码，无须重新下载资源。</p>\n<p>Etag指的是版本标识符，由服务端配置。</p>\n<p>例如：</p>\n<pre><code>响应报文：\n\n  HTTP/1.1 200 OK   \n  Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT   \n  ETag: &quot;10c24bc-4ab-457e1c1f&quot;   \n  Content-Length: 12195\n\n下一次的请求报文 ：\n\n  GET /i/yahoo.gif HTTP/1.1   \n  Host: us.yimg.com   \n  If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT   \n  If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;  \n\n再次响应的报文：\n\n  HTTP/1.1 304 Not Modified\n</code></pre><p>这件事一般交由你用的服务器（比如Nginx）去做</p>\n<h4 id=\"3-减少DOM元素的数量\"><a href=\"#3-减少DOM元素的数量\" class=\"headerlink\" title=\"3. 减少DOM元素的数量\"></a>3. 减少DOM元素的数量</h4><p>过多的DOM元素会拖慢js执行的速度</p>\n<h4 id=\"4-避免404\"><a href=\"#4-避免404\" class=\"headerlink\" title=\"4. 避免404\"></a>4. 避免404</h4><h4 id=\"5-预加载组件\"><a href=\"#5-预加载组件\" class=\"headerlink\" title=\"5. 预加载组件\"></a>5. 预加载组件</h4><h4 id=\"6-延迟加载组件\"><a href=\"#6-延迟加载组件\" class=\"headerlink\" title=\"6. 延迟加载组件\"></a>6. 延迟加载组件</h4><p>5，6都是为了拆分初始化负载</p>\n<h4 id=\"7-减少DNS查找\"><a href=\"#7-减少DNS查找\" class=\"headerlink\" title=\"7. 减少DNS查找\"></a>7. 减少DNS查找</h4><h4 id=\"8-跨域分离组件\"><a href=\"#8-跨域分离组件\" class=\"headerlink\" title=\"8. 跨域分离组件\"></a>8. 跨域分离组件</h4><h4 id=\"9-尽量少用iframe\"><a href=\"#9-尽量少用iframe\" class=\"headerlink\" title=\"9. 尽量少用iframe\"></a>9. 尽量少用iframe</h4><h3 id=\"二-服务器（7条）\"><a href=\"#二-服务器（7条）\" class=\"headerlink\" title=\"二. 服务器（7条）\"></a>二. 服务器（7条）</h3><h4 id=\"1-使用CDN（Content-Delivery-Network）内容分发网络（加速静态资源的访问）\"><a href=\"#1-使用CDN（Content-Delivery-Network）内容分发网络（加速静态资源的访问）\" class=\"headerlink\" title=\"1. 使用CDN（Content Delivery Network）内容分发网络（加速静态资源的访问）\"></a>1. 使用CDN（Content Delivery Network）内容分发网络（加速静态资源的访问）</h4><p>一般的大型网站，为了优化网络资源，通常会将页面和静态资源分集群部署。</p>\n<p>一般会把静态资源部署到CDN上，使用户就近取得所需要的内容，解决Internet网络拥挤状况，提高用户访问网络的响应速度。</p>\n<h4 id=\"2-尽量使用GET请求\"><a href=\"#2-尽量使用GET请求\" class=\"headerlink\" title=\"2. 尽量使用GET请求\"></a>2. 尽量使用GET请求</h4><p>GET方法耗时较短</p>\n<p>浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。</p>\n<h4 id=\"3-服务器启用Gzip压缩\"><a href=\"#3-服务器启用Gzip压缩\" class=\"headerlink\" title=\"3. 服务器启用Gzip压缩\"></a>3. 服务器启用Gzip压缩</h4><p>在发送的请求中添加：</p>\n<pre><code>GET /index.html HTTP/1.1\nAccept-Encoding: gzip\n</code></pre><p>服务器接收到这个请求后，就会返回压缩后的数据</p>\n<p>你可以gzip一切，除了图片和pdf，因为这些文件一般都是压缩过了的，使用gzip甚至可能会增大文件大小。</p>\n<h4 id=\"4-避免图片src的属性为空\"><a href=\"#4-避免图片src的属性为空\" class=\"headerlink\" title=\"4. 避免图片src的属性为空\"></a>4. 避免图片src的属性为空</h4><h4 id=\"5-尽早清空缓存区\"><a href=\"#5-尽早清空缓存区\" class=\"headerlink\" title=\"5. 尽早清空缓存区\"></a>5. 尽早清空缓存区</h4><h4 id=\"6-配置Etag\"><a href=\"#6-配置Etag\" class=\"headerlink\" title=\"6. 配置Etag\"></a>6. 配置Etag</h4><h4 id=\"7-在请求头中添加Expires或者Cache-Control\"><a href=\"#7-在请求头中添加Expires或者Cache-Control\" class=\"headerlink\" title=\"7. 在请求头中添加Expires或者Cache-Control\"></a>7. 在请求头中添加Expires或者Cache-Control</h4><p>6、7其实就是一中的缓存ajax返回的数据</p>\n<h3 id=\"三-Cookie（2条）\"><a href=\"#三-Cookie（2条）\" class=\"headerlink\" title=\"三. Cookie（2条）\"></a>三. Cookie（2条）</h3><h4 id=\"1-减小Cookie的大小\"><a href=\"#1-减小Cookie的大小\" class=\"headerlink\" title=\"1. 减小Cookie的大小\"></a>1. 减小Cookie的大小</h4><p>由于Cookie是用来标识服务器的特有信息，一般通过http请求中的头部一起发送到服务器端。在客户端和服务器端之间来回传递</p>\n<h4 id=\"2-把组件放在不含cookie的域下\"><a href=\"#2-把组件放在不含cookie的域下\" class=\"headerlink\" title=\"2. 把组件放在不含cookie的域下\"></a>2. 把组件放在不含cookie的域下</h4><h3 id=\"四-CSS（6条）\"><a href=\"#四-CSS（6条）\" class=\"headerlink\" title=\"四. CSS（6条）\"></a>四. CSS（6条）</h3><h4 id=\"1-将CSS样式表置顶\"><a href=\"#1-将CSS样式表置顶\" class=\"headerlink\" title=\"1. 将CSS样式表置顶\"></a>1. 将CSS样式表置顶</h4><p>将css文件放在head中</p>\n<p>原因：浏览器解析代码是从上到下的。如果把css放在底部，当网速慢时，html代码加载完成后而css没加载完的话，会导致页面没有样式而难以阅读，所以先加载css样式能让页面正常显示。</p>\n<p>加载和解析css不会阻塞页面。</p>\n<h4 id=\"2-合并多个css文件\"><a href=\"#2-合并多个css文件\" class=\"headerlink\" title=\"2. 合并多个css文件\"></a>2. 合并多个css文件</h4><p>减少http请求次数</p>\n<h4 id=\"3-压缩css文件\"><a href=\"#3-压缩css文件\" class=\"headerlink\" title=\"3. 压缩css文件\"></a>3. 压缩css文件</h4><ul>\n<li>去掉不必要的空格、回车</li>\n<li>给一些样式添加前缀（解决兼容性）</li>\n<li>抽取出共同的样式？</li>\n</ul>\n<h4 id=\"4-把css放到外面\"><a href=\"#4-把css放到外面\" class=\"headerlink\" title=\"4. 把css放到外面\"></a>4. 把css放到外面</h4><h4 id=\"5-避免使用滤镜\"><a href=\"#5-避免使用滤镜\" class=\"headerlink\" title=\"5. 避免使用滤镜\"></a>5. 避免使用滤镜</h4><h4 id=\"6-避免使用-import\"><a href=\"#6-避免使用-import\" class=\"headerlink\" title=\"6. 避免使用@import\"></a>6. 避免使用@import</h4><h3 id=\"五-JavaScript的相关性能优化（6条）\"><a href=\"#五-JavaScript的相关性能优化（6条）\" class=\"headerlink\" title=\"五. JavaScript的相关性能优化（6条）\"></a>五. JavaScript的相关性能优化（6条）</h3><h4 id=\"1-将脚本置底\"><a href=\"#1-将脚本置底\" class=\"headerlink\" title=\"1. 将脚本置底\"></a>1. 将脚本置底</h4><p><strong>JavaScript代码的加载和执行</strong>会阻塞页面的解析渲染以及其他资源的下载。</p>\n<p>如果<strong>放在head里面</strong>，当加载多个js时，就会阻塞页面渲染而出现白屏，用户体验会很差。</p>\n<p>所以将脚本放在</body>之前，等其他部分加载好了，再加载脚本。</p>\n<h4 id=\"2-把脚本放在外面\"><a href=\"#2-把脚本放在外面\" class=\"headerlink\" title=\"2. 把脚本放在外面\"></a>2. 把脚本放在外面</h4><h4 id=\"3-合并多个script标签\"><a href=\"#3-合并多个script标签\" class=\"headerlink\" title=\"3. 合并多个script标签\"></a>3. 合并多个script标签</h4><p>合并多个js文件来减少HTTP请求的次数,减少三次握手的次数和多余的HTTP头传输,降低响应时间提高用户体验。</p>\n<h4 id=\"4-去除重复的脚本\"><a href=\"#4-去除重复的脚本\" class=\"headerlink\" title=\"4. 去除重复的脚本\"></a>4. 去除重复的脚本</h4><h4 id=\"5-减少对dom的操作\"><a href=\"#5-减少对dom的操作\" class=\"headerlink\" title=\"5. 减少对dom的操作\"></a>5. 减少对dom的操作</h4><p>尽量减少回流（reflow）和重绘（repaint）</p>\n<h4 id=\"6-使用无阻塞加载js的方法\"><a href=\"#6-使用无阻塞加载js的方法\" class=\"headerlink\" title=\"6. 使用无阻塞加载js的方法\"></a>6. 使用无阻塞加载js的方法</h4><ul>\n<li>使用script标签的defer和async属性</li>\n<li>使用动态创建的script标签来加载执行js代码</li>\n<li>使用XHR对象加载js代码并注入页面</li>\n</ul>\n<h4 id=\"7-压缩js\"><a href=\"#7-压缩js\" class=\"headerlink\" title=\"7. 压缩js\"></a>7. 压缩js</h4><ul>\n<li>保证每句话的结尾用”;”</li>\n<li>去掉注释、空格</li>\n<li>if else用{}包好</li>\n<li>变量命名的优化</li>\n</ul>\n<h3 id=\"六-图片的相关性能优化（4条）\"><a href=\"#六-图片的相关性能优化（4条）\" class=\"headerlink\" title=\"六. 图片的相关性能优化（4条）\"></a>六. 图片的相关性能优化（4条）</h3><h4 id=\"1-压缩图片\"><a href=\"#1-压缩图片\" class=\"headerlink\" title=\"1. 压缩图片\"></a>1. 压缩图片</h4><h4 id=\"2-使用css-sprite技术\"><a href=\"#2-使用css-sprite技术\" class=\"headerlink\" title=\"2. 使用css sprite技术\"></a>2. 使用css sprite技术</h4><p>将多个小图标放在一张图片上，减少http请求，将多幅图片拼成一副图片，然后通过控制在什么地方具体显示这整张图片的什么位置</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>减少网页的http请求</li>\n<li>减少图片的字节：3张图片合并成1张图片的字节总是小于这3张图片的字节总和</li>\n<li>不需要对每一个小元素进行命名</li>\n</ul>\n<h4 id=\"3-iconfont矢量图标库\"><a href=\"#3-iconfont矢量图标库\" class=\"headerlink\" title=\"3. iconfont矢量图标库\"></a>3. iconfont矢量图标库</h4><p>icon图片过多的情况下，考虑使用iconfont技术</p>\n<h4 id=\"4-不要用HTML缩放图片\"><a href=\"#4-不要用HTML缩放图片\" class=\"headerlink\" title=\"4. 不要用HTML缩放图片\"></a>4. 不要用HTML缩放图片</h4><pre><code>多个CSS样式表是不会同时加载的，但是所有的样式表都加载完了之后，再一起解析，加载css不会阻塞页面。\n\n多个js也是不会同时加载的，如果没有设定一些特殊的属性的情形下，一般是加载完了直接执行。\n\n多个图片是可以同时加载的，加载图片也不会阻塞页面\n</code></pre><h3 id=\"七-移动端（2条）\"><a href=\"#七-移动端（2条）\" class=\"headerlink\" title=\"七. 移动端（2条）\"></a>七. 移动端（2条）</h3><h4 id=\"1-保证所有组件都小于25k\"><a href=\"#1-保证所有组件都小于25k\" class=\"headerlink\" title=\"1. 保证所有组件都小于25k\"></a>1. 保证所有组件都小于25k</h4><h4 id=\"2-把组件打包到一个复合文档里\"><a href=\"#2-把组件打包到一个复合文档里\" class=\"headerlink\" title=\"2. 把组件打包到一个复合文档里\"></a>2. 把组件打包到一个复合文档里</h4><h2 id=\"编写高效的js\"><a href=\"#编写高效的js\" class=\"headerlink\" title=\"编写高效的js\"></a>编写高效的js</h2><p>上面的几点都不是在写代码的过程中的优化</p>\n<h4 id=\"1-管理作用域-————-使用局部变量，尽量少使用全局变量\"><a href=\"#1-管理作用域-————-使用局部变量，尽量少使用全局变量\" class=\"headerlink\" title=\"1. 管理作用域 ———— 使用局部变量，尽量少使用全局变量\"></a>1. 管理作用域 ———— 使用局部变量，尽量少使用全局变量</h4><p>局部变量是js中读写最快的标识符</p>\n<p>因为局部变量一般都在作用域链的活动对象中，在作用域链的顶部。</p>\n<p>标识符在作用域链中的位置越靠上，存取的速度就越快。</p>\n<p>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不好的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createChildFor</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>),</span><br><span class=\"line\">\tnewElement = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\telement.appendChild(newElement);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//好的写法</span></span><br><span class=\"line\"><span class=\"comment\">//使用局部变量缓存全局变量document</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createChildFor</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> doc = <span class=\"built_in\">document</span>,</span><br><span class=\"line\">\telement = doc.getElementById(<span class=\"string\">'id'</span>),</span><br><span class=\"line\">\tnewElement = doc.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\telement.appendChild(newElement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-存取读取数据的方式-————-将频繁需要读取的值存储在局部变量中\"><a href=\"#2-存取读取数据的方式-————-将频繁需要读取的值存储在局部变量中\" class=\"headerlink\" title=\"2. 存取读取数据的方式 ———— 将频繁需要读取的值存储在局部变量中\"></a>2. 存取读取数据的方式 ———— 将频繁需要读取的值存储在局部变量中</h4><p>举个栗子：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不好的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(data.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//好的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">process</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的长度存到一个局部变量中</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> len = data.length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-if语句和switch语句\"><a href=\"#3-if语句和switch语句\" class=\"headerlink\" title=\"3. if语句和switch语句\"></a>3. if语句和switch语句</h4><p>使用if语句的情况：2个之内的离散值需要判断；有区间范围</p>\n<p>使用switch语句的情况：10个离散值需要判断</p>\n<p>使用数组查询？？？？</p>\n<h4 id=\"4-快速循环\"><a href=\"#4-快速循环\" class=\"headerlink\" title=\"4. 快速循环\"></a>4. 快速循环</h4><p>for / while / do … while</p>\n<p>用局部变量缓存数组的长度</p>\n<p>将循环递减到0，而不是增加到总长度</p>\n<h4 id=\"5-使用定时器\"><a href=\"#5-使用定时器\" class=\"headerlink\" title=\"5. 使用定时器\"></a>5. 使用定时器</h4><p>使用setTimeout进行数组分块处理</p>\n<p><strong>使用setTimeout进行函数节流</strong></p>\n<p><a href=\"http://panpanfish.com/2016/05/16/2016-05-16-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/\">http://panpanfish.com/2016/05/16/2016-05-16-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</a></p>\n<h4 id=\"6-减少对dom的操作\"><a href=\"#6-减少对dom的操作\" class=\"headerlink\" title=\"6. 减少对dom的操作\"></a>6. 减少对dom的操作</h4><p>使用DocumentFragment优化多次append</p>\n<p>使用一次innerHTML赋值代替构建dom元素</p>\n<h4 id=\"7-减少重绘和回流\"><a href=\"#7-减少重绘和回流\" class=\"headerlink\" title=\"7. 减少重绘和回流\"></a>7. 减少重绘和回流</h4><p>利用className代替style</p>\n<p>为动画的元素使之脱离文档流</p>\n<h4 id=\"8-使用事件代理\"><a href=\"#8-使用事件代理\" class=\"headerlink\" title=\"8. 使用事件代理\"></a>8. 使用事件代理</h4><h4 id=\"9-尽量少使用eval函数\"><a href=\"#9-尽量少使用eval函数\" class=\"headerlink\" title=\"9. 尽量少使用eval函数\"></a>9. 尽量少使用eval函数</h4>"},{"layout":"post","title":"js中的变量和函数声明提升","date":"2016-05-07T16:00:00.000Z","description":null,"_content":"\nJavaScript 能够在**变量**和**函数**被声明之前使用它们。\n\n原因：js解析器将**当前作用域内**所有的**变量声明**和**函数声明**都会放到作用域的开始处，但是，只有<font color=\"red\">变量的声明被提前到作用域的开始处了，而赋值操作被保留在原处。</font>\n\n### 一. 定义函数的两种方式\n\n#### 1. 函数声明\n\n(1) 什么是函数声明\n\n  function myFunc(){ }\n\n  上面就是函数声明\n\n(2) 函数声明提升\n\n  函数声明提升————执行函数之前会读取函数声明\n\n  函数声明并不仅仅是函数名“被提前”了，整个函数的定义也“被提前”了\n\n    eg:    \n    myFunc();//执行函数   \n    function myFunc(){ };//函数声明\n\t由于函数申明提升特性，上面的代码不会报错\n\n#### 2. 函数表达式\n\nvar myFunc = function(){}\n\n创建一个函数，这里创建的函数是匿名的（function后面没有标识符），并把函数赋值给一个变量\n\n\teg:\t\n\tmyFunc();//会报错，这个时候，myFunc还不是一个函数\n\tvar myFunc = function(){};\n\n\t上面的代码等价于：\n\tvar myFunc;\n\tmyFuc();//会报错，这个时候，myFunc还不是一个函数\n\tmyFunc = function(){};\n\nvar myFunc = function f(){}\n\n创建一个函数，这里创建的函数是命名函数，并把函数赋值给一个变量，命名函数表达式的名字不会进入名字空间，也不会被提升\n\n\teg:\t\n\tmyFunc();//会报错，这个时候，myFunc还不是一个函数\n\tvar myFunc = function f(){};\n\tmyFunc();//不会报错\n\tf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效\n\n\t上面的代码等价于：\n\tvar myFunc;\n\tmyFuc();//会报错，这个时候，myFunc还不是一个函数\n\tmyFunc = function f(){};\n\tmyFunc();//不会报错\n\tf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效\t\n\n<font color=\"red\">这里和变量声明提前的规则一致：变量声明提前了，但是变量的赋值操作还留在原地。</font>\n\n### 二. 变量声明提升\n\n#### 1. 定义变量的方法\n\njs的变量是一种松散类型，可以用来保存任何类型的数据。\n\n    定义变量：\n    var myvar;//像这样，未经过初始化的变量会保存一个特殊的值：undefined\n\n**注意：**没有使用var声明的变量，都是全局变量。\n\n#### 2. 变量声明提升\n\n    var name = \"A\";    \n    (function () {\n    \talert(name);//undefined    \n    \tvar name = \"B\";    \n    \talert(name);//B       \n    })();\n\n\t上面的代码等价于：\n\tvar name = \"A\";    \n    (function () {\n\t\tvar name;//局部变量的声明被提升到作用域的最前面\n    \talert(name);//undefined    \n    \tname = \"B\";    \n    \talert(name);//B       \n    })();\n\n\t函数内部的name是一个局部变量\n\n**全局作用域中声明的变量、函数都是window对象的属性和方法。**\n\n\teg1:\n    var in_window = \"a\" in window; \n    console.log(in_window); //false\n\n\teg2:\n    var in_window = \"a\" in window; \n    console.log(in_window); //true\n    if(!(\"a\" in window)) \n    { var a = 1; }\n\n    上面的代码相当于：\n    var a,in_window;\n    in_window = \"a\" in window; \n    console.log(in_window); //true a是全局变量中声明的，所以a是window的属性\n    if(!(\"a\" in window)) \n    { var a = 1; }\n\n\teg3:\n\t if(!(\"a\" in window)) \n\t{ var a = 1; } \n\tconsole.log(a); //undefined \n\n\t上面的代码相当于：\n\tvar a;//if语句块内的申明的变量a，会自动提到上面去申明\n\tif(!(\"a\" in window)) //\"a\" in window为true\n\t{ a = 1; } //不会执行赋值语句\n\tconsole.log(a); //undefined\n\t\n\teg4:\n\tif(!(\"a\" in window)) //没有变量声明提升，所以!(\"a\" in window)为true\n\t{ a = 1 } //执行函数体内部的赋值语句\n\tconsole.log(a); //\n\n**总结：**\n\n- 所有变量的声明被提前到**作用域**顶部，赋值保留在原地\n- 函数声明整个“被提前”\n\n### 三. 函数声明和变量声明，谁的优先级更高\n\n- 对于同一个变量名，函数声明会覆盖变量声明\n\n\t\teg1:\n\t\tvar a;\n\t\tfunction a(){}\n\t\tconsole.log(a);//function a(){}\t\t\n\n\t\teg2:\n\t\tfunction a(){}\n\t\tvar a;\n\t\tconsole.log(a);//function a(){}\n\n\t\t上面两个例子均输出function a(){}，可见函数声明会覆盖变量声明\n\n\n- 如果在声明变量的同时对变量进行了初始化，那么对同一个变量名，声明变量同时初始化变量优先级高于函数声明\n\n\t\teg1:\n\t\tvar a=1;\n\t\tfunction a(){}\n\t\tconsole.log(a);//1\t\n\n\t\t上面的代码等价于：\n\t\tvar a;\n \t\tfunction a(){}\n\t\ta = 1;\n\t\tconsole.log(a)\t\n\n\t\teg2:\n\t\tfunction a(){}\n\t\tvar a=1;\n\t\tconsole.log(a);//1\n\n\t\t上面两个例子均输出1，可见声明变量同时初始化变量优先级高于函数声明\n\n多看几个例子：\n\n\t\teg1:\n\t\t(function(a){\n\t\t    console.log(a);\n\t\t    var a=10;\n\t\t    function a(){};\n\t\t})(100)\n\n    输出：function a(){}\n    解析：function(a){}里面的a只是一个形参，换成b,c,d...都行，所以没什么关联；变量和函数的声明同时被提升了，但是变量的赋值语句没有被提升，由于函数声明的优先级高于变量声明，因此输出function a(){}\n\n\t\teg2:\n\t\tvar a = 0, b = 0;\n\t\tfunction A(a) {\n\t\t\tA = function(b) {\n\t\t\t\talert(a+b++);\n\t\t\t}\n\t\t\talert(a++);\n\t\t}\n\t\tA(1);//alert 1\n\t\tA(2);//alert 4\n\t\tconsole.log(a);//0\n\n\t\t解析：这个程序里考到的知识点有 函数声明提升、运算符的优先级、函数参数按值传递\n\t\t在执行A(1)时，运行的是函数\n\t\tfunction A(a) {\n\t\t\tA = function(b) {\n\t\t\t\talert(a+b++);\n\t\t\t}\n\t\t\talert(a++);\n\t\t}\n\t\t然后会alert(a++);(a++)这个表达式仍然等于1，a=2；所以会alert出1\n\t\t执行了上面这个函数之后，A被重新赋值了，也就是说\n\t\tA(2)运行的是函数，alert的是4\n\t\tfunction(b) {\n\t\t\t\talert(a+b++);//a+b++ = a+(b++) = 4\n\t\t\t\t//这里的a相当于外部函数里面的局部变量a，由于第一次运行a=2;所以alert出4\n\t\t\t\t//形参是局部变量，由于这里用了闭包，所以外层函数的局部变量a没有释放。\n\t\t}\n\t\t\n### 四. js中名字解析的顺序\n\n比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：\n\n1. 当前作用域内是否有 var foo 的定义。\n2. 函数形式参数是否有使用 foo 名称的。\n3. 函数自身是否叫做 foo。\n4. 回溯到上一级作用域，然后从 #1 重新开始。\n    \n\n\n","source":"_posts/2016-05-08-变量声明提升.md","raw":"---\nlayout: post\ntitle: js中的变量和函数声明提升\ndate: 2016-05-08\ncategories: javaScript\ntags: [javaScript,函数]\ndescription: \n---\n\nJavaScript 能够在**变量**和**函数**被声明之前使用它们。\n\n原因：js解析器将**当前作用域内**所有的**变量声明**和**函数声明**都会放到作用域的开始处，但是，只有<font color=\"red\">变量的声明被提前到作用域的开始处了，而赋值操作被保留在原处。</font>\n\n### 一. 定义函数的两种方式\n\n#### 1. 函数声明\n\n(1) 什么是函数声明\n\n  function myFunc(){ }\n\n  上面就是函数声明\n\n(2) 函数声明提升\n\n  函数声明提升————执行函数之前会读取函数声明\n\n  函数声明并不仅仅是函数名“被提前”了，整个函数的定义也“被提前”了\n\n    eg:    \n    myFunc();//执行函数   \n    function myFunc(){ };//函数声明\n\t由于函数申明提升特性，上面的代码不会报错\n\n#### 2. 函数表达式\n\nvar myFunc = function(){}\n\n创建一个函数，这里创建的函数是匿名的（function后面没有标识符），并把函数赋值给一个变量\n\n\teg:\t\n\tmyFunc();//会报错，这个时候，myFunc还不是一个函数\n\tvar myFunc = function(){};\n\n\t上面的代码等价于：\n\tvar myFunc;\n\tmyFuc();//会报错，这个时候，myFunc还不是一个函数\n\tmyFunc = function(){};\n\nvar myFunc = function f(){}\n\n创建一个函数，这里创建的函数是命名函数，并把函数赋值给一个变量，命名函数表达式的名字不会进入名字空间，也不会被提升\n\n\teg:\t\n\tmyFunc();//会报错，这个时候，myFunc还不是一个函数\n\tvar myFunc = function f(){};\n\tmyFunc();//不会报错\n\tf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效\n\n\t上面的代码等价于：\n\tvar myFunc;\n\tmyFuc();//会报错，这个时候，myFunc还不是一个函数\n\tmyFunc = function f(){};\n\tmyFunc();//不会报错\n\tf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效\t\n\n<font color=\"red\">这里和变量声明提前的规则一致：变量声明提前了，但是变量的赋值操作还留在原地。</font>\n\n### 二. 变量声明提升\n\n#### 1. 定义变量的方法\n\njs的变量是一种松散类型，可以用来保存任何类型的数据。\n\n    定义变量：\n    var myvar;//像这样，未经过初始化的变量会保存一个特殊的值：undefined\n\n**注意：**没有使用var声明的变量，都是全局变量。\n\n#### 2. 变量声明提升\n\n    var name = \"A\";    \n    (function () {\n    \talert(name);//undefined    \n    \tvar name = \"B\";    \n    \talert(name);//B       \n    })();\n\n\t上面的代码等价于：\n\tvar name = \"A\";    \n    (function () {\n\t\tvar name;//局部变量的声明被提升到作用域的最前面\n    \talert(name);//undefined    \n    \tname = \"B\";    \n    \talert(name);//B       \n    })();\n\n\t函数内部的name是一个局部变量\n\n**全局作用域中声明的变量、函数都是window对象的属性和方法。**\n\n\teg1:\n    var in_window = \"a\" in window; \n    console.log(in_window); //false\n\n\teg2:\n    var in_window = \"a\" in window; \n    console.log(in_window); //true\n    if(!(\"a\" in window)) \n    { var a = 1; }\n\n    上面的代码相当于：\n    var a,in_window;\n    in_window = \"a\" in window; \n    console.log(in_window); //true a是全局变量中声明的，所以a是window的属性\n    if(!(\"a\" in window)) \n    { var a = 1; }\n\n\teg3:\n\t if(!(\"a\" in window)) \n\t{ var a = 1; } \n\tconsole.log(a); //undefined \n\n\t上面的代码相当于：\n\tvar a;//if语句块内的申明的变量a，会自动提到上面去申明\n\tif(!(\"a\" in window)) //\"a\" in window为true\n\t{ a = 1; } //不会执行赋值语句\n\tconsole.log(a); //undefined\n\t\n\teg4:\n\tif(!(\"a\" in window)) //没有变量声明提升，所以!(\"a\" in window)为true\n\t{ a = 1 } //执行函数体内部的赋值语句\n\tconsole.log(a); //\n\n**总结：**\n\n- 所有变量的声明被提前到**作用域**顶部，赋值保留在原地\n- 函数声明整个“被提前”\n\n### 三. 函数声明和变量声明，谁的优先级更高\n\n- 对于同一个变量名，函数声明会覆盖变量声明\n\n\t\teg1:\n\t\tvar a;\n\t\tfunction a(){}\n\t\tconsole.log(a);//function a(){}\t\t\n\n\t\teg2:\n\t\tfunction a(){}\n\t\tvar a;\n\t\tconsole.log(a);//function a(){}\n\n\t\t上面两个例子均输出function a(){}，可见函数声明会覆盖变量声明\n\n\n- 如果在声明变量的同时对变量进行了初始化，那么对同一个变量名，声明变量同时初始化变量优先级高于函数声明\n\n\t\teg1:\n\t\tvar a=1;\n\t\tfunction a(){}\n\t\tconsole.log(a);//1\t\n\n\t\t上面的代码等价于：\n\t\tvar a;\n \t\tfunction a(){}\n\t\ta = 1;\n\t\tconsole.log(a)\t\n\n\t\teg2:\n\t\tfunction a(){}\n\t\tvar a=1;\n\t\tconsole.log(a);//1\n\n\t\t上面两个例子均输出1，可见声明变量同时初始化变量优先级高于函数声明\n\n多看几个例子：\n\n\t\teg1:\n\t\t(function(a){\n\t\t    console.log(a);\n\t\t    var a=10;\n\t\t    function a(){};\n\t\t})(100)\n\n    输出：function a(){}\n    解析：function(a){}里面的a只是一个形参，换成b,c,d...都行，所以没什么关联；变量和函数的声明同时被提升了，但是变量的赋值语句没有被提升，由于函数声明的优先级高于变量声明，因此输出function a(){}\n\n\t\teg2:\n\t\tvar a = 0, b = 0;\n\t\tfunction A(a) {\n\t\t\tA = function(b) {\n\t\t\t\talert(a+b++);\n\t\t\t}\n\t\t\talert(a++);\n\t\t}\n\t\tA(1);//alert 1\n\t\tA(2);//alert 4\n\t\tconsole.log(a);//0\n\n\t\t解析：这个程序里考到的知识点有 函数声明提升、运算符的优先级、函数参数按值传递\n\t\t在执行A(1)时，运行的是函数\n\t\tfunction A(a) {\n\t\t\tA = function(b) {\n\t\t\t\talert(a+b++);\n\t\t\t}\n\t\t\talert(a++);\n\t\t}\n\t\t然后会alert(a++);(a++)这个表达式仍然等于1，a=2；所以会alert出1\n\t\t执行了上面这个函数之后，A被重新赋值了，也就是说\n\t\tA(2)运行的是函数，alert的是4\n\t\tfunction(b) {\n\t\t\t\talert(a+b++);//a+b++ = a+(b++) = 4\n\t\t\t\t//这里的a相当于外部函数里面的局部变量a，由于第一次运行a=2;所以alert出4\n\t\t\t\t//形参是局部变量，由于这里用了闭包，所以外层函数的局部变量a没有释放。\n\t\t}\n\t\t\n### 四. js中名字解析的顺序\n\n比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：\n\n1. 当前作用域内是否有 var foo 的定义。\n2. 函数形式参数是否有使用 foo 名称的。\n3. 函数自身是否叫做 foo。\n4. 回溯到上一级作用域，然后从 #1 重新开始。\n    \n\n\n","slug":"2016-05-08-变量声明提升","published":1,"updated":"2016-08-23T08:34:46.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfp0056d5u8ndngllco","content":"<p>JavaScript 能够在<strong>变量</strong>和<strong>函数</strong>被声明之前使用它们。</p>\n<p>原因：js解析器将<strong>当前作用域内</strong>所有的<strong>变量声明</strong>和<strong>函数声明</strong>都会放到作用域的开始处，但是，只有<font color=\"red\">变量的声明被提前到作用域的开始处了，而赋值操作被保留在原处。</font></p>\n<h3 id=\"一-定义函数的两种方式\"><a href=\"#一-定义函数的两种方式\" class=\"headerlink\" title=\"一. 定义函数的两种方式\"></a>一. 定义函数的两种方式</h3><h4 id=\"1-函数声明\"><a href=\"#1-函数声明\" class=\"headerlink\" title=\"1. 函数声明\"></a>1. 函数声明</h4><p>(1) 什么是函数声明</p>\n<p>  function myFunc(){ }</p>\n<p>  上面就是函数声明</p>\n<p>(2) 函数声明提升</p>\n<p>  函数声明提升————执行函数之前会读取函数声明</p>\n<p>  函数声明并不仅仅是函数名“被提前”了，整个函数的定义也“被提前”了</p>\n<pre><code>eg:    \nmyFunc();//执行函数   \nfunction myFunc(){ };//函数声明\n由于函数申明提升特性，上面的代码不会报错\n</code></pre><h4 id=\"2-函数表达式\"><a href=\"#2-函数表达式\" class=\"headerlink\" title=\"2. 函数表达式\"></a>2. 函数表达式</h4><p>var myFunc = function(){}</p>\n<p>创建一个函数，这里创建的函数是匿名的（function后面没有标识符），并把函数赋值给一个变量</p>\n<pre><code>eg:    \nmyFunc();//会报错，这个时候，myFunc还不是一个函数\nvar myFunc = function(){};\n\n上面的代码等价于：\nvar myFunc;\nmyFuc();//会报错，这个时候，myFunc还不是一个函数\nmyFunc = function(){};\n</code></pre><p>var myFunc = function f(){}</p>\n<p>创建一个函数，这里创建的函数是命名函数，并把函数赋值给一个变量，命名函数表达式的名字不会进入名字空间，也不会被提升</p>\n<pre><code>eg:    \nmyFunc();//会报错，这个时候，myFunc还不是一个函数\nvar myFunc = function f(){};\nmyFunc();//不会报错\nf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效\n\n上面的代码等价于：\nvar myFunc;\nmyFuc();//会报错，这个时候，myFunc还不是一个函数\nmyFunc = function f(){};\nmyFunc();//不会报错\nf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效    \n</code></pre><font color=\"red\">这里和变量声明提前的规则一致：变量声明提前了，但是变量的赋值操作还留在原地。</font>\n\n<h3 id=\"二-变量声明提升\"><a href=\"#二-变量声明提升\" class=\"headerlink\" title=\"二. 变量声明提升\"></a>二. 变量声明提升</h3><h4 id=\"1-定义变量的方法\"><a href=\"#1-定义变量的方法\" class=\"headerlink\" title=\"1. 定义变量的方法\"></a>1. 定义变量的方法</h4><p>js的变量是一种松散类型，可以用来保存任何类型的数据。</p>\n<pre><code>定义变量：\nvar myvar;//像这样，未经过初始化的变量会保存一个特殊的值：undefined\n</code></pre><p><strong>注意：</strong>没有使用var声明的变量，都是全局变量。</p>\n<h4 id=\"2-变量声明提升\"><a href=\"#2-变量声明提升\" class=\"headerlink\" title=\"2. 变量声明提升\"></a>2. 变量声明提升</h4><pre><code>var name = &quot;A&quot;;    \n(function () {\n    alert(name);//undefined    \n    var name = &quot;B&quot;;    \n    alert(name);//B       \n})();\n\n上面的代码等价于：\nvar name = &quot;A&quot;;    \n(function () {\n    var name;//局部变量的声明被提升到作用域的最前面\n    alert(name);//undefined    \n    name = &quot;B&quot;;    \n    alert(name);//B       \n})();\n\n函数内部的name是一个局部变量\n</code></pre><p><strong>全局作用域中声明的变量、函数都是window对象的属性和方法。</strong></p>\n<pre><code>eg1:\nvar in_window = &quot;a&quot; in window; \nconsole.log(in_window); //false\n\neg2:\nvar in_window = &quot;a&quot; in window; \nconsole.log(in_window); //true\nif(!(&quot;a&quot; in window)) \n{ var a = 1; }\n\n上面的代码相当于：\nvar a,in_window;\nin_window = &quot;a&quot; in window; \nconsole.log(in_window); //true a是全局变量中声明的，所以a是window的属性\nif(!(&quot;a&quot; in window)) \n{ var a = 1; }\n\neg3:\n if(!(&quot;a&quot; in window)) \n{ var a = 1; } \nconsole.log(a); //undefined \n\n上面的代码相当于：\nvar a;//if语句块内的申明的变量a，会自动提到上面去申明\nif(!(&quot;a&quot; in window)) //&quot;a&quot; in window为true\n{ a = 1; } //不会执行赋值语句\nconsole.log(a); //undefined\n\neg4:\nif(!(&quot;a&quot; in window)) //没有变量声明提升，所以!(&quot;a&quot; in window)为true\n{ a = 1 } //执行函数体内部的赋值语句\nconsole.log(a); //\n</code></pre><p><strong>总结：</strong></p>\n<ul>\n<li>所有变量的声明被提前到<strong>作用域</strong>顶部，赋值保留在原地</li>\n<li>函数声明整个“被提前”</li>\n</ul>\n<h3 id=\"三-函数声明和变量声明，谁的优先级更高\"><a href=\"#三-函数声明和变量声明，谁的优先级更高\" class=\"headerlink\" title=\"三. 函数声明和变量声明，谁的优先级更高\"></a>三. 函数声明和变量声明，谁的优先级更高</h3><ul>\n<li><p>对于同一个变量名，函数声明会覆盖变量声明</p>\n<pre><code>eg1:\nvar a;\nfunction a(){}\nconsole.log(a);//function a(){}        \n\neg2:\nfunction a(){}\nvar a;\nconsole.log(a);//function a(){}\n\n上面两个例子均输出function a(){}，可见函数声明会覆盖变量声明\n</code></pre></li>\n</ul>\n<ul>\n<li><p>如果在声明变量的同时对变量进行了初始化，那么对同一个变量名，声明变量同时初始化变量优先级高于函数声明</p>\n<pre><code>eg1:\nvar a=1;\nfunction a(){}\nconsole.log(a);//1    \n\n上面的代码等价于：\nvar a;\n function a(){}\na = 1;\nconsole.log(a)    \n\neg2:\nfunction a(){}\nvar a=1;\nconsole.log(a);//1\n\n上面两个例子均输出1，可见声明变量同时初始化变量优先级高于函数声明\n</code></pre></li>\n</ul>\n<p>多看几个例子：</p>\n<pre><code>    eg1:\n    (function(a){\n        console.log(a);\n        var a=10;\n        function a(){};\n    })(100)\n\n输出：function a(){}\n解析：function(a){}里面的a只是一个形参，换成b,c,d...都行，所以没什么关联；变量和函数的声明同时被提升了，但是变量的赋值语句没有被提升，由于函数声明的优先级高于变量声明，因此输出function a(){}\n\n    eg2:\n    var a = 0, b = 0;\n    function A(a) {\n        A = function(b) {\n            alert(a+b++);\n        }\n        alert(a++);\n    }\n    A(1);//alert 1\n    A(2);//alert 4\n    console.log(a);//0\n\n    解析：这个程序里考到的知识点有 函数声明提升、运算符的优先级、函数参数按值传递\n    在执行A(1)时，运行的是函数\n    function A(a) {\n        A = function(b) {\n            alert(a+b++);\n        }\n        alert(a++);\n    }\n    然后会alert(a++);(a++)这个表达式仍然等于1，a=2；所以会alert出1\n    执行了上面这个函数之后，A被重新赋值了，也就是说\n    A(2)运行的是函数，alert的是4\n    function(b) {\n            alert(a+b++);//a+b++ = a+(b++) = 4\n            //这里的a相当于外部函数里面的局部变量a，由于第一次运行a=2;所以alert出4\n            //形参是局部变量，由于这里用了闭包，所以外层函数的局部变量a没有释放。\n    }\n</code></pre><h3 id=\"四-js中名字解析的顺序\"><a href=\"#四-js中名字解析的顺序\" class=\"headerlink\" title=\"四. js中名字解析的顺序\"></a>四. js中名字解析的顺序</h3><p>比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：</p>\n<ol>\n<li>当前作用域内是否有 var foo 的定义。</li>\n<li>函数形式参数是否有使用 foo 名称的。</li>\n<li>函数自身是否叫做 foo。</li>\n<li>回溯到上一级作用域，然后从 #1 重新开始。</li>\n</ol>\n","excerpt":"","more":"<p>JavaScript 能够在<strong>变量</strong>和<strong>函数</strong>被声明之前使用它们。</p>\n<p>原因：js解析器将<strong>当前作用域内</strong>所有的<strong>变量声明</strong>和<strong>函数声明</strong>都会放到作用域的开始处，但是，只有<font color=\"red\">变量的声明被提前到作用域的开始处了，而赋值操作被保留在原处。</font></p>\n<h3 id=\"一-定义函数的两种方式\"><a href=\"#一-定义函数的两种方式\" class=\"headerlink\" title=\"一. 定义函数的两种方式\"></a>一. 定义函数的两种方式</h3><h4 id=\"1-函数声明\"><a href=\"#1-函数声明\" class=\"headerlink\" title=\"1. 函数声明\"></a>1. 函数声明</h4><p>(1) 什么是函数声明</p>\n<p>  function myFunc(){ }</p>\n<p>  上面就是函数声明</p>\n<p>(2) 函数声明提升</p>\n<p>  函数声明提升————执行函数之前会读取函数声明</p>\n<p>  函数声明并不仅仅是函数名“被提前”了，整个函数的定义也“被提前”了</p>\n<pre><code>eg:    \nmyFunc();//执行函数   \nfunction myFunc(){ };//函数声明\n由于函数申明提升特性，上面的代码不会报错\n</code></pre><h4 id=\"2-函数表达式\"><a href=\"#2-函数表达式\" class=\"headerlink\" title=\"2. 函数表达式\"></a>2. 函数表达式</h4><p>var myFunc = function(){}</p>\n<p>创建一个函数，这里创建的函数是匿名的（function后面没有标识符），并把函数赋值给一个变量</p>\n<pre><code>eg:    \nmyFunc();//会报错，这个时候，myFunc还不是一个函数\nvar myFunc = function(){};\n\n上面的代码等价于：\nvar myFunc;\nmyFuc();//会报错，这个时候，myFunc还不是一个函数\nmyFunc = function(){};\n</code></pre><p>var myFunc = function f(){}</p>\n<p>创建一个函数，这里创建的函数是命名函数，并把函数赋值给一个变量，命名函数表达式的名字不会进入名字空间，也不会被提升</p>\n<pre><code>eg:    \nmyFunc();//会报错，这个时候，myFunc还不是一个函数\nvar myFunc = function f(){};\nmyFunc();//不会报错\nf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效\n\n上面的代码等价于：\nvar myFunc;\nmyFuc();//会报错，这个时候，myFunc还不是一个函数\nmyFunc = function f(){};\nmyFunc();//不会报错\nf();//会报错，命名函数表达式的名字只在该函数的作用域内部有效    \n</code></pre><font color=\"red\">这里和变量声明提前的规则一致：变量声明提前了，但是变量的赋值操作还留在原地。</font>\n\n<h3 id=\"二-变量声明提升\"><a href=\"#二-变量声明提升\" class=\"headerlink\" title=\"二. 变量声明提升\"></a>二. 变量声明提升</h3><h4 id=\"1-定义变量的方法\"><a href=\"#1-定义变量的方法\" class=\"headerlink\" title=\"1. 定义变量的方法\"></a>1. 定义变量的方法</h4><p>js的变量是一种松散类型，可以用来保存任何类型的数据。</p>\n<pre><code>定义变量：\nvar myvar;//像这样，未经过初始化的变量会保存一个特殊的值：undefined\n</code></pre><p><strong>注意：</strong>没有使用var声明的变量，都是全局变量。</p>\n<h4 id=\"2-变量声明提升\"><a href=\"#2-变量声明提升\" class=\"headerlink\" title=\"2. 变量声明提升\"></a>2. 变量声明提升</h4><pre><code>var name = &quot;A&quot;;    \n(function () {\n    alert(name);//undefined    \n    var name = &quot;B&quot;;    \n    alert(name);//B       \n})();\n\n上面的代码等价于：\nvar name = &quot;A&quot;;    \n(function () {\n    var name;//局部变量的声明被提升到作用域的最前面\n    alert(name);//undefined    \n    name = &quot;B&quot;;    \n    alert(name);//B       \n})();\n\n函数内部的name是一个局部变量\n</code></pre><p><strong>全局作用域中声明的变量、函数都是window对象的属性和方法。</strong></p>\n<pre><code>eg1:\nvar in_window = &quot;a&quot; in window; \nconsole.log(in_window); //false\n\neg2:\nvar in_window = &quot;a&quot; in window; \nconsole.log(in_window); //true\nif(!(&quot;a&quot; in window)) \n{ var a = 1; }\n\n上面的代码相当于：\nvar a,in_window;\nin_window = &quot;a&quot; in window; \nconsole.log(in_window); //true a是全局变量中声明的，所以a是window的属性\nif(!(&quot;a&quot; in window)) \n{ var a = 1; }\n\neg3:\n if(!(&quot;a&quot; in window)) \n{ var a = 1; } \nconsole.log(a); //undefined \n\n上面的代码相当于：\nvar a;//if语句块内的申明的变量a，会自动提到上面去申明\nif(!(&quot;a&quot; in window)) //&quot;a&quot; in window为true\n{ a = 1; } //不会执行赋值语句\nconsole.log(a); //undefined\n\neg4:\nif(!(&quot;a&quot; in window)) //没有变量声明提升，所以!(&quot;a&quot; in window)为true\n{ a = 1 } //执行函数体内部的赋值语句\nconsole.log(a); //\n</code></pre><p><strong>总结：</strong></p>\n<ul>\n<li>所有变量的声明被提前到<strong>作用域</strong>顶部，赋值保留在原地</li>\n<li>函数声明整个“被提前”</li>\n</ul>\n<h3 id=\"三-函数声明和变量声明，谁的优先级更高\"><a href=\"#三-函数声明和变量声明，谁的优先级更高\" class=\"headerlink\" title=\"三. 函数声明和变量声明，谁的优先级更高\"></a>三. 函数声明和变量声明，谁的优先级更高</h3><ul>\n<li><p>对于同一个变量名，函数声明会覆盖变量声明</p>\n<pre><code>eg1:\nvar a;\nfunction a(){}\nconsole.log(a);//function a(){}        \n\neg2:\nfunction a(){}\nvar a;\nconsole.log(a);//function a(){}\n\n上面两个例子均输出function a(){}，可见函数声明会覆盖变量声明\n</code></pre></li>\n</ul>\n<ul>\n<li><p>如果在声明变量的同时对变量进行了初始化，那么对同一个变量名，声明变量同时初始化变量优先级高于函数声明</p>\n<pre><code>eg1:\nvar a=1;\nfunction a(){}\nconsole.log(a);//1    \n\n上面的代码等价于：\nvar a;\n function a(){}\na = 1;\nconsole.log(a)    \n\neg2:\nfunction a(){}\nvar a=1;\nconsole.log(a);//1\n\n上面两个例子均输出1，可见声明变量同时初始化变量优先级高于函数声明\n</code></pre></li>\n</ul>\n<p>多看几个例子：</p>\n<pre><code>    eg1:\n    (function(a){\n        console.log(a);\n        var a=10;\n        function a(){};\n    })(100)\n\n输出：function a(){}\n解析：function(a){}里面的a只是一个形参，换成b,c,d...都行，所以没什么关联；变量和函数的声明同时被提升了，但是变量的赋值语句没有被提升，由于函数声明的优先级高于变量声明，因此输出function a(){}\n\n    eg2:\n    var a = 0, b = 0;\n    function A(a) {\n        A = function(b) {\n            alert(a+b++);\n        }\n        alert(a++);\n    }\n    A(1);//alert 1\n    A(2);//alert 4\n    console.log(a);//0\n\n    解析：这个程序里考到的知识点有 函数声明提升、运算符的优先级、函数参数按值传递\n    在执行A(1)时，运行的是函数\n    function A(a) {\n        A = function(b) {\n            alert(a+b++);\n        }\n        alert(a++);\n    }\n    然后会alert(a++);(a++)这个表达式仍然等于1，a=2；所以会alert出1\n    执行了上面这个函数之后，A被重新赋值了，也就是说\n    A(2)运行的是函数，alert的是4\n    function(b) {\n            alert(a+b++);//a+b++ = a+(b++) = 4\n            //这里的a相当于外部函数里面的局部变量a，由于第一次运行a=2;所以alert出4\n            //形参是局部变量，由于这里用了闭包，所以外层函数的局部变量a没有释放。\n    }\n</code></pre><h3 id=\"四-js中名字解析的顺序\"><a href=\"#四-js中名字解析的顺序\" class=\"headerlink\" title=\"四. js中名字解析的顺序\"></a>四. js中名字解析的顺序</h3><p>比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：</p>\n<ol>\n<li>当前作用域内是否有 var foo 的定义。</li>\n<li>函数形式参数是否有使用 foo 名称的。</li>\n<li>函数自身是否叫做 foo。</li>\n<li>回溯到上一级作用域，然后从 #1 重新开始。</li>\n</ol>\n"},{"layout":"post","title":"js中的ajax","date":"2016-05-08T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是ajax\n\n异步的javascript and xml\n\n是一种不需要刷新页面就可以从服务台请求数据的一种技术。\n\n### 二. ajax的过程\n\n**1.新建一个XMLHttpRequest对象**\n\n    var xhr = new XMLHttpRequest();\n\n**2.调用open()方法，请求准备阶段**\n\n注意：调用open()方法时，并没有发送请求，只是启动一个请求以备发送。\n\n    xhr.open(\"请求的方法\",\"请求的地址\",是否发送异步请求);\n\n\n\tGET请求：向服务器查询某些信息，把查询的字符串追加到URL末尾\n\tPOST请求：用于向服务器发送某些要保存的数据。\n\n\tflase:请求不是异步\n\ttrue:请求是异步的\n\n\n**3.调用send()方法，发送请求**\n\n    xhr.send(null);\n    \n    send()函数里面接收的参数，是作为请求主体发送的数据，如果不发送数据，那么必须将参数置为null\n\n**4.给xhr绑定一个状态变化的监听事件onreadystatechange**\n\n**为了满足跨浏览器的兼容性，必须在open事件调用之前指定onreadystatechange事件处理程序**\n\n    xhr.onreadystatechange = function(){\n    \tif(xhr.readystate == 4)//请求响应的当前活动阶段，4表示响应已完成\n    \t{\n    \t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304)\n    \t\t{alert(responseText);}\n    \t\telse\n    \t\t{alert(\"unsuccessful\")}\t\n    \t}\n    }\n\n服务器响应之后，XHR对象的4个属性值发生了变化\n\n    responseText:响应的内容\n    responseXML：响应的类型\n    status：响应的状态\n    statusText：响应状态的文字说明\n    readyState: ajax请求响应过程的当前活动阶段\n\n根据响应状态status写相关的操作函数\n\n    status的几种取值：\n    200表示成功\n    304表示可以使用浏览器的缓存版本\n    204表示没有新文档\n\nreadyState的几种取值：\n\n    0：未调用open()\n    1：已调用open()，未调用send()\n    2：已调用send()，但没有接收到响应\n    3：已接收到部分响应数据\n    4：已接收到全部响应数据\n    \n在接收到响应之前取消异步请求的方法：\n\nxhr.abort()\n\n\n**5.获取异步调用返回的数据**\n\n**6.使用js和DOM实现局部刷新**\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-05-09-js中的ajax.md","raw":"---\nlayout: post\ntitle: js中的ajax\ndate: 2016-05-09\ncategories: 前端笔记\ntags: [javaScript,Ajax]\ndescription: \n---\n\n### 一. 什么是ajax\n\n异步的javascript and xml\n\n是一种不需要刷新页面就可以从服务台请求数据的一种技术。\n\n### 二. ajax的过程\n\n**1.新建一个XMLHttpRequest对象**\n\n    var xhr = new XMLHttpRequest();\n\n**2.调用open()方法，请求准备阶段**\n\n注意：调用open()方法时，并没有发送请求，只是启动一个请求以备发送。\n\n    xhr.open(\"请求的方法\",\"请求的地址\",是否发送异步请求);\n\n\n\tGET请求：向服务器查询某些信息，把查询的字符串追加到URL末尾\n\tPOST请求：用于向服务器发送某些要保存的数据。\n\n\tflase:请求不是异步\n\ttrue:请求是异步的\n\n\n**3.调用send()方法，发送请求**\n\n    xhr.send(null);\n    \n    send()函数里面接收的参数，是作为请求主体发送的数据，如果不发送数据，那么必须将参数置为null\n\n**4.给xhr绑定一个状态变化的监听事件onreadystatechange**\n\n**为了满足跨浏览器的兼容性，必须在open事件调用之前指定onreadystatechange事件处理程序**\n\n    xhr.onreadystatechange = function(){\n    \tif(xhr.readystate == 4)//请求响应的当前活动阶段，4表示响应已完成\n    \t{\n    \t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304)\n    \t\t{alert(responseText);}\n    \t\telse\n    \t\t{alert(\"unsuccessful\")}\t\n    \t}\n    }\n\n服务器响应之后，XHR对象的4个属性值发生了变化\n\n    responseText:响应的内容\n    responseXML：响应的类型\n    status：响应的状态\n    statusText：响应状态的文字说明\n    readyState: ajax请求响应过程的当前活动阶段\n\n根据响应状态status写相关的操作函数\n\n    status的几种取值：\n    200表示成功\n    304表示可以使用浏览器的缓存版本\n    204表示没有新文档\n\nreadyState的几种取值：\n\n    0：未调用open()\n    1：已调用open()，未调用send()\n    2：已调用send()，但没有接收到响应\n    3：已接收到部分响应数据\n    4：已接收到全部响应数据\n    \n在接收到响应之前取消异步请求的方法：\n\nxhr.abort()\n\n\n**5.获取异步调用返回的数据**\n\n**6.使用js和DOM实现局部刷新**\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-05-09-js中的ajax","published":1,"updated":"2016-08-17T07:20:20.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfr0059d5u8jammgbrx","content":"<h3 id=\"一-什么是ajax\"><a href=\"#一-什么是ajax\" class=\"headerlink\" title=\"一. 什么是ajax\"></a>一. 什么是ajax</h3><p>异步的javascript and xml</p>\n<p>是一种不需要刷新页面就可以从服务台请求数据的一种技术。</p>\n<h3 id=\"二-ajax的过程\"><a href=\"#二-ajax的过程\" class=\"headerlink\" title=\"二. ajax的过程\"></a>二. ajax的过程</h3><p><strong>1.新建一个XMLHttpRequest对象</strong></p>\n<pre><code>var xhr = new XMLHttpRequest();\n</code></pre><p><strong>2.调用open()方法，请求准备阶段</strong></p>\n<p>注意：调用open()方法时，并没有发送请求，只是启动一个请求以备发送。</p>\n<pre><code>xhr.open(&quot;请求的方法&quot;,&quot;请求的地址&quot;,是否发送异步请求);\n\n\nGET请求：向服务器查询某些信息，把查询的字符串追加到URL末尾\nPOST请求：用于向服务器发送某些要保存的数据。\n\nflase:请求不是异步\ntrue:请求是异步的\n</code></pre><p><strong>3.调用send()方法，发送请求</strong></p>\n<pre><code>xhr.send(null);\n\nsend()函数里面接收的参数，是作为请求主体发送的数据，如果不发送数据，那么必须将参数置为null\n</code></pre><p><strong>4.给xhr绑定一个状态变化的监听事件onreadystatechange</strong></p>\n<p><strong>为了满足跨浏览器的兼容性，必须在open事件调用之前指定onreadystatechange事件处理程序</strong></p>\n<pre><code>xhr.onreadystatechange = function(){\n    if(xhr.readystate == 4)//请求响应的当前活动阶段，4表示响应已完成\n    {\n        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)\n        {alert(responseText);}\n        else\n        {alert(&quot;unsuccessful&quot;)}    \n    }\n}\n</code></pre><p>服务器响应之后，XHR对象的4个属性值发生了变化</p>\n<pre><code>responseText:响应的内容\nresponseXML：响应的类型\nstatus：响应的状态\nstatusText：响应状态的文字说明\nreadyState: ajax请求响应过程的当前活动阶段\n</code></pre><p>根据响应状态status写相关的操作函数</p>\n<pre><code>status的几种取值：\n200表示成功\n304表示可以使用浏览器的缓存版本\n204表示没有新文档\n</code></pre><p>readyState的几种取值：</p>\n<pre><code>0：未调用open()\n1：已调用open()，未调用send()\n2：已调用send()，但没有接收到响应\n3：已接收到部分响应数据\n4：已接收到全部响应数据\n</code></pre><p>在接收到响应之前取消异步请求的方法：</p>\n<p>xhr.abort()</p>\n<p><strong>5.获取异步调用返回的数据</strong></p>\n<p><strong>6.使用js和DOM实现局部刷新</strong></p>\n","excerpt":"","more":"<h3 id=\"一-什么是ajax\"><a href=\"#一-什么是ajax\" class=\"headerlink\" title=\"一. 什么是ajax\"></a>一. 什么是ajax</h3><p>异步的javascript and xml</p>\n<p>是一种不需要刷新页面就可以从服务台请求数据的一种技术。</p>\n<h3 id=\"二-ajax的过程\"><a href=\"#二-ajax的过程\" class=\"headerlink\" title=\"二. ajax的过程\"></a>二. ajax的过程</h3><p><strong>1.新建一个XMLHttpRequest对象</strong></p>\n<pre><code>var xhr = new XMLHttpRequest();\n</code></pre><p><strong>2.调用open()方法，请求准备阶段</strong></p>\n<p>注意：调用open()方法时，并没有发送请求，只是启动一个请求以备发送。</p>\n<pre><code>xhr.open(&quot;请求的方法&quot;,&quot;请求的地址&quot;,是否发送异步请求);\n\n\nGET请求：向服务器查询某些信息，把查询的字符串追加到URL末尾\nPOST请求：用于向服务器发送某些要保存的数据。\n\nflase:请求不是异步\ntrue:请求是异步的\n</code></pre><p><strong>3.调用send()方法，发送请求</strong></p>\n<pre><code>xhr.send(null);\n\nsend()函数里面接收的参数，是作为请求主体发送的数据，如果不发送数据，那么必须将参数置为null\n</code></pre><p><strong>4.给xhr绑定一个状态变化的监听事件onreadystatechange</strong></p>\n<p><strong>为了满足跨浏览器的兼容性，必须在open事件调用之前指定onreadystatechange事件处理程序</strong></p>\n<pre><code>xhr.onreadystatechange = function(){\n    if(xhr.readystate == 4)//请求响应的当前活动阶段，4表示响应已完成\n    {\n        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)\n        {alert(responseText);}\n        else\n        {alert(&quot;unsuccessful&quot;)}    \n    }\n}\n</code></pre><p>服务器响应之后，XHR对象的4个属性值发生了变化</p>\n<pre><code>responseText:响应的内容\nresponseXML：响应的类型\nstatus：响应的状态\nstatusText：响应状态的文字说明\nreadyState: ajax请求响应过程的当前活动阶段\n</code></pre><p>根据响应状态status写相关的操作函数</p>\n<pre><code>status的几种取值：\n200表示成功\n304表示可以使用浏览器的缓存版本\n204表示没有新文档\n</code></pre><p>readyState的几种取值：</p>\n<pre><code>0：未调用open()\n1：已调用open()，未调用send()\n2：已调用send()，但没有接收到响应\n3：已接收到部分响应数据\n4：已接收到全部响应数据\n</code></pre><p>在接收到响应之前取消异步请求的方法：</p>\n<p>xhr.abort()</p>\n<p><strong>5.获取异步调用返回的数据</strong></p>\n<p><strong>6.使用js和DOM实现局部刷新</strong></p>\n"},{"layout":"post","title":"js中的this对象","date":"2016-05-07T16:00:00.000Z","description":null,"_content":"\n`this`在**面向对象编程**里十分重要。`this`是js中的关键字，指示的是函数的上下文对象。`this`是**动态绑定**，或称为运行期绑定的，指的是在运行时基于函数的执行环境绑定的。\n\n`this`可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式\n\n**JavaScript中函数的调用有以下几种方式：**\n\n- 作为对象方法调用\n- 作为函数调用\n- 作为构造函数调用\n- 使用apply或call调用\n- 作为事件的回调函数调用(onclick、addEventListener、attachEvent)\n- 作为setTimeout/setInterval里的回调函数调用\n\n下面我们将按照调用方式的不同，分别讨论 this 的含义\n\n#### 1. 函数作为对象的方法被调用时，this指向当前对象\n\n   当一个函数保存为对象的一个属性时，称之为对象的一个方法。\n\n\tvar point = { \n\t     x : 0, \n\t     y : 0, \n\t     moveTo : function(x, y) { \n\t     this.x = this.x + x; \n\t     this.y = this.y + y; \n\t     } \n     }; \n    \n     point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象\n\t\t\t\t\t\t//point.x、point.y都变成了 1\n\n#### 2. 作为函数调用时，this指向全局对象\n\n当一个函数并非为一个对象的属性的时候，他就是被当做一个函数来调用的。\n\n\teg1:\n\tfunction makeNoSense(x) { \n\t\tthis.x = x; \n\t} \t\n\tmakeNoSense(5); \n\tconsole.log(x);// x 已经成为一个值为 5 的全局变量\n\n\teg2:\n\tvar point = { \n\t x : 0, \n\t y : 0, \n\t moveTo : function(x, y) { \n\t     // 内部函数\n\t     var moveX = function(x) { \n\t     \tthis.x = x;//this 绑定到了哪里？\n\t    }; \n\t    // 内部函数\n\t    var moveY = function(y) { \n\t    \tthis.y = y;//this 绑定到了哪里？\n\t    }; \n\t\n\t    moveX(x); //作为函数调用，所以moveX里面的this指向的是全局对象\n\t    moveY(y); //作为函数调用，所以moveY里面的this指向的是全局对象\n\t    } \n\t }; \n\t point.moveTo(1, 1); \n\t point.x; //==>0 \n\t point.y; //==>0 \n\t x; //==>1 \n\t y; //==>1\n\n\teg3:\n\tvar point = { \n\t x : 0, \n\t y : 0, \n\t moveTo : function(x, y) { \n\t      var that = this; \n\t     // 内部函数\n\t     var moveX = function(x) { \n\t     \tthat.x = x; //使用了闭包 \n\t     }; \n\t     // 内部函数\n\t     var moveY = function(y) { \n\t     \tthat.y = y; \n\t     } \n\t     moveX(x); \n\t     moveY(y); \n\t     } \n\t }; \n\t point.moveTo(1, 1); \n\t point.x; //==>1 \n\t point.y; //==>1\n\n#### 3. 作为构造函数调用时，this 绑定到新创建的对象上\n\nJavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，**构造函数以大写字母开头**，提醒调用者使用正确的方式调用。\n\n    function Point(x, y){ \n\t    this.x = x; \n\t    this.y = y; \n     }\n    var obj = new Point(1,2);//this指向obj\n\n#### 4. 使用apply或者call调用\n\n利用apply和call可以改变this的指向\n\n\t function Point(x, y){ \n\t    this.x = x; \n\t    this.y = y; \n\t    this.moveTo = function(x, y){ \n\t        this.x = x; \n\t        this.y = y; \n\t    } \n\t } \n\t\n\t var p1 = new Point(0, 0); \n\t var p2 = {x: 0, y: 0}; \n\t p1.moveTo(1, 1); \n\t p1.moveTo.apply(p2, [10, 10]);//moveTo 的this又指向了p2\n\n\tvar name=\"A\";\n\tvar obj = {\n      name:\"B\",\n      child:{\n\t\t\t\tname:\"C\",\n\t\t\t\tconName:function(){\n\t    \t\t\tconsole.log(this.name);\n\t      \t\t}\t\n\t  }\n\t\t\n    };\n      \n    obj.child.conName();//C 作为对象的方法调用，指向当前的对象\n\t\n\tvar output = obj.child.conName;\n\toutput();//A output作为函数调用时，this指向全局变量\n\n\n**举个栗子：**\n\n\tvar name = 'yuan'\n\tvar info = {\n\t    name: \"yuanzm\",\n\t    sayName: function() {\n\t        console.log(this.name);\n\t    }\n\t}\n\tvar sayName = info.sayName;\n\t// 我们本身是希望得到yuanzm的，但是确得到了yuan这个结果。为什么会得到这个结果，前面的长篇大论起作用了。\n\t// 如果是采用info.sayName()这种调用方式，符合对象的方法调用模式，this指的是info对象；\n\t// 如果令一个变量sayName为info.sayName，这个时候再调用函数，就是普通的函数调用模式了，结果自然为yuan。\n\tsayName();    // yuan \n\n#### 5. 作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\n\n\t<input value=\"click\" id=\"btn\" type=\"button\"/>\n\n    <script>  \n      var nam = \"some\";\n      var btn = document.getElementById(\"btn\");\n      var ad = {\n        nam: \"ad\",\n        say: function() {\n          console.log(this);\n        }\n      }\n      ad.say();//作为对象的方法调用，this指向ad\n      btn.onclick = ad.say;//this指向<input>\n      btn.addEventListener(\"click\",ad.say,false);//this指向<input>\n\t</script>\n\n<font color=\"red\">注意：addEventListener和attachEvent绑定事件时，this指向不同</font>\n\n- addEventListener绑定事件时，this指向绑定该事件的dom元素\n- attachEvent绑定事件时，this指向window\n\n    ie10（不包括ie10）以上就只支持addEventListener绑定事件了\n    ie9,ie10支持addeventListener和attachEvent\n    ie8及其以下都只支持attachEvent\n\n#### 6. 作为setTimeout、setInterval的回调函数调用时，指向window\n\n作为setTimeOut、setInterval的回调函数调用，其实和普通函数调用是一样的，所以指向的是window\n\n\t<script>  \n      var nam = \"some\";\n      var btn = document.getElementById(\"btn\");\n      var ad = {\n        nam: \"ad\",\n        say: function() {\n          console.log(this);\n        }\n      }\n      ad.say();//作为对象的方法调用，this指向ad\n      setTimeout(ad.say,1000);//this指向window\n\t  setInterval(ad.say,1000);//this指向window\n\t</script>\n\n    \n\n\n","source":"_posts/2016-05-08-js中的this对象.md","raw":"---\nlayout: post\ntitle: js中的this对象\ndate: 2016-05-08\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n`this`在**面向对象编程**里十分重要。`this`是js中的关键字，指示的是函数的上下文对象。`this`是**动态绑定**，或称为运行期绑定的，指的是在运行时基于函数的执行环境绑定的。\n\n`this`可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式\n\n**JavaScript中函数的调用有以下几种方式：**\n\n- 作为对象方法调用\n- 作为函数调用\n- 作为构造函数调用\n- 使用apply或call调用\n- 作为事件的回调函数调用(onclick、addEventListener、attachEvent)\n- 作为setTimeout/setInterval里的回调函数调用\n\n下面我们将按照调用方式的不同，分别讨论 this 的含义\n\n#### 1. 函数作为对象的方法被调用时，this指向当前对象\n\n   当一个函数保存为对象的一个属性时，称之为对象的一个方法。\n\n\tvar point = { \n\t     x : 0, \n\t     y : 0, \n\t     moveTo : function(x, y) { \n\t     this.x = this.x + x; \n\t     this.y = this.y + y; \n\t     } \n     }; \n    \n     point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象\n\t\t\t\t\t\t//point.x、point.y都变成了 1\n\n#### 2. 作为函数调用时，this指向全局对象\n\n当一个函数并非为一个对象的属性的时候，他就是被当做一个函数来调用的。\n\n\teg1:\n\tfunction makeNoSense(x) { \n\t\tthis.x = x; \n\t} \t\n\tmakeNoSense(5); \n\tconsole.log(x);// x 已经成为一个值为 5 的全局变量\n\n\teg2:\n\tvar point = { \n\t x : 0, \n\t y : 0, \n\t moveTo : function(x, y) { \n\t     // 内部函数\n\t     var moveX = function(x) { \n\t     \tthis.x = x;//this 绑定到了哪里？\n\t    }; \n\t    // 内部函数\n\t    var moveY = function(y) { \n\t    \tthis.y = y;//this 绑定到了哪里？\n\t    }; \n\t\n\t    moveX(x); //作为函数调用，所以moveX里面的this指向的是全局对象\n\t    moveY(y); //作为函数调用，所以moveY里面的this指向的是全局对象\n\t    } \n\t }; \n\t point.moveTo(1, 1); \n\t point.x; //==>0 \n\t point.y; //==>0 \n\t x; //==>1 \n\t y; //==>1\n\n\teg3:\n\tvar point = { \n\t x : 0, \n\t y : 0, \n\t moveTo : function(x, y) { \n\t      var that = this; \n\t     // 内部函数\n\t     var moveX = function(x) { \n\t     \tthat.x = x; //使用了闭包 \n\t     }; \n\t     // 内部函数\n\t     var moveY = function(y) { \n\t     \tthat.y = y; \n\t     } \n\t     moveX(x); \n\t     moveY(y); \n\t     } \n\t }; \n\t point.moveTo(1, 1); \n\t point.x; //==>1 \n\t point.y; //==>1\n\n#### 3. 作为构造函数调用时，this 绑定到新创建的对象上\n\nJavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，**构造函数以大写字母开头**，提醒调用者使用正确的方式调用。\n\n    function Point(x, y){ \n\t    this.x = x; \n\t    this.y = y; \n     }\n    var obj = new Point(1,2);//this指向obj\n\n#### 4. 使用apply或者call调用\n\n利用apply和call可以改变this的指向\n\n\t function Point(x, y){ \n\t    this.x = x; \n\t    this.y = y; \n\t    this.moveTo = function(x, y){ \n\t        this.x = x; \n\t        this.y = y; \n\t    } \n\t } \n\t\n\t var p1 = new Point(0, 0); \n\t var p2 = {x: 0, y: 0}; \n\t p1.moveTo(1, 1); \n\t p1.moveTo.apply(p2, [10, 10]);//moveTo 的this又指向了p2\n\n\tvar name=\"A\";\n\tvar obj = {\n      name:\"B\",\n      child:{\n\t\t\t\tname:\"C\",\n\t\t\t\tconName:function(){\n\t    \t\t\tconsole.log(this.name);\n\t      \t\t}\t\n\t  }\n\t\t\n    };\n      \n    obj.child.conName();//C 作为对象的方法调用，指向当前的对象\n\t\n\tvar output = obj.child.conName;\n\toutput();//A output作为函数调用时，this指向全局变量\n\n\n**举个栗子：**\n\n\tvar name = 'yuan'\n\tvar info = {\n\t    name: \"yuanzm\",\n\t    sayName: function() {\n\t        console.log(this.name);\n\t    }\n\t}\n\tvar sayName = info.sayName;\n\t// 我们本身是希望得到yuanzm的，但是确得到了yuan这个结果。为什么会得到这个结果，前面的长篇大论起作用了。\n\t// 如果是采用info.sayName()这种调用方式，符合对象的方法调用模式，this指的是info对象；\n\t// 如果令一个变量sayName为info.sayName，这个时候再调用函数，就是普通的函数调用模式了，结果自然为yuan。\n\tsayName();    // yuan \n\n#### 5. 作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\n\n\t<input value=\"click\" id=\"btn\" type=\"button\"/>\n\n    <script>  \n      var nam = \"some\";\n      var btn = document.getElementById(\"btn\");\n      var ad = {\n        nam: \"ad\",\n        say: function() {\n          console.log(this);\n        }\n      }\n      ad.say();//作为对象的方法调用，this指向ad\n      btn.onclick = ad.say;//this指向<input>\n      btn.addEventListener(\"click\",ad.say,false);//this指向<input>\n\t</script>\n\n<font color=\"red\">注意：addEventListener和attachEvent绑定事件时，this指向不同</font>\n\n- addEventListener绑定事件时，this指向绑定该事件的dom元素\n- attachEvent绑定事件时，this指向window\n\n    ie10（不包括ie10）以上就只支持addEventListener绑定事件了\n    ie9,ie10支持addeventListener和attachEvent\n    ie8及其以下都只支持attachEvent\n\n#### 6. 作为setTimeout、setInterval的回调函数调用时，指向window\n\n作为setTimeOut、setInterval的回调函数调用，其实和普通函数调用是一样的，所以指向的是window\n\n\t<script>  \n      var nam = \"some\";\n      var btn = document.getElementById(\"btn\");\n      var ad = {\n        nam: \"ad\",\n        say: function() {\n          console.log(this);\n        }\n      }\n      ad.say();//作为对象的方法调用，this指向ad\n      setTimeout(ad.say,1000);//this指向window\n\t  setInterval(ad.say,1000);//this指向window\n\t</script>\n\n    \n\n\n","slug":"2016-05-08-js中的this对象","published":1,"updated":"2016-08-19T07:24:02.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfw005dd5u87amj1gs4","content":"<p><code>this</code>在<strong>面向对象编程</strong>里十分重要。<code>this</code>是js中的关键字，指示的是函数的上下文对象。<code>this</code>是<strong>动态绑定</strong>，或称为运行期绑定的，指的是在运行时基于函数的执行环境绑定的。</p>\n<p><code>this</code>可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式</p>\n<p><strong>JavaScript中函数的调用有以下几种方式：</strong></p>\n<ul>\n<li>作为对象方法调用</li>\n<li>作为函数调用</li>\n<li>作为构造函数调用</li>\n<li>使用apply或call调用</li>\n<li>作为事件的回调函数调用(onclick、addEventListener、attachEvent)</li>\n<li>作为setTimeout/setInterval里的回调函数调用</li>\n</ul>\n<p>下面我们将按照调用方式的不同，分别讨论 this 的含义</p>\n<h4 id=\"1-函数作为对象的方法被调用时，this指向当前对象\"><a href=\"#1-函数作为对象的方法被调用时，this指向当前对象\" class=\"headerlink\" title=\"1. 函数作为对象的方法被调用时，this指向当前对象\"></a>1. 函数作为对象的方法被调用时，this指向当前对象</h4><p>   当一个函数保存为对象的一个属性时，称之为对象的一个方法。</p>\n<pre><code>var point = { \n     x : 0, \n     y : 0, \n     moveTo : function(x, y) { \n     this.x = this.x + x; \n     this.y = this.y + y; \n     } \n }; \n\n point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象\n                    //point.x、point.y都变成了 1\n</code></pre><h4 id=\"2-作为函数调用时，this指向全局对象\"><a href=\"#2-作为函数调用时，this指向全局对象\" class=\"headerlink\" title=\"2. 作为函数调用时，this指向全局对象\"></a>2. 作为函数调用时，this指向全局对象</h4><p>当一个函数并非为一个对象的属性的时候，他就是被当做一个函数来调用的。</p>\n<pre><code>eg1:\nfunction makeNoSense(x) { \n    this.x = x; \n}     \nmakeNoSense(5); \nconsole.log(x);// x 已经成为一个值为 5 的全局变量\n\neg2:\nvar point = { \n x : 0, \n y : 0, \n moveTo : function(x, y) { \n     // 内部函数\n     var moveX = function(x) { \n         this.x = x;//this 绑定到了哪里？\n    }; \n    // 内部函数\n    var moveY = function(y) { \n        this.y = y;//this 绑定到了哪里？\n    }; \n\n    moveX(x); //作为函数调用，所以moveX里面的this指向的是全局对象\n    moveY(y); //作为函数调用，所以moveY里面的this指向的是全局对象\n    } \n }; \n point.moveTo(1, 1); \n point.x; //==&gt;0 \n point.y; //==&gt;0 \n x; //==&gt;1 \n y; //==&gt;1\n\neg3:\nvar point = { \n x : 0, \n y : 0, \n moveTo : function(x, y) { \n      var that = this; \n     // 内部函数\n     var moveX = function(x) { \n         that.x = x; //使用了闭包 \n     }; \n     // 内部函数\n     var moveY = function(y) { \n         that.y = y; \n     } \n     moveX(x); \n     moveY(y); \n     } \n }; \n point.moveTo(1, 1); \n point.x; //==&gt;1 \n point.y; //==&gt;1\n</code></pre><h4 id=\"3-作为构造函数调用时，this-绑定到新创建的对象上\"><a href=\"#3-作为构造函数调用时，this-绑定到新创建的对象上\" class=\"headerlink\" title=\"3. 作为构造函数调用时，this 绑定到新创建的对象上\"></a>3. 作为构造函数调用时，this 绑定到新创建的对象上</h4><p>JavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，<strong>构造函数以大写字母开头</strong>，提醒调用者使用正确的方式调用。</p>\n<pre><code>function Point(x, y){ \n    this.x = x; \n    this.y = y; \n }\nvar obj = new Point(1,2);//this指向obj\n</code></pre><h4 id=\"4-使用apply或者call调用\"><a href=\"#4-使用apply或者call调用\" class=\"headerlink\" title=\"4. 使用apply或者call调用\"></a>4. 使用apply或者call调用</h4><p>利用apply和call可以改变this的指向</p>\n<pre><code> function Point(x, y){ \n    this.x = x; \n    this.y = y; \n    this.moveTo = function(x, y){ \n        this.x = x; \n        this.y = y; \n    } \n } \n\n var p1 = new Point(0, 0); \n var p2 = {x: 0, y: 0}; \n p1.moveTo(1, 1); \n p1.moveTo.apply(p2, [10, 10]);//moveTo 的this又指向了p2\n\nvar name=&quot;A&quot;;\nvar obj = {\n  name:&quot;B&quot;,\n  child:{\n            name:&quot;C&quot;,\n            conName:function(){\n                console.log(this.name);\n              }    \n  }\n\n};\n\nobj.child.conName();//C 作为对象的方法调用，指向当前的对象\n\nvar output = obj.child.conName;\noutput();//A output作为函数调用时，this指向全局变量\n</code></pre><p><strong>举个栗子：</strong></p>\n<pre><code>var name = &apos;yuan&apos;\nvar info = {\n    name: &quot;yuanzm&quot;,\n    sayName: function() {\n        console.log(this.name);\n    }\n}\nvar sayName = info.sayName;\n// 我们本身是希望得到yuanzm的，但是确得到了yuan这个结果。为什么会得到这个结果，前面的长篇大论起作用了。\n// 如果是采用info.sayName()这种调用方式，符合对象的方法调用模式，this指的是info对象；\n// 如果令一个变量sayName为info.sayName，这个时候再调用函数，就是普通的函数调用模式了，结果自然为yuan。\nsayName();    // yuan \n</code></pre><h4 id=\"5-作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\"><a href=\"#5-作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\" class=\"headerlink\" title=\"5. 作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\"></a>5. 作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）</h4><pre><code>&lt;input value=&quot;click&quot; id=&quot;btn&quot; type=&quot;button&quot;/&gt;\n\n&lt;script&gt;  \n  var nam = &quot;some&quot;;\n  var btn = document.getElementById(&quot;btn&quot;);\n  var ad = {\n    nam: &quot;ad&quot;,\n    say: function() {\n      console.log(this);\n    }\n  }\n  ad.say();//作为对象的方法调用，this指向ad\n  btn.onclick = ad.say;//this指向&lt;input&gt;\n  btn.addEventListener(&quot;click&quot;,ad.say,false);//this指向&lt;input&gt;\n&lt;/script&gt;\n</code></pre><font color=\"red\">注意：addEventListener和attachEvent绑定事件时，this指向不同</font>\n\n<ul>\n<li>addEventListener绑定事件时，this指向绑定该事件的dom元素</li>\n<li><p>attachEvent绑定事件时，this指向window</p>\n<p>  ie10（不包括ie10）以上就只支持addEventListener绑定事件了<br>  ie9,ie10支持addeventListener和attachEvent<br>  ie8及其以下都只支持attachEvent</p>\n</li>\n</ul>\n<h4 id=\"6-作为setTimeout、setInterval的回调函数调用时，指向window\"><a href=\"#6-作为setTimeout、setInterval的回调函数调用时，指向window\" class=\"headerlink\" title=\"6. 作为setTimeout、setInterval的回调函数调用时，指向window\"></a>6. 作为setTimeout、setInterval的回调函数调用时，指向window</h4><p>作为setTimeOut、setInterval的回调函数调用，其实和普通函数调用是一样的，所以指向的是window</p>\n<pre><code>&lt;script&gt;  \n  var nam = &quot;some&quot;;\n  var btn = document.getElementById(&quot;btn&quot;);\n  var ad = {\n    nam: &quot;ad&quot;,\n    say: function() {\n      console.log(this);\n    }\n  }\n  ad.say();//作为对象的方法调用，this指向ad\n  setTimeout(ad.say,1000);//this指向window\n  setInterval(ad.say,1000);//this指向window\n&lt;/script&gt;\n</code></pre>","excerpt":"","more":"<p><code>this</code>在<strong>面向对象编程</strong>里十分重要。<code>this</code>是js中的关键字，指示的是函数的上下文对象。<code>this</code>是<strong>动态绑定</strong>，或称为运行期绑定的，指的是在运行时基于函数的执行环境绑定的。</p>\n<p><code>this</code>可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式</p>\n<p><strong>JavaScript中函数的调用有以下几种方式：</strong></p>\n<ul>\n<li>作为对象方法调用</li>\n<li>作为函数调用</li>\n<li>作为构造函数调用</li>\n<li>使用apply或call调用</li>\n<li>作为事件的回调函数调用(onclick、addEventListener、attachEvent)</li>\n<li>作为setTimeout/setInterval里的回调函数调用</li>\n</ul>\n<p>下面我们将按照调用方式的不同，分别讨论 this 的含义</p>\n<h4 id=\"1-函数作为对象的方法被调用时，this指向当前对象\"><a href=\"#1-函数作为对象的方法被调用时，this指向当前对象\" class=\"headerlink\" title=\"1. 函数作为对象的方法被调用时，this指向当前对象\"></a>1. 函数作为对象的方法被调用时，this指向当前对象</h4><p>   当一个函数保存为对象的一个属性时，称之为对象的一个方法。</p>\n<pre><code>var point = { \n     x : 0, \n     y : 0, \n     moveTo : function(x, y) { \n     this.x = this.x + x; \n     this.y = this.y + y; \n     } \n }; \n\n point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象\n                    //point.x、point.y都变成了 1\n</code></pre><h4 id=\"2-作为函数调用时，this指向全局对象\"><a href=\"#2-作为函数调用时，this指向全局对象\" class=\"headerlink\" title=\"2. 作为函数调用时，this指向全局对象\"></a>2. 作为函数调用时，this指向全局对象</h4><p>当一个函数并非为一个对象的属性的时候，他就是被当做一个函数来调用的。</p>\n<pre><code>eg1:\nfunction makeNoSense(x) { \n    this.x = x; \n}     \nmakeNoSense(5); \nconsole.log(x);// x 已经成为一个值为 5 的全局变量\n\neg2:\nvar point = { \n x : 0, \n y : 0, \n moveTo : function(x, y) { \n     // 内部函数\n     var moveX = function(x) { \n         this.x = x;//this 绑定到了哪里？\n    }; \n    // 内部函数\n    var moveY = function(y) { \n        this.y = y;//this 绑定到了哪里？\n    }; \n\n    moveX(x); //作为函数调用，所以moveX里面的this指向的是全局对象\n    moveY(y); //作为函数调用，所以moveY里面的this指向的是全局对象\n    } \n }; \n point.moveTo(1, 1); \n point.x; //==&gt;0 \n point.y; //==&gt;0 \n x; //==&gt;1 \n y; //==&gt;1\n\neg3:\nvar point = { \n x : 0, \n y : 0, \n moveTo : function(x, y) { \n      var that = this; \n     // 内部函数\n     var moveX = function(x) { \n         that.x = x; //使用了闭包 \n     }; \n     // 内部函数\n     var moveY = function(y) { \n         that.y = y; \n     } \n     moveX(x); \n     moveY(y); \n     } \n }; \n point.moveTo(1, 1); \n point.x; //==&gt;1 \n point.y; //==&gt;1\n</code></pre><h4 id=\"3-作为构造函数调用时，this-绑定到新创建的对象上\"><a href=\"#3-作为构造函数调用时，this-绑定到新创建的对象上\" class=\"headerlink\" title=\"3. 作为构造函数调用时，this 绑定到新创建的对象上\"></a>3. 作为构造函数调用时，this 绑定到新创建的对象上</h4><p>JavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，<strong>构造函数以大写字母开头</strong>，提醒调用者使用正确的方式调用。</p>\n<pre><code>function Point(x, y){ \n    this.x = x; \n    this.y = y; \n }\nvar obj = new Point(1,2);//this指向obj\n</code></pre><h4 id=\"4-使用apply或者call调用\"><a href=\"#4-使用apply或者call调用\" class=\"headerlink\" title=\"4. 使用apply或者call调用\"></a>4. 使用apply或者call调用</h4><p>利用apply和call可以改变this的指向</p>\n<pre><code> function Point(x, y){ \n    this.x = x; \n    this.y = y; \n    this.moveTo = function(x, y){ \n        this.x = x; \n        this.y = y; \n    } \n } \n\n var p1 = new Point(0, 0); \n var p2 = {x: 0, y: 0}; \n p1.moveTo(1, 1); \n p1.moveTo.apply(p2, [10, 10]);//moveTo 的this又指向了p2\n\nvar name=&quot;A&quot;;\nvar obj = {\n  name:&quot;B&quot;,\n  child:{\n            name:&quot;C&quot;,\n            conName:function(){\n                console.log(this.name);\n              }    \n  }\n\n};\n\nobj.child.conName();//C 作为对象的方法调用，指向当前的对象\n\nvar output = obj.child.conName;\noutput();//A output作为函数调用时，this指向全局变量\n</code></pre><p><strong>举个栗子：</strong></p>\n<pre><code>var name = &apos;yuan&apos;\nvar info = {\n    name: &quot;yuanzm&quot;,\n    sayName: function() {\n        console.log(this.name);\n    }\n}\nvar sayName = info.sayName;\n// 我们本身是希望得到yuanzm的，但是确得到了yuan这个结果。为什么会得到这个结果，前面的长篇大论起作用了。\n// 如果是采用info.sayName()这种调用方式，符合对象的方法调用模式，this指的是info对象；\n// 如果令一个变量sayName为info.sayName，这个时候再调用函数，就是普通的函数调用模式了，结果自然为yuan。\nsayName();    // yuan \n</code></pre><h4 id=\"5-作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\"><a href=\"#5-作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\" class=\"headerlink\" title=\"5. 作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）\"></a>5. 作为事件的回调函数调用时，指向的是绑定事件的dom节点（或者window，attachEvent指向window）</h4><pre><code>&lt;input value=&quot;click&quot; id=&quot;btn&quot; type=&quot;button&quot;/&gt;\n\n&lt;script&gt;  \n  var nam = &quot;some&quot;;\n  var btn = document.getElementById(&quot;btn&quot;);\n  var ad = {\n    nam: &quot;ad&quot;,\n    say: function() {\n      console.log(this);\n    }\n  }\n  ad.say();//作为对象的方法调用，this指向ad\n  btn.onclick = ad.say;//this指向&lt;input&gt;\n  btn.addEventListener(&quot;click&quot;,ad.say,false);//this指向&lt;input&gt;\n&lt;/script&gt;\n</code></pre><font color=\"red\">注意：addEventListener和attachEvent绑定事件时，this指向不同</font>\n\n<ul>\n<li>addEventListener绑定事件时，this指向绑定该事件的dom元素</li>\n<li><p>attachEvent绑定事件时，this指向window</p>\n<p>  ie10（不包括ie10）以上就只支持addEventListener绑定事件了<br>  ie9,ie10支持addeventListener和attachEvent<br>  ie8及其以下都只支持attachEvent</p>\n</li>\n</ul>\n<h4 id=\"6-作为setTimeout、setInterval的回调函数调用时，指向window\"><a href=\"#6-作为setTimeout、setInterval的回调函数调用时，指向window\" class=\"headerlink\" title=\"6. 作为setTimeout、setInterval的回调函数调用时，指向window\"></a>6. 作为setTimeout、setInterval的回调函数调用时，指向window</h4><p>作为setTimeOut、setInterval的回调函数调用，其实和普通函数调用是一样的，所以指向的是window</p>\n<pre><code>&lt;script&gt;  \n  var nam = &quot;some&quot;;\n  var btn = document.getElementById(&quot;btn&quot;);\n  var ad = {\n    nam: &quot;ad&quot;,\n    say: function() {\n      console.log(this);\n    }\n  }\n  ad.say();//作为对象的方法调用，this指向ad\n  setTimeout(ad.say,1000);//this指向window\n  setInterval(ad.say,1000);//this指向window\n&lt;/script&gt;\n</code></pre>"},{"layout":"post","title":"js中的函数参数传递","date":"2016-05-08T16:00:00.000Z","description":null,"_content":"\n函数外部的值复制给函数内部的参数，就和把值从一个**变量**复制到另一个变量一样。\n\n### 一. js里面变量的类型\n\njs里变量类型包括两种：基本类型值、引用类型值。\n\n**基本类型：**简单的数据段。包括：undefined、Null、Boolean、Number、String（按值访问）\n\n**引用类型：**指的是可能由多个值构成的对象。包括：对象、数组、日期、正则表达式、函数（按引用访问）\n\n### 二. 复制变量\n\n#### 1. 复制基本类型的变量\n\n```js\nvar num1 = 5;\nvar num2 = num1;//num2中保存的值也是5，但是这个与num1中的值是完全独立的。\n```\n\n#### 2. 复制引用类型的变量\n\n```js\nvar obj1 = {\n\tage: 2;\n}//创建了一个对象，并存储这个对象的内存地址赋给obj1\n\nvar obj2 = obj1;//将obj1指向的内存地址赋给obj2，因此obj1和obj2指向同一个内存\n\n//若改变obj2.age的值\nobj2.age = 3;\nconsole.log(obj1.age);//3 因为obj1和obj2引用的是同一个对象\n``` \n\n### 三. js中函数参数的传递\n\n#### 1. 传递的是基本类型的参数\n\n函数传递的是基本类型的参数时，只是将传递的值复制给一个函数内部的局部变量（arguments对象中的一个元素），而原来那个变量没有变化。\n\n\teg:\n    function addTen(num){\n      num+=10;\n      return num;\n    }\n    var count=20;\n    var reslut=addTen(count);//30\n    alert(count);//20 并没有变化\n\n#### 2. 传递的是引用类型的参数时\n\n在向参数传递引用类型的值时，会把这个值在内存中的**地址**复制给函数中的局部变量（arguments对象中的一个元素），因此这个局部变量的变化会反映在函数的外部。\n\n     eg1:\n\t function setName(obj){\n       obj.name=\"ss\";\n     }\n     var person=new Object();\n     setName(person);//把person在内存中的地址复制给了obj，所以对obj的修改其实就是对外部person的修改\n     alert(person.name);//\"ss\"\n\n\teg2:\n\tfunction setName(obj){\n\t  obj.name=\"ss\";\n\t  obj=new Object();//相当于把新创建的对象地址赋值给了obj，因此下面对obj.name进行赋值不回影响person\n\t  obj.name=\"dd\";\n\t}\n\tvar person=new Object();\n\tsetName(person);//将person的地址传给了obj\n\talert(person.name)//\"ss\"\n\n\n\teg3:\n    var a={b:1};\n    var c=1;\n    var foo1 = function(value){\n       value=2;\n    }\n\n    foo1(a.b);\n    foo1(c);\n\tconsole.log(a.b);//1\n\tconsole.log(c);//1\n\n\tvar foo2 = function(value){\n\t\tvalue.b = 2;\n\t}\n\tfoo2(a);\n\tconsole.log(a.b);//2 按引用传\n\n### 四. 如何让引用类型赋值时也实现传值\n\n#### 1. 遍历数组或对象，拆成一个个基本类型，然后进行赋值\n\n**利用for... in...进行遍历**\n\n    eg:\n    //遍历数组\n    var a = ['o','p','q'], c = [];\n    \n    for(var i in a) {\n    \tc[i] = a[i];\n    \ttypeof i; //String\n    }\n    \n    c[2] = 's';\n    console.log(a[2]); //q\n    \n    //遍历对象\n    var b = {name: \"xiaoming\",\n    \t\t age: 7,\n    \t\t tel: 12345\n    \t},\n    e = {};\n    \n    for(var i in b) {\n    \te[i] = b[i];\n    }\n    \n    e[name] = 'lala';\n    \n    console.log(b[name]); // xiaoming\n    \n 但是一般还是不要使用for-in对数组进行遍历，其缺点有：\n\n（1）循环变量i的值不是数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。\n\n（2）作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。\n\n（3）最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。\n\n总之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。\n\n#### 2. 数组实现传值的简单做法\n\n**利用slice()和concat()函数**\n\n\t由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值\n    \n    eg:\n    \n    var a = [1,2,3];\n    var b = a;\n    b.push(4);\n    console.log(a);//[1,2,3,4]，a也发生了变化\n    console.log(b);//[1,2,3,4]\n    \n    利用slice()或者concat()让数组实现传值\n    var a = [1,2,3];\n    var b = a.slice();\n    var c = a.concat();\n    \n    b.push(4);\n    c.push(5);\n    console.log(a);//[1,2,3]\n    console.log(b);//[1,2,3,4]\n    console.log(c);//[1,2,3,5]\n    \n    //concat／slice对数组是深复制，但是对数组里面的对象是浅复制\n    var a = [{a:1}];\n    var b = a.slice();\n    var c = a.concat();\n    \n    b[0].a = 2;\n    console.log(a[0].a); //2","source":"_posts/2016-05-09-js中的函数参数的传递.md","raw":"---\nlayout: post\ntitle: js中的函数参数传递\ndate: 2016-05-09\ncategories: javaScript\ntags: [javaScript,函数]\ndescription: \n---\n\n函数外部的值复制给函数内部的参数，就和把值从一个**变量**复制到另一个变量一样。\n\n### 一. js里面变量的类型\n\njs里变量类型包括两种：基本类型值、引用类型值。\n\n**基本类型：**简单的数据段。包括：undefined、Null、Boolean、Number、String（按值访问）\n\n**引用类型：**指的是可能由多个值构成的对象。包括：对象、数组、日期、正则表达式、函数（按引用访问）\n\n### 二. 复制变量\n\n#### 1. 复制基本类型的变量\n\n```js\nvar num1 = 5;\nvar num2 = num1;//num2中保存的值也是5，但是这个与num1中的值是完全独立的。\n```\n\n#### 2. 复制引用类型的变量\n\n```js\nvar obj1 = {\n\tage: 2;\n}//创建了一个对象，并存储这个对象的内存地址赋给obj1\n\nvar obj2 = obj1;//将obj1指向的内存地址赋给obj2，因此obj1和obj2指向同一个内存\n\n//若改变obj2.age的值\nobj2.age = 3;\nconsole.log(obj1.age);//3 因为obj1和obj2引用的是同一个对象\n``` \n\n### 三. js中函数参数的传递\n\n#### 1. 传递的是基本类型的参数\n\n函数传递的是基本类型的参数时，只是将传递的值复制给一个函数内部的局部变量（arguments对象中的一个元素），而原来那个变量没有变化。\n\n\teg:\n    function addTen(num){\n      num+=10;\n      return num;\n    }\n    var count=20;\n    var reslut=addTen(count);//30\n    alert(count);//20 并没有变化\n\n#### 2. 传递的是引用类型的参数时\n\n在向参数传递引用类型的值时，会把这个值在内存中的**地址**复制给函数中的局部变量（arguments对象中的一个元素），因此这个局部变量的变化会反映在函数的外部。\n\n     eg1:\n\t function setName(obj){\n       obj.name=\"ss\";\n     }\n     var person=new Object();\n     setName(person);//把person在内存中的地址复制给了obj，所以对obj的修改其实就是对外部person的修改\n     alert(person.name);//\"ss\"\n\n\teg2:\n\tfunction setName(obj){\n\t  obj.name=\"ss\";\n\t  obj=new Object();//相当于把新创建的对象地址赋值给了obj，因此下面对obj.name进行赋值不回影响person\n\t  obj.name=\"dd\";\n\t}\n\tvar person=new Object();\n\tsetName(person);//将person的地址传给了obj\n\talert(person.name)//\"ss\"\n\n\n\teg3:\n    var a={b:1};\n    var c=1;\n    var foo1 = function(value){\n       value=2;\n    }\n\n    foo1(a.b);\n    foo1(c);\n\tconsole.log(a.b);//1\n\tconsole.log(c);//1\n\n\tvar foo2 = function(value){\n\t\tvalue.b = 2;\n\t}\n\tfoo2(a);\n\tconsole.log(a.b);//2 按引用传\n\n### 四. 如何让引用类型赋值时也实现传值\n\n#### 1. 遍历数组或对象，拆成一个个基本类型，然后进行赋值\n\n**利用for... in...进行遍历**\n\n    eg:\n    //遍历数组\n    var a = ['o','p','q'], c = [];\n    \n    for(var i in a) {\n    \tc[i] = a[i];\n    \ttypeof i; //String\n    }\n    \n    c[2] = 's';\n    console.log(a[2]); //q\n    \n    //遍历对象\n    var b = {name: \"xiaoming\",\n    \t\t age: 7,\n    \t\t tel: 12345\n    \t},\n    e = {};\n    \n    for(var i in b) {\n    \te[i] = b[i];\n    }\n    \n    e[name] = 'lala';\n    \n    console.log(b[name]); // xiaoming\n    \n 但是一般还是不要使用for-in对数组进行遍历，其缺点有：\n\n（1）循环变量i的值不是数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。\n\n（2）作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。\n\n（3）最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。\n\n总之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。\n\n#### 2. 数组实现传值的简单做法\n\n**利用slice()和concat()函数**\n\n\t由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值\n    \n    eg:\n    \n    var a = [1,2,3];\n    var b = a;\n    b.push(4);\n    console.log(a);//[1,2,3,4]，a也发生了变化\n    console.log(b);//[1,2,3,4]\n    \n    利用slice()或者concat()让数组实现传值\n    var a = [1,2,3];\n    var b = a.slice();\n    var c = a.concat();\n    \n    b.push(4);\n    c.push(5);\n    console.log(a);//[1,2,3]\n    console.log(b);//[1,2,3,4]\n    console.log(c);//[1,2,3,5]\n    \n    //concat／slice对数组是深复制，但是对数组里面的对象是浅复制\n    var a = [{a:1}];\n    var b = a.slice();\n    var c = a.concat();\n    \n    b[0].a = 2;\n    console.log(a[0].a); //2","slug":"2016-05-09-js中的函数参数的传递","published":1,"updated":"2016-08-19T03:02:16.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocfy005gd5u8n1cb7xfe","content":"<p>函数外部的值复制给函数内部的参数，就和把值从一个<strong>变量</strong>复制到另一个变量一样。</p>\n<h3 id=\"一-js里面变量的类型\"><a href=\"#一-js里面变量的类型\" class=\"headerlink\" title=\"一. js里面变量的类型\"></a>一. js里面变量的类型</h3><p>js里变量类型包括两种：基本类型值、引用类型值。</p>\n<p><strong>基本类型：</strong>简单的数据段。包括：undefined、Null、Boolean、Number、String（按值访问）</p>\n<p><strong>引用类型：</strong>指的是可能由多个值构成的对象。包括：对象、数组、日期、正则表达式、函数（按引用访问）</p>\n<h3 id=\"二-复制变量\"><a href=\"#二-复制变量\" class=\"headerlink\" title=\"二. 复制变量\"></a>二. 复制变量</h3><h4 id=\"1-复制基本类型的变量\"><a href=\"#1-复制基本类型的变量\" class=\"headerlink\" title=\"1. 复制基本类型的变量\"></a>1. 复制基本类型的变量</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num1 = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num2 = num1;<span class=\"comment\">//num2中保存的值也是5，但是这个与num1中的值是完全独立的。</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-复制引用类型的变量\"><a href=\"#2-复制引用类型的变量\" class=\"headerlink\" title=\"2. 复制引用类型的变量\"></a>2. 复制引用类型的变量</h4><pre><code class=\"js\"><span class=\"keyword\">var</span> obj1 = {\n    age: <span class=\"number\">2</span>;\n}<span class=\"comment\">//创建了一个对象，并存储这个对象的内存地址赋给obj1</span>\n\n<span class=\"keyword\">var</span> obj2 = obj1;<span class=\"comment\">//将obj1指向的内存地址赋给obj2，因此obj1和obj2指向同一个内存</span>\n\n<span class=\"comment\">//若改变obj2.age的值</span>\nobj2.age = <span class=\"number\">3</span>;\n<span class=\"built_in\">console</span>.log(obj1.age);<span class=\"comment\">//3 因为obj1和obj2引用的是同一个对象</span>\n</code></pre>\n<h3 id=\"三-js中函数参数的传递\"><a href=\"#三-js中函数参数的传递\" class=\"headerlink\" title=\"三. js中函数参数的传递\"></a>三. js中函数参数的传递</h3><h4 id=\"1-传递的是基本类型的参数\"><a href=\"#1-传递的是基本类型的参数\" class=\"headerlink\" title=\"1. 传递的是基本类型的参数\"></a>1. 传递的是基本类型的参数</h4><p>函数传递的是基本类型的参数时，只是将传递的值复制给一个函数内部的局部变量（arguments对象中的一个元素），而原来那个变量没有变化。</p>\n<pre><code>eg:\nfunction addTen(num){\n  num+=10;\n  return num;\n}\nvar count=20;\nvar reslut=addTen(count);//30\nalert(count);//20 并没有变化\n</code></pre><h4 id=\"2-传递的是引用类型的参数时\"><a href=\"#2-传递的是引用类型的参数时\" class=\"headerlink\" title=\"2. 传递的是引用类型的参数时\"></a>2. 传递的是引用类型的参数时</h4><p>在向参数传递引用类型的值时，会把这个值在内存中的<strong>地址</strong>复制给函数中的局部变量（arguments对象中的一个元素），因此这个局部变量的变化会反映在函数的外部。</p>\n<pre><code> eg1:\n function setName(obj){\n   obj.name=&quot;ss&quot;;\n }\n var person=new Object();\n setName(person);//把person在内存中的地址复制给了obj，所以对obj的修改其实就是对外部person的修改\n alert(person.name);//&quot;ss&quot;\n\neg2:\nfunction setName(obj){\n  obj.name=&quot;ss&quot;;\n  obj=new Object();//相当于把新创建的对象地址赋值给了obj，因此下面对obj.name进行赋值不回影响person\n  obj.name=&quot;dd&quot;;\n}\nvar person=new Object();\nsetName(person);//将person的地址传给了obj\nalert(person.name)//&quot;ss&quot;\n\n\neg3:\nvar a={b:1};\nvar c=1;\nvar foo1 = function(value){\n   value=2;\n}\n\nfoo1(a.b);\nfoo1(c);\nconsole.log(a.b);//1\nconsole.log(c);//1\n\nvar foo2 = function(value){\n    value.b = 2;\n}\nfoo2(a);\nconsole.log(a.b);//2 按引用传\n</code></pre><h3 id=\"四-如何让引用类型赋值时也实现传值\"><a href=\"#四-如何让引用类型赋值时也实现传值\" class=\"headerlink\" title=\"四. 如何让引用类型赋值时也实现传值\"></a>四. 如何让引用类型赋值时也实现传值</h3><h4 id=\"1-遍历数组或对象，拆成一个个基本类型，然后进行赋值\"><a href=\"#1-遍历数组或对象，拆成一个个基本类型，然后进行赋值\" class=\"headerlink\" title=\"1. 遍历数组或对象，拆成一个个基本类型，然后进行赋值\"></a>1. 遍历数组或对象，拆成一个个基本类型，然后进行赋值</h4><p><strong>利用for… in…进行遍历</strong></p>\n<pre><code>eg:\n//遍历数组\nvar a = [&apos;o&apos;,&apos;p&apos;,&apos;q&apos;], c = [];\n\nfor(var i in a) {\n    c[i] = a[i];\n    typeof i; //String\n}\n\nc[2] = &apos;s&apos;;\nconsole.log(a[2]); //q\n\n//遍历对象\nvar b = {name: &quot;xiaoming&quot;,\n         age: 7,\n         tel: 12345\n    },\ne = {};\n\nfor(var i in b) {\n    e[i] = b[i];\n}\n\ne[name] = &apos;lala&apos;;\n\nconsole.log(b[name]); // xiaoming\n</code></pre><p> 但是一般还是不要使用for-in对数组进行遍历，其缺点有：</p>\n<p>（1）循环变量i的值不是数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。</p>\n<p>（2）作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。</p>\n<p>（3）最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。</p>\n<p>总之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。</p>\n<h4 id=\"2-数组实现传值的简单做法\"><a href=\"#2-数组实现传值的简单做法\" class=\"headerlink\" title=\"2. 数组实现传值的简单做法\"></a>2. 数组实现传值的简单做法</h4><p><strong>利用slice()和concat()函数</strong></p>\n<pre><code>由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值\n\neg:\n\nvar a = [1,2,3];\nvar b = a;\nb.push(4);\nconsole.log(a);//[1,2,3,4]，a也发生了变化\nconsole.log(b);//[1,2,3,4]\n\n利用slice()或者concat()让数组实现传值\nvar a = [1,2,3];\nvar b = a.slice();\nvar c = a.concat();\n\nb.push(4);\nc.push(5);\nconsole.log(a);//[1,2,3]\nconsole.log(b);//[1,2,3,4]\nconsole.log(c);//[1,2,3,5]\n\n//concat／slice对数组是深复制，但是对数组里面的对象是浅复制\nvar a = [{a:1}];\nvar b = a.slice();\nvar c = a.concat();\n\nb[0].a = 2;\nconsole.log(a[0].a); //2\n</code></pre>","excerpt":"","more":"<p>函数外部的值复制给函数内部的参数，就和把值从一个<strong>变量</strong>复制到另一个变量一样。</p>\n<h3 id=\"一-js里面变量的类型\"><a href=\"#一-js里面变量的类型\" class=\"headerlink\" title=\"一. js里面变量的类型\"></a>一. js里面变量的类型</h3><p>js里变量类型包括两种：基本类型值、引用类型值。</p>\n<p><strong>基本类型：</strong>简单的数据段。包括：undefined、Null、Boolean、Number、String（按值访问）</p>\n<p><strong>引用类型：</strong>指的是可能由多个值构成的对象。包括：对象、数组、日期、正则表达式、函数（按引用访问）</p>\n<h3 id=\"二-复制变量\"><a href=\"#二-复制变量\" class=\"headerlink\" title=\"二. 复制变量\"></a>二. 复制变量</h3><h4 id=\"1-复制基本类型的变量\"><a href=\"#1-复制基本类型的变量\" class=\"headerlink\" title=\"1. 复制基本类型的变量\"></a>1. 复制基本类型的变量</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num1 = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num2 = num1;<span class=\"comment\">//num2中保存的值也是5，但是这个与num1中的值是完全独立的。</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-复制引用类型的变量\"><a href=\"#2-复制引用类型的变量\" class=\"headerlink\" title=\"2. 复制引用类型的变量\"></a>2. 复制引用类型的变量</h4><pre><code class=\"js\"><span class=\"keyword\">var</span> obj1 = {\n    age: <span class=\"number\">2</span>;\n}<span class=\"comment\">//创建了一个对象，并存储这个对象的内存地址赋给obj1</span>\n\n<span class=\"keyword\">var</span> obj2 = obj1;<span class=\"comment\">//将obj1指向的内存地址赋给obj2，因此obj1和obj2指向同一个内存</span>\n\n<span class=\"comment\">//若改变obj2.age的值</span>\nobj2.age = <span class=\"number\">3</span>;\n<span class=\"built_in\">console</span>.log(obj1.age);<span class=\"comment\">//3 因为obj1和obj2引用的是同一个对象</span>\n</code></pre>\n<h3 id=\"三-js中函数参数的传递\"><a href=\"#三-js中函数参数的传递\" class=\"headerlink\" title=\"三. js中函数参数的传递\"></a>三. js中函数参数的传递</h3><h4 id=\"1-传递的是基本类型的参数\"><a href=\"#1-传递的是基本类型的参数\" class=\"headerlink\" title=\"1. 传递的是基本类型的参数\"></a>1. 传递的是基本类型的参数</h4><p>函数传递的是基本类型的参数时，只是将传递的值复制给一个函数内部的局部变量（arguments对象中的一个元素），而原来那个变量没有变化。</p>\n<pre><code>eg:\nfunction addTen(num){\n  num+=10;\n  return num;\n}\nvar count=20;\nvar reslut=addTen(count);//30\nalert(count);//20 并没有变化\n</code></pre><h4 id=\"2-传递的是引用类型的参数时\"><a href=\"#2-传递的是引用类型的参数时\" class=\"headerlink\" title=\"2. 传递的是引用类型的参数时\"></a>2. 传递的是引用类型的参数时</h4><p>在向参数传递引用类型的值时，会把这个值在内存中的<strong>地址</strong>复制给函数中的局部变量（arguments对象中的一个元素），因此这个局部变量的变化会反映在函数的外部。</p>\n<pre><code> eg1:\n function setName(obj){\n   obj.name=&quot;ss&quot;;\n }\n var person=new Object();\n setName(person);//把person在内存中的地址复制给了obj，所以对obj的修改其实就是对外部person的修改\n alert(person.name);//&quot;ss&quot;\n\neg2:\nfunction setName(obj){\n  obj.name=&quot;ss&quot;;\n  obj=new Object();//相当于把新创建的对象地址赋值给了obj，因此下面对obj.name进行赋值不回影响person\n  obj.name=&quot;dd&quot;;\n}\nvar person=new Object();\nsetName(person);//将person的地址传给了obj\nalert(person.name)//&quot;ss&quot;\n\n\neg3:\nvar a={b:1};\nvar c=1;\nvar foo1 = function(value){\n   value=2;\n}\n\nfoo1(a.b);\nfoo1(c);\nconsole.log(a.b);//1\nconsole.log(c);//1\n\nvar foo2 = function(value){\n    value.b = 2;\n}\nfoo2(a);\nconsole.log(a.b);//2 按引用传\n</code></pre><h3 id=\"四-如何让引用类型赋值时也实现传值\"><a href=\"#四-如何让引用类型赋值时也实现传值\" class=\"headerlink\" title=\"四. 如何让引用类型赋值时也实现传值\"></a>四. 如何让引用类型赋值时也实现传值</h3><h4 id=\"1-遍历数组或对象，拆成一个个基本类型，然后进行赋值\"><a href=\"#1-遍历数组或对象，拆成一个个基本类型，然后进行赋值\" class=\"headerlink\" title=\"1. 遍历数组或对象，拆成一个个基本类型，然后进行赋值\"></a>1. 遍历数组或对象，拆成一个个基本类型，然后进行赋值</h4><p><strong>利用for… in…进行遍历</strong></p>\n<pre><code>eg:\n//遍历数组\nvar a = [&apos;o&apos;,&apos;p&apos;,&apos;q&apos;], c = [];\n\nfor(var i in a) {\n    c[i] = a[i];\n    typeof i; //String\n}\n\nc[2] = &apos;s&apos;;\nconsole.log(a[2]); //q\n\n//遍历对象\nvar b = {name: &quot;xiaoming&quot;,\n         age: 7,\n         tel: 12345\n    },\ne = {};\n\nfor(var i in b) {\n    e[i] = b[i];\n}\n\ne[name] = &apos;lala&apos;;\n\nconsole.log(b[name]); // xiaoming\n</code></pre><p> 但是一般还是不要使用for-in对数组进行遍历，其缺点有：</p>\n<p>（1）循环变量i的值不是数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。</p>\n<p>（2）作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。</p>\n<p>（3）最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。</p>\n<p>总之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。</p>\n<h4 id=\"2-数组实现传值的简单做法\"><a href=\"#2-数组实现传值的简单做法\" class=\"headerlink\" title=\"2. 数组实现传值的简单做法\"></a>2. 数组实现传值的简单做法</h4><p><strong>利用slice()和concat()函数</strong></p>\n<pre><code>由于slice()和concat()都是会生成一个新的数组，因此可以利用这两个函数让数组传值\n\neg:\n\nvar a = [1,2,3];\nvar b = a;\nb.push(4);\nconsole.log(a);//[1,2,3,4]，a也发生了变化\nconsole.log(b);//[1,2,3,4]\n\n利用slice()或者concat()让数组实现传值\nvar a = [1,2,3];\nvar b = a.slice();\nvar c = a.concat();\n\nb.push(4);\nc.push(5);\nconsole.log(a);//[1,2,3]\nconsole.log(b);//[1,2,3,4]\nconsole.log(c);//[1,2,3,5]\n\n//concat／slice对数组是深复制，但是对数组里面的对象是浅复制\nvar a = [{a:1}];\nvar b = a.slice();\nvar c = a.concat();\n\nb[0].a = 2;\nconsole.log(a[0].a); //2\n</code></pre>"},{"layout":"post","title":"数组分块技术","date":"2016-05-09T16:00:00.000Z","description":null,"_content":"\n### 一. 浏览器中对js程序的限制\n\njs在浏览器中运行时，会被分配一个确定数量的资源。\n\n主要是在下面两个方面进行了限制：\n\n- 运行时间\n- 语句数量\n\n如果程序超过了限制，便会有一个弹出框，询问用户是否继续执行该段程序。\n\n使用定时器可以绕开这个弹出框\n\n### 二. 数组分块技术\n\n长时间的循环\n\n思想：将对整个数组的操作分割成一小块一小块来操作，可以使用setTimeout将每一次操作插入到消息队列中。\n\n```\nfunction chunk(array, process, context) {\n\tsetTimeout(function(){\n\t\t//获得数组的第一项\n\t\tvar item = array.shift();\n\t\t\n\t\t//对数组的第一项进行处理\n\t\tprocess.call(context,item);\n\t\t\n\t\tif(array.length > 0) {\n\t\t\t\n\t\t\t//arguments.callee指的是当前正在执行的函数\n\t\t\tsetTimeout(arguments.callee, 100);\n\t\t}\n\t\t\n\t}, 100);\n}\n\nvar names = ['a','b','c','d','e'],\n\ttodo = names.concat(); //复制数组\n\nchunk(todo, function(item) {\n\t\t...一些复杂的操作\n});\n```","source":"_posts/2016-05-10-数组分块.md","raw":"---\nlayout: post\ntitle: 数组分块技术\ndate: 2016-05-10\ncategories: javaScript\ntags: [javaScript,定时器]\ndescription: \n---\n\n### 一. 浏览器中对js程序的限制\n\njs在浏览器中运行时，会被分配一个确定数量的资源。\n\n主要是在下面两个方面进行了限制：\n\n- 运行时间\n- 语句数量\n\n如果程序超过了限制，便会有一个弹出框，询问用户是否继续执行该段程序。\n\n使用定时器可以绕开这个弹出框\n\n### 二. 数组分块技术\n\n长时间的循环\n\n思想：将对整个数组的操作分割成一小块一小块来操作，可以使用setTimeout将每一次操作插入到消息队列中。\n\n```\nfunction chunk(array, process, context) {\n\tsetTimeout(function(){\n\t\t//获得数组的第一项\n\t\tvar item = array.shift();\n\t\t\n\t\t//对数组的第一项进行处理\n\t\tprocess.call(context,item);\n\t\t\n\t\tif(array.length > 0) {\n\t\t\t\n\t\t\t//arguments.callee指的是当前正在执行的函数\n\t\t\tsetTimeout(arguments.callee, 100);\n\t\t}\n\t\t\n\t}, 100);\n}\n\nvar names = ['a','b','c','d','e'],\n\ttodo = names.concat(); //复制数组\n\nchunk(todo, function(item) {\n\t\t...一些复杂的操作\n});\n```","slug":"2016-05-10-数组分块","published":1,"updated":"2016-09-13T02:36:12.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocg1005kd5u8buidgoq1","content":"<h3 id=\"一-浏览器中对js程序的限制\"><a href=\"#一-浏览器中对js程序的限制\" class=\"headerlink\" title=\"一. 浏览器中对js程序的限制\"></a>一. 浏览器中对js程序的限制</h3><p>js在浏览器中运行时，会被分配一个确定数量的资源。</p>\n<p>主要是在下面两个方面进行了限制：</p>\n<ul>\n<li>运行时间</li>\n<li>语句数量</li>\n</ul>\n<p>如果程序超过了限制，便会有一个弹出框，询问用户是否继续执行该段程序。</p>\n<p>使用定时器可以绕开这个弹出框</p>\n<h3 id=\"二-数组分块技术\"><a href=\"#二-数组分块技术\" class=\"headerlink\" title=\"二. 数组分块技术\"></a>二. 数组分块技术</h3><p>长时间的循环</p>\n<p>思想：将对整个数组的操作分割成一小块一小块来操作，可以使用setTimeout将每一次操作插入到消息队列中。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chunk</span><span class=\"params\">(array, process, context)</span> </span>&#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//获得数组的第一项</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> item = <span class=\"keyword\">array</span>.shift();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//对数组的第一项进行处理</span></span><br><span class=\"line\">\t\tprocess.call(context,item);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">array</span>.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//arguments.callee指的是当前正在执行的函数</span></span><br><span class=\"line\">\t\t\tsetTimeout(arguments.callee, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> names = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>],</span><br><span class=\"line\">\ttodo = names.concat(); <span class=\"comment\">//复制数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">chunk(todo, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(item)</span> </span>&#123;</span><br><span class=\"line\">\t\t...一些复杂的操作</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-浏览器中对js程序的限制\"><a href=\"#一-浏览器中对js程序的限制\" class=\"headerlink\" title=\"一. 浏览器中对js程序的限制\"></a>一. 浏览器中对js程序的限制</h3><p>js在浏览器中运行时，会被分配一个确定数量的资源。</p>\n<p>主要是在下面两个方面进行了限制：</p>\n<ul>\n<li>运行时间</li>\n<li>语句数量</li>\n</ul>\n<p>如果程序超过了限制，便会有一个弹出框，询问用户是否继续执行该段程序。</p>\n<p>使用定时器可以绕开这个弹出框</p>\n<h3 id=\"二-数组分块技术\"><a href=\"#二-数组分块技术\" class=\"headerlink\" title=\"二. 数组分块技术\"></a>二. 数组分块技术</h3><p>长时间的循环</p>\n<p>思想：将对整个数组的操作分割成一小块一小块来操作，可以使用setTimeout将每一次操作插入到消息队列中。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chunk</span><span class=\"params\">(array, process, context)</span> </span>&#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//获得数组的第一项</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> item = <span class=\"keyword\">array</span>.shift();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//对数组的第一项进行处理</span></span><br><span class=\"line\">\t\tprocess.call(context,item);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">array</span>.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//arguments.callee指的是当前正在执行的函数</span></span><br><span class=\"line\">\t\t\tsetTimeout(arguments.callee, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> names = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>,<span class=\"string\">'e'</span>],</span><br><span class=\"line\">\ttodo = names.concat(); <span class=\"comment\">//复制数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">chunk(todo, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(item)</span> </span>&#123;</span><br><span class=\"line\">\t\t...一些复杂的操作</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"听指令的小方块","date":"2016-05-12T16:00:00.000Z","description":null,"_content":"\n### 一. 听指令的小方块\n\nDemo地址：[http://panpanfish.com/myDemo/instruct-block.html](http://panpanfish.com/myDemo/instruct-block.html \"听指令的小方块\")\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html](https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html \"听指令的小方块\")\n\n### 二. 遇到的问题\n\n#### 1. setTimeout问题\n\n**实现小方块的功能：**让小方块**移动**之后再让让小方块**旋转**\n\n为了说明遇到的问题，下面是一个简化版程序\n\n```js\n    <div id=\"box\" style=\"position:absolute;left:100px;width:200px;height:200px;background:#000;transform:rotate(5deg);\">\n    </div>\n\n\tfunction A(i){\n\t\t//旋转\n\t\tvar j = parseInt(box.style.left);\n\t\tfunction Af(){\n\t\t    j++;\n\t\t    box.style.left = j +\"px\";\n\t\t    console.log(\"j\"+box.style.left);\n\t\t    //console.log((Af());\n\t\t    if(j < 205){\n\t\t    \t\t\tsetTimeout(Af,20);\n\t\t    }\n\t\t    \t\t\t\n\t\t }\n\n\t\t if(i == 1){\n\t\t    \t\t Af();\n\t\t }\n\t\t    \t\t\n\t}\n\t\n\tfunction B(i){\n\t\t\t//移动\n\t\t    var k = parseFloat(box.style.transform.substring(box.style.transform.indexOf(\"(\")+1,box.style.transform.indexOf(\")\")));\n\n\t\t    function Bf(){\n\t\t    \t\t\tk++;\n\t\t    \t\t\tbox.style.transform = \"rotate(\"+k+\"deg)\";\n\t\t    \t\t\tconsole.log(\"k\"+box.style.transform);\n\t\t    \t\t\tif(k < 10){\n\t\t    \t\t\t\tsetTimeout(Bf,20);\n\t\t    \t\t\t}\n\t\t    \t\t\t\n\t\t    }\n\n\t\t    if(i == 1){\n\t\t    \t\t\tBf();\n\t\t    }\n\t}\n\t\n\tA(1);//\n\tconsole.log(\"分割\");\n\tB(1);//\n```\n\n这样写之后，发现小方块并不是先移动，后旋转的\n\n\n    输出为：\n    j201px \n    分割 \n    krotate(6deg) \n    j202px \n    krotate(7deg) \n    j203px \n    krotate(8deg) \n    j204px \n    krotate(9deg) \n    j205px \n    krotate(10deg)\n\n\n**出现上面的情况的原因：**\n\nsetTimeout捣的鬼，由于setTimeout是将回调函数放在任务队列中，在指定的时间之后执行（如果任务队列前没有其他任务，且主线程处于空闲状态）。\n\n**上述代码执行过程为：**\n\n    A(1) -> Af()[将Af()放到任务队列，时延为20ms] -> 输出分割 -> B(1) -> Bf()[将Bf()放到任务队列，时延为20ms]  \n    \n    主线程为空\n    \n    执行任务队列里面的最前面的一个任务Af()[将Af()放到任务队列，时延为20ms]\n    \n    .\n    .\n    .\n    依此类推\n\n若要让程序按照我们想要的方式执行，可采用如下方法：\n\n\n    setTimeout(function(){\n    \tA(1);\n    },0);\n    \n    console.log(\"分割\");\n    \n    setTimeout(function(){\n    \tB(1);\n    },120);//让B在A中插入任务队列的任务执行完之后再执行\n\n\n这样运行的效果就是我们想要的，输出结果如下：\n\n```js\n    分割 \n    j201px \n    j202px \n    j203px \n    j204px \n    j205px \n    krotate(6deg) \n    krotate(7deg) \n    krotate(8deg) \n    krotate(9deg) \n    krotate(10deg) \n```\n\t\n\n\n\n\n","source":"_posts/2016-05-13-听指令的小方块.md","raw":"---\nlayout: post\ntitle: 听指令的小方块\ndate: 2016-05-13\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n### 一. 听指令的小方块\n\nDemo地址：[http://panpanfish.com/myDemo/instruct-block.html](http://panpanfish.com/myDemo/instruct-block.html \"听指令的小方块\")\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html](https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html \"听指令的小方块\")\n\n### 二. 遇到的问题\n\n#### 1. setTimeout问题\n\n**实现小方块的功能：**让小方块**移动**之后再让让小方块**旋转**\n\n为了说明遇到的问题，下面是一个简化版程序\n\n```js\n    <div id=\"box\" style=\"position:absolute;left:100px;width:200px;height:200px;background:#000;transform:rotate(5deg);\">\n    </div>\n\n\tfunction A(i){\n\t\t//旋转\n\t\tvar j = parseInt(box.style.left);\n\t\tfunction Af(){\n\t\t    j++;\n\t\t    box.style.left = j +\"px\";\n\t\t    console.log(\"j\"+box.style.left);\n\t\t    //console.log((Af());\n\t\t    if(j < 205){\n\t\t    \t\t\tsetTimeout(Af,20);\n\t\t    }\n\t\t    \t\t\t\n\t\t }\n\n\t\t if(i == 1){\n\t\t    \t\t Af();\n\t\t }\n\t\t    \t\t\n\t}\n\t\n\tfunction B(i){\n\t\t\t//移动\n\t\t    var k = parseFloat(box.style.transform.substring(box.style.transform.indexOf(\"(\")+1,box.style.transform.indexOf(\")\")));\n\n\t\t    function Bf(){\n\t\t    \t\t\tk++;\n\t\t    \t\t\tbox.style.transform = \"rotate(\"+k+\"deg)\";\n\t\t    \t\t\tconsole.log(\"k\"+box.style.transform);\n\t\t    \t\t\tif(k < 10){\n\t\t    \t\t\t\tsetTimeout(Bf,20);\n\t\t    \t\t\t}\n\t\t    \t\t\t\n\t\t    }\n\n\t\t    if(i == 1){\n\t\t    \t\t\tBf();\n\t\t    }\n\t}\n\t\n\tA(1);//\n\tconsole.log(\"分割\");\n\tB(1);//\n```\n\n这样写之后，发现小方块并不是先移动，后旋转的\n\n\n    输出为：\n    j201px \n    分割 \n    krotate(6deg) \n    j202px \n    krotate(7deg) \n    j203px \n    krotate(8deg) \n    j204px \n    krotate(9deg) \n    j205px \n    krotate(10deg)\n\n\n**出现上面的情况的原因：**\n\nsetTimeout捣的鬼，由于setTimeout是将回调函数放在任务队列中，在指定的时间之后执行（如果任务队列前没有其他任务，且主线程处于空闲状态）。\n\n**上述代码执行过程为：**\n\n    A(1) -> Af()[将Af()放到任务队列，时延为20ms] -> 输出分割 -> B(1) -> Bf()[将Bf()放到任务队列，时延为20ms]  \n    \n    主线程为空\n    \n    执行任务队列里面的最前面的一个任务Af()[将Af()放到任务队列，时延为20ms]\n    \n    .\n    .\n    .\n    依此类推\n\n若要让程序按照我们想要的方式执行，可采用如下方法：\n\n\n    setTimeout(function(){\n    \tA(1);\n    },0);\n    \n    console.log(\"分割\");\n    \n    setTimeout(function(){\n    \tB(1);\n    },120);//让B在A中插入任务队列的任务执行完之后再执行\n\n\n这样运行的效果就是我们想要的，输出结果如下：\n\n```js\n    分割 \n    j201px \n    j202px \n    j203px \n    j204px \n    j205px \n    krotate(6deg) \n    krotate(7deg) \n    krotate(8deg) \n    krotate(9deg) \n    krotate(10deg) \n```\n\t\n\n\n\n\n","slug":"2016-05-13-听指令的小方块","published":1,"updated":"2016-08-23T06:28:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocg3005nd5u8olpgoria","content":"<h3 id=\"一-听指令的小方块\"><a href=\"#一-听指令的小方块\" class=\"headerlink\" title=\"一. 听指令的小方块\"></a>一. 听指令的小方块</h3><p>Demo地址：<a href=\"http://panpanfish.com/myDemo/instruct-block.html\" title=\"听指令的小方块\">http://panpanfish.com/myDemo/instruct-block.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html\" title=\"听指令的小方块\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html</a></p>\n<h3 id=\"二-遇到的问题\"><a href=\"#二-遇到的问题\" class=\"headerlink\" title=\"二. 遇到的问题\"></a>二. 遇到的问题</h3><h4 id=\"1-setTimeout问题\"><a href=\"#1-setTimeout问题\" class=\"headerlink\" title=\"1. setTimeout问题\"></a>1. setTimeout问题</h4><p><strong>实现小方块的功能：</strong>让小方块<strong>移动</strong>之后再让让小方块<strong>旋转</strong></p>\n<p>为了说明遇到的问题，下面是一个简化版程序</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   &lt;div id=<span class=\"string\">\"box\"</span> style=<span class=\"string\">\"position:absolute;left:100px;width:200px;height:200px;background:#000;transform:rotate(5deg);\"</span>&gt;</span><br><span class=\"line\">   <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">i</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//旋转</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> j = <span class=\"built_in\">parseInt</span>(box.style.left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Af</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t    j++;</span><br><span class=\"line\">\t    box.style.left = j +<span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"j\"</span>+box.style.left);</span><br><span class=\"line\">\t    <span class=\"comment\">//console.log((Af());</span></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(j &lt; <span class=\"number\">205</span>)&#123;</span><br><span class=\"line\">\t    \t\t\tsetTimeout(Af,<span class=\"number\">20</span>);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    \t\t\t</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t    \t\t Af();</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t    \t\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">i</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//移动</span></span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> k = <span class=\"built_in\">parseFloat</span>(box.style.transform.substring(box.style.transform.indexOf(<span class=\"string\">\"(\"</span>)+<span class=\"number\">1</span>,box.style.transform.indexOf(<span class=\"string\">\")\"</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bf</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t    \t\t\tk++;</span><br><span class=\"line\">\t    \t\t\tbox.style.transform = <span class=\"string\">\"rotate(\"</span>+k+<span class=\"string\">\"deg)\"</span>;</span><br><span class=\"line\">\t    \t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"k\"</span>+box.style.transform);</span><br><span class=\"line\">\t    \t\t\t<span class=\"keyword\">if</span>(k &lt; <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">\t    \t\t\t\tsetTimeout(Bf,<span class=\"number\">20</span>);</span><br><span class=\"line\">\t    \t\t\t&#125;</span><br><span class=\"line\">\t    \t\t\t</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t    \t\t\tBf();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A(<span class=\"number\">1</span>);<span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"分割\"</span>);</span><br><span class=\"line\">B(<span class=\"number\">1</span>);<span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>这样写之后，发现小方块并不是先移动，后旋转的</p>\n<pre><code>输出为：\nj201px \n分割 \nkrotate(6deg) \nj202px \nkrotate(7deg) \nj203px \nkrotate(8deg) \nj204px \nkrotate(9deg) \nj205px \nkrotate(10deg)\n</code></pre><p><strong>出现上面的情况的原因：</strong></p>\n<p>setTimeout捣的鬼，由于setTimeout是将回调函数放在任务队列中，在指定的时间之后执行（如果任务队列前没有其他任务，且主线程处于空闲状态）。</p>\n<p><strong>上述代码执行过程为：</strong></p>\n<pre><code>A(1) -&gt; Af()[将Af()放到任务队列，时延为20ms] -&gt; 输出分割 -&gt; B(1) -&gt; Bf()[将Bf()放到任务队列，时延为20ms]  \n\n主线程为空\n\n执行任务队列里面的最前面的一个任务Af()[将Af()放到任务队列，时延为20ms]\n\n.\n.\n.\n依此类推\n</code></pre><p>若要让程序按照我们想要的方式执行，可采用如下方法：</p>\n<pre><code>setTimeout(function(){\n    A(1);\n},0);\n\nconsole.log(&quot;分割&quot;);\n\nsetTimeout(function(){\n    B(1);\n},120);//让B在A中插入任务队列的任务执行完之后再执行\n</code></pre><p>这样运行的效果就是我们想要的，输出结果如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分割 </span><br><span class=\"line\">j201px </span><br><span class=\"line\">j202px </span><br><span class=\"line\">j203px </span><br><span class=\"line\">j204px </span><br><span class=\"line\">j205px </span><br><span class=\"line\">krotate(<span class=\"number\">6</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">7</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">8</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">9</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">10</span>deg)</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-听指令的小方块\"><a href=\"#一-听指令的小方块\" class=\"headerlink\" title=\"一. 听指令的小方块\"></a>一. 听指令的小方块</h3><p>Demo地址：<a href=\"http://panpanfish.com/myDemo/instruct-block.html\" title=\"听指令的小方块\">http://panpanfish.com/myDemo/instruct-block.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html\" title=\"听指令的小方块\">https://github.com/panpan040828/myDemo/blob/gh-pages/instruct-block.html</a></p>\n<h3 id=\"二-遇到的问题\"><a href=\"#二-遇到的问题\" class=\"headerlink\" title=\"二. 遇到的问题\"></a>二. 遇到的问题</h3><h4 id=\"1-setTimeout问题\"><a href=\"#1-setTimeout问题\" class=\"headerlink\" title=\"1. setTimeout问题\"></a>1. setTimeout问题</h4><p><strong>实现小方块的功能：</strong>让小方块<strong>移动</strong>之后再让让小方块<strong>旋转</strong></p>\n<p>为了说明遇到的问题，下面是一个简化版程序</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   &lt;div id=<span class=\"string\">\"box\"</span> style=<span class=\"string\">\"position:absolute;left:100px;width:200px;height:200px;background:#000;transform:rotate(5deg);\"</span>&gt;</span><br><span class=\"line\">   <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">i</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//旋转</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> j = <span class=\"built_in\">parseInt</span>(box.style.left);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Af</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t    j++;</span><br><span class=\"line\">\t    box.style.left = j +<span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"j\"</span>+box.style.left);</span><br><span class=\"line\">\t    <span class=\"comment\">//console.log((Af());</span></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(j &lt; <span class=\"number\">205</span>)&#123;</span><br><span class=\"line\">\t    \t\t\tsetTimeout(Af,<span class=\"number\">20</span>);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    \t\t\t</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t    \t\t Af();</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t    \t\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\">i</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//移动</span></span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> k = <span class=\"built_in\">parseFloat</span>(box.style.transform.substring(box.style.transform.indexOf(<span class=\"string\">\"(\"</span>)+<span class=\"number\">1</span>,box.style.transform.indexOf(<span class=\"string\">\")\"</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bf</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t    \t\t\tk++;</span><br><span class=\"line\">\t    \t\t\tbox.style.transform = <span class=\"string\">\"rotate(\"</span>+k+<span class=\"string\">\"deg)\"</span>;</span><br><span class=\"line\">\t    \t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"k\"</span>+box.style.transform);</span><br><span class=\"line\">\t    \t\t\t<span class=\"keyword\">if</span>(k &lt; <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">\t    \t\t\t\tsetTimeout(Bf,<span class=\"number\">20</span>);</span><br><span class=\"line\">\t    \t\t\t&#125;</span><br><span class=\"line\">\t    \t\t\t</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t    \t\t\tBf();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A(<span class=\"number\">1</span>);<span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"分割\"</span>);</span><br><span class=\"line\">B(<span class=\"number\">1</span>);<span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>这样写之后，发现小方块并不是先移动，后旋转的</p>\n<pre><code>输出为：\nj201px \n分割 \nkrotate(6deg) \nj202px \nkrotate(7deg) \nj203px \nkrotate(8deg) \nj204px \nkrotate(9deg) \nj205px \nkrotate(10deg)\n</code></pre><p><strong>出现上面的情况的原因：</strong></p>\n<p>setTimeout捣的鬼，由于setTimeout是将回调函数放在任务队列中，在指定的时间之后执行（如果任务队列前没有其他任务，且主线程处于空闲状态）。</p>\n<p><strong>上述代码执行过程为：</strong></p>\n<pre><code>A(1) -&gt; Af()[将Af()放到任务队列，时延为20ms] -&gt; 输出分割 -&gt; B(1) -&gt; Bf()[将Bf()放到任务队列，时延为20ms]  \n\n主线程为空\n\n执行任务队列里面的最前面的一个任务Af()[将Af()放到任务队列，时延为20ms]\n\n.\n.\n.\n依此类推\n</code></pre><p>若要让程序按照我们想要的方式执行，可采用如下方法：</p>\n<pre><code>setTimeout(function(){\n    A(1);\n},0);\n\nconsole.log(&quot;分割&quot;);\n\nsetTimeout(function(){\n    B(1);\n},120);//让B在A中插入任务队列的任务执行完之后再执行\n</code></pre><p>这样运行的效果就是我们想要的，输出结果如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分割 </span><br><span class=\"line\">j201px </span><br><span class=\"line\">j202px </span><br><span class=\"line\">j203px </span><br><span class=\"line\">j204px </span><br><span class=\"line\">j205px </span><br><span class=\"line\">krotate(<span class=\"number\">6</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">7</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">8</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">9</span>deg) </span><br><span class=\"line\">krotate(<span class=\"number\">10</span>deg)</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"js中的同步和异步执行","date":"2016-05-12T16:00:00.000Z","description":null,"_content":"\n### 一. js引擎是单线程\n\njs是以单线程的方式执行，但是其运行环境浏览器却是多线程的。\n\n#### 1. 浏览器是多线程的\n\n**浏览器多线程包括：**\n\n- javascript引擎线程\n- 界面渲染线程\n- 浏览器事件触发线程\n- Http请求线程\n\njs引擎线程只是浏览器多线程中的一个线程。\n\n#### 2. js引擎是单线程的\n\n我理解的单线程指的是，某一时刻内只能执行特定的一个任务，就像排队一样，某一时间只有一个人在办理业务。所以只有等一个任务执行完了之后才会执行另外一个任务。\n\n**单线程执行的原因**：由于js主要是与用户互动、操作DOM，若以多线程的方式执行，会造成操作中的冲突。\n\n**单线程造成的问题：**单线程执行很容易造成线程阻塞，当遇到一个很费时的任务时，这时其他的任务就被阻塞了。\n\n因此，当遇到一个很费时的操作时，不必等他们执行完之后再执行后面的操作；在这些任务完成前，JavaScript完全可以往下执行其他操作，当这些耗时的任务完成后则以回调的方式执行相应处理。这些就是JavaScript与生俱来的特性：**异步与回调**。\n\n>当然对于不可避免的耗时操作（如：繁重的运算，多重循环），HTML5提出了Web Worker，它会在当前JavaScript的执行主线程中利用Worker类新开辟一个额外的线程来加载和运行特定的JavaScript文件，这个新的线程和JavaScript的主线程之间并不会互相影响和阻塞执行，而且在Web Worker中提供了这个新线程和JavaScript主线程之间数据交换的接口：postMessage和onMessage事件。但在HTML5 Web Worker中是不能操作DOM的，任何需要操作DOM的任务都需要委托给JavaScript主线程来执行，所以虽然引入HTML5 Web Worker，但仍然没有改线JavaScript单线程的本质。\n\n### 二. js中的同步执行和异步执行\n\n**1. js的执行引擎分两个序列：**\n\n- 主线程：任务都会在主线程中执行\n- 事件队列：onclick, ajax, setTimeout, setInterval都会将任务放到事件队列里，然后等到主线程为空时，将队列中的任务取出，放在主线程中执行\n\n**2. 为了方便描述与理解，作出以下约定：**\n\n- Stack栈为主线程\n- Queue队列为任务队列（等待调度到主线程执行）\n\n**3. Javascript将任务的执行模式分成两种：同步、异步。**\n\n同步、异步指的是**代码顺序**和**任务执行顺序**是否是同步的。\n\n- 同步模式：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。\n\n- 异步模式：每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\njs引擎单线程执行的,它是基于**事件驱动**的语言。\n\n它的执行顺序是遵循一个叫做事件队列的机制。\n\n浏览器有各种各样的线程,比如事件触发器（onclick）,网络请求(ajax),定时器(setTimeout、setInterval)等等。线程的联系都是基于事件的。\n\njs引擎处理到与其他线程相关的代码,就会分发给其他线程,他们处理完之后,需要js引擎计算时就是在事件队列里面添加一个任务。\n\n这个过程中,js并不会阻塞代码等待其他线程执行完毕,而且其他线程执行完毕后添加事件任务告诉js引擎执行相关操作.这就是js的**异步编程模型**。\n\n**4. js中对dom的操作是异步的**\n\n浏览器的另外一个引擎——>**GUI渲染引擎**。 在js中渲染操作也是异步的，比如dom操作的代码会在事件队列中生成一个任务,js执行到这个任务时就会去调用GUI引擎渲染。\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title></title>\n\t</head>\n\t<body>\n\t    <table border=1>\n\t        <tr><td><button id='do'>Do long calc - bad status!</button></td>\n\t            <td><div id='status'>Not Calculating yet.</div></td>\n\t        </tr>\n\t        <tr><td><button id='do_ok'>Do long calc - good status!</button></td>\n\t            <td><div id='status_ok'>Not Calculating yet.</div></td>\n\t        </tr>\n\t    </table>    \n\t<script>\n\t\n\tfunction long_running(status_div) {\n\t\n\t    var result = 0;\n\t    for (var i = 0; i < 1000; i++) {\n\t        for (var j = 0; j < 700; j++) {\n\t            for (var k = 0; k < 300; k++) {\n\t                result = result + i + j + k;\n\t            }\n\t        }\n\t    }\n\t    document.querySelector(status_div).innerHTML = 'calclation done' ;\n\t}\n\t\n\tdocument.querySelector('#do').onclick = function () {\n\t    document.querySelector('#status').innerHTML = 'calculating....';\n\t    long_running('#status');\n\t};\n\t\n\tdocument.querySelector('#do_ok').onclick = function () {\n\t    document.querySelector('#status_ok').innerHTML = 'calculating....';\n\t    window.setTimeout(function (){ long_running('#status_ok') }, 0);\n\t};\n\t\n\t</script>\n\t</body>\n\t</html>\n\n我们希望能看到计算的每一个过程,我们在程序开始,计算,结束时,都执行了一个dom操作,插入了代表当前状态的字符串,Not Calculating yet.和calculating....和calclation done.计算中是一个耗时的3重for循环. 在没有使用settimeout的时候,执行结果是由Not Calculating yet 直接跳到了calclation done.这显然不是我们希望的.而造成这样结果的原因正是js的事件循环单线程机制.dom操作是异步的,for循环计算是同步的.异步操作都会被延迟到同步计算之后执行.也就是代码的执行顺序变了.calculating....和calclation done的dom操作都被放到事件队列后面而且紧跟在一起,造成了丢帧.无法实时的反应.这个例子也告诉了我们,在需要实时反馈的操作,如渲染等,和其他相关同步的代码,要么一起同步,要么一起异步才能保证代码的执行顺序.在js中,就只能让同步代码也异步.即给for计算加上settimeout.\n\n### 三. js中的回调\n\n回调不一定是异步的\n\n\t\t/****************** 同步回调 ************************/\n\t\tvar syncFun = function(callback) {\n\t\t    var start = new Date();\n\t\t    while(new Date() - start < 1000) { // delay 1 sec\n\t\t        ;\n\t\t    }\n\t\t    callback();\n\t\t    console.log('同步方法返回'); // 2\n\t\t};\n\n\t\tsyncFun(function() {\n\t\t    console.log('这是同步回调'); // 1\n\t\t});\n\t\tconsole.log('同步方法会阻塞当前逻辑'); // 3\n\n\t\t/****************** 异步回调 ************************/\n\t\tvar asyncFun = function(callback) {\n\t\t    setTimeout(callback, 1000); // delay 1 sec\n\t\t    console.log('异步方法返回'); // 4\n\t\t};\n\t\tasyncFun(function() {\n\t\t    console.log('这是异步回调'); // 6\n\t\t});\n\t\tconsole.log('异步方法不会阻塞当前逻辑'); // 5\n\n不能光看调用的形式，要看实际调用代码的实现方式\n\t\n\teg1:\n\tfunction A(){\n\t setTimeout(function(){\n\t   console.log('~~A~~');\n\t  },1000);\n\t}\n\t\n\tfunction B(){\n\t setTimeout(function(){\n\t   console.log('~~B~~');\n\t  },100);\n\t}\n\t\n\tfunction C(){\n\t setTimeout(function(){\n\t   console.log('~~C~~');\n\t  },2000);\n\t}\n\t\n\tfunction D(){\n\t    console.log('~~D~~');\n\t}\n\t\n\tfunction E(){\n\t    console.log('~~E~~');\n\t}\n\t\n\tA();\n\tB();\n\tC();\n\tD();\n\tE();\n\t//输出结果为 ~~D~~/~~E~~/~~B~~/~~A~~/~~C~~\n\n\t例一中，A/B/C/D/E函数将按代码的书写顺序顺序执行，但并不是说各个函数的内部代码的执行顺序和调用顺序相同。要具体看各个函数的实现\n\n\t\n\n\n\n\n","source":"_posts/2016-05-13-js中的同步和异步执行.md","raw":"---\nlayout: post\ntitle: js中的同步和异步执行\ndate: 2016-05-13\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\n### 一. js引擎是单线程\n\njs是以单线程的方式执行，但是其运行环境浏览器却是多线程的。\n\n#### 1. 浏览器是多线程的\n\n**浏览器多线程包括：**\n\n- javascript引擎线程\n- 界面渲染线程\n- 浏览器事件触发线程\n- Http请求线程\n\njs引擎线程只是浏览器多线程中的一个线程。\n\n#### 2. js引擎是单线程的\n\n我理解的单线程指的是，某一时刻内只能执行特定的一个任务，就像排队一样，某一时间只有一个人在办理业务。所以只有等一个任务执行完了之后才会执行另外一个任务。\n\n**单线程执行的原因**：由于js主要是与用户互动、操作DOM，若以多线程的方式执行，会造成操作中的冲突。\n\n**单线程造成的问题：**单线程执行很容易造成线程阻塞，当遇到一个很费时的任务时，这时其他的任务就被阻塞了。\n\n因此，当遇到一个很费时的操作时，不必等他们执行完之后再执行后面的操作；在这些任务完成前，JavaScript完全可以往下执行其他操作，当这些耗时的任务完成后则以回调的方式执行相应处理。这些就是JavaScript与生俱来的特性：**异步与回调**。\n\n>当然对于不可避免的耗时操作（如：繁重的运算，多重循环），HTML5提出了Web Worker，它会在当前JavaScript的执行主线程中利用Worker类新开辟一个额外的线程来加载和运行特定的JavaScript文件，这个新的线程和JavaScript的主线程之间并不会互相影响和阻塞执行，而且在Web Worker中提供了这个新线程和JavaScript主线程之间数据交换的接口：postMessage和onMessage事件。但在HTML5 Web Worker中是不能操作DOM的，任何需要操作DOM的任务都需要委托给JavaScript主线程来执行，所以虽然引入HTML5 Web Worker，但仍然没有改线JavaScript单线程的本质。\n\n### 二. js中的同步执行和异步执行\n\n**1. js的执行引擎分两个序列：**\n\n- 主线程：任务都会在主线程中执行\n- 事件队列：onclick, ajax, setTimeout, setInterval都会将任务放到事件队列里，然后等到主线程为空时，将队列中的任务取出，放在主线程中执行\n\n**2. 为了方便描述与理解，作出以下约定：**\n\n- Stack栈为主线程\n- Queue队列为任务队列（等待调度到主线程执行）\n\n**3. Javascript将任务的执行模式分成两种：同步、异步。**\n\n同步、异步指的是**代码顺序**和**任务执行顺序**是否是同步的。\n\n- 同步模式：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。\n\n- 异步模式：每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\njs引擎单线程执行的,它是基于**事件驱动**的语言。\n\n它的执行顺序是遵循一个叫做事件队列的机制。\n\n浏览器有各种各样的线程,比如事件触发器（onclick）,网络请求(ajax),定时器(setTimeout、setInterval)等等。线程的联系都是基于事件的。\n\njs引擎处理到与其他线程相关的代码,就会分发给其他线程,他们处理完之后,需要js引擎计算时就是在事件队列里面添加一个任务。\n\n这个过程中,js并不会阻塞代码等待其他线程执行完毕,而且其他线程执行完毕后添加事件任务告诉js引擎执行相关操作.这就是js的**异步编程模型**。\n\n**4. js中对dom的操作是异步的**\n\n浏览器的另外一个引擎——>**GUI渲染引擎**。 在js中渲染操作也是异步的，比如dom操作的代码会在事件队列中生成一个任务,js执行到这个任务时就会去调用GUI引擎渲染。\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title></title>\n\t</head>\n\t<body>\n\t    <table border=1>\n\t        <tr><td><button id='do'>Do long calc - bad status!</button></td>\n\t            <td><div id='status'>Not Calculating yet.</div></td>\n\t        </tr>\n\t        <tr><td><button id='do_ok'>Do long calc - good status!</button></td>\n\t            <td><div id='status_ok'>Not Calculating yet.</div></td>\n\t        </tr>\n\t    </table>    \n\t<script>\n\t\n\tfunction long_running(status_div) {\n\t\n\t    var result = 0;\n\t    for (var i = 0; i < 1000; i++) {\n\t        for (var j = 0; j < 700; j++) {\n\t            for (var k = 0; k < 300; k++) {\n\t                result = result + i + j + k;\n\t            }\n\t        }\n\t    }\n\t    document.querySelector(status_div).innerHTML = 'calclation done' ;\n\t}\n\t\n\tdocument.querySelector('#do').onclick = function () {\n\t    document.querySelector('#status').innerHTML = 'calculating....';\n\t    long_running('#status');\n\t};\n\t\n\tdocument.querySelector('#do_ok').onclick = function () {\n\t    document.querySelector('#status_ok').innerHTML = 'calculating....';\n\t    window.setTimeout(function (){ long_running('#status_ok') }, 0);\n\t};\n\t\n\t</script>\n\t</body>\n\t</html>\n\n我们希望能看到计算的每一个过程,我们在程序开始,计算,结束时,都执行了一个dom操作,插入了代表当前状态的字符串,Not Calculating yet.和calculating....和calclation done.计算中是一个耗时的3重for循环. 在没有使用settimeout的时候,执行结果是由Not Calculating yet 直接跳到了calclation done.这显然不是我们希望的.而造成这样结果的原因正是js的事件循环单线程机制.dom操作是异步的,for循环计算是同步的.异步操作都会被延迟到同步计算之后执行.也就是代码的执行顺序变了.calculating....和calclation done的dom操作都被放到事件队列后面而且紧跟在一起,造成了丢帧.无法实时的反应.这个例子也告诉了我们,在需要实时反馈的操作,如渲染等,和其他相关同步的代码,要么一起同步,要么一起异步才能保证代码的执行顺序.在js中,就只能让同步代码也异步.即给for计算加上settimeout.\n\n### 三. js中的回调\n\n回调不一定是异步的\n\n\t\t/****************** 同步回调 ************************/\n\t\tvar syncFun = function(callback) {\n\t\t    var start = new Date();\n\t\t    while(new Date() - start < 1000) { // delay 1 sec\n\t\t        ;\n\t\t    }\n\t\t    callback();\n\t\t    console.log('同步方法返回'); // 2\n\t\t};\n\n\t\tsyncFun(function() {\n\t\t    console.log('这是同步回调'); // 1\n\t\t});\n\t\tconsole.log('同步方法会阻塞当前逻辑'); // 3\n\n\t\t/****************** 异步回调 ************************/\n\t\tvar asyncFun = function(callback) {\n\t\t    setTimeout(callback, 1000); // delay 1 sec\n\t\t    console.log('异步方法返回'); // 4\n\t\t};\n\t\tasyncFun(function() {\n\t\t    console.log('这是异步回调'); // 6\n\t\t});\n\t\tconsole.log('异步方法不会阻塞当前逻辑'); // 5\n\n不能光看调用的形式，要看实际调用代码的实现方式\n\t\n\teg1:\n\tfunction A(){\n\t setTimeout(function(){\n\t   console.log('~~A~~');\n\t  },1000);\n\t}\n\t\n\tfunction B(){\n\t setTimeout(function(){\n\t   console.log('~~B~~');\n\t  },100);\n\t}\n\t\n\tfunction C(){\n\t setTimeout(function(){\n\t   console.log('~~C~~');\n\t  },2000);\n\t}\n\t\n\tfunction D(){\n\t    console.log('~~D~~');\n\t}\n\t\n\tfunction E(){\n\t    console.log('~~E~~');\n\t}\n\t\n\tA();\n\tB();\n\tC();\n\tD();\n\tE();\n\t//输出结果为 ~~D~~/~~E~~/~~B~~/~~A~~/~~C~~\n\n\t例一中，A/B/C/D/E函数将按代码的书写顺序顺序执行，但并不是说各个函数的内部代码的执行顺序和调用顺序相同。要具体看各个函数的实现\n\n\t\n\n\n\n\n","slug":"2016-05-13-js中的同步和异步执行","published":1,"updated":"2016-08-11T06:48:40.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocg5005rd5u8zzpcwqjn","content":"<h3 id=\"一-js引擎是单线程\"><a href=\"#一-js引擎是单线程\" class=\"headerlink\" title=\"一. js引擎是单线程\"></a>一. js引擎是单线程</h3><p>js是以单线程的方式执行，但是其运行环境浏览器却是多线程的。</p>\n<h4 id=\"1-浏览器是多线程的\"><a href=\"#1-浏览器是多线程的\" class=\"headerlink\" title=\"1. 浏览器是多线程的\"></a>1. 浏览器是多线程的</h4><p><strong>浏览器多线程包括：</strong></p>\n<ul>\n<li>javascript引擎线程</li>\n<li>界面渲染线程</li>\n<li>浏览器事件触发线程</li>\n<li>Http请求线程</li>\n</ul>\n<p>js引擎线程只是浏览器多线程中的一个线程。</p>\n<h4 id=\"2-js引擎是单线程的\"><a href=\"#2-js引擎是单线程的\" class=\"headerlink\" title=\"2. js引擎是单线程的\"></a>2. js引擎是单线程的</h4><p>我理解的单线程指的是，某一时刻内只能执行特定的一个任务，就像排队一样，某一时间只有一个人在办理业务。所以只有等一个任务执行完了之后才会执行另外一个任务。</p>\n<p><strong>单线程执行的原因</strong>：由于js主要是与用户互动、操作DOM，若以多线程的方式执行，会造成操作中的冲突。</p>\n<p><strong>单线程造成的问题：</strong>单线程执行很容易造成线程阻塞，当遇到一个很费时的任务时，这时其他的任务就被阻塞了。</p>\n<p>因此，当遇到一个很费时的操作时，不必等他们执行完之后再执行后面的操作；在这些任务完成前，JavaScript完全可以往下执行其他操作，当这些耗时的任务完成后则以回调的方式执行相应处理。这些就是JavaScript与生俱来的特性：<strong>异步与回调</strong>。</p>\n<blockquote>\n<p>当然对于不可避免的耗时操作（如：繁重的运算，多重循环），HTML5提出了Web Worker，它会在当前JavaScript的执行主线程中利用Worker类新开辟一个额外的线程来加载和运行特定的JavaScript文件，这个新的线程和JavaScript的主线程之间并不会互相影响和阻塞执行，而且在Web Worker中提供了这个新线程和JavaScript主线程之间数据交换的接口：postMessage和onMessage事件。但在HTML5 Web Worker中是不能操作DOM的，任何需要操作DOM的任务都需要委托给JavaScript主线程来执行，所以虽然引入HTML5 Web Worker，但仍然没有改线JavaScript单线程的本质。</p>\n</blockquote>\n<h3 id=\"二-js中的同步执行和异步执行\"><a href=\"#二-js中的同步执行和异步执行\" class=\"headerlink\" title=\"二. js中的同步执行和异步执行\"></a>二. js中的同步执行和异步执行</h3><p><strong>1. js的执行引擎分两个序列：</strong></p>\n<ul>\n<li>主线程：任务都会在主线程中执行</li>\n<li>事件队列：onclick, ajax, setTimeout, setInterval都会将任务放到事件队列里，然后等到主线程为空时，将队列中的任务取出，放在主线程中执行</li>\n</ul>\n<p><strong>2. 为了方便描述与理解，作出以下约定：</strong></p>\n<ul>\n<li>Stack栈为主线程</li>\n<li>Queue队列为任务队列（等待调度到主线程执行）</li>\n</ul>\n<p><strong>3. Javascript将任务的执行模式分成两种：同步、异步。</strong></p>\n<p>同步、异步指的是<strong>代码顺序</strong>和<strong>任务执行顺序</strong>是否是同步的。</p>\n<ul>\n<li><p>同步模式：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。</p>\n</li>\n<li><p>异步模式：每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</li>\n</ul>\n<p>js引擎单线程执行的,它是基于<strong>事件驱动</strong>的语言。</p>\n<p>它的执行顺序是遵循一个叫做事件队列的机制。</p>\n<p>浏览器有各种各样的线程,比如事件触发器（onclick）,网络请求(ajax),定时器(setTimeout、setInterval)等等。线程的联系都是基于事件的。</p>\n<p>js引擎处理到与其他线程相关的代码,就会分发给其他线程,他们处理完之后,需要js引擎计算时就是在事件队列里面添加一个任务。</p>\n<p>这个过程中,js并不会阻塞代码等待其他线程执行完毕,而且其他线程执行完毕后添加事件任务告诉js引擎执行相关操作.这就是js的<strong>异步编程模型</strong>。</p>\n<p><strong>4. js中对dom的操作是异步的</strong></p>\n<p>浏览器的另外一个引擎——&gt;<strong>GUI渲染引擎</strong>。 在js中渲染操作也是异步的，比如dom操作的代码会在事件队列中生成一个任务,js执行到这个任务时就会去调用GUI引擎渲染。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;table border=1&gt;\n        &lt;tr&gt;&lt;td&gt;&lt;button id=&apos;do&apos;&gt;Do long calc - bad status!&lt;/button&gt;&lt;/td&gt;\n            &lt;td&gt;&lt;div id=&apos;status&apos;&gt;Not Calculating yet.&lt;/div&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;&lt;td&gt;&lt;button id=&apos;do_ok&apos;&gt;Do long calc - good status!&lt;/button&gt;&lt;/td&gt;\n            &lt;td&gt;&lt;div id=&apos;status_ok&apos;&gt;Not Calculating yet.&lt;/div&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;    \n&lt;script&gt;\n\nfunction long_running(status_div) {\n\n    var result = 0;\n    for (var i = 0; i &lt; 1000; i++) {\n        for (var j = 0; j &lt; 700; j++) {\n            for (var k = 0; k &lt; 300; k++) {\n                result = result + i + j + k;\n            }\n        }\n    }\n    document.querySelector(status_div).innerHTML = &apos;calclation done&apos; ;\n}\n\ndocument.querySelector(&apos;#do&apos;).onclick = function () {\n    document.querySelector(&apos;#status&apos;).innerHTML = &apos;calculating....&apos;;\n    long_running(&apos;#status&apos;);\n};\n\ndocument.querySelector(&apos;#do_ok&apos;).onclick = function () {\n    document.querySelector(&apos;#status_ok&apos;).innerHTML = &apos;calculating....&apos;;\n    window.setTimeout(function (){ long_running(&apos;#status_ok&apos;) }, 0);\n};\n\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>我们希望能看到计算的每一个过程,我们在程序开始,计算,结束时,都执行了一个dom操作,插入了代表当前状态的字符串,Not Calculating yet.和calculating….和calclation done.计算中是一个耗时的3重for循环. 在没有使用settimeout的时候,执行结果是由Not Calculating yet 直接跳到了calclation done.这显然不是我们希望的.而造成这样结果的原因正是js的事件循环单线程机制.dom操作是异步的,for循环计算是同步的.异步操作都会被延迟到同步计算之后执行.也就是代码的执行顺序变了.calculating….和calclation done的dom操作都被放到事件队列后面而且紧跟在一起,造成了丢帧.无法实时的反应.这个例子也告诉了我们,在需要实时反馈的操作,如渲染等,和其他相关同步的代码,要么一起同步,要么一起异步才能保证代码的执行顺序.在js中,就只能让同步代码也异步.即给for计算加上settimeout.</p>\n<h3 id=\"三-js中的回调\"><a href=\"#三-js中的回调\" class=\"headerlink\" title=\"三. js中的回调\"></a>三. js中的回调</h3><p>回调不一定是异步的</p>\n<pre><code>/****************** 同步回调 ************************/\nvar syncFun = function(callback) {\n    var start = new Date();\n    while(new Date() - start &lt; 1000) { // delay 1 sec\n        ;\n    }\n    callback();\n    console.log(&apos;同步方法返回&apos;); // 2\n};\n\nsyncFun(function() {\n    console.log(&apos;这是同步回调&apos;); // 1\n});\nconsole.log(&apos;同步方法会阻塞当前逻辑&apos;); // 3\n\n/****************** 异步回调 ************************/\nvar asyncFun = function(callback) {\n    setTimeout(callback, 1000); // delay 1 sec\n    console.log(&apos;异步方法返回&apos;); // 4\n};\nasyncFun(function() {\n    console.log(&apos;这是异步回调&apos;); // 6\n});\nconsole.log(&apos;异步方法不会阻塞当前逻辑&apos;); // 5\n</code></pre><p>不能光看调用的形式，要看实际调用代码的实现方式</p>\n<pre><code>eg1:\nfunction A(){\n setTimeout(function(){\n   console.log(&apos;~~A~~&apos;);\n  },1000);\n}\n\nfunction B(){\n setTimeout(function(){\n   console.log(&apos;~~B~~&apos;);\n  },100);\n}\n\nfunction C(){\n setTimeout(function(){\n   console.log(&apos;~~C~~&apos;);\n  },2000);\n}\n\nfunction D(){\n    console.log(&apos;~~D~~&apos;);\n}\n\nfunction E(){\n    console.log(&apos;~~E~~&apos;);\n}\n\nA();\nB();\nC();\nD();\nE();\n//输出结果为 ~~D~~/~~E~~/~~B~~/~~A~~/~~C~~\n\n例一中，A/B/C/D/E函数将按代码的书写顺序顺序执行，但并不是说各个函数的内部代码的执行顺序和调用顺序相同。要具体看各个函数的实现\n</code></pre>","excerpt":"","more":"<h3 id=\"一-js引擎是单线程\"><a href=\"#一-js引擎是单线程\" class=\"headerlink\" title=\"一. js引擎是单线程\"></a>一. js引擎是单线程</h3><p>js是以单线程的方式执行，但是其运行环境浏览器却是多线程的。</p>\n<h4 id=\"1-浏览器是多线程的\"><a href=\"#1-浏览器是多线程的\" class=\"headerlink\" title=\"1. 浏览器是多线程的\"></a>1. 浏览器是多线程的</h4><p><strong>浏览器多线程包括：</strong></p>\n<ul>\n<li>javascript引擎线程</li>\n<li>界面渲染线程</li>\n<li>浏览器事件触发线程</li>\n<li>Http请求线程</li>\n</ul>\n<p>js引擎线程只是浏览器多线程中的一个线程。</p>\n<h4 id=\"2-js引擎是单线程的\"><a href=\"#2-js引擎是单线程的\" class=\"headerlink\" title=\"2. js引擎是单线程的\"></a>2. js引擎是单线程的</h4><p>我理解的单线程指的是，某一时刻内只能执行特定的一个任务，就像排队一样，某一时间只有一个人在办理业务。所以只有等一个任务执行完了之后才会执行另外一个任务。</p>\n<p><strong>单线程执行的原因</strong>：由于js主要是与用户互动、操作DOM，若以多线程的方式执行，会造成操作中的冲突。</p>\n<p><strong>单线程造成的问题：</strong>单线程执行很容易造成线程阻塞，当遇到一个很费时的任务时，这时其他的任务就被阻塞了。</p>\n<p>因此，当遇到一个很费时的操作时，不必等他们执行完之后再执行后面的操作；在这些任务完成前，JavaScript完全可以往下执行其他操作，当这些耗时的任务完成后则以回调的方式执行相应处理。这些就是JavaScript与生俱来的特性：<strong>异步与回调</strong>。</p>\n<blockquote>\n<p>当然对于不可避免的耗时操作（如：繁重的运算，多重循环），HTML5提出了Web Worker，它会在当前JavaScript的执行主线程中利用Worker类新开辟一个额外的线程来加载和运行特定的JavaScript文件，这个新的线程和JavaScript的主线程之间并不会互相影响和阻塞执行，而且在Web Worker中提供了这个新线程和JavaScript主线程之间数据交换的接口：postMessage和onMessage事件。但在HTML5 Web Worker中是不能操作DOM的，任何需要操作DOM的任务都需要委托给JavaScript主线程来执行，所以虽然引入HTML5 Web Worker，但仍然没有改线JavaScript单线程的本质。</p>\n</blockquote>\n<h3 id=\"二-js中的同步执行和异步执行\"><a href=\"#二-js中的同步执行和异步执行\" class=\"headerlink\" title=\"二. js中的同步执行和异步执行\"></a>二. js中的同步执行和异步执行</h3><p><strong>1. js的执行引擎分两个序列：</strong></p>\n<ul>\n<li>主线程：任务都会在主线程中执行</li>\n<li>事件队列：onclick, ajax, setTimeout, setInterval都会将任务放到事件队列里，然后等到主线程为空时，将队列中的任务取出，放在主线程中执行</li>\n</ul>\n<p><strong>2. 为了方便描述与理解，作出以下约定：</strong></p>\n<ul>\n<li>Stack栈为主线程</li>\n<li>Queue队列为任务队列（等待调度到主线程执行）</li>\n</ul>\n<p><strong>3. Javascript将任务的执行模式分成两种：同步、异步。</strong></p>\n<p>同步、异步指的是<strong>代码顺序</strong>和<strong>任务执行顺序</strong>是否是同步的。</p>\n<ul>\n<li><p>同步模式：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。</p>\n</li>\n<li><p>异步模式：每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n</li>\n</ul>\n<p>js引擎单线程执行的,它是基于<strong>事件驱动</strong>的语言。</p>\n<p>它的执行顺序是遵循一个叫做事件队列的机制。</p>\n<p>浏览器有各种各样的线程,比如事件触发器（onclick）,网络请求(ajax),定时器(setTimeout、setInterval)等等。线程的联系都是基于事件的。</p>\n<p>js引擎处理到与其他线程相关的代码,就会分发给其他线程,他们处理完之后,需要js引擎计算时就是在事件队列里面添加一个任务。</p>\n<p>这个过程中,js并不会阻塞代码等待其他线程执行完毕,而且其他线程执行完毕后添加事件任务告诉js引擎执行相关操作.这就是js的<strong>异步编程模型</strong>。</p>\n<p><strong>4. js中对dom的操作是异步的</strong></p>\n<p>浏览器的另外一个引擎——&gt;<strong>GUI渲染引擎</strong>。 在js中渲染操作也是异步的，比如dom操作的代码会在事件队列中生成一个任务,js执行到这个任务时就会去调用GUI引擎渲染。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;table border=1&gt;\n        &lt;tr&gt;&lt;td&gt;&lt;button id=&apos;do&apos;&gt;Do long calc - bad status!&lt;/button&gt;&lt;/td&gt;\n            &lt;td&gt;&lt;div id=&apos;status&apos;&gt;Not Calculating yet.&lt;/div&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;&lt;td&gt;&lt;button id=&apos;do_ok&apos;&gt;Do long calc - good status!&lt;/button&gt;&lt;/td&gt;\n            &lt;td&gt;&lt;div id=&apos;status_ok&apos;&gt;Not Calculating yet.&lt;/div&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;    \n&lt;script&gt;\n\nfunction long_running(status_div) {\n\n    var result = 0;\n    for (var i = 0; i &lt; 1000; i++) {\n        for (var j = 0; j &lt; 700; j++) {\n            for (var k = 0; k &lt; 300; k++) {\n                result = result + i + j + k;\n            }\n        }\n    }\n    document.querySelector(status_div).innerHTML = &apos;calclation done&apos; ;\n}\n\ndocument.querySelector(&apos;#do&apos;).onclick = function () {\n    document.querySelector(&apos;#status&apos;).innerHTML = &apos;calculating....&apos;;\n    long_running(&apos;#status&apos;);\n};\n\ndocument.querySelector(&apos;#do_ok&apos;).onclick = function () {\n    document.querySelector(&apos;#status_ok&apos;).innerHTML = &apos;calculating....&apos;;\n    window.setTimeout(function (){ long_running(&apos;#status_ok&apos;) }, 0);\n};\n\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>我们希望能看到计算的每一个过程,我们在程序开始,计算,结束时,都执行了一个dom操作,插入了代表当前状态的字符串,Not Calculating yet.和calculating….和calclation done.计算中是一个耗时的3重for循环. 在没有使用settimeout的时候,执行结果是由Not Calculating yet 直接跳到了calclation done.这显然不是我们希望的.而造成这样结果的原因正是js的事件循环单线程机制.dom操作是异步的,for循环计算是同步的.异步操作都会被延迟到同步计算之后执行.也就是代码的执行顺序变了.calculating….和calclation done的dom操作都被放到事件队列后面而且紧跟在一起,造成了丢帧.无法实时的反应.这个例子也告诉了我们,在需要实时反馈的操作,如渲染等,和其他相关同步的代码,要么一起同步,要么一起异步才能保证代码的执行顺序.在js中,就只能让同步代码也异步.即给for计算加上settimeout.</p>\n<h3 id=\"三-js中的回调\"><a href=\"#三-js中的回调\" class=\"headerlink\" title=\"三. js中的回调\"></a>三. js中的回调</h3><p>回调不一定是异步的</p>\n<pre><code>/****************** 同步回调 ************************/\nvar syncFun = function(callback) {\n    var start = new Date();\n    while(new Date() - start &lt; 1000) { // delay 1 sec\n        ;\n    }\n    callback();\n    console.log(&apos;同步方法返回&apos;); // 2\n};\n\nsyncFun(function() {\n    console.log(&apos;这是同步回调&apos;); // 1\n});\nconsole.log(&apos;同步方法会阻塞当前逻辑&apos;); // 3\n\n/****************** 异步回调 ************************/\nvar asyncFun = function(callback) {\n    setTimeout(callback, 1000); // delay 1 sec\n    console.log(&apos;异步方法返回&apos;); // 4\n};\nasyncFun(function() {\n    console.log(&apos;这是异步回调&apos;); // 6\n});\nconsole.log(&apos;异步方法不会阻塞当前逻辑&apos;); // 5\n</code></pre><p>不能光看调用的形式，要看实际调用代码的实现方式</p>\n<pre><code>eg1:\nfunction A(){\n setTimeout(function(){\n   console.log(&apos;~~A~~&apos;);\n  },1000);\n}\n\nfunction B(){\n setTimeout(function(){\n   console.log(&apos;~~B~~&apos;);\n  },100);\n}\n\nfunction C(){\n setTimeout(function(){\n   console.log(&apos;~~C~~&apos;);\n  },2000);\n}\n\nfunction D(){\n    console.log(&apos;~~D~~&apos;);\n}\n\nfunction E(){\n    console.log(&apos;~~E~~&apos;);\n}\n\nA();\nB();\nC();\nD();\nE();\n//输出结果为 ~~D~~/~~E~~/~~B~~/~~A~~/~~C~~\n\n例一中，A/B/C/D/E函数将按代码的书写顺序顺序执行，但并不是说各个函数的内部代码的执行顺序和调用顺序相同。要具体看各个函数的实现\n</code></pre>"},{"layout":"post","title":"js的消息队列","date":"2016-05-08T16:00:00.000Z","description":null,"_content":"\n### 一. js中的消息队列\n\nJavaScript是**单线程**的,在执行时必须等前面的任务处理完以后才会处理后面的,而且是一个一个连续同步执行的，不象多线程可以同时处理多个任务。\n\n每一个**消息**都可以理解为一个代码片段，有很多消息被放在一个**消息队列**中，他们也是一个个顺序执行过来的，无法同时处理两个消息。这些消息中有很大一部分是系统消息，一般是用来处理页面渲染之类的。比如拖动滚动条时候会触发滚动条事件，同时页面也需要重绘，这些事件、重绘、都是消息。\n\n我们当然也可以使用setTimeout之类的函数来往消息队列中添加自己的消息，setTimeout的功能就是把一个函数作为一个新的消息放入消息队列中\n\nsetInterval则是每隔一个设置的时间就把指定函数作为消息往消息队列中添加一次。\n\n消息添加到消息队列中并不是立即处理，因为消息队列中的消息也是一个个顺序处理的\n\nsetTimeout，xhr.send，包括其他的异步函数，都是注册了一个事件回调，没有马上执行\n\nJavaScript中的任务分为同步任务和异步任务，同步任务就是主线程上一个个排队执行的任务；相反的异步任务则不进入主线任务而是被加入到“任务队列”中，任务队列的任务只有在主线任务执行完成之后才去处理任务队列中的任务。\n\n这样就可以解释上面的问题了：setTimeout(function(){console.log(1);}, 0);这里的0代表的是0秒后加入到任务队列并没有执行，他要等主线程上面的任务console.log(2)执行完成后才会执行。\n\n### 二. js中的定时器\n\njs是运行在单线程环境中的，定时器是在指定的时间内将代码添加进消息队列里面，不一定会立刻执行。\n\n定时器的意思是：计划在某个时间执行某段代码，但实际的执行时间是不一定的。\n\n#### 1. setTimeOut\n    \n    eg:\n    \n    setTimeOut(function(){},200ms);\n\n例如上面的function并不是在200ms之后马上执行，而是在200ms之后添加到消息队列里面，如果这个时候，主线程上是空闲状态，并且这个消息之前没有消息在等待，那么这段代码就会被执行。\n\n**关于setTimeout的第一个参数：**\n\n第一个参数是一个回调函数，传入的应该是一个函数\n\n    function a(){}\n    \n    setTimeout(a,1000);//这里应该是a而不是a()，a()就成了函数的返回值\n\n<font color=\"red\">那么，问题来了，如何传入一个带参数的回调函数呢？</font>\n\n**方法一：**\n\n\tfunction a(i){}\n    \n    setTimeout(\"a(1)\",1000);\n\n**方法二：**\n\n\tfunction a(i){}\n\n\tfunction b(i){\n\t\treturn function a(i){};\n\t}\n    \n    setTimeout(\"b(1)\",1000);\n\n **关于setTimeout的第2个参数：**\n\n- 默认为0\n- 当指定时间小于4ms时，则增加到4ms（HTML5标准指定）\n\n**(1). 当指定第二个参数为0时**\n\n并不是立刻执行，取决于主线程当前是否空闲、“消息队列”里前面是否有等待的任务。\n\n\t\teg1:\n\t\t(function () {\n\t\t\n\t\t  console.log('this is the start');//1\n\t\t\n\t\t  setTimeout(function cb() {\n\t\t    \tconsole.log('this is a msg from call back');//4\n\t\t  });\n\t\t\n\t\t  console.log('this is just a message');//2\n\t\t\n\t\t  setTimeout(function cb1() {\n\t\t    \tconsole.log('this is a msg from call back1');//5\n\t\t  }, 0);\n\t\t\n\t\t  console.log('this is the  end');//3\n\t\t\n\t\t})();\n\t\t\n\t\t// 输出如下：\n\t\tthis is the start\n\t\tthis is just a message\n\t\tthis is the end\n\t\tundefined // 立即调用函数的返回值\n\t\tthis is a msg from callback\n\t\tthis is a msg from a callback1\n\n#### 2. setInterval\n\n    setInterval(function(){},interval);\n\n按指定的时间，将代码规则地插入消息队列\n\n如果消息队列中已经有一个等待的执行的定时器代码，那么定时器代码就不会被插入\n\n**使用setInterval产生的2个问题：**\n\n- 定时器代码可能会连续执行\n- 某些间隔会被跳过\n\n解决方法：使用链式的setTimeOut\n\n    eg:\n    \n    setTimeOut(function(){\n    \t//处理代码\n    \t\n    \t//arguments.callee指向当前正在执行的函数\n    \tsetTimeOut(arguments.callee,interval);\n    \n    },interval)","source":"_posts/2016-05-09-js的消息机制.md","raw":"---\nlayout: post\ntitle: js的消息队列\ndate: 2016-05-09\ncategories: javaScript\ntags: [javaScript,定时器]\ndescription: \n---\n\n### 一. js中的消息队列\n\nJavaScript是**单线程**的,在执行时必须等前面的任务处理完以后才会处理后面的,而且是一个一个连续同步执行的，不象多线程可以同时处理多个任务。\n\n每一个**消息**都可以理解为一个代码片段，有很多消息被放在一个**消息队列**中，他们也是一个个顺序执行过来的，无法同时处理两个消息。这些消息中有很大一部分是系统消息，一般是用来处理页面渲染之类的。比如拖动滚动条时候会触发滚动条事件，同时页面也需要重绘，这些事件、重绘、都是消息。\n\n我们当然也可以使用setTimeout之类的函数来往消息队列中添加自己的消息，setTimeout的功能就是把一个函数作为一个新的消息放入消息队列中\n\nsetInterval则是每隔一个设置的时间就把指定函数作为消息往消息队列中添加一次。\n\n消息添加到消息队列中并不是立即处理，因为消息队列中的消息也是一个个顺序处理的\n\nsetTimeout，xhr.send，包括其他的异步函数，都是注册了一个事件回调，没有马上执行\n\nJavaScript中的任务分为同步任务和异步任务，同步任务就是主线程上一个个排队执行的任务；相反的异步任务则不进入主线任务而是被加入到“任务队列”中，任务队列的任务只有在主线任务执行完成之后才去处理任务队列中的任务。\n\n这样就可以解释上面的问题了：setTimeout(function(){console.log(1);}, 0);这里的0代表的是0秒后加入到任务队列并没有执行，他要等主线程上面的任务console.log(2)执行完成后才会执行。\n\n### 二. js中的定时器\n\njs是运行在单线程环境中的，定时器是在指定的时间内将代码添加进消息队列里面，不一定会立刻执行。\n\n定时器的意思是：计划在某个时间执行某段代码，但实际的执行时间是不一定的。\n\n#### 1. setTimeOut\n    \n    eg:\n    \n    setTimeOut(function(){},200ms);\n\n例如上面的function并不是在200ms之后马上执行，而是在200ms之后添加到消息队列里面，如果这个时候，主线程上是空闲状态，并且这个消息之前没有消息在等待，那么这段代码就会被执行。\n\n**关于setTimeout的第一个参数：**\n\n第一个参数是一个回调函数，传入的应该是一个函数\n\n    function a(){}\n    \n    setTimeout(a,1000);//这里应该是a而不是a()，a()就成了函数的返回值\n\n<font color=\"red\">那么，问题来了，如何传入一个带参数的回调函数呢？</font>\n\n**方法一：**\n\n\tfunction a(i){}\n    \n    setTimeout(\"a(1)\",1000);\n\n**方法二：**\n\n\tfunction a(i){}\n\n\tfunction b(i){\n\t\treturn function a(i){};\n\t}\n    \n    setTimeout(\"b(1)\",1000);\n\n **关于setTimeout的第2个参数：**\n\n- 默认为0\n- 当指定时间小于4ms时，则增加到4ms（HTML5标准指定）\n\n**(1). 当指定第二个参数为0时**\n\n并不是立刻执行，取决于主线程当前是否空闲、“消息队列”里前面是否有等待的任务。\n\n\t\teg1:\n\t\t(function () {\n\t\t\n\t\t  console.log('this is the start');//1\n\t\t\n\t\t  setTimeout(function cb() {\n\t\t    \tconsole.log('this is a msg from call back');//4\n\t\t  });\n\t\t\n\t\t  console.log('this is just a message');//2\n\t\t\n\t\t  setTimeout(function cb1() {\n\t\t    \tconsole.log('this is a msg from call back1');//5\n\t\t  }, 0);\n\t\t\n\t\t  console.log('this is the  end');//3\n\t\t\n\t\t})();\n\t\t\n\t\t// 输出如下：\n\t\tthis is the start\n\t\tthis is just a message\n\t\tthis is the end\n\t\tundefined // 立即调用函数的返回值\n\t\tthis is a msg from callback\n\t\tthis is a msg from a callback1\n\n#### 2. setInterval\n\n    setInterval(function(){},interval);\n\n按指定的时间，将代码规则地插入消息队列\n\n如果消息队列中已经有一个等待的执行的定时器代码，那么定时器代码就不会被插入\n\n**使用setInterval产生的2个问题：**\n\n- 定时器代码可能会连续执行\n- 某些间隔会被跳过\n\n解决方法：使用链式的setTimeOut\n\n    eg:\n    \n    setTimeOut(function(){\n    \t//处理代码\n    \t\n    \t//arguments.callee指向当前正在执行的函数\n    \tsetTimeOut(arguments.callee,interval);\n    \n    },interval)","slug":"2016-05-09-js的消息机制","published":1,"updated":"2016-08-19T04:06:32.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocg6005ud5u8bewh2d3o","content":"<h3 id=\"一-js中的消息队列\"><a href=\"#一-js中的消息队列\" class=\"headerlink\" title=\"一. js中的消息队列\"></a>一. js中的消息队列</h3><p>JavaScript是<strong>单线程</strong>的,在执行时必须等前面的任务处理完以后才会处理后面的,而且是一个一个连续同步执行的，不象多线程可以同时处理多个任务。</p>\n<p>每一个<strong>消息</strong>都可以理解为一个代码片段，有很多消息被放在一个<strong>消息队列</strong>中，他们也是一个个顺序执行过来的，无法同时处理两个消息。这些消息中有很大一部分是系统消息，一般是用来处理页面渲染之类的。比如拖动滚动条时候会触发滚动条事件，同时页面也需要重绘，这些事件、重绘、都是消息。</p>\n<p>我们当然也可以使用setTimeout之类的函数来往消息队列中添加自己的消息，setTimeout的功能就是把一个函数作为一个新的消息放入消息队列中</p>\n<p>setInterval则是每隔一个设置的时间就把指定函数作为消息往消息队列中添加一次。</p>\n<p>消息添加到消息队列中并不是立即处理，因为消息队列中的消息也是一个个顺序处理的</p>\n<p>setTimeout，xhr.send，包括其他的异步函数，都是注册了一个事件回调，没有马上执行</p>\n<p>JavaScript中的任务分为同步任务和异步任务，同步任务就是主线程上一个个排队执行的任务；相反的异步任务则不进入主线任务而是被加入到“任务队列”中，任务队列的任务只有在主线任务执行完成之后才去处理任务队列中的任务。</p>\n<p>这样就可以解释上面的问题了：setTimeout(function(){console.log(1);}, 0);这里的0代表的是0秒后加入到任务队列并没有执行，他要等主线程上面的任务console.log(2)执行完成后才会执行。</p>\n<h3 id=\"二-js中的定时器\"><a href=\"#二-js中的定时器\" class=\"headerlink\" title=\"二. js中的定时器\"></a>二. js中的定时器</h3><p>js是运行在单线程环境中的，定时器是在指定的时间内将代码添加进消息队列里面，不一定会立刻执行。</p>\n<p>定时器的意思是：计划在某个时间执行某段代码，但实际的执行时间是不一定的。</p>\n<h4 id=\"1-setTimeOut\"><a href=\"#1-setTimeOut\" class=\"headerlink\" title=\"1. setTimeOut\"></a>1. setTimeOut</h4><pre><code>eg:\n\nsetTimeOut(function(){},200ms);\n</code></pre><p>例如上面的function并不是在200ms之后马上执行，而是在200ms之后添加到消息队列里面，如果这个时候，主线程上是空闲状态，并且这个消息之前没有消息在等待，那么这段代码就会被执行。</p>\n<p><strong>关于setTimeout的第一个参数：</strong></p>\n<p>第一个参数是一个回调函数，传入的应该是一个函数</p>\n<pre><code>function a(){}\n\nsetTimeout(a,1000);//这里应该是a而不是a()，a()就成了函数的返回值\n</code></pre><font color=\"red\">那么，问题来了，如何传入一个带参数的回调函数呢？</font>\n\n<p><strong>方法一：</strong></p>\n<pre><code>function a(i){}\n\nsetTimeout(&quot;a(1)&quot;,1000);\n</code></pre><p><strong>方法二：</strong></p>\n<pre><code>function a(i){}\n\nfunction b(i){\n    return function a(i){};\n}\n\nsetTimeout(&quot;b(1)&quot;,1000);\n</code></pre><p> <strong>关于setTimeout的第2个参数：</strong></p>\n<ul>\n<li>默认为0</li>\n<li>当指定时间小于4ms时，则增加到4ms（HTML5标准指定）</li>\n</ul>\n<p><strong>(1). 当指定第二个参数为0时</strong></p>\n<p>并不是立刻执行，取决于主线程当前是否空闲、“消息队列”里前面是否有等待的任务。</p>\n<pre><code>eg1:\n(function () {\n\n  console.log(&apos;this is the start&apos;);//1\n\n  setTimeout(function cb() {\n        console.log(&apos;this is a msg from call back&apos;);//4\n  });\n\n  console.log(&apos;this is just a message&apos;);//2\n\n  setTimeout(function cb1() {\n        console.log(&apos;this is a msg from call back1&apos;);//5\n  }, 0);\n\n  console.log(&apos;this is the  end&apos;);//3\n\n})();\n\n// 输出如下：\nthis is the start\nthis is just a message\nthis is the end\nundefined // 立即调用函数的返回值\nthis is a msg from callback\nthis is a msg from a callback1\n</code></pre><h4 id=\"2-setInterval\"><a href=\"#2-setInterval\" class=\"headerlink\" title=\"2. setInterval\"></a>2. setInterval</h4><pre><code>setInterval(function(){},interval);\n</code></pre><p>按指定的时间，将代码规则地插入消息队列</p>\n<p>如果消息队列中已经有一个等待的执行的定时器代码，那么定时器代码就不会被插入</p>\n<p><strong>使用setInterval产生的2个问题：</strong></p>\n<ul>\n<li>定时器代码可能会连续执行</li>\n<li>某些间隔会被跳过</li>\n</ul>\n<p>解决方法：使用链式的setTimeOut</p>\n<pre><code>eg:\n\nsetTimeOut(function(){\n    //处理代码\n\n    //arguments.callee指向当前正在执行的函数\n    setTimeOut(arguments.callee,interval);\n\n},interval)\n</code></pre>","excerpt":"","more":"<h3 id=\"一-js中的消息队列\"><a href=\"#一-js中的消息队列\" class=\"headerlink\" title=\"一. js中的消息队列\"></a>一. js中的消息队列</h3><p>JavaScript是<strong>单线程</strong>的,在执行时必须等前面的任务处理完以后才会处理后面的,而且是一个一个连续同步执行的，不象多线程可以同时处理多个任务。</p>\n<p>每一个<strong>消息</strong>都可以理解为一个代码片段，有很多消息被放在一个<strong>消息队列</strong>中，他们也是一个个顺序执行过来的，无法同时处理两个消息。这些消息中有很大一部分是系统消息，一般是用来处理页面渲染之类的。比如拖动滚动条时候会触发滚动条事件，同时页面也需要重绘，这些事件、重绘、都是消息。</p>\n<p>我们当然也可以使用setTimeout之类的函数来往消息队列中添加自己的消息，setTimeout的功能就是把一个函数作为一个新的消息放入消息队列中</p>\n<p>setInterval则是每隔一个设置的时间就把指定函数作为消息往消息队列中添加一次。</p>\n<p>消息添加到消息队列中并不是立即处理，因为消息队列中的消息也是一个个顺序处理的</p>\n<p>setTimeout，xhr.send，包括其他的异步函数，都是注册了一个事件回调，没有马上执行</p>\n<p>JavaScript中的任务分为同步任务和异步任务，同步任务就是主线程上一个个排队执行的任务；相反的异步任务则不进入主线任务而是被加入到“任务队列”中，任务队列的任务只有在主线任务执行完成之后才去处理任务队列中的任务。</p>\n<p>这样就可以解释上面的问题了：setTimeout(function(){console.log(1);}, 0);这里的0代表的是0秒后加入到任务队列并没有执行，他要等主线程上面的任务console.log(2)执行完成后才会执行。</p>\n<h3 id=\"二-js中的定时器\"><a href=\"#二-js中的定时器\" class=\"headerlink\" title=\"二. js中的定时器\"></a>二. js中的定时器</h3><p>js是运行在单线程环境中的，定时器是在指定的时间内将代码添加进消息队列里面，不一定会立刻执行。</p>\n<p>定时器的意思是：计划在某个时间执行某段代码，但实际的执行时间是不一定的。</p>\n<h4 id=\"1-setTimeOut\"><a href=\"#1-setTimeOut\" class=\"headerlink\" title=\"1. setTimeOut\"></a>1. setTimeOut</h4><pre><code>eg:\n\nsetTimeOut(function(){},200ms);\n</code></pre><p>例如上面的function并不是在200ms之后马上执行，而是在200ms之后添加到消息队列里面，如果这个时候，主线程上是空闲状态，并且这个消息之前没有消息在等待，那么这段代码就会被执行。</p>\n<p><strong>关于setTimeout的第一个参数：</strong></p>\n<p>第一个参数是一个回调函数，传入的应该是一个函数</p>\n<pre><code>function a(){}\n\nsetTimeout(a,1000);//这里应该是a而不是a()，a()就成了函数的返回值\n</code></pre><font color=\"red\">那么，问题来了，如何传入一个带参数的回调函数呢？</font>\n\n<p><strong>方法一：</strong></p>\n<pre><code>function a(i){}\n\nsetTimeout(&quot;a(1)&quot;,1000);\n</code></pre><p><strong>方法二：</strong></p>\n<pre><code>function a(i){}\n\nfunction b(i){\n    return function a(i){};\n}\n\nsetTimeout(&quot;b(1)&quot;,1000);\n</code></pre><p> <strong>关于setTimeout的第2个参数：</strong></p>\n<ul>\n<li>默认为0</li>\n<li>当指定时间小于4ms时，则增加到4ms（HTML5标准指定）</li>\n</ul>\n<p><strong>(1). 当指定第二个参数为0时</strong></p>\n<p>并不是立刻执行，取决于主线程当前是否空闲、“消息队列”里前面是否有等待的任务。</p>\n<pre><code>eg1:\n(function () {\n\n  console.log(&apos;this is the start&apos;);//1\n\n  setTimeout(function cb() {\n        console.log(&apos;this is a msg from call back&apos;);//4\n  });\n\n  console.log(&apos;this is just a message&apos;);//2\n\n  setTimeout(function cb1() {\n        console.log(&apos;this is a msg from call back1&apos;);//5\n  }, 0);\n\n  console.log(&apos;this is the  end&apos;);//3\n\n})();\n\n// 输出如下：\nthis is the start\nthis is just a message\nthis is the end\nundefined // 立即调用函数的返回值\nthis is a msg from callback\nthis is a msg from a callback1\n</code></pre><h4 id=\"2-setInterval\"><a href=\"#2-setInterval\" class=\"headerlink\" title=\"2. setInterval\"></a>2. setInterval</h4><pre><code>setInterval(function(){},interval);\n</code></pre><p>按指定的时间，将代码规则地插入消息队列</p>\n<p>如果消息队列中已经有一个等待的执行的定时器代码，那么定时器代码就不会被插入</p>\n<p><strong>使用setInterval产生的2个问题：</strong></p>\n<ul>\n<li>定时器代码可能会连续执行</li>\n<li>某些间隔会被跳过</li>\n</ul>\n<p>解决方法：使用链式的setTimeOut</p>\n<pre><code>eg:\n\nsetTimeOut(function(){\n    //处理代码\n\n    //arguments.callee指向当前正在执行的函数\n    setTimeOut(arguments.callee,interval);\n\n},interval)\n</code></pre>"},{"layout":"post","title":"JSON","date":"2016-05-15T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是JSON\n\njson是一种数据格式，json语法能表示简单值、对象、数组三种类型的值。\n\n对象和数组通常是json数据结构的最外层形式\n\n#### 1. 简单值\n\nbool、字符串、number、null\n\n其中字符串与js中的字符串中的不同之处：**必须用双引号**\n\n#### 2. 对象\n\n**json对象和js中对象的区别：**\n\n- json对象的属性名必须用双引号\n- 末尾没有分号(不是一个js语句)\n\n#### 3. 数组\n\n### 二. json序列化\n\n**JSON对象的方法**\n\n- JSON.stringify(js对象)：把js对象序列化为json字符串\n- JSON.parse(json字符串)：把json字符串解析为原生的json对象\n\n#### 1. 将对象序列化成json字符串 JSON.stringify()\n\n在序列化js对象时，函数和undefined值都会被跳过。\n\nJSON.stringify()第一个参数为json对象，第二个参数可以为一个数组，或者一个函数（过滤器）\n\n**第二个参数为数组时:**\n\n```\nvar book = {\n\t\"title\": \"javaScript\",\n\tedition: 1,\n\tyear: 2011\n};\n\nvar bookStr = JSON.stringify(book,[\"title\",\"edition\"]);\nconsole.log(bookStr); // \"{\"title\":\"javaScript\",\"edition\":1}\"\ntypeof bookStr; //string\n```\n\n**第二个参数为函数时：**\n\n```\n//一般的js对象里的key值是可以不加引号的\nvar book = {\n\t\"title\": \"javaScript\",\n\tedition: 1,\n\tyear: 2011\n};\n\n//注意：过滤器函数一定要设置default的值\nvar bookStr = JSON.stringify(book,function(key,value){\n\tswitch(key) {\n\t\tcase \"year\":\n\t\t\treturn 2016;\n\t\tdefault:\n\t\t\treturn value;\n\t}\n});\n\nconsole.log(bookStr); // \"{\"title\":\"javaScript\",\"edition\":1,\"year\":2016}\"\ntypeof bookStr; //string\n```\n\n#### 2. 将json字符串解析成对象\n\nJSON.parse()第一个参数是一个json字符串，第二个参数可以是一个函数\n\n```\nvar book1 = {\n\t\"title\": \"javaScript\",\n\tedition: 1,\n\tyear: 2011\n};\n\nvar bookStr = JSON.stringify(book1);\n\nvar book2 = JSON.parse(bookStr,function(key,value){\n\tif(key == \"edition\") {\n\t\treturn 2;\n\t} else {\n\t\treturn value;\n\t}\n});\n\nconsole.log(book); // Object {title: \"javaScript\", edition: 2, year: 2016}\n```\n\n### 三. 除了json以外的数据格式\n\nXML：可扩展通用标记语言\n\n与json相比：\n\nXML文件庞大，格式复杂，传输占带宽；json较轻量级","source":"_posts/2016-05-16-JSON.md","raw":"---\nlayout: post\ntitle: JSON\ndate: 2016-05-16\ncategories: javaScript\ntags: [javaScript,JSON]\ndescription: \n---\n\n### 一. 什么是JSON\n\njson是一种数据格式，json语法能表示简单值、对象、数组三种类型的值。\n\n对象和数组通常是json数据结构的最外层形式\n\n#### 1. 简单值\n\nbool、字符串、number、null\n\n其中字符串与js中的字符串中的不同之处：**必须用双引号**\n\n#### 2. 对象\n\n**json对象和js中对象的区别：**\n\n- json对象的属性名必须用双引号\n- 末尾没有分号(不是一个js语句)\n\n#### 3. 数组\n\n### 二. json序列化\n\n**JSON对象的方法**\n\n- JSON.stringify(js对象)：把js对象序列化为json字符串\n- JSON.parse(json字符串)：把json字符串解析为原生的json对象\n\n#### 1. 将对象序列化成json字符串 JSON.stringify()\n\n在序列化js对象时，函数和undefined值都会被跳过。\n\nJSON.stringify()第一个参数为json对象，第二个参数可以为一个数组，或者一个函数（过滤器）\n\n**第二个参数为数组时:**\n\n```\nvar book = {\n\t\"title\": \"javaScript\",\n\tedition: 1,\n\tyear: 2011\n};\n\nvar bookStr = JSON.stringify(book,[\"title\",\"edition\"]);\nconsole.log(bookStr); // \"{\"title\":\"javaScript\",\"edition\":1}\"\ntypeof bookStr; //string\n```\n\n**第二个参数为函数时：**\n\n```\n//一般的js对象里的key值是可以不加引号的\nvar book = {\n\t\"title\": \"javaScript\",\n\tedition: 1,\n\tyear: 2011\n};\n\n//注意：过滤器函数一定要设置default的值\nvar bookStr = JSON.stringify(book,function(key,value){\n\tswitch(key) {\n\t\tcase \"year\":\n\t\t\treturn 2016;\n\t\tdefault:\n\t\t\treturn value;\n\t}\n});\n\nconsole.log(bookStr); // \"{\"title\":\"javaScript\",\"edition\":1,\"year\":2016}\"\ntypeof bookStr; //string\n```\n\n#### 2. 将json字符串解析成对象\n\nJSON.parse()第一个参数是一个json字符串，第二个参数可以是一个函数\n\n```\nvar book1 = {\n\t\"title\": \"javaScript\",\n\tedition: 1,\n\tyear: 2011\n};\n\nvar bookStr = JSON.stringify(book1);\n\nvar book2 = JSON.parse(bookStr,function(key,value){\n\tif(key == \"edition\") {\n\t\treturn 2;\n\t} else {\n\t\treturn value;\n\t}\n});\n\nconsole.log(book); // Object {title: \"javaScript\", edition: 2, year: 2016}\n```\n\n### 三. 除了json以外的数据格式\n\nXML：可扩展通用标记语言\n\n与json相比：\n\nXML文件庞大，格式复杂，传输占带宽；json较轻量级","slug":"2016-05-16-JSON","published":1,"updated":"2016-09-18T01:54:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocga005yd5u8hhfqw1ff","content":"<h3 id=\"一-什么是JSON\"><a href=\"#一-什么是JSON\" class=\"headerlink\" title=\"一. 什么是JSON\"></a>一. 什么是JSON</h3><p>json是一种数据格式，json语法能表示简单值、对象、数组三种类型的值。</p>\n<p>对象和数组通常是json数据结构的最外层形式</p>\n<h4 id=\"1-简单值\"><a href=\"#1-简单值\" class=\"headerlink\" title=\"1. 简单值\"></a>1. 简单值</h4><p>bool、字符串、number、null</p>\n<p>其中字符串与js中的字符串中的不同之处：<strong>必须用双引号</strong></p>\n<h4 id=\"2-对象\"><a href=\"#2-对象\" class=\"headerlink\" title=\"2. 对象\"></a>2. 对象</h4><p><strong>json对象和js中对象的区别：</strong></p>\n<ul>\n<li>json对象的属性名必须用双引号</li>\n<li>末尾没有分号(不是一个js语句)</li>\n</ul>\n<h4 id=\"3-数组\"><a href=\"#3-数组\" class=\"headerlink\" title=\"3. 数组\"></a>3. 数组</h4><h3 id=\"二-json序列化\"><a href=\"#二-json序列化\" class=\"headerlink\" title=\"二. json序列化\"></a>二. json序列化</h3><p><strong>JSON对象的方法</strong></p>\n<ul>\n<li>JSON.stringify(js对象)：把js对象序列化为json字符串</li>\n<li>JSON.parse(json字符串)：把json字符串解析为原生的json对象</li>\n</ul>\n<h4 id=\"1-将对象序列化成json字符串-JSON-stringify\"><a href=\"#1-将对象序列化成json字符串-JSON-stringify\" class=\"headerlink\" title=\"1. 将对象序列化成json字符串 JSON.stringify()\"></a>1. 将对象序列化成json字符串 JSON.stringify()</h4><p>在序列化js对象时，函数和undefined值都会被跳过。</p>\n<p>JSON.stringify()第一个参数为json对象，第二个参数可以为一个数组，或者一个函数（过滤器）</p>\n<p><strong>第二个参数为数组时:</strong></p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> book = &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"title\"</span>: <span class=\"string\">\"javaScript\"</span>,</span><br><span class=\"line\">\tedition: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tyear: <span class=\"number\">2011</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> bookStr = JSON.stringify(book,[<span class=\"string\">\"title\"</span>,<span class=\"string\">\"edition\"</span>]);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(bookStr); // <span class=\"string\">\"&#123;\"</span><span class=\"built_in\">title</span><span class=\"string\">\":\"</span>javaScript<span class=\"string\">\",\"</span>edition<span class=\"string\">\":1&#125;\"</span></span><br><span class=\"line\">typeof bookStr; //<span class=\"built_in\">string</span></span><br></pre></td></tr></table></figure>\n<p><strong>第二个参数为函数时：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一般的js对象里的key值是可以不加引号的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"title\"</span>: <span class=\"string\">\"javaScript\"</span>,</span><br><span class=\"line\">\tedition: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tyear: <span class=\"number\">2011</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意：过滤器函数一定要设置default的值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bookStr = <span class=\"built_in\">JSON</span>.stringify(book,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,value</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(key) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"year\"</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">2016</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bookStr); <span class=\"comment\">// \"&#123;\"title\":\"javaScript\",\"edition\":1,\"year\":2016&#125;\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bookStr; <span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-将json字符串解析成对象\"><a href=\"#2-将json字符串解析成对象\" class=\"headerlink\" title=\"2. 将json字符串解析成对象\"></a>2. 将json字符串解析成对象</h4><p>JSON.parse()第一个参数是一个json字符串，第二个参数可以是一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book1 = &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"title\"</span>: <span class=\"string\">\"javaScript\"</span>,</span><br><span class=\"line\">\tedition: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tyear: <span class=\"number\">2011</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bookStr = <span class=\"built_in\">JSON</span>.stringify(book1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"built_in\">JSON</span>.parse(bookStr,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,value</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(key == <span class=\"string\">\"edition\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book); <span class=\"comment\">// Object &#123;title: \"javaScript\", edition: 2, year: 2016&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三-除了json以外的数据格式\"><a href=\"#三-除了json以外的数据格式\" class=\"headerlink\" title=\"三. 除了json以外的数据格式\"></a>三. 除了json以外的数据格式</h3><p>XML：可扩展通用标记语言</p>\n<p>与json相比：</p>\n<p>XML文件庞大，格式复杂，传输占带宽；json较轻量级</p>\n","excerpt":"","more":"<h3 id=\"一-什么是JSON\"><a href=\"#一-什么是JSON\" class=\"headerlink\" title=\"一. 什么是JSON\"></a>一. 什么是JSON</h3><p>json是一种数据格式，json语法能表示简单值、对象、数组三种类型的值。</p>\n<p>对象和数组通常是json数据结构的最外层形式</p>\n<h4 id=\"1-简单值\"><a href=\"#1-简单值\" class=\"headerlink\" title=\"1. 简单值\"></a>1. 简单值</h4><p>bool、字符串、number、null</p>\n<p>其中字符串与js中的字符串中的不同之处：<strong>必须用双引号</strong></p>\n<h4 id=\"2-对象\"><a href=\"#2-对象\" class=\"headerlink\" title=\"2. 对象\"></a>2. 对象</h4><p><strong>json对象和js中对象的区别：</strong></p>\n<ul>\n<li>json对象的属性名必须用双引号</li>\n<li>末尾没有分号(不是一个js语句)</li>\n</ul>\n<h4 id=\"3-数组\"><a href=\"#3-数组\" class=\"headerlink\" title=\"3. 数组\"></a>3. 数组</h4><h3 id=\"二-json序列化\"><a href=\"#二-json序列化\" class=\"headerlink\" title=\"二. json序列化\"></a>二. json序列化</h3><p><strong>JSON对象的方法</strong></p>\n<ul>\n<li>JSON.stringify(js对象)：把js对象序列化为json字符串</li>\n<li>JSON.parse(json字符串)：把json字符串解析为原生的json对象</li>\n</ul>\n<h4 id=\"1-将对象序列化成json字符串-JSON-stringify\"><a href=\"#1-将对象序列化成json字符串-JSON-stringify\" class=\"headerlink\" title=\"1. 将对象序列化成json字符串 JSON.stringify()\"></a>1. 将对象序列化成json字符串 JSON.stringify()</h4><p>在序列化js对象时，函数和undefined值都会被跳过。</p>\n<p>JSON.stringify()第一个参数为json对象，第二个参数可以为一个数组，或者一个函数（过滤器）</p>\n<p><strong>第二个参数为数组时:</strong></p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> book = &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"title\"</span>: <span class=\"string\">\"javaScript\"</span>,</span><br><span class=\"line\">\tedition: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tyear: <span class=\"number\">2011</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> bookStr = JSON.stringify(book,[<span class=\"string\">\"title\"</span>,<span class=\"string\">\"edition\"</span>]);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(bookStr); // <span class=\"string\">\"&#123;\"</span><span class=\"built_in\">title</span><span class=\"string\">\":\"</span>javaScript<span class=\"string\">\",\"</span>edition<span class=\"string\">\":1&#125;\"</span></span><br><span class=\"line\">typeof bookStr; //<span class=\"built_in\">string</span></span><br></pre></td></tr></table></figure>\n<p><strong>第二个参数为函数时：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一般的js对象里的key值是可以不加引号的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"title\"</span>: <span class=\"string\">\"javaScript\"</span>,</span><br><span class=\"line\">\tedition: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tyear: <span class=\"number\">2011</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意：过滤器函数一定要设置default的值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bookStr = <span class=\"built_in\">JSON</span>.stringify(book,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,value</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(key) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"year\"</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">2016</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bookStr); <span class=\"comment\">// \"&#123;\"title\":\"javaScript\",\"edition\":1,\"year\":2016&#125;\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bookStr; <span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-将json字符串解析成对象\"><a href=\"#2-将json字符串解析成对象\" class=\"headerlink\" title=\"2. 将json字符串解析成对象\"></a>2. 将json字符串解析成对象</h4><p>JSON.parse()第一个参数是一个json字符串，第二个参数可以是一个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book1 = &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"title\"</span>: <span class=\"string\">\"javaScript\"</span>,</span><br><span class=\"line\">\tedition: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tyear: <span class=\"number\">2011</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bookStr = <span class=\"built_in\">JSON</span>.stringify(book1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> book2 = <span class=\"built_in\">JSON</span>.parse(bookStr,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,value</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(key == <span class=\"string\">\"edition\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book); <span class=\"comment\">// Object &#123;title: \"javaScript\", edition: 2, year: 2016&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三-除了json以外的数据格式\"><a href=\"#三-除了json以外的数据格式\" class=\"headerlink\" title=\"三. 除了json以外的数据格式\"></a>三. 除了json以外的数据格式</h3><p>XML：可扩展通用标记语言</p>\n<p>与json相比：</p>\n<p>XML文件庞大，格式复杂，传输占带宽；json较轻量级</p>\n"},{"layout":"post","title":"将url参数解析成字典对象","date":"2016-05-15T16:00:00.000Z","description":null,"_content":"\n### 一. js中的location对象\n\nwindow.location对象\n\nlocation对象的属性\n\n- hostname web主机域名\n- pathname 当前页的路径和文件名\n- port web主机的端口\n- protocol 使用的web协议\n- href 当前的url\n\nlocation.search是从？开始的字符串\n\n`var linkURL = 'http://localhost:8080/String/string_6.html？name1=value1&name2=value2'; `\n\n那么 `location.search = '？name1=value1&name2=value2';`\n\n### 二. 什么是字典对象\n\n**字典**是以键值对形式存储数据的数据结构，就像电话号码薄里的名字和电话号码那样的一一对应的关系。\n\n### 三. 提取url中的参数\n\n当我们使用GET请求时，会将查询的字符串追加到url的末尾，以便将信息发送给服务器。\n\n**举个栗子：**\n\n\tvar linkURL = 'http://localhost:8080/String/string_6.html？name1=value1&name2=value2'; \n\n提取url中的查询参数并解析成字典对象的方式：\n\n- 拆字符\n- 正则匹配\n\n强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。\n\n**下面的例子是用正则匹配的方法：**\n\n\tfunction getQueryObject() {\n\n\t\t//获取从?之后的键值对\n\t    var url = location.search.substr(1);\n\n\t    var obj = {};\n\t    var reg = /([^?&=]+)=([^?&=]*)/g;\n\n\t    search.replace(reg, function (rs, $1, $2) {\n\t        var name = decodeURIComponent($1);\n\t        var val = decodeURIComponent($2);                \n\t        val = String(val);\n\t        obj[name] = val;\n\t        return rs;\n\t    });\n\t    return obj;\n\t}\n\n\trs是匹配的子串，$1和$2代表匹配的第n个分组，这里也就是([^?&=]+)（即query的name）和([^?&=]*)（即query的value），遍历同时将value赋值到obj对应的name属性上；后面的函数会遍历字符串中所有匹配正则表达式的字符串。\n\n\ta.replace(reg,函数)；\n\t\n\t意思是：字符串a中，满足正则表达式reg的字符串都执行后面的函数。\n\n**使用split分割法**\n\n\tfunction getQueryObject() {\n\t\t//获取从?之后的键值对\n\t    var url = location.search;\n\t\t\n\t\tvar obj = {};\n\n\t\tif(url.indexof('?') != -1) {\n\t\t\tvar str = url.substr(1);\n\t\t\tvar strs = str.split('&');\n\t\t\t\n\t\t\tfor(var i = 0; i < strs.length; i++) {\n\t\t\t\tvar name = decodeURIComponent(strs[i].split('=')[0]);\n\t\t\t\tvar value = decodeURIComponent(strs[i].split('=')[1]);\n\n\t\t\t\tobj[name] = value;\t\t\t\t\n\t\t\t}\n\t\t}\n\t    return obj;\n\t}","source":"_posts/2016-05-16-将url参数解析成字典对象.md","raw":"---\nlayout: post\ntitle: 将url参数解析成字典对象\ndate: 2016-05-16\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\n### 一. js中的location对象\n\nwindow.location对象\n\nlocation对象的属性\n\n- hostname web主机域名\n- pathname 当前页的路径和文件名\n- port web主机的端口\n- protocol 使用的web协议\n- href 当前的url\n\nlocation.search是从？开始的字符串\n\n`var linkURL = 'http://localhost:8080/String/string_6.html？name1=value1&name2=value2'; `\n\n那么 `location.search = '？name1=value1&name2=value2';`\n\n### 二. 什么是字典对象\n\n**字典**是以键值对形式存储数据的数据结构，就像电话号码薄里的名字和电话号码那样的一一对应的关系。\n\n### 三. 提取url中的参数\n\n当我们使用GET请求时，会将查询的字符串追加到url的末尾，以便将信息发送给服务器。\n\n**举个栗子：**\n\n\tvar linkURL = 'http://localhost:8080/String/string_6.html？name1=value1&name2=value2'; \n\n提取url中的查询参数并解析成字典对象的方式：\n\n- 拆字符\n- 正则匹配\n\n强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。\n\n**下面的例子是用正则匹配的方法：**\n\n\tfunction getQueryObject() {\n\n\t\t//获取从?之后的键值对\n\t    var url = location.search.substr(1);\n\n\t    var obj = {};\n\t    var reg = /([^?&=]+)=([^?&=]*)/g;\n\n\t    search.replace(reg, function (rs, $1, $2) {\n\t        var name = decodeURIComponent($1);\n\t        var val = decodeURIComponent($2);                \n\t        val = String(val);\n\t        obj[name] = val;\n\t        return rs;\n\t    });\n\t    return obj;\n\t}\n\n\trs是匹配的子串，$1和$2代表匹配的第n个分组，这里也就是([^?&=]+)（即query的name）和([^?&=]*)（即query的value），遍历同时将value赋值到obj对应的name属性上；后面的函数会遍历字符串中所有匹配正则表达式的字符串。\n\n\ta.replace(reg,函数)；\n\t\n\t意思是：字符串a中，满足正则表达式reg的字符串都执行后面的函数。\n\n**使用split分割法**\n\n\tfunction getQueryObject() {\n\t\t//获取从?之后的键值对\n\t    var url = location.search;\n\t\t\n\t\tvar obj = {};\n\n\t\tif(url.indexof('?') != -1) {\n\t\t\tvar str = url.substr(1);\n\t\t\tvar strs = str.split('&');\n\t\t\t\n\t\t\tfor(var i = 0; i < strs.length; i++) {\n\t\t\t\tvar name = decodeURIComponent(strs[i].split('=')[0]);\n\t\t\t\tvar value = decodeURIComponent(strs[i].split('=')[1]);\n\n\t\t\t\tobj[name] = value;\t\t\t\t\n\t\t\t}\n\t\t}\n\t    return obj;\n\t}","slug":"2016-05-16-将url参数解析成字典对象","published":1,"updated":"2016-09-07T08:23:58.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgc0061d5u8pmhlq4pt","content":"<h3 id=\"一-js中的location对象\"><a href=\"#一-js中的location对象\" class=\"headerlink\" title=\"一. js中的location对象\"></a>一. js中的location对象</h3><p>window.location对象</p>\n<p>location对象的属性</p>\n<ul>\n<li>hostname web主机域名</li>\n<li>pathname 当前页的路径和文件名</li>\n<li>port web主机的端口</li>\n<li>protocol 使用的web协议</li>\n<li>href 当前的url</li>\n</ul>\n<p>location.search是从？开始的字符串</p>\n<p><code>var linkURL = &#39;http://localhost:8080/String/string_6.html？name1=value1&amp;name2=value2&#39;;</code></p>\n<p>那么 <code>location.search = &#39;？name1=value1&amp;name2=value2&#39;;</code></p>\n<h3 id=\"二-什么是字典对象\"><a href=\"#二-什么是字典对象\" class=\"headerlink\" title=\"二. 什么是字典对象\"></a>二. 什么是字典对象</h3><p><strong>字典</strong>是以键值对形式存储数据的数据结构，就像电话号码薄里的名字和电话号码那样的一一对应的关系。</p>\n<h3 id=\"三-提取url中的参数\"><a href=\"#三-提取url中的参数\" class=\"headerlink\" title=\"三. 提取url中的参数\"></a>三. 提取url中的参数</h3><p>当我们使用GET请求时，会将查询的字符串追加到url的末尾，以便将信息发送给服务器。</p>\n<p><strong>举个栗子：</strong></p>\n<pre><code>var linkURL = &apos;http://localhost:8080/String/string_6.html？name1=value1&amp;name2=value2&apos;; \n</code></pre><p>提取url中的查询参数并解析成字典对象的方式：</p>\n<ul>\n<li>拆字符</li>\n<li>正则匹配</li>\n</ul>\n<p>强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。</p>\n<p><strong>下面的例子是用正则匹配的方法：</strong></p>\n<pre><code>function getQueryObject() {\n\n    //获取从?之后的键值对\n    var url = location.search.substr(1);\n\n    var obj = {};\n    var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g;\n\n    search.replace(reg, function (rs, $1, $2) {\n        var name = decodeURIComponent($1);\n        var val = decodeURIComponent($2);                \n        val = String(val);\n        obj[name] = val;\n        return rs;\n    });\n    return obj;\n}\n\nrs是匹配的子串，$1和$2代表匹配的第n个分组，这里也就是([^?&amp;=]+)（即query的name）和([^?&amp;=]*)（即query的value），遍历同时将value赋值到obj对应的name属性上；后面的函数会遍历字符串中所有匹配正则表达式的字符串。\n\na.replace(reg,函数)；\n\n意思是：字符串a中，满足正则表达式reg的字符串都执行后面的函数。\n</code></pre><p><strong>使用split分割法</strong></p>\n<pre><code>function getQueryObject() {\n    //获取从?之后的键值对\n    var url = location.search;\n\n    var obj = {};\n\n    if(url.indexof(&apos;?&apos;) != -1) {\n        var str = url.substr(1);\n        var strs = str.split(&apos;&amp;&apos;);\n\n        for(var i = 0; i &lt; strs.length; i++) {\n            var name = decodeURIComponent(strs[i].split(&apos;=&apos;)[0]);\n            var value = decodeURIComponent(strs[i].split(&apos;=&apos;)[1]);\n\n            obj[name] = value;                \n        }\n    }\n    return obj;\n}\n</code></pre>","excerpt":"","more":"<h3 id=\"一-js中的location对象\"><a href=\"#一-js中的location对象\" class=\"headerlink\" title=\"一. js中的location对象\"></a>一. js中的location对象</h3><p>window.location对象</p>\n<p>location对象的属性</p>\n<ul>\n<li>hostname web主机域名</li>\n<li>pathname 当前页的路径和文件名</li>\n<li>port web主机的端口</li>\n<li>protocol 使用的web协议</li>\n<li>href 当前的url</li>\n</ul>\n<p>location.search是从？开始的字符串</p>\n<p><code>var linkURL = &#39;http://localhost:8080/String/string_6.html？name1=value1&amp;name2=value2&#39;;</code></p>\n<p>那么 <code>location.search = &#39;？name1=value1&amp;name2=value2&#39;;</code></p>\n<h3 id=\"二-什么是字典对象\"><a href=\"#二-什么是字典对象\" class=\"headerlink\" title=\"二. 什么是字典对象\"></a>二. 什么是字典对象</h3><p><strong>字典</strong>是以键值对形式存储数据的数据结构，就像电话号码薄里的名字和电话号码那样的一一对应的关系。</p>\n<h3 id=\"三-提取url中的参数\"><a href=\"#三-提取url中的参数\" class=\"headerlink\" title=\"三. 提取url中的参数\"></a>三. 提取url中的参数</h3><p>当我们使用GET请求时，会将查询的字符串追加到url的末尾，以便将信息发送给服务器。</p>\n<p><strong>举个栗子：</strong></p>\n<pre><code>var linkURL = &apos;http://localhost:8080/String/string_6.html？name1=value1&amp;name2=value2&apos;; \n</code></pre><p>提取url中的查询参数并解析成字典对象的方式：</p>\n<ul>\n<li>拆字符</li>\n<li>正则匹配</li>\n</ul>\n<p>强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。</p>\n<p><strong>下面的例子是用正则匹配的方法：</strong></p>\n<pre><code>function getQueryObject() {\n\n    //获取从?之后的键值对\n    var url = location.search.substr(1);\n\n    var obj = {};\n    var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g;\n\n    search.replace(reg, function (rs, $1, $2) {\n        var name = decodeURIComponent($1);\n        var val = decodeURIComponent($2);                \n        val = String(val);\n        obj[name] = val;\n        return rs;\n    });\n    return obj;\n}\n\nrs是匹配的子串，$1和$2代表匹配的第n个分组，这里也就是([^?&amp;=]+)（即query的name）和([^?&amp;=]*)（即query的value），遍历同时将value赋值到obj对应的name属性上；后面的函数会遍历字符串中所有匹配正则表达式的字符串。\n\na.replace(reg,函数)；\n\n意思是：字符串a中，满足正则表达式reg的字符串都执行后面的函数。\n</code></pre><p><strong>使用split分割法</strong></p>\n<pre><code>function getQueryObject() {\n    //获取从?之后的键值对\n    var url = location.search;\n\n    var obj = {};\n\n    if(url.indexof(&apos;?&apos;) != -1) {\n        var str = url.substr(1);\n        var strs = str.split(&apos;&amp;&apos;);\n\n        for(var i = 0; i &lt; strs.length; i++) {\n            var name = decodeURIComponent(strs[i].split(&apos;=&apos;)[0]);\n            var value = decodeURIComponent(strs[i].split(&apos;=&apos;)[1]);\n\n            obj[name] = value;                \n        }\n    }\n    return obj;\n}\n</code></pre>"},{"layout":"post","title":"js中的call和apply和bind","date":"2016-05-14T16:00:00.000Z","description":null,"_content":"\napply、call、bind是为了手动绑定this对象，合理利用apply、call和bind会使得javaScript代码更加优雅。\n\n### 一. js中的apply()、call()、bind()\n\n#### 1. apply:应用某一对象的一个方法，用另一个对象替换当前对象。\n\n**apply(obj,参数数组)** \n\n#### 2. call:与apply的作用一样，只是参数列表不一样\n\n**call(obj,参数1,参数2...)**\n\n#### 3. bind()与call和apply的不同之处在于，bind会返回一个绑定函数\n\nbind()会创建一个新的函数，称为绑定函数，,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n**bind(obj,参数1，参数2...)**\n\n**举个栗子：**\n\t```js\n\tvar xw = {\n\t\t\t    name : \"小王\",\n\t\t\t    gender : \"男\",\n\t\t\t    age : 24,\n\t\t\t    say : function(a,b) {\n\t\t\t      alert(this.name + a + b);\n\t\t    \t}\n      }\n    \n    var xh = {\n\t\t\t    name : \"小红\",\n\t\t\t    gender : \"女\",\n\t\t\t    age : 18\n    }\n    \n    xw.say();//输出  小王\n\n\t如何用xw里面的方法 say 来输出xh里面的name呢\n\t\n\t用call()实现\n\txw.say.call(xh,\"my\",\"call\");//  小红mycall\n\n\t用apply()实现\t\n\txw.say.apply(xh,[\"my\",\"apply\"]); 小红myapply\n\n\t用bind()实现\n\txw.say.bind(xh,\"my\",\"bind\")();//bind返回的是一个函数\n\txw.say.bind(xh)(\"my\",\"bind\");//由于bind返回的是一个函数，因此也可以在调用的时候传入参数\n\t```\n\n#### 4. js中将类数组对象转化为一般数组\n\n(1) 什么是类数组对象\n\t```js\n\teg:\n    var myObj = {\n    \t\"0\": 1,\n    \t\"1\": 2,\n    \t\"2\": 3,\n    \t\"length\": 3\n    }\n\tmyObj就是一个类数组，myObj是一个对象，此对象将数组的下标作为属性名。\n\t```\n\n(2) arguments对象是类数组对象\n\n在函数体内，arguments是收到的**实参**副本。（注意是实参，不是形参，由实际接收到的参数决定）\n\t```js\n    eg:\n    function myfuc() {\n    \tconsole.log(arguments[0]+arguments[1]);\n    \tconsole.log(arguments.length);\n    }\n    \n    myfuc(\"h\",\"d\");//控制台打印出 hd 2\n\t```\n\n(3) 如何将类数组对象转换为一般的数组\n\n利用数组中的slice()方法，此方法会生成一个新的数组。\n\t```js\n    var argArr = Array.prototype.slice.call(arguments,0);\n\n\teg：\n\n\tvar my_object = {\n        '0': 'zero',\n         '1': 'one',\n         '2': 'two',\n         '3': 'three',\n         '4': 'four',\n         length: 5\n     };\n\n    console.log(my_object);//my_object是一个对象\n    var a = Array.prototype.slice.call(my_object,0);\n    console.log(a);//a是一个数组\n\t```\n\n#### 5. 函数原型中的bind函数\n\n旧版本中的写法:\n\t```js\n\tFunction.prototype.bind = function(){ \n\t    \n\t    var fn = this;// bind作为Function的prototype属性，每一个函数都具有bind方法，其中的this指向调用该方法的函数(也即一个函数对象实例)————**作为对象方法调用时，指向该对象**\n\t    \n\t    var args = Array.prototype.slice.call(arguments);// 将bind函数传入的实参对象转换成数组\n\t    \n\t    var object = args.shift();// 数组的shift方法会移除数组的第一个元素，并返回第一个元素，在bind方法的参数里面，第一个参数就是需要绑定this的对象\n)\n\t    return function(){ //返回一个函数，这个函数的功能如下：\n\t        \n\t\t\treturn fn.apply(object, args.concat(Array.prototype.slice.call(arguments))); \n\n\t        // 这里的Array.prototype.slice.call(arguments)指的是bind返回的那个函数的实参列表，也就是实际执行时bind返回的那个函数时传入的参数\n\t    }; \n\t};\n\t```\n\n新版本中的写法：\n\t```js\n\tfunction bind(context) {\n\t    if (arguments.length < 2 && Object.isUndefined(arguments[0]))\n\t        return this;\n\t\n\t    if (!Object.isFunction(this))\n\t        throw new TypeError(\"The object is not callable.\");\n\t\n\t    var nop = function() {};\n\t    var __method = this, args = slice.call(arguments, 1);\n\t\n\t    var bound = function() {\n\t        var a = merge(args, arguments);\n\t        // Ignore the supplied context when the bound function is called with\n\t        // the \"new\" keyword.\n\t        var c = this instanceof bound ? this : context;\n\t        return __method.apply(c, a);\n\t    };\n\t\n\t    nop.prototype   = this.prototype;\n\t    bound.prototype = new nop();\n\t\n\t    return bound;\n\t}\n\t```\n\t\n\t\n```\nfunction bind(fn, self){\n  var args = [].slice.call(arguments, 2)\n  return function(){\n    return fn.apply(self, [].concat.call(args, arguments));\n  };\n};\n\n\nfunction add(a, b){\n  return a + b;\n};\n\n\n// add.bind(this)\n\nvar fn = bind(add, this, 1)\n\nfn(2); // 3\n\n```\n\n\n   \n\n\n\n\n","source":"_posts/2016-05-15-js中的call和apply和bind.md","raw":"---\nlayout: post\ntitle: js中的call和apply和bind\ndate: 2016-05-15\ncategories: javaScript\ntags: [javaScript,算法]\ndescription: \n---\n\napply、call、bind是为了手动绑定this对象，合理利用apply、call和bind会使得javaScript代码更加优雅。\n\n### 一. js中的apply()、call()、bind()\n\n#### 1. apply:应用某一对象的一个方法，用另一个对象替换当前对象。\n\n**apply(obj,参数数组)** \n\n#### 2. call:与apply的作用一样，只是参数列表不一样\n\n**call(obj,参数1,参数2...)**\n\n#### 3. bind()与call和apply的不同之处在于，bind会返回一个绑定函数\n\nbind()会创建一个新的函数，称为绑定函数，,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n**bind(obj,参数1，参数2...)**\n\n**举个栗子：**\n\t```js\n\tvar xw = {\n\t\t\t    name : \"小王\",\n\t\t\t    gender : \"男\",\n\t\t\t    age : 24,\n\t\t\t    say : function(a,b) {\n\t\t\t      alert(this.name + a + b);\n\t\t    \t}\n      }\n    \n    var xh = {\n\t\t\t    name : \"小红\",\n\t\t\t    gender : \"女\",\n\t\t\t    age : 18\n    }\n    \n    xw.say();//输出  小王\n\n\t如何用xw里面的方法 say 来输出xh里面的name呢\n\t\n\t用call()实现\n\txw.say.call(xh,\"my\",\"call\");//  小红mycall\n\n\t用apply()实现\t\n\txw.say.apply(xh,[\"my\",\"apply\"]); 小红myapply\n\n\t用bind()实现\n\txw.say.bind(xh,\"my\",\"bind\")();//bind返回的是一个函数\n\txw.say.bind(xh)(\"my\",\"bind\");//由于bind返回的是一个函数，因此也可以在调用的时候传入参数\n\t```\n\n#### 4. js中将类数组对象转化为一般数组\n\n(1) 什么是类数组对象\n\t```js\n\teg:\n    var myObj = {\n    \t\"0\": 1,\n    \t\"1\": 2,\n    \t\"2\": 3,\n    \t\"length\": 3\n    }\n\tmyObj就是一个类数组，myObj是一个对象，此对象将数组的下标作为属性名。\n\t```\n\n(2) arguments对象是类数组对象\n\n在函数体内，arguments是收到的**实参**副本。（注意是实参，不是形参，由实际接收到的参数决定）\n\t```js\n    eg:\n    function myfuc() {\n    \tconsole.log(arguments[0]+arguments[1]);\n    \tconsole.log(arguments.length);\n    }\n    \n    myfuc(\"h\",\"d\");//控制台打印出 hd 2\n\t```\n\n(3) 如何将类数组对象转换为一般的数组\n\n利用数组中的slice()方法，此方法会生成一个新的数组。\n\t```js\n    var argArr = Array.prototype.slice.call(arguments,0);\n\n\teg：\n\n\tvar my_object = {\n        '0': 'zero',\n         '1': 'one',\n         '2': 'two',\n         '3': 'three',\n         '4': 'four',\n         length: 5\n     };\n\n    console.log(my_object);//my_object是一个对象\n    var a = Array.prototype.slice.call(my_object,0);\n    console.log(a);//a是一个数组\n\t```\n\n#### 5. 函数原型中的bind函数\n\n旧版本中的写法:\n\t```js\n\tFunction.prototype.bind = function(){ \n\t    \n\t    var fn = this;// bind作为Function的prototype属性，每一个函数都具有bind方法，其中的this指向调用该方法的函数(也即一个函数对象实例)————**作为对象方法调用时，指向该对象**\n\t    \n\t    var args = Array.prototype.slice.call(arguments);// 将bind函数传入的实参对象转换成数组\n\t    \n\t    var object = args.shift();// 数组的shift方法会移除数组的第一个元素，并返回第一个元素，在bind方法的参数里面，第一个参数就是需要绑定this的对象\n)\n\t    return function(){ //返回一个函数，这个函数的功能如下：\n\t        \n\t\t\treturn fn.apply(object, args.concat(Array.prototype.slice.call(arguments))); \n\n\t        // 这里的Array.prototype.slice.call(arguments)指的是bind返回的那个函数的实参列表，也就是实际执行时bind返回的那个函数时传入的参数\n\t    }; \n\t};\n\t```\n\n新版本中的写法：\n\t```js\n\tfunction bind(context) {\n\t    if (arguments.length < 2 && Object.isUndefined(arguments[0]))\n\t        return this;\n\t\n\t    if (!Object.isFunction(this))\n\t        throw new TypeError(\"The object is not callable.\");\n\t\n\t    var nop = function() {};\n\t    var __method = this, args = slice.call(arguments, 1);\n\t\n\t    var bound = function() {\n\t        var a = merge(args, arguments);\n\t        // Ignore the supplied context when the bound function is called with\n\t        // the \"new\" keyword.\n\t        var c = this instanceof bound ? this : context;\n\t        return __method.apply(c, a);\n\t    };\n\t\n\t    nop.prototype   = this.prototype;\n\t    bound.prototype = new nop();\n\t\n\t    return bound;\n\t}\n\t```\n\t\n\t\n```\nfunction bind(fn, self){\n  var args = [].slice.call(arguments, 2)\n  return function(){\n    return fn.apply(self, [].concat.call(args, arguments));\n  };\n};\n\n\nfunction add(a, b){\n  return a + b;\n};\n\n\n// add.bind(this)\n\nvar fn = bind(add, this, 1)\n\nfn(2); // 3\n\n```\n\n\n   \n\n\n\n\n","slug":"2016-05-15-js中的call和apply和bind","published":1,"updated":"2016-08-23T14:31:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgf0064d5u8caff8p4b","content":"<p>apply、call、bind是为了手动绑定this对象，合理利用apply、call和bind会使得javaScript代码更加优雅。</p>\n<h3 id=\"一-js中的apply-、call-、bind\"><a href=\"#一-js中的apply-、call-、bind\" class=\"headerlink\" title=\"一. js中的apply()、call()、bind()\"></a>一. js中的apply()、call()、bind()</h3><h4 id=\"1-apply-应用某一对象的一个方法，用另一个对象替换当前对象。\"><a href=\"#1-apply-应用某一对象的一个方法，用另一个对象替换当前对象。\" class=\"headerlink\" title=\"1. apply:应用某一对象的一个方法，用另一个对象替换当前对象。\"></a>1. apply:应用某一对象的一个方法，用另一个对象替换当前对象。</h4><p><strong>apply(obj,参数数组)</strong> </p>\n<h4 id=\"2-call-与apply的作用一样，只是参数列表不一样\"><a href=\"#2-call-与apply的作用一样，只是参数列表不一样\" class=\"headerlink\" title=\"2. call:与apply的作用一样，只是参数列表不一样\"></a>2. call:与apply的作用一样，只是参数列表不一样</h4><p><strong>call(obj,参数1,参数2…)</strong></p>\n<h4 id=\"3-bind-与call和apply的不同之处在于，bind会返回一个绑定函数\"><a href=\"#3-bind-与call和apply的不同之处在于，bind会返回一个绑定函数\" class=\"headerlink\" title=\"3. bind()与call和apply的不同之处在于，bind会返回一个绑定函数\"></a>3. bind()与call和apply的不同之处在于，bind会返回一个绑定函数</h4><p>bind()会创建一个新的函数，称为绑定函数，,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n<p><strong>bind(obj,参数1，参数2…)</strong></p>\n<p><strong>举个栗子：</strong><br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xw = &#123;</span><br><span class=\"line\">\t\t    name : <span class=\"string\">\"小王\"</span>,</span><br><span class=\"line\">\t\t    gender : <span class=\"string\">\"男\"</span>,</span><br><span class=\"line\">\t\t    age : <span class=\"number\">24</span>,</span><br><span class=\"line\">\t\t    say : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">\t\t      alert(<span class=\"keyword\">this</span>.name + a + b);</span><br><span class=\"line\">\t    \t&#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">var</span> xh = &#123;</span><br><span class=\"line\">\t\t    name : <span class=\"string\">\"小红\"</span>,</span><br><span class=\"line\">\t\t    gender : <span class=\"string\">\"女\"</span>,</span><br><span class=\"line\">\t\t    age : <span class=\"number\">18</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   xw.say();<span class=\"comment\">//输出  小王</span></span><br><span class=\"line\"></span><br><span class=\"line\">如何用xw里面的方法 say 来输出xh里面的name呢</span><br><span class=\"line\"></span><br><span class=\"line\">用call()实现</span><br><span class=\"line\">xw.say.call(xh,<span class=\"string\">\"my\"</span>,<span class=\"string\">\"call\"</span>);<span class=\"comment\">//  小红mycall</span></span><br><span class=\"line\"></span><br><span class=\"line\">用apply()实现\t</span><br><span class=\"line\">xw.say.apply(xh,[<span class=\"string\">\"my\"</span>,<span class=\"string\">\"apply\"</span>]); 小红myapply</span><br><span class=\"line\"></span><br><span class=\"line\">用bind()实现</span><br><span class=\"line\">xw.say.bind(xh,<span class=\"string\">\"my\"</span>,<span class=\"string\">\"bind\"</span>)();<span class=\"comment\">//bind返回的是一个函数</span></span><br><span class=\"line\">xw.say.bind(xh)(<span class=\"string\">\"my\"</span>,<span class=\"string\">\"bind\"</span>);<span class=\"comment\">//由于bind返回的是一个函数，因此也可以在调用的时候传入参数</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-js中将类数组对象转化为一般数组\"><a href=\"#4-js中将类数组对象转化为一般数组\" class=\"headerlink\" title=\"4. js中将类数组对象转化为一般数组\"></a>4. js中将类数组对象转化为一般数组</h4><p>(1) 什么是类数组对象<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">   <span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">   \t<span class=\"string\">\"0\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">   \t<span class=\"string\">\"1\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">   \t<span class=\"string\">\"2\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">   \t<span class=\"string\">\"length\"</span>: <span class=\"number\">3</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">myObj就是一个类数组，myObj是一个对象，此对象将数组的下标作为属性名。</span><br></pre></td></tr></table></figure></p>\n<p>(2) arguments对象是类数组对象</p>\n<p>在函数体内，arguments是收到的<strong>实参</strong>副本。（注意是实参，不是形参，由实际接收到的参数决定）<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myfuc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]+<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myfuc(<span class=\"string\">\"h\"</span>,<span class=\"string\">\"d\"</span>);<span class=\"comment\">//控制台打印出 hd 2</span></span><br></pre></td></tr></table></figure></p>\n<p>(3) 如何将类数组对象转换为一般的数组</p>\n<p>利用数组中的slice()方法，此方法会生成一个新的数组。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">var</span> argArr = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">eg：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> my_object = &#123;</span><br><span class=\"line\">       <span class=\"string\">'0'</span>: <span class=\"string\">'zero'</span>,</span><br><span class=\"line\">        <span class=\"string\">'1'</span>: <span class=\"string\">'one'</span>,</span><br><span class=\"line\">        <span class=\"string\">'2'</span>: <span class=\"string\">'two'</span>,</span><br><span class=\"line\">        <span class=\"string\">'3'</span>: <span class=\"string\">'three'</span>,</span><br><span class=\"line\">        <span class=\"string\">'4'</span>: <span class=\"string\">'four'</span>,</span><br><span class=\"line\">        length: <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(my_object);<span class=\"comment\">//my_object是一个对象</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(my_object,<span class=\"number\">0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//a是一个数组</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-函数原型中的bind函数\"><a href=\"#5-函数原型中的bind函数\" class=\"headerlink\" title=\"5. 函数原型中的bind函数\"></a>5. 函数原型中的bind函数</h4><p>旧版本中的写法:<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;<span class=\"comment\">// bind作为Function的prototype属性，每一个函数都具有bind方法，其中的this指向调用该方法的函数(也即一个函数对象实例)————**作为对象方法调用时，指向该对象**</span></span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);<span class=\"comment\">// 将bind函数传入的实参对象转换成数组</span></span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> object = args.shift();<span class=\"comment\">// 数组的shift方法会移除数组的第一个元素，并返回第一个元素，在bind方法的参数里面，第一个参数就是需要绑定this的对象</span></span><br><span class=\"line\">)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//返回一个函数，这个函数的功能如下：</span></span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fn.apply(object, args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>))); </span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"comment\">// 这里的Array.prototype.slice.call(arguments)指的是bind返回的那个函数的实参列表，也就是实际执行时bind返回的那个函数时传入的参数</span></span><br><span class=\"line\">\t    &#125;; </span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>新版本中的写法：<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &lt; <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">Object</span>.isUndefined(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Object</span>.isFunction(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"The object is not callable.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> __method = <span class=\"keyword\">this</span>, args = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = merge(args, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Ignore the supplied context when the bound function is called with</span></span><br><span class=\"line\">        <span class=\"comment\">// the \"new\" keyword.</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> bound ? <span class=\"keyword\">this</span> : context;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __method.apply(c, a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    nop.prototype   = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">    bound.prototype = <span class=\"keyword\">new</span> nop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, self</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(self, [].concat.call(args, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add.bind(this)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = bind(add, <span class=\"keyword\">this</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>apply、call、bind是为了手动绑定this对象，合理利用apply、call和bind会使得javaScript代码更加优雅。</p>\n<h3 id=\"一-js中的apply-、call-、bind\"><a href=\"#一-js中的apply-、call-、bind\" class=\"headerlink\" title=\"一. js中的apply()、call()、bind()\"></a>一. js中的apply()、call()、bind()</h3><h4 id=\"1-apply-应用某一对象的一个方法，用另一个对象替换当前对象。\"><a href=\"#1-apply-应用某一对象的一个方法，用另一个对象替换当前对象。\" class=\"headerlink\" title=\"1. apply:应用某一对象的一个方法，用另一个对象替换当前对象。\"></a>1. apply:应用某一对象的一个方法，用另一个对象替换当前对象。</h4><p><strong>apply(obj,参数数组)</strong> </p>\n<h4 id=\"2-call-与apply的作用一样，只是参数列表不一样\"><a href=\"#2-call-与apply的作用一样，只是参数列表不一样\" class=\"headerlink\" title=\"2. call:与apply的作用一样，只是参数列表不一样\"></a>2. call:与apply的作用一样，只是参数列表不一样</h4><p><strong>call(obj,参数1,参数2…)</strong></p>\n<h4 id=\"3-bind-与call和apply的不同之处在于，bind会返回一个绑定函数\"><a href=\"#3-bind-与call和apply的不同之处在于，bind会返回一个绑定函数\" class=\"headerlink\" title=\"3. bind()与call和apply的不同之处在于，bind会返回一个绑定函数\"></a>3. bind()与call和apply的不同之处在于，bind会返回一个绑定函数</h4><p>bind()会创建一个新的函数，称为绑定函数，,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n<p><strong>bind(obj,参数1，参数2…)</strong></p>\n<p><strong>举个栗子：</strong><br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xw = &#123;</span><br><span class=\"line\">\t\t    name : <span class=\"string\">\"小王\"</span>,</span><br><span class=\"line\">\t\t    gender : <span class=\"string\">\"男\"</span>,</span><br><span class=\"line\">\t\t    age : <span class=\"number\">24</span>,</span><br><span class=\"line\">\t\t    say : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">\t\t      alert(<span class=\"keyword\">this</span>.name + a + b);</span><br><span class=\"line\">\t    \t&#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">var</span> xh = &#123;</span><br><span class=\"line\">\t\t    name : <span class=\"string\">\"小红\"</span>,</span><br><span class=\"line\">\t\t    gender : <span class=\"string\">\"女\"</span>,</span><br><span class=\"line\">\t\t    age : <span class=\"number\">18</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   xw.say();<span class=\"comment\">//输出  小王</span></span><br><span class=\"line\"></span><br><span class=\"line\">如何用xw里面的方法 say 来输出xh里面的name呢</span><br><span class=\"line\"></span><br><span class=\"line\">用call()实现</span><br><span class=\"line\">xw.say.call(xh,<span class=\"string\">\"my\"</span>,<span class=\"string\">\"call\"</span>);<span class=\"comment\">//  小红mycall</span></span><br><span class=\"line\"></span><br><span class=\"line\">用apply()实现\t</span><br><span class=\"line\">xw.say.apply(xh,[<span class=\"string\">\"my\"</span>,<span class=\"string\">\"apply\"</span>]); 小红myapply</span><br><span class=\"line\"></span><br><span class=\"line\">用bind()实现</span><br><span class=\"line\">xw.say.bind(xh,<span class=\"string\">\"my\"</span>,<span class=\"string\">\"bind\"</span>)();<span class=\"comment\">//bind返回的是一个函数</span></span><br><span class=\"line\">xw.say.bind(xh)(<span class=\"string\">\"my\"</span>,<span class=\"string\">\"bind\"</span>);<span class=\"comment\">//由于bind返回的是一个函数，因此也可以在调用的时候传入参数</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-js中将类数组对象转化为一般数组\"><a href=\"#4-js中将类数组对象转化为一般数组\" class=\"headerlink\" title=\"4. js中将类数组对象转化为一般数组\"></a>4. js中将类数组对象转化为一般数组</h4><p>(1) 什么是类数组对象<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">   <span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">   \t<span class=\"string\">\"0\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">   \t<span class=\"string\">\"1\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">   \t<span class=\"string\">\"2\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">   \t<span class=\"string\">\"length\"</span>: <span class=\"number\">3</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">myObj就是一个类数组，myObj是一个对象，此对象将数组的下标作为属性名。</span><br></pre></td></tr></table></figure></p>\n<p>(2) arguments对象是类数组对象</p>\n<p>在函数体内，arguments是收到的<strong>实参</strong>副本。（注意是实参，不是形参，由实际接收到的参数决定）<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myfuc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]+<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myfuc(<span class=\"string\">\"h\"</span>,<span class=\"string\">\"d\"</span>);<span class=\"comment\">//控制台打印出 hd 2</span></span><br></pre></td></tr></table></figure></p>\n<p>(3) 如何将类数组对象转换为一般的数组</p>\n<p>利用数组中的slice()方法，此方法会生成一个新的数组。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">var</span> argArr = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">eg：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> my_object = &#123;</span><br><span class=\"line\">       <span class=\"string\">'0'</span>: <span class=\"string\">'zero'</span>,</span><br><span class=\"line\">        <span class=\"string\">'1'</span>: <span class=\"string\">'one'</span>,</span><br><span class=\"line\">        <span class=\"string\">'2'</span>: <span class=\"string\">'two'</span>,</span><br><span class=\"line\">        <span class=\"string\">'3'</span>: <span class=\"string\">'three'</span>,</span><br><span class=\"line\">        <span class=\"string\">'4'</span>: <span class=\"string\">'four'</span>,</span><br><span class=\"line\">        length: <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(my_object);<span class=\"comment\">//my_object是一个对象</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(my_object,<span class=\"number\">0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//a是一个数组</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-函数原型中的bind函数\"><a href=\"#5-函数原型中的bind函数\" class=\"headerlink\" title=\"5. 函数原型中的bind函数\"></a>5. 函数原型中的bind函数</h4><p>旧版本中的写法:<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;<span class=\"comment\">// bind作为Function的prototype属性，每一个函数都具有bind方法，其中的this指向调用该方法的函数(也即一个函数对象实例)————**作为对象方法调用时，指向该对象**</span></span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);<span class=\"comment\">// 将bind函数传入的实参对象转换成数组</span></span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> object = args.shift();<span class=\"comment\">// 数组的shift方法会移除数组的第一个元素，并返回第一个元素，在bind方法的参数里面，第一个参数就是需要绑定this的对象</span></span><br><span class=\"line\">)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//返回一个函数，这个函数的功能如下：</span></span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fn.apply(object, args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>))); </span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"comment\">// 这里的Array.prototype.slice.call(arguments)指的是bind返回的那个函数的实参列表，也就是实际执行时bind返回的那个函数时传入的参数</span></span><br><span class=\"line\">\t    &#125;; </span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>新版本中的写法：<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &lt; <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">Object</span>.isUndefined(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Object</span>.isFunction(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"The object is not callable.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> __method = <span class=\"keyword\">this</span>, args = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = merge(args, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Ignore the supplied context when the bound function is called with</span></span><br><span class=\"line\">        <span class=\"comment\">// the \"new\" keyword.</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> bound ? <span class=\"keyword\">this</span> : context;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __method.apply(c, a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    nop.prototype   = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">    bound.prototype = <span class=\"keyword\">new</span> nop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, self</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(self, [].concat.call(args, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add.bind(this)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = bind(add, <span class=\"keyword\">this</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"纯函数","date":"2016-05-15T16:00:00.000Z","description":null,"_content":"\n### 1. 什么是纯函数\n\n相同的输入，永远会得到相同的输出；而且没有任何可观察的副作用。\n\neg：\n\n\tfunction myFunc(){\n\t    return 'hello, ' + this.name；\n\t}\n\n这不是一个纯函数，因为this指向不明，this指向什么跟函数执行的方式有关。\n\n你永远不知道this.name会被谁改写，测试用例也不可能覆盖所有情况。如果正巧有一个外部函数，它每隔一个月将this.name改写成'shit'，你和测试人员熬了几个通宵没有发现一点问题，你也信心满满。\n\n**共享状态导致的混乱是绝大多数bug的万恶之源**\n\n不提倡全局变量\n\n### 2. JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 ：\n\n1，函数入口使用参数运算，而不修改它 \n2，函数内不修改函数外的变量，如全局变量 \n3，运算结果通过函数返回给外部（出口）","source":"_posts/2016-05-16-纯函数.md","raw":"---\nlayout: post\ntitle: 纯函数\ndate: 2016-05-16\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\n### 1. 什么是纯函数\n\n相同的输入，永远会得到相同的输出；而且没有任何可观察的副作用。\n\neg：\n\n\tfunction myFunc(){\n\t    return 'hello, ' + this.name；\n\t}\n\n这不是一个纯函数，因为this指向不明，this指向什么跟函数执行的方式有关。\n\n你永远不知道this.name会被谁改写，测试用例也不可能覆盖所有情况。如果正巧有一个外部函数，它每隔一个月将this.name改写成'shit'，你和测试人员熬了几个通宵没有发现一点问题，你也信心满满。\n\n**共享状态导致的混乱是绝大多数bug的万恶之源**\n\n不提倡全局变量\n\n### 2. JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 ：\n\n1，函数入口使用参数运算，而不修改它 \n2，函数内不修改函数外的变量，如全局变量 \n3，运算结果通过函数返回给外部（出口）","slug":"2016-05-16-纯函数","published":1,"updated":"2016-05-16T13:28:32.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgj0068d5u8eeun6u57","content":"<h3 id=\"1-什么是纯函数\"><a href=\"#1-什么是纯函数\" class=\"headerlink\" title=\"1. 什么是纯函数\"></a>1. 什么是纯函数</h3><p>相同的输入，永远会得到相同的输出；而且没有任何可观察的副作用。</p>\n<p>eg：</p>\n<pre><code>function myFunc(){\n    return &apos;hello, &apos; + this.name；\n}\n</code></pre><p>这不是一个纯函数，因为this指向不明，this指向什么跟函数执行的方式有关。</p>\n<p>你永远不知道this.name会被谁改写，测试用例也不可能覆盖所有情况。如果正巧有一个外部函数，它每隔一个月将this.name改写成’shit’，你和测试人员熬了几个通宵没有发现一点问题，你也信心满满。</p>\n<p><strong>共享状态导致的混乱是绝大多数bug的万恶之源</strong></p>\n<p>不提倡全局变量</p>\n<h3 id=\"2-JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即-：\"><a href=\"#2-JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即-：\" class=\"headerlink\" title=\"2. JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 ：\"></a>2. JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 ：</h3><p>1，函数入口使用参数运算，而不修改它<br>2，函数内不修改函数外的变量，如全局变量<br>3，运算结果通过函数返回给外部（出口）</p>\n","excerpt":"","more":"<h3 id=\"1-什么是纯函数\"><a href=\"#1-什么是纯函数\" class=\"headerlink\" title=\"1. 什么是纯函数\"></a>1. 什么是纯函数</h3><p>相同的输入，永远会得到相同的输出；而且没有任何可观察的副作用。</p>\n<p>eg：</p>\n<pre><code>function myFunc(){\n    return &apos;hello, &apos; + this.name；\n}\n</code></pre><p>这不是一个纯函数，因为this指向不明，this指向什么跟函数执行的方式有关。</p>\n<p>你永远不知道this.name会被谁改写，测试用例也不可能覆盖所有情况。如果正巧有一个外部函数，它每隔一个月将this.name改写成’shit’，你和测试人员熬了几个通宵没有发现一点问题，你也信心满满。</p>\n<p><strong>共享状态导致的混乱是绝大多数bug的万恶之源</strong></p>\n<p>不提倡全局变量</p>\n<h3 id=\"2-JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即-：\"><a href=\"#2-JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即-：\" class=\"headerlink\" title=\"2. JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 ：\"></a>2. JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即 ：</h3><p>1，函数入口使用参数运算，而不修改它<br>2，函数内不修改函数外的变量，如全局变量<br>3，运算结果通过函数返回给外部（出口）</p>\n"},{"layout":"post","title":"函数节流和函数去抖","date":"2016-05-15T16:00:00.000Z","description":null,"_content":"\n### 一. 函数节流\n\n#### 1. 什么是函数节流\n\n如果用户在一个短的时间内触发非常多次事件绑定程序，如果在这个程序内部绑定了一些DOM操作，高频率的更改就会使浏览器崩溃。\n\n为了防止这种情况，就需要用到函数节流的思想，某些代码不可以在没有间断的情况下连续重复地执行。\n\neg: \n\n1. 给浏览器绑定一个onresize事件，当用户在将浏览器宽度变大变小的过程中，会一直触发onresize事件。\n\n2. 页面滚动时，滚动到哪有一定的效果，绑定onscroll事件\n\n大部分节流都采用时间做节流，即时间间隔小于多少的不再调用，但同时保证一个最小调用间隔\n\n#### 2. 用定时器来实现函数节流\n\n原理：当我触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。\n\n    function throttle(method, context) {\n\t     clearTimeout(method.tId);//将定时器存在method.tId里\n\t     method.tId = setTimeout(function(){\n\t     \tmethod.call(context);//确保函数在正确的环境中执行\n\t     }， 100);//两次函数调用之间的间隔至少为100ms\n     }\n    \n\tfunction myFunc(){\n\t\tvar div = document.getElementById(\"myDiv\");\n\t\tdiv.style.height = div.offsetWidth + \"px\";//实现使一个div的高度等于其宽度\n\t}\n\n    window.onresize = function(){\n    \t throttle(myFunc);//不直接调用myFunc，而是通过throttle来调用myFunc\n    }\n\n### 二. 函数去抖\n\n#### 1. 什么是函数去抖\n\n当一个函数在在一定的间隔内没有被调用时，才开始执行被调用的方法。\n\n例如：用户在输入一段文字时，对文字进行处理，监听文字改变事件，每一次改变都会调用一次回调函数，但是想要的功能只是在用户输入停下来的时候才去执行回调函数。\n\n```\nfunction debounce(func, wait, immediate) {\n\tvar timeout, result;\n\n\treturn function() {\n\t\tvar context = this, args = arguments;\n\n\t\tvar later = function() {\n\t\t\ttimeout = null;\n\t\t\t\n\t\t\tif(!immediate) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t}\n\t\t}\n\n\t\tvar callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\n\t\ttimeout = setTimeout(later, wait);\n\n\t\tif(callNow) {\n\t\t\tresult = func.apply(context, args);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n```\n\n假设immediate == true：\n\n首次调用debounce(func,wait,immediate)，callNow = true，执行func函数；\n\n第二次调用debounce(func,wait,immediate)\n\n- 若间隔时间 < wait，callNow == false，不执行func函数\n- 若间隔时间 > wait，callNow == true，执行func函数","source":"_posts/2016-05-16-函数节流.md","raw":"---\nlayout: post\ntitle: 函数节流和函数去抖\ndate: 2016-05-16\ncategories: javaScript\ntags: [javaScript,定时器]\ndescription: \n---\n\n### 一. 函数节流\n\n#### 1. 什么是函数节流\n\n如果用户在一个短的时间内触发非常多次事件绑定程序，如果在这个程序内部绑定了一些DOM操作，高频率的更改就会使浏览器崩溃。\n\n为了防止这种情况，就需要用到函数节流的思想，某些代码不可以在没有间断的情况下连续重复地执行。\n\neg: \n\n1. 给浏览器绑定一个onresize事件，当用户在将浏览器宽度变大变小的过程中，会一直触发onresize事件。\n\n2. 页面滚动时，滚动到哪有一定的效果，绑定onscroll事件\n\n大部分节流都采用时间做节流，即时间间隔小于多少的不再调用，但同时保证一个最小调用间隔\n\n#### 2. 用定时器来实现函数节流\n\n原理：当我触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。\n\n    function throttle(method, context) {\n\t     clearTimeout(method.tId);//将定时器存在method.tId里\n\t     method.tId = setTimeout(function(){\n\t     \tmethod.call(context);//确保函数在正确的环境中执行\n\t     }， 100);//两次函数调用之间的间隔至少为100ms\n     }\n    \n\tfunction myFunc(){\n\t\tvar div = document.getElementById(\"myDiv\");\n\t\tdiv.style.height = div.offsetWidth + \"px\";//实现使一个div的高度等于其宽度\n\t}\n\n    window.onresize = function(){\n    \t throttle(myFunc);//不直接调用myFunc，而是通过throttle来调用myFunc\n    }\n\n### 二. 函数去抖\n\n#### 1. 什么是函数去抖\n\n当一个函数在在一定的间隔内没有被调用时，才开始执行被调用的方法。\n\n例如：用户在输入一段文字时，对文字进行处理，监听文字改变事件，每一次改变都会调用一次回调函数，但是想要的功能只是在用户输入停下来的时候才去执行回调函数。\n\n```\nfunction debounce(func, wait, immediate) {\n\tvar timeout, result;\n\n\treturn function() {\n\t\tvar context = this, args = arguments;\n\n\t\tvar later = function() {\n\t\t\ttimeout = null;\n\t\t\t\n\t\t\tif(!immediate) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t}\n\t\t}\n\n\t\tvar callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\n\t\ttimeout = setTimeout(later, wait);\n\n\t\tif(callNow) {\n\t\t\tresult = func.apply(context, args);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n```\n\n假设immediate == true：\n\n首次调用debounce(func,wait,immediate)，callNow = true，执行func函数；\n\n第二次调用debounce(func,wait,immediate)\n\n- 若间隔时间 < wait，callNow == false，不执行func函数\n- 若间隔时间 > wait，callNow == true，执行func函数","slug":"2016-05-16-函数节流","published":1,"updated":"2016-09-13T07:54:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgl006bd5u8pnou1qj2","content":"<h3 id=\"一-函数节流\"><a href=\"#一-函数节流\" class=\"headerlink\" title=\"一. 函数节流\"></a>一. 函数节流</h3><h4 id=\"1-什么是函数节流\"><a href=\"#1-什么是函数节流\" class=\"headerlink\" title=\"1. 什么是函数节流\"></a>1. 什么是函数节流</h4><p>如果用户在一个短的时间内触发非常多次事件绑定程序，如果在这个程序内部绑定了一些DOM操作，高频率的更改就会使浏览器崩溃。</p>\n<p>为了防止这种情况，就需要用到函数节流的思想，某些代码不可以在没有间断的情况下连续重复地执行。</p>\n<p>eg: </p>\n<ol>\n<li><p>给浏览器绑定一个onresize事件，当用户在将浏览器宽度变大变小的过程中，会一直触发onresize事件。</p>\n</li>\n<li><p>页面滚动时，滚动到哪有一定的效果，绑定onscroll事件</p>\n</li>\n</ol>\n<p>大部分节流都采用时间做节流，即时间间隔小于多少的不再调用，但同时保证一个最小调用间隔</p>\n<h4 id=\"2-用定时器来实现函数节流\"><a href=\"#2-用定时器来实现函数节流\" class=\"headerlink\" title=\"2. 用定时器来实现函数节流\"></a>2. 用定时器来实现函数节流</h4><p>原理：当我触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。</p>\n<pre><code>function throttle(method, context) {\n     clearTimeout(method.tId);//将定时器存在method.tId里\n     method.tId = setTimeout(function(){\n         method.call(context);//确保函数在正确的环境中执行\n     }， 100);//两次函数调用之间的间隔至少为100ms\n }\n\nfunction myFunc(){\n    var div = document.getElementById(&quot;myDiv&quot;);\n    div.style.height = div.offsetWidth + &quot;px&quot;;//实现使一个div的高度等于其宽度\n}\n\nwindow.onresize = function(){\n     throttle(myFunc);//不直接调用myFunc，而是通过throttle来调用myFunc\n}\n</code></pre><h3 id=\"二-函数去抖\"><a href=\"#二-函数去抖\" class=\"headerlink\" title=\"二. 函数去抖\"></a>二. 函数去抖</h3><h4 id=\"1-什么是函数去抖\"><a href=\"#1-什么是函数去抖\" class=\"headerlink\" title=\"1. 什么是函数去抖\"></a>1. 什么是函数去抖</h4><p>当一个函数在在一定的间隔内没有被调用时，才开始执行被调用的方法。</p>\n<p>例如：用户在输入一段文字时，对文字进行处理，监听文字改变事件，每一次改变都会调用一次回调函数，但是想要的功能只是在用户输入停下来的时候才去执行回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> timeout, result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>, args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\ttimeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!immediate) &#123;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">\t\tclearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimeout = setTimeout(later, wait);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(callNow) &#123;</span><br><span class=\"line\">\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设immediate == true：</p>\n<p>首次调用debounce(func,wait,immediate)，callNow = true，执行func函数；</p>\n<p>第二次调用debounce(func,wait,immediate)</p>\n<ul>\n<li>若间隔时间 &lt; wait，callNow == false，不执行func函数</li>\n<li>若间隔时间 &gt; wait，callNow == true，执行func函数</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-函数节流\"><a href=\"#一-函数节流\" class=\"headerlink\" title=\"一. 函数节流\"></a>一. 函数节流</h3><h4 id=\"1-什么是函数节流\"><a href=\"#1-什么是函数节流\" class=\"headerlink\" title=\"1. 什么是函数节流\"></a>1. 什么是函数节流</h4><p>如果用户在一个短的时间内触发非常多次事件绑定程序，如果在这个程序内部绑定了一些DOM操作，高频率的更改就会使浏览器崩溃。</p>\n<p>为了防止这种情况，就需要用到函数节流的思想，某些代码不可以在没有间断的情况下连续重复地执行。</p>\n<p>eg: </p>\n<ol>\n<li><p>给浏览器绑定一个onresize事件，当用户在将浏览器宽度变大变小的过程中，会一直触发onresize事件。</p>\n</li>\n<li><p>页面滚动时，滚动到哪有一定的效果，绑定onscroll事件</p>\n</li>\n</ol>\n<p>大部分节流都采用时间做节流，即时间间隔小于多少的不再调用，但同时保证一个最小调用间隔</p>\n<h4 id=\"2-用定时器来实现函数节流\"><a href=\"#2-用定时器来实现函数节流\" class=\"headerlink\" title=\"2. 用定时器来实现函数节流\"></a>2. 用定时器来实现函数节流</h4><p>原理：当我触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。</p>\n<pre><code>function throttle(method, context) {\n     clearTimeout(method.tId);//将定时器存在method.tId里\n     method.tId = setTimeout(function(){\n         method.call(context);//确保函数在正确的环境中执行\n     }， 100);//两次函数调用之间的间隔至少为100ms\n }\n\nfunction myFunc(){\n    var div = document.getElementById(&quot;myDiv&quot;);\n    div.style.height = div.offsetWidth + &quot;px&quot;;//实现使一个div的高度等于其宽度\n}\n\nwindow.onresize = function(){\n     throttle(myFunc);//不直接调用myFunc，而是通过throttle来调用myFunc\n}\n</code></pre><h3 id=\"二-函数去抖\"><a href=\"#二-函数去抖\" class=\"headerlink\" title=\"二. 函数去抖\"></a>二. 函数去抖</h3><h4 id=\"1-什么是函数去抖\"><a href=\"#1-什么是函数去抖\" class=\"headerlink\" title=\"1. 什么是函数去抖\"></a>1. 什么是函数去抖</h4><p>当一个函数在在一定的间隔内没有被调用时，才开始执行被调用的方法。</p>\n<p>例如：用户在输入一段文字时，对文字进行处理，监听文字改变事件，每一次改变都会调用一次回调函数，但是想要的功能只是在用户输入停下来的时候才去执行回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> timeout, result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>, args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\ttimeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!immediate) &#123;</span><br><span class=\"line\">\t\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">\t\tclearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimeout = setTimeout(later, wait);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(callNow) &#123;</span><br><span class=\"line\">\t\t\tresult = func.apply(context, args);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设immediate == true：</p>\n<p>首次调用debounce(func,wait,immediate)，callNow = true，执行func函数；</p>\n<p>第二次调用debounce(func,wait,immediate)</p>\n<ul>\n<li>若间隔时间 &lt; wait，callNow == false，不执行func函数</li>\n<li>若间隔时间 &gt; wait，callNow == true，执行func函数</li>\n</ul>\n"},{"layout":"post","title":"GET和POST的区别","date":"2016-05-16T16:00:00.000Z","description":null,"_content":"\n### 1. GET请求\n\n从指定的服务器请求数据。\n\n查询的字符串（名值对）是在GET请求的URL中发送的。\n\n    /test/test.php?name1=value1&name2=value2\n\n### 2. POST请求\n\n查询字符串（名称/值对）是在 POST 请求的 **HTTP 消息主体**中发送的：\n\n    POST /test/test.php HTTP/1.1\n    Host: baidu.com\n    \n    name1=value1&name2=value2\n\n### 3. GET请求和POST请求的区别\n\n**（1）安全性**\n\nGET安全性较差，因为所发送的数据是URL的一部分。（发送密码或者敏感信息时不要使用GET）\n\nPOST比GET安全性好，参数不会被保存到浏览器历史或者web服务器日志中。\n\n**（2）对数据长度的限制**\n\nGET在URL中添加数据，URL长度是有限制的。\n\nPOST的数据长度无限制。\n\n**（3）可见性**\n\nGET请求的数据在URL中，因此是可见的。\n\nPOST请求的数据不会显示在URL中。\n\n**（4）缓存**\n\nGET请求可以被缓存\n\nPOST请求不会被缓存\n\n**（5）浏览器历史记录中**\n\nGET请求可以被保存在浏览器历史记录中\n\nPOST请求不会保存在浏览器历史记录中\n\n**（6）后退按钮/刷新按钮**\n\nGET请求：没有什么影响\n\nPOST请求：数据会被重新提交（浏览器应该告诉用户数据会被重新提交）\n\n\n\n","source":"_posts/2016-05-17-GET和POST的区别.md","raw":"---\nlayout: post\ntitle: GET和POST的区别\ndate: 2016-05-17\ncategories: http协议\ntags: [http]\ndescription: \n---\n\n### 1. GET请求\n\n从指定的服务器请求数据。\n\n查询的字符串（名值对）是在GET请求的URL中发送的。\n\n    /test/test.php?name1=value1&name2=value2\n\n### 2. POST请求\n\n查询字符串（名称/值对）是在 POST 请求的 **HTTP 消息主体**中发送的：\n\n    POST /test/test.php HTTP/1.1\n    Host: baidu.com\n    \n    name1=value1&name2=value2\n\n### 3. GET请求和POST请求的区别\n\n**（1）安全性**\n\nGET安全性较差，因为所发送的数据是URL的一部分。（发送密码或者敏感信息时不要使用GET）\n\nPOST比GET安全性好，参数不会被保存到浏览器历史或者web服务器日志中。\n\n**（2）对数据长度的限制**\n\nGET在URL中添加数据，URL长度是有限制的。\n\nPOST的数据长度无限制。\n\n**（3）可见性**\n\nGET请求的数据在URL中，因此是可见的。\n\nPOST请求的数据不会显示在URL中。\n\n**（4）缓存**\n\nGET请求可以被缓存\n\nPOST请求不会被缓存\n\n**（5）浏览器历史记录中**\n\nGET请求可以被保存在浏览器历史记录中\n\nPOST请求不会保存在浏览器历史记录中\n\n**（6）后退按钮/刷新按钮**\n\nGET请求：没有什么影响\n\nPOST请求：数据会被重新提交（浏览器应该告诉用户数据会被重新提交）\n\n\n\n","slug":"2016-05-17-GET和POST的区别","published":1,"updated":"2016-08-20T07:55:20.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgn006fd5u87tldkjlo","content":"<h3 id=\"1-GET请求\"><a href=\"#1-GET请求\" class=\"headerlink\" title=\"1. GET请求\"></a>1. GET请求</h3><p>从指定的服务器请求数据。</p>\n<p>查询的字符串（名值对）是在GET请求的URL中发送的。</p>\n<pre><code>/test/test.php?name1=value1&amp;name2=value2\n</code></pre><h3 id=\"2-POST请求\"><a href=\"#2-POST请求\" class=\"headerlink\" title=\"2. POST请求\"></a>2. POST请求</h3><p>查询字符串（名称/值对）是在 POST 请求的 <strong>HTTP 消息主体</strong>中发送的：</p>\n<pre><code>POST /test/test.php HTTP/1.1\nHost: baidu.com\n\nname1=value1&amp;name2=value2\n</code></pre><h3 id=\"3-GET请求和POST请求的区别\"><a href=\"#3-GET请求和POST请求的区别\" class=\"headerlink\" title=\"3. GET请求和POST请求的区别\"></a>3. GET请求和POST请求的区别</h3><p><strong>（1）安全性</strong></p>\n<p>GET安全性较差，因为所发送的数据是URL的一部分。（发送密码或者敏感信息时不要使用GET）</p>\n<p>POST比GET安全性好，参数不会被保存到浏览器历史或者web服务器日志中。</p>\n<p><strong>（2）对数据长度的限制</strong></p>\n<p>GET在URL中添加数据，URL长度是有限制的。</p>\n<p>POST的数据长度无限制。</p>\n<p><strong>（3）可见性</strong></p>\n<p>GET请求的数据在URL中，因此是可见的。</p>\n<p>POST请求的数据不会显示在URL中。</p>\n<p><strong>（4）缓存</strong></p>\n<p>GET请求可以被缓存</p>\n<p>POST请求不会被缓存</p>\n<p><strong>（5）浏览器历史记录中</strong></p>\n<p>GET请求可以被保存在浏览器历史记录中</p>\n<p>POST请求不会保存在浏览器历史记录中</p>\n<p><strong>（6）后退按钮/刷新按钮</strong></p>\n<p>GET请求：没有什么影响</p>\n<p>POST请求：数据会被重新提交（浏览器应该告诉用户数据会被重新提交）</p>\n","excerpt":"","more":"<h3 id=\"1-GET请求\"><a href=\"#1-GET请求\" class=\"headerlink\" title=\"1. GET请求\"></a>1. GET请求</h3><p>从指定的服务器请求数据。</p>\n<p>查询的字符串（名值对）是在GET请求的URL中发送的。</p>\n<pre><code>/test/test.php?name1=value1&amp;name2=value2\n</code></pre><h3 id=\"2-POST请求\"><a href=\"#2-POST请求\" class=\"headerlink\" title=\"2. POST请求\"></a>2. POST请求</h3><p>查询字符串（名称/值对）是在 POST 请求的 <strong>HTTP 消息主体</strong>中发送的：</p>\n<pre><code>POST /test/test.php HTTP/1.1\nHost: baidu.com\n\nname1=value1&amp;name2=value2\n</code></pre><h3 id=\"3-GET请求和POST请求的区别\"><a href=\"#3-GET请求和POST请求的区别\" class=\"headerlink\" title=\"3. GET请求和POST请求的区别\"></a>3. GET请求和POST请求的区别</h3><p><strong>（1）安全性</strong></p>\n<p>GET安全性较差，因为所发送的数据是URL的一部分。（发送密码或者敏感信息时不要使用GET）</p>\n<p>POST比GET安全性好，参数不会被保存到浏览器历史或者web服务器日志中。</p>\n<p><strong>（2）对数据长度的限制</strong></p>\n<p>GET在URL中添加数据，URL长度是有限制的。</p>\n<p>POST的数据长度无限制。</p>\n<p><strong>（3）可见性</strong></p>\n<p>GET请求的数据在URL中，因此是可见的。</p>\n<p>POST请求的数据不会显示在URL中。</p>\n<p><strong>（4）缓存</strong></p>\n<p>GET请求可以被缓存</p>\n<p>POST请求不会被缓存</p>\n<p><strong>（5）浏览器历史记录中</strong></p>\n<p>GET请求可以被保存在浏览器历史记录中</p>\n<p>POST请求不会保存在浏览器历史记录中</p>\n<p><strong>（6）后退按钮/刷新按钮</strong></p>\n<p>GET请求：没有什么影响</p>\n<p>POST请求：数据会被重新提交（浏览器应该告诉用户数据会被重新提交）</p>\n"},{"layout":"post","title":"js 数据类型","date":"2016-05-15T16:00:00.000Z","description":null,"_content":"\njs中的变量分为2种类型：基本类型、引用类型\n\n基本类型：简单的数据段。按值访问，操作保存在变量中的实际的值。\n\n引用类型：可能由多个值构成的对象。按**引用访问**，操作的是对象的引用，而不是实际的对象。\n\n### 一. 基本类型的分类\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n**null、undefined的区别**\n\n#### 1. 相同点\n\n(1) 在if语句中，都会自动被转换成false\n\t```js\n    var a = undefined;\n    if(!a){\n    \talert(a);//undefined\n    }\n    \n    var a = null;\n    if(!a){\n    \talert(a);//null\n    }\n\t```\n\n\n(2) 在相等运算符中，两者是相等的\n\t```js\n\tif(undefined == null){\n\t\talert(\"1\");//1\n\t}\n\t```\n\n#### 2. 不同之处\n\n**undefined指的是一个基本类型没有值（缺少值）。**\n\t```js\n    变量声明了，但是没有赋值时，这时变量等于undefined\n    var i;\n    i // undefined\n    \n    函数没有返回值时，默认返回undefined\n    var x = f();\n    x // undefined\n    \n    调用函数时，没有提供需要的参数，该参数等于undefined\n    function f(x){console.log(x)}\n    f() // undefined\n    \n    对象的属性没有被赋值时，等于undefined\n    var  o = new Object();\n    o.p // undefined\n\t```\n\nnull表示一个空对象的指针，可作为原型链的终点\n\ntypeof null; //Object\nnull instanceof Object; //false\n\n### 二. 引用类型的分类\n\n- Object\n- Array\n- Date\n- RegExp\n- Function\n\n### 三. 三种类型的检测方法\n\n#### 1. typeof\n\n检测一个变量是否是 string、number、boolean、undefined\n\n检测一个变量是否为**函数**\n\n```js\nvar a = \"123\";\nvar b = 22;\nvar c = false;\nvar d;\nvar e = function() {\n\t...\n};\n\nconsole.log(typeof a);//string\nconsole.log(typeof b);//number\nconsole.log(typeof c);//boolean\nconsole.log(typeof d);//undefined\nconsole.log(typeof e);//function\n```\n\n当用typeof来检测引用类型和null时，返回的都是object\n\n```js\nvar e = {};\nvar f = null;\n\nconsole.log(typeof e);\nconsole.log(typeof f);\n```\n\n#### 2. instanceof\n\n检测引用类型、null\n\n```js\nvar myArr=[1,2,3];\nconsole.log(myArr instanceof Array);//true\n```\n\n用instanceof检测基本类型都会返回false\n\n**instanceof实现原理**\n\n实例 instanceof 构造函数\n\n只要后面的构造函数是原型链中出现过的构造函数就会返回true，并不仅仅是判断实例的constructor的指向\n\n举个栗子：\n\n```\n\tfunction Bar() {};\n\tfunction Foo() {};\n\n\tBar.prototype = new Foo();//Bar继承了Foo\n\n\tnew Bar() instanceof Bar;//true\n\tnew Bar() instanceof Foo;//true\n```\n\n#### 3. Object.prototype.toString.call()\n\n用于检测内置对象\n\nObject.prototype.toString.call([])\n\n会输出'[object Array]'\n\n**检测数组的方法：**\n\nArray.isArray([]); //true\n\n\n\n\n\n","source":"_posts/2016-05-16-js 基本数据类型.md","raw":"---\nlayout: post\ntitle: js 数据类型\ndate: 2016-05-16\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\njs中的变量分为2种类型：基本类型、引用类型\n\n基本类型：简单的数据段。按值访问，操作保存在变量中的实际的值。\n\n引用类型：可能由多个值构成的对象。按**引用访问**，操作的是对象的引用，而不是实际的对象。\n\n### 一. 基本类型的分类\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n**null、undefined的区别**\n\n#### 1. 相同点\n\n(1) 在if语句中，都会自动被转换成false\n\t```js\n    var a = undefined;\n    if(!a){\n    \talert(a);//undefined\n    }\n    \n    var a = null;\n    if(!a){\n    \talert(a);//null\n    }\n\t```\n\n\n(2) 在相等运算符中，两者是相等的\n\t```js\n\tif(undefined == null){\n\t\talert(\"1\");//1\n\t}\n\t```\n\n#### 2. 不同之处\n\n**undefined指的是一个基本类型没有值（缺少值）。**\n\t```js\n    变量声明了，但是没有赋值时，这时变量等于undefined\n    var i;\n    i // undefined\n    \n    函数没有返回值时，默认返回undefined\n    var x = f();\n    x // undefined\n    \n    调用函数时，没有提供需要的参数，该参数等于undefined\n    function f(x){console.log(x)}\n    f() // undefined\n    \n    对象的属性没有被赋值时，等于undefined\n    var  o = new Object();\n    o.p // undefined\n\t```\n\nnull表示一个空对象的指针，可作为原型链的终点\n\ntypeof null; //Object\nnull instanceof Object; //false\n\n### 二. 引用类型的分类\n\n- Object\n- Array\n- Date\n- RegExp\n- Function\n\n### 三. 三种类型的检测方法\n\n#### 1. typeof\n\n检测一个变量是否是 string、number、boolean、undefined\n\n检测一个变量是否为**函数**\n\n```js\nvar a = \"123\";\nvar b = 22;\nvar c = false;\nvar d;\nvar e = function() {\n\t...\n};\n\nconsole.log(typeof a);//string\nconsole.log(typeof b);//number\nconsole.log(typeof c);//boolean\nconsole.log(typeof d);//undefined\nconsole.log(typeof e);//function\n```\n\n当用typeof来检测引用类型和null时，返回的都是object\n\n```js\nvar e = {};\nvar f = null;\n\nconsole.log(typeof e);\nconsole.log(typeof f);\n```\n\n#### 2. instanceof\n\n检测引用类型、null\n\n```js\nvar myArr=[1,2,3];\nconsole.log(myArr instanceof Array);//true\n```\n\n用instanceof检测基本类型都会返回false\n\n**instanceof实现原理**\n\n实例 instanceof 构造函数\n\n只要后面的构造函数是原型链中出现过的构造函数就会返回true，并不仅仅是判断实例的constructor的指向\n\n举个栗子：\n\n```\n\tfunction Bar() {};\n\tfunction Foo() {};\n\n\tBar.prototype = new Foo();//Bar继承了Foo\n\n\tnew Bar() instanceof Bar;//true\n\tnew Bar() instanceof Foo;//true\n```\n\n#### 3. Object.prototype.toString.call()\n\n用于检测内置对象\n\nObject.prototype.toString.call([])\n\n会输出'[object Array]'\n\n**检测数组的方法：**\n\nArray.isArray([]); //true\n\n\n\n\n\n","slug":"2016-05-16-js 基本数据类型","published":1,"updated":"2016-08-27T14:43:32.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgp006id5u8te7ntv6e","content":"<p>js中的变量分为2种类型：基本类型、引用类型</p>\n<p>基本类型：简单的数据段。按值访问，操作保存在变量中的实际的值。</p>\n<p>引用类型：可能由多个值构成的对象。按<strong>引用访问</strong>，操作的是对象的引用，而不是实际的对象。</p>\n<h3 id=\"一-基本类型的分类\"><a href=\"#一-基本类型的分类\" class=\"headerlink\" title=\"一. 基本类型的分类\"></a>一. 基本类型的分类</h3><ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ul>\n<p><strong>null、undefined的区别</strong></p>\n<h4 id=\"1-相同点\"><a href=\"#1-相同点\" class=\"headerlink\" title=\"1. 相同点\"></a>1. 相同点</h4><p>(1) 在if语句中，都会自动被转换成false<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!a)&#123;</span><br><span class=\"line\">\talert(a);<span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!a)&#123;</span><br><span class=\"line\">\talert(a);<span class=\"comment\">//null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>(2) 在相等运算符中，两者是相等的<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">undefined</span> == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"1\"</span>);<span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-不同之处\"><a href=\"#2-不同之处\" class=\"headerlink\" title=\"2. 不同之处\"></a>2. 不同之处</h4><p><strong>undefined指的是一个基本类型没有值（缺少值）。</strong><br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量声明了，但是没有赋值时，这时变量等于<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">函数没有返回值时，默认返回<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = f();</span><br><span class=\"line\">x <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">调用函数时，没有提供需要的参数，该参数等于<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"built_in\">console</span>.log(x)&#125;</span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">对象的属性没有被赋值时，等于<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>  o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.p <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>null表示一个空对象的指针，可作为原型链的终点</p>\n<p>typeof null; //Object<br>null instanceof Object; //false</p>\n<h3 id=\"二-引用类型的分类\"><a href=\"#二-引用类型的分类\" class=\"headerlink\" title=\"二. 引用类型的分类\"></a>二. 引用类型的分类</h3><ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Function</li>\n</ul>\n<h3 id=\"三-三种类型的检测方法\"><a href=\"#三-三种类型的检测方法\" class=\"headerlink\" title=\"三. 三种类型的检测方法\"></a>三. 三种类型的检测方法</h3><h4 id=\"1-typeof\"><a href=\"#1-typeof\" class=\"headerlink\" title=\"1. typeof\"></a>1. typeof</h4><p>检测一个变量是否是 string、number、boolean、undefined</p>\n<p>检测一个变量是否为<strong>函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a);<span class=\"comment\">//string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> b);<span class=\"comment\">//number</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> c);<span class=\"comment\">//boolean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> d);<span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> e);<span class=\"comment\">//function</span></span><br></pre></td></tr></table></figure>\n<p>当用typeof来检测引用类型和null时，返回的都是object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> e = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> e);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> f);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-instanceof\"><a href=\"#2-instanceof\" class=\"headerlink\" title=\"2. instanceof\"></a>2. instanceof</h4><p>检测引用类型、null</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>用instanceof检测基本类型都会返回false</p>\n<p><strong>instanceof实现原理</strong></p>\n<p>实例 instanceof 构造函数</p>\n<p>只要后面的构造函数是原型链中出现过的构造函数就会返回true，并不仅仅是判断实例的constructor的指向</p>\n<p>举个栗子：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype = <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//Bar继承了Foo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bar() <span class=\"keyword\">instanceof</span> Bar;<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bar() <span class=\"keyword\">instanceof</span> Foo;<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-Object-prototype-toString-call\"><a href=\"#3-Object-prototype-toString-call\" class=\"headerlink\" title=\"3. Object.prototype.toString.call()\"></a>3. Object.prototype.toString.call()</h4><p>用于检测内置对象</p>\n<p>Object.prototype.toString.call([])</p>\n<p>会输出’[object Array]’</p>\n<p><strong>检测数组的方法：</strong></p>\n<p>Array.isArray([]); //true</p>\n","excerpt":"","more":"<p>js中的变量分为2种类型：基本类型、引用类型</p>\n<p>基本类型：简单的数据段。按值访问，操作保存在变量中的实际的值。</p>\n<p>引用类型：可能由多个值构成的对象。按<strong>引用访问</strong>，操作的是对象的引用，而不是实际的对象。</p>\n<h3 id=\"一-基本类型的分类\"><a href=\"#一-基本类型的分类\" class=\"headerlink\" title=\"一. 基本类型的分类\"></a>一. 基本类型的分类</h3><ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ul>\n<p><strong>null、undefined的区别</strong></p>\n<h4 id=\"1-相同点\"><a href=\"#1-相同点\" class=\"headerlink\" title=\"1. 相同点\"></a>1. 相同点</h4><p>(1) 在if语句中，都会自动被转换成false<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!a)&#123;</span><br><span class=\"line\">\talert(a);<span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!a)&#123;</span><br><span class=\"line\">\talert(a);<span class=\"comment\">//null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>(2) 在相等运算符中，两者是相等的<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">undefined</span> == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"1\"</span>);<span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-不同之处\"><a href=\"#2-不同之处\" class=\"headerlink\" title=\"2. 不同之处\"></a>2. 不同之处</h4><p><strong>undefined指的是一个基本类型没有值（缺少值）。</strong><br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量声明了，但是没有赋值时，这时变量等于<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">函数没有返回值时，默认返回<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = f();</span><br><span class=\"line\">x <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">调用函数时，没有提供需要的参数，该参数等于<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"built_in\">console</span>.log(x)&#125;</span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">对象的属性没有被赋值时，等于<span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>  o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.p <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>null表示一个空对象的指针，可作为原型链的终点</p>\n<p>typeof null; //Object<br>null instanceof Object; //false</p>\n<h3 id=\"二-引用类型的分类\"><a href=\"#二-引用类型的分类\" class=\"headerlink\" title=\"二. 引用类型的分类\"></a>二. 引用类型的分类</h3><ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Function</li>\n</ul>\n<h3 id=\"三-三种类型的检测方法\"><a href=\"#三-三种类型的检测方法\" class=\"headerlink\" title=\"三. 三种类型的检测方法\"></a>三. 三种类型的检测方法</h3><h4 id=\"1-typeof\"><a href=\"#1-typeof\" class=\"headerlink\" title=\"1. typeof\"></a>1. typeof</h4><p>检测一个变量是否是 string、number、boolean、undefined</p>\n<p>检测一个变量是否为<strong>函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a);<span class=\"comment\">//string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> b);<span class=\"comment\">//number</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> c);<span class=\"comment\">//boolean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> d);<span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> e);<span class=\"comment\">//function</span></span><br></pre></td></tr></table></figure>\n<p>当用typeof来检测引用类型和null时，返回的都是object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> e = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> e);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> f);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-instanceof\"><a href=\"#2-instanceof\" class=\"headerlink\" title=\"2. instanceof\"></a>2. instanceof</h4><p>检测引用类型、null</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>用instanceof检测基本类型都会返回false</p>\n<p><strong>instanceof实现原理</strong></p>\n<p>实例 instanceof 构造函数</p>\n<p>只要后面的构造函数是原型链中出现过的构造函数就会返回true，并不仅仅是判断实例的constructor的指向</p>\n<p>举个栗子：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype = <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//Bar继承了Foo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bar() <span class=\"keyword\">instanceof</span> Bar;<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bar() <span class=\"keyword\">instanceof</span> Foo;<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-Object-prototype-toString-call\"><a href=\"#3-Object-prototype-toString-call\" class=\"headerlink\" title=\"3. Object.prototype.toString.call()\"></a>3. Object.prototype.toString.call()</h4><p>用于检测内置对象</p>\n<p>Object.prototype.toString.call([])</p>\n<p>会输出’[object Array]’</p>\n<p><strong>检测数组的方法：</strong></p>\n<p>Array.isArray([]); //true</p>\n"},{"layout":"post","title":"js中的设计模式","date":"2016-05-16T16:00:00.000Z","description":null,"_content":"\n《js设计模式》\n\n随着js能做的事情越来越多，在js编程中也会考虑设计模式。\n\n**<font color=\"red\">考虑设计模式的优点：</font>**\n\n- 可维护性：设计模式有助于降低模块之间的耦合程度。\n- 沟通：提供了一种通用的术语。\n- 性能：有的设计模式能够提高程序的运行速度。\n\n**<font color=\"red\">考虑设计模式带来的问题：</font>**\n\n- 复杂性：程序可能会变得复杂一些。\n- 性能：有的设计模式可能会使代码的性能变差。\n\n**<font color=\"red\">设计模式的类别：</font>**\n\n**创建型设计模式：**用于处理对象创建机制。\n\n    eg：\n    Constructor（构造器）—— 构造函数\n\tFactory（工厂）\n\tAbstract（抽象）\n\tprototype（原型）\n\tSingleton（单例）\n\tBuilder（生成器）\n\n**结构型设计模式：**找出在不同对象之间建立关系的简单方法。\n\n    eg:\n    Decorator（装饰者）\n    Facade（外观）\n    Flyweight（享元）\n    Adapter（适配器）\n    Proxy（代理）\n\n**行为设计模式：**改善或者简化系统中不同对象之间的通信。\n\n    eg:\n    Iterator（迭代器）\n    Mediator（中介者）\n    Observer（观察者）\n    Vistor（访问者）\n\n\n### 一. 接口\n\n#### 1. 什么是接口\n\n接口中定义了一个类实现了哪些方法，这些方法有哪些参数。\n\n#### 2. 接口的作用\n\n促进代码的重用。\n\n#### 3. 在js中模仿接口\n\n- 注释法\n- 属性法\n- 鸭式辨法\n\n将注释法和鸭式辨法结合起来：\n\n//Interfaces\nvar Composite = new Interface(\"Composite\",[\"add\",\"remove\"]);\nvar FormItem = new Interface(\"FormItem\",[\"save\"]);\n\n\n### 二. 封装\n\n封装就是把一个对象保护起来，使其只提供定义的接口方法，而保护私有的变量。打个比方，游戏中的一个人物对象，它的经验只有通过打死怪兽这个接口方法来增加。如果可以直接修改经验就会直接影响到整个游戏的设定。所以这个时候经验这个属性就是一个需要保护的变量。\n\n闭包实现封装类\n\n### 三. 继承\n\n继承是一种减少重复性代码的一种设计模式，尽量弱化对象间耦合，开闭原则的一种很好的实现。\n\n\n### 四. 单例\n\n单例是一个全局变量，使用单例可以更好的控制全局变量，还可以利用分支技术来封装浏览器之间的差异。网页中使用全局变量由于可以被重写风险很大。所以使用单例会更好的控制全局变量。\n\n### 五. 链式调用\n\n这个解释起来比较难，我觉得直接看代码比较直接，这个链式调用的主要用处，就是使代码更加简化，增加代码易读性。使用回调技术可以使取值器方法也只是链式调用。\n\n### 六. 工厂模式\n\n1.工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。\n\n2.工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。\n\n### 七. 抽象工厂模式\n\n抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。下面通过一个例子来深入理解。\n\n### 八. 发布/订阅模式（观察者模式）\n\n广播电台，人们会把频道调到他们最喜欢的节目。广播站不知道观众听得是什么或者他们正在听什么。他只需要发布他们的节目就可以啦。观众也不知道广播站制作节目的过程。他们只要在他们最喜欢的节目运行的时候把台调到对应的频道或者告知朋友就行。\n\n**广播站是发布者，听众是订阅者。**\n\n**订阅者和发布者之间是相互独立地运行。**\n\n这个模式中，包含三个部分：订阅、发布、事件。\n\n看一下jquery里面的trigger\n\t```js\n\t$(\".ele\").on(\"click\",function(){\n\t    console.log(\"clicking\");//监听事件（订阅）\n\t});\n\n\t$(\".ele\").trigger(\"click\");//触发事件（发布）\n\t```\n\n登录框和header的部分是完全不同的两个部分。这个场景就很适合发布订阅模式了。\n看一下\n\n如果你的登录状态改变了的话，会有一系列的订阅程序发生.而且每个订阅之间互不干扰，你可以随便添加或者删除订阅，这都不会影响你的登录的执行逻辑. \n\n订阅发布模式如果按数学翻译其实就是.一对多的映射关系.怎么解释呢？ 就是一个开关，同时并联几个灯泡(在不同房间),触发的时候，几个灯泡都会得到指令，然后执行发光的行为。\n\n一个订阅(监听程序),一个发布(触发事件).而他们中间的链接枢纽就是事件。\n\t```js\n\tvar makePubSub = function(){\n\n        var callbacks={};//callbacks是一个hash表，将监听的事件作为属性，将相应的订阅函数作为值，例如：订阅了一个callbacks={\"click\":func}\n\n        var subscribe = function(ev,func){\n            //检验该事件是否被监听了\n            \n            if(!callbacks[ev]){\n                callbacks[ev]=[];\n            }\n            callbacks[ev].push(func);\n            console.log(this);//这里的this指向调用这个方法的对象\n            return this;            \n        };\n\n        var publish = function(){\n            //将输入的实参变成数组（将类数组对象变成数组）\n            var args=Array.prototype.slice.call(arguments,0);\n    \n            //函数的第一个实参是要触发的事件\n            var ev=args.shift();\n    \n            //Return if callbacks object doesn't contain\n            //any entry for event\n            var list,i;\n            if(!callbacks[ev]){//如果hash表中不存在这个事件\n                console.log(this);\n                return this;\n                \n            }\n\n            list=callbacks[ev];\n            console.log(list[i]);\n\n            //触发事件，list里面装的是事件触发时需要执行的函数，list里面可以有多个函数\n            for(i=0;i<list.length;i++){\n                list[i].apply(this,args);\n                console.log(args);\n                console.log(this);\n            }\n            console.log(this);\n            return this;\n            \n        };\n    \n        return {pub:publish,sub:subscribe};\n    }\n    \n    var test=makePubSub();//由于函数返回的是一个对象，因此test是一个对象，有sub,pub两个方法\n\n    test.sub(\"click\",function(){alert(\"hell0\");});//订阅一个click事件，执行的回调是alert(\"hell0\")\n\n    test.pub(\"click\");//触发一个click事件\n\t```","source":"_posts/2016-05-17-js中的设计模式.md","raw":"---\nlayout: post\ntitle: js中的设计模式\ndate: 2016-05-17\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n《js设计模式》\n\n随着js能做的事情越来越多，在js编程中也会考虑设计模式。\n\n**<font color=\"red\">考虑设计模式的优点：</font>**\n\n- 可维护性：设计模式有助于降低模块之间的耦合程度。\n- 沟通：提供了一种通用的术语。\n- 性能：有的设计模式能够提高程序的运行速度。\n\n**<font color=\"red\">考虑设计模式带来的问题：</font>**\n\n- 复杂性：程序可能会变得复杂一些。\n- 性能：有的设计模式可能会使代码的性能变差。\n\n**<font color=\"red\">设计模式的类别：</font>**\n\n**创建型设计模式：**用于处理对象创建机制。\n\n    eg：\n    Constructor（构造器）—— 构造函数\n\tFactory（工厂）\n\tAbstract（抽象）\n\tprototype（原型）\n\tSingleton（单例）\n\tBuilder（生成器）\n\n**结构型设计模式：**找出在不同对象之间建立关系的简单方法。\n\n    eg:\n    Decorator（装饰者）\n    Facade（外观）\n    Flyweight（享元）\n    Adapter（适配器）\n    Proxy（代理）\n\n**行为设计模式：**改善或者简化系统中不同对象之间的通信。\n\n    eg:\n    Iterator（迭代器）\n    Mediator（中介者）\n    Observer（观察者）\n    Vistor（访问者）\n\n\n### 一. 接口\n\n#### 1. 什么是接口\n\n接口中定义了一个类实现了哪些方法，这些方法有哪些参数。\n\n#### 2. 接口的作用\n\n促进代码的重用。\n\n#### 3. 在js中模仿接口\n\n- 注释法\n- 属性法\n- 鸭式辨法\n\n将注释法和鸭式辨法结合起来：\n\n//Interfaces\nvar Composite = new Interface(\"Composite\",[\"add\",\"remove\"]);\nvar FormItem = new Interface(\"FormItem\",[\"save\"]);\n\n\n### 二. 封装\n\n封装就是把一个对象保护起来，使其只提供定义的接口方法，而保护私有的变量。打个比方，游戏中的一个人物对象，它的经验只有通过打死怪兽这个接口方法来增加。如果可以直接修改经验就会直接影响到整个游戏的设定。所以这个时候经验这个属性就是一个需要保护的变量。\n\n闭包实现封装类\n\n### 三. 继承\n\n继承是一种减少重复性代码的一种设计模式，尽量弱化对象间耦合，开闭原则的一种很好的实现。\n\n\n### 四. 单例\n\n单例是一个全局变量，使用单例可以更好的控制全局变量，还可以利用分支技术来封装浏览器之间的差异。网页中使用全局变量由于可以被重写风险很大。所以使用单例会更好的控制全局变量。\n\n### 五. 链式调用\n\n这个解释起来比较难，我觉得直接看代码比较直接，这个链式调用的主要用处，就是使代码更加简化，增加代码易读性。使用回调技术可以使取值器方法也只是链式调用。\n\n### 六. 工厂模式\n\n1.工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。\n\n2.工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。\n\n### 七. 抽象工厂模式\n\n抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。下面通过一个例子来深入理解。\n\n### 八. 发布/订阅模式（观察者模式）\n\n广播电台，人们会把频道调到他们最喜欢的节目。广播站不知道观众听得是什么或者他们正在听什么。他只需要发布他们的节目就可以啦。观众也不知道广播站制作节目的过程。他们只要在他们最喜欢的节目运行的时候把台调到对应的频道或者告知朋友就行。\n\n**广播站是发布者，听众是订阅者。**\n\n**订阅者和发布者之间是相互独立地运行。**\n\n这个模式中，包含三个部分：订阅、发布、事件。\n\n看一下jquery里面的trigger\n\t```js\n\t$(\".ele\").on(\"click\",function(){\n\t    console.log(\"clicking\");//监听事件（订阅）\n\t});\n\n\t$(\".ele\").trigger(\"click\");//触发事件（发布）\n\t```\n\n登录框和header的部分是完全不同的两个部分。这个场景就很适合发布订阅模式了。\n看一下\n\n如果你的登录状态改变了的话，会有一系列的订阅程序发生.而且每个订阅之间互不干扰，你可以随便添加或者删除订阅，这都不会影响你的登录的执行逻辑. \n\n订阅发布模式如果按数学翻译其实就是.一对多的映射关系.怎么解释呢？ 就是一个开关，同时并联几个灯泡(在不同房间),触发的时候，几个灯泡都会得到指令，然后执行发光的行为。\n\n一个订阅(监听程序),一个发布(触发事件).而他们中间的链接枢纽就是事件。\n\t```js\n\tvar makePubSub = function(){\n\n        var callbacks={};//callbacks是一个hash表，将监听的事件作为属性，将相应的订阅函数作为值，例如：订阅了一个callbacks={\"click\":func}\n\n        var subscribe = function(ev,func){\n            //检验该事件是否被监听了\n            \n            if(!callbacks[ev]){\n                callbacks[ev]=[];\n            }\n            callbacks[ev].push(func);\n            console.log(this);//这里的this指向调用这个方法的对象\n            return this;            \n        };\n\n        var publish = function(){\n            //将输入的实参变成数组（将类数组对象变成数组）\n            var args=Array.prototype.slice.call(arguments,0);\n    \n            //函数的第一个实参是要触发的事件\n            var ev=args.shift();\n    \n            //Return if callbacks object doesn't contain\n            //any entry for event\n            var list,i;\n            if(!callbacks[ev]){//如果hash表中不存在这个事件\n                console.log(this);\n                return this;\n                \n            }\n\n            list=callbacks[ev];\n            console.log(list[i]);\n\n            //触发事件，list里面装的是事件触发时需要执行的函数，list里面可以有多个函数\n            for(i=0;i<list.length;i++){\n                list[i].apply(this,args);\n                console.log(args);\n                console.log(this);\n            }\n            console.log(this);\n            return this;\n            \n        };\n    \n        return {pub:publish,sub:subscribe};\n    }\n    \n    var test=makePubSub();//由于函数返回的是一个对象，因此test是一个对象，有sub,pub两个方法\n\n    test.sub(\"click\",function(){alert(\"hell0\");});//订阅一个click事件，执行的回调是alert(\"hell0\")\n\n    test.pub(\"click\");//触发一个click事件\n\t```","slug":"2016-05-17-js中的设计模式","published":1,"updated":"2016-07-04T14:11:24.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgs006md5u8pjqj1dzz","content":"<p>《js设计模式》</p>\n<p>随着js能做的事情越来越多，在js编程中也会考虑设计模式。</p>\n<p><strong><font color=\"red\">考虑设计模式的优点：</font></strong></p>\n<ul>\n<li>可维护性：设计模式有助于降低模块之间的耦合程度。</li>\n<li>沟通：提供了一种通用的术语。</li>\n<li>性能：有的设计模式能够提高程序的运行速度。</li>\n</ul>\n<p><strong><font color=\"red\">考虑设计模式带来的问题：</font></strong></p>\n<ul>\n<li>复杂性：程序可能会变得复杂一些。</li>\n<li>性能：有的设计模式可能会使代码的性能变差。</li>\n</ul>\n<p><strong><font color=\"red\">设计模式的类别：</font></strong></p>\n<p><strong>创建型设计模式：</strong>用于处理对象创建机制。</p>\n<pre><code>eg：\nConstructor（构造器）—— 构造函数\nFactory（工厂）\nAbstract（抽象）\nprototype（原型）\nSingleton（单例）\nBuilder（生成器）\n</code></pre><p><strong>结构型设计模式：</strong>找出在不同对象之间建立关系的简单方法。</p>\n<pre><code>eg:\nDecorator（装饰者）\nFacade（外观）\nFlyweight（享元）\nAdapter（适配器）\nProxy（代理）\n</code></pre><p><strong>行为设计模式：</strong>改善或者简化系统中不同对象之间的通信。</p>\n<pre><code>eg:\nIterator（迭代器）\nMediator（中介者）\nObserver（观察者）\nVistor（访问者）\n</code></pre><h3 id=\"一-接口\"><a href=\"#一-接口\" class=\"headerlink\" title=\"一. 接口\"></a>一. 接口</h3><h4 id=\"1-什么是接口\"><a href=\"#1-什么是接口\" class=\"headerlink\" title=\"1. 什么是接口\"></a>1. 什么是接口</h4><p>接口中定义了一个类实现了哪些方法，这些方法有哪些参数。</p>\n<h4 id=\"2-接口的作用\"><a href=\"#2-接口的作用\" class=\"headerlink\" title=\"2. 接口的作用\"></a>2. 接口的作用</h4><p>促进代码的重用。</p>\n<h4 id=\"3-在js中模仿接口\"><a href=\"#3-在js中模仿接口\" class=\"headerlink\" title=\"3. 在js中模仿接口\"></a>3. 在js中模仿接口</h4><ul>\n<li>注释法</li>\n<li>属性法</li>\n<li>鸭式辨法</li>\n</ul>\n<p>将注释法和鸭式辨法结合起来：</p>\n<p>//Interfaces<br>var Composite = new Interface(“Composite”,[“add”,”remove”]);<br>var FormItem = new Interface(“FormItem”,[“save”]);</p>\n<h3 id=\"二-封装\"><a href=\"#二-封装\" class=\"headerlink\" title=\"二. 封装\"></a>二. 封装</h3><p>封装就是把一个对象保护起来，使其只提供定义的接口方法，而保护私有的变量。打个比方，游戏中的一个人物对象，它的经验只有通过打死怪兽这个接口方法来增加。如果可以直接修改经验就会直接影响到整个游戏的设定。所以这个时候经验这个属性就是一个需要保护的变量。</p>\n<p>闭包实现封装类</p>\n<h3 id=\"三-继承\"><a href=\"#三-继承\" class=\"headerlink\" title=\"三. 继承\"></a>三. 继承</h3><p>继承是一种减少重复性代码的一种设计模式，尽量弱化对象间耦合，开闭原则的一种很好的实现。</p>\n<h3 id=\"四-单例\"><a href=\"#四-单例\" class=\"headerlink\" title=\"四. 单例\"></a>四. 单例</h3><p>单例是一个全局变量，使用单例可以更好的控制全局变量，还可以利用分支技术来封装浏览器之间的差异。网页中使用全局变量由于可以被重写风险很大。所以使用单例会更好的控制全局变量。</p>\n<h3 id=\"五-链式调用\"><a href=\"#五-链式调用\" class=\"headerlink\" title=\"五. 链式调用\"></a>五. 链式调用</h3><p>这个解释起来比较难，我觉得直接看代码比较直接，这个链式调用的主要用处，就是使代码更加简化，增加代码易读性。使用回调技术可以使取值器方法也只是链式调用。</p>\n<h3 id=\"六-工厂模式\"><a href=\"#六-工厂模式\" class=\"headerlink\" title=\"六. 工厂模式\"></a>六. 工厂模式</h3><p>1.工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。</p>\n<p>2.工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</p>\n<h3 id=\"七-抽象工厂模式\"><a href=\"#七-抽象工厂模式\" class=\"headerlink\" title=\"七. 抽象工厂模式\"></a>七. 抽象工厂模式</h3><p>抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。下面通过一个例子来深入理解。</p>\n<h3 id=\"八-发布-订阅模式（观察者模式）\"><a href=\"#八-发布-订阅模式（观察者模式）\" class=\"headerlink\" title=\"八. 发布/订阅模式（观察者模式）\"></a>八. 发布/订阅模式（观察者模式）</h3><p>广播电台，人们会把频道调到他们最喜欢的节目。广播站不知道观众听得是什么或者他们正在听什么。他只需要发布他们的节目就可以啦。观众也不知道广播站制作节目的过程。他们只要在他们最喜欢的节目运行的时候把台调到对应的频道或者告知朋友就行。</p>\n<p><strong>广播站是发布者，听众是订阅者。</strong></p>\n<p><strong>订阅者和发布者之间是相互独立地运行。</strong></p>\n<p>这个模式中，包含三个部分：订阅、发布、事件。</p>\n<p>看一下jquery里面的trigger<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicking\"</span>);<span class=\"comment\">//监听事件（订阅）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).trigger(<span class=\"string\">\"click\"</span>);<span class=\"comment\">//触发事件（发布）</span></span><br></pre></td></tr></table></figure></p>\n<p>登录框和header的部分是完全不同的两个部分。这个场景就很适合发布订阅模式了。<br>看一下</p>\n<p>如果你的登录状态改变了的话，会有一系列的订阅程序发生.而且每个订阅之间互不干扰，你可以随便添加或者删除订阅，这都不会影响你的登录的执行逻辑. </p>\n<p>订阅发布模式如果按数学翻译其实就是.一对多的映射关系.怎么解释呢？ 就是一个开关，同时并联几个灯泡(在不同房间),触发的时候，几个灯泡都会得到指令，然后执行发光的行为。</p>\n<p>一个订阅(监听程序),一个发布(触发事件).而他们中间的链接枢纽就是事件。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> makePubSub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">var</span> callbacks=&#123;&#125;;<span class=\"comment\">//callbacks是一个hash表，将监听的事件作为属性，将相应的订阅函数作为值，例如：订阅了一个callbacks=&#123;\"click\":func&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">var</span> subscribe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev,func</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">//检验该事件是否被监听了</span></span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">if</span>(!callbacks[ev])&#123;</span><br><span class=\"line\">               callbacks[ev]=[];</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           callbacks[ev].push(func);</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">//这里的this指向调用这个方法的对象</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;            </span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">var</span> publish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">//将输入的实参变成数组（将类数组对象变成数组）</span></span><br><span class=\"line\">           <span class=\"keyword\">var</span> args=<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"comment\">//函数的第一个实参是要触发的事件</span></span><br><span class=\"line\">           <span class=\"keyword\">var</span> ev=args.shift();</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"comment\">//Return if callbacks object doesn't contain</span></span><br><span class=\"line\">           <span class=\"comment\">//any entry for event</span></span><br><span class=\"line\">           <span class=\"keyword\">var</span> list,i;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(!callbacks[ev])&#123;<span class=\"comment\">//如果hash表中不存在这个事件</span></span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           list=callbacks[ev];</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(list[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//触发事件，list里面装的是事件触发时需要执行的函数，list里面可以有多个函数</span></span><br><span class=\"line\">           <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;list.length;i++)&#123;</span><br><span class=\"line\">               list[i].apply(<span class=\"keyword\">this</span>,args);</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(args);</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"keyword\">return</span> &#123;pub:publish,sub:subscribe&#125;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">var</span> test=makePubSub();<span class=\"comment\">//由于函数返回的是一个对象，因此test是一个对象，有sub,pub两个方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">   test.sub(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">\"hell0\"</span>);&#125;);<span class=\"comment\">//订阅一个click事件，执行的回调是alert(\"hell0\")</span></span><br><span class=\"line\"></span><br><span class=\"line\">   test.pub(<span class=\"string\">\"click\"</span>);<span class=\"comment\">//触发一个click事件</span></span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>《js设计模式》</p>\n<p>随着js能做的事情越来越多，在js编程中也会考虑设计模式。</p>\n<p><strong><font color=\"red\">考虑设计模式的优点：</font></strong></p>\n<ul>\n<li>可维护性：设计模式有助于降低模块之间的耦合程度。</li>\n<li>沟通：提供了一种通用的术语。</li>\n<li>性能：有的设计模式能够提高程序的运行速度。</li>\n</ul>\n<p><strong><font color=\"red\">考虑设计模式带来的问题：</font></strong></p>\n<ul>\n<li>复杂性：程序可能会变得复杂一些。</li>\n<li>性能：有的设计模式可能会使代码的性能变差。</li>\n</ul>\n<p><strong><font color=\"red\">设计模式的类别：</font></strong></p>\n<p><strong>创建型设计模式：</strong>用于处理对象创建机制。</p>\n<pre><code>eg：\nConstructor（构造器）—— 构造函数\nFactory（工厂）\nAbstract（抽象）\nprototype（原型）\nSingleton（单例）\nBuilder（生成器）\n</code></pre><p><strong>结构型设计模式：</strong>找出在不同对象之间建立关系的简单方法。</p>\n<pre><code>eg:\nDecorator（装饰者）\nFacade（外观）\nFlyweight（享元）\nAdapter（适配器）\nProxy（代理）\n</code></pre><p><strong>行为设计模式：</strong>改善或者简化系统中不同对象之间的通信。</p>\n<pre><code>eg:\nIterator（迭代器）\nMediator（中介者）\nObserver（观察者）\nVistor（访问者）\n</code></pre><h3 id=\"一-接口\"><a href=\"#一-接口\" class=\"headerlink\" title=\"一. 接口\"></a>一. 接口</h3><h4 id=\"1-什么是接口\"><a href=\"#1-什么是接口\" class=\"headerlink\" title=\"1. 什么是接口\"></a>1. 什么是接口</h4><p>接口中定义了一个类实现了哪些方法，这些方法有哪些参数。</p>\n<h4 id=\"2-接口的作用\"><a href=\"#2-接口的作用\" class=\"headerlink\" title=\"2. 接口的作用\"></a>2. 接口的作用</h4><p>促进代码的重用。</p>\n<h4 id=\"3-在js中模仿接口\"><a href=\"#3-在js中模仿接口\" class=\"headerlink\" title=\"3. 在js中模仿接口\"></a>3. 在js中模仿接口</h4><ul>\n<li>注释法</li>\n<li>属性法</li>\n<li>鸭式辨法</li>\n</ul>\n<p>将注释法和鸭式辨法结合起来：</p>\n<p>//Interfaces<br>var Composite = new Interface(“Composite”,[“add”,”remove”]);<br>var FormItem = new Interface(“FormItem”,[“save”]);</p>\n<h3 id=\"二-封装\"><a href=\"#二-封装\" class=\"headerlink\" title=\"二. 封装\"></a>二. 封装</h3><p>封装就是把一个对象保护起来，使其只提供定义的接口方法，而保护私有的变量。打个比方，游戏中的一个人物对象，它的经验只有通过打死怪兽这个接口方法来增加。如果可以直接修改经验就会直接影响到整个游戏的设定。所以这个时候经验这个属性就是一个需要保护的变量。</p>\n<p>闭包实现封装类</p>\n<h3 id=\"三-继承\"><a href=\"#三-继承\" class=\"headerlink\" title=\"三. 继承\"></a>三. 继承</h3><p>继承是一种减少重复性代码的一种设计模式，尽量弱化对象间耦合，开闭原则的一种很好的实现。</p>\n<h3 id=\"四-单例\"><a href=\"#四-单例\" class=\"headerlink\" title=\"四. 单例\"></a>四. 单例</h3><p>单例是一个全局变量，使用单例可以更好的控制全局变量，还可以利用分支技术来封装浏览器之间的差异。网页中使用全局变量由于可以被重写风险很大。所以使用单例会更好的控制全局变量。</p>\n<h3 id=\"五-链式调用\"><a href=\"#五-链式调用\" class=\"headerlink\" title=\"五. 链式调用\"></a>五. 链式调用</h3><p>这个解释起来比较难，我觉得直接看代码比较直接，这个链式调用的主要用处，就是使代码更加简化，增加代码易读性。使用回调技术可以使取值器方法也只是链式调用。</p>\n<h3 id=\"六-工厂模式\"><a href=\"#六-工厂模式\" class=\"headerlink\" title=\"六. 工厂模式\"></a>六. 工厂模式</h3><p>1.工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。</p>\n<p>2.工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</p>\n<h3 id=\"七-抽象工厂模式\"><a href=\"#七-抽象工厂模式\" class=\"headerlink\" title=\"七. 抽象工厂模式\"></a>七. 抽象工厂模式</h3><p>抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。下面通过一个例子来深入理解。</p>\n<h3 id=\"八-发布-订阅模式（观察者模式）\"><a href=\"#八-发布-订阅模式（观察者模式）\" class=\"headerlink\" title=\"八. 发布/订阅模式（观察者模式）\"></a>八. 发布/订阅模式（观察者模式）</h3><p>广播电台，人们会把频道调到他们最喜欢的节目。广播站不知道观众听得是什么或者他们正在听什么。他只需要发布他们的节目就可以啦。观众也不知道广播站制作节目的过程。他们只要在他们最喜欢的节目运行的时候把台调到对应的频道或者告知朋友就行。</p>\n<p><strong>广播站是发布者，听众是订阅者。</strong></p>\n<p><strong>订阅者和发布者之间是相互独立地运行。</strong></p>\n<p>这个模式中，包含三个部分：订阅、发布、事件。</p>\n<p>看一下jquery里面的trigger<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicking\"</span>);<span class=\"comment\">//监听事件（订阅）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).trigger(<span class=\"string\">\"click\"</span>);<span class=\"comment\">//触发事件（发布）</span></span><br></pre></td></tr></table></figure></p>\n<p>登录框和header的部分是完全不同的两个部分。这个场景就很适合发布订阅模式了。<br>看一下</p>\n<p>如果你的登录状态改变了的话，会有一系列的订阅程序发生.而且每个订阅之间互不干扰，你可以随便添加或者删除订阅，这都不会影响你的登录的执行逻辑. </p>\n<p>订阅发布模式如果按数学翻译其实就是.一对多的映射关系.怎么解释呢？ 就是一个开关，同时并联几个灯泡(在不同房间),触发的时候，几个灯泡都会得到指令，然后执行发光的行为。</p>\n<p>一个订阅(监听程序),一个发布(触发事件).而他们中间的链接枢纽就是事件。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> makePubSub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">var</span> callbacks=&#123;&#125;;<span class=\"comment\">//callbacks是一个hash表，将监听的事件作为属性，将相应的订阅函数作为值，例如：订阅了一个callbacks=&#123;\"click\":func&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">var</span> subscribe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev,func</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">//检验该事件是否被监听了</span></span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">if</span>(!callbacks[ev])&#123;</span><br><span class=\"line\">               callbacks[ev]=[];</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           callbacks[ev].push(func);</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">//这里的this指向调用这个方法的对象</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;            </span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">var</span> publish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">//将输入的实参变成数组（将类数组对象变成数组）</span></span><br><span class=\"line\">           <span class=\"keyword\">var</span> args=<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"comment\">//函数的第一个实参是要触发的事件</span></span><br><span class=\"line\">           <span class=\"keyword\">var</span> ev=args.shift();</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"comment\">//Return if callbacks object doesn't contain</span></span><br><span class=\"line\">           <span class=\"comment\">//any entry for event</span></span><br><span class=\"line\">           <span class=\"keyword\">var</span> list,i;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(!callbacks[ev])&#123;<span class=\"comment\">//如果hash表中不存在这个事件</span></span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           list=callbacks[ev];</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(list[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//触发事件，list里面装的是事件触发时需要执行的函数，list里面可以有多个函数</span></span><br><span class=\"line\">           <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;list.length;i++)&#123;</span><br><span class=\"line\">               list[i].apply(<span class=\"keyword\">this</span>,args);</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(args);</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">           </span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"keyword\">return</span> &#123;pub:publish,sub:subscribe&#125;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">var</span> test=makePubSub();<span class=\"comment\">//由于函数返回的是一个对象，因此test是一个对象，有sub,pub两个方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">   test.sub(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"string\">\"hell0\"</span>);&#125;);<span class=\"comment\">//订阅一个click事件，执行的回调是alert(\"hell0\")</span></span><br><span class=\"line\"></span><br><span class=\"line\">   test.pub(<span class=\"string\">\"click\"</span>);<span class=\"comment\">//触发一个click事件</span></span><br></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"css中的像素","date":"2016-05-16T16:00:00.000Z","description":null,"_content":"\n- em\n- rem\n- px\n- pt\n- vw/vh\n\n#### 1. em\n\nem是相对单位，基准点是父元素的font-size。\n\t```js\n\teg:\n\t<body style=\"font-size:14px\">\n\t    <p style=\"font-size:2em\">我这里的字体显示大小是28px(14px*2)</p>  \n\t    <div style=\"font-size:18px\">\n\t        <p style=\"font-size:2em\">我这里显示字体大小是36px(18px*2),而不是上面计算的28px</p>\n\t    </div>\n\t</body>\n\t```\n\n#### 2. rem css3中新增的\n\nroot emphasize\n\nrem是css3的属性，基准点是相对于html根元素的。\n\nrem布局方式\n\t```js\n\teg:\n\thtml{\n    \tfont-size:20px;\n\t}\n\t.btn {\n    \twidth: 6rem;\n    \theight: 3rem;\n    \tline-height: 3rem;\n    \tfont-size: 1.2rem;\n    \tdisplay: inline-block;\n    \tbackground: #06c;\n    \tcolor: #fff;\n    \tborder-radius: .5rem;\n    \ttext-decoration: none;\n    \ttext-align: center;    \n\t}\n\t```\n**rem的优点：**\n\n- 只修改根元素就成比例地调整所有字体大小\n- 可以避免字体大小逐层复合的连锁反应\t\n\n#### 3. px 像素\n\npx(pixel)指的是像素，是**屏幕上显示数据的最基本的点**，表示**相对大小**。不同分辨率下相同长度的px元素显示会不一样，\n\n相同的屏幕大小，分辨率越大，那么每一个像素就越小。\n\n比如同样是14px大小的字，在**分辨率为1366 * 768**显示屏下会显示的小，在**分辨率1024 * 768**尺寸的显示器下会相对大点\n\n#### 4. pt \n\n印刷行业常用的单位，表示绝对长度\n\n#### 5. vw和vh\n\n\t```js\n    vw:屏幕宽度相关，1vw是屏幕宽度的1%\n    vh:屏幕高度相关，1vh是屏幕高度的1%\n    vmin，vmax 分别表示两者中较小和较大的部分。\n\t```\n\n可以使用vw实现一个正方形\n\n```\n<div class=\"vw\">hello,viewport</div>\n\n.vw {\n        width: 50%;\n        height: 50vw;\n        background: #ccc;\n    }\n```","source":"_posts/2016-05-17-css中的像素.md","raw":"---\nlayout: post\ntitle: css中的像素\ndate: 2016-05-17\ncategories: CSS\ntags: [css]\ndescription: \n---\n\n- em\n- rem\n- px\n- pt\n- vw/vh\n\n#### 1. em\n\nem是相对单位，基准点是父元素的font-size。\n\t```js\n\teg:\n\t<body style=\"font-size:14px\">\n\t    <p style=\"font-size:2em\">我这里的字体显示大小是28px(14px*2)</p>  \n\t    <div style=\"font-size:18px\">\n\t        <p style=\"font-size:2em\">我这里显示字体大小是36px(18px*2),而不是上面计算的28px</p>\n\t    </div>\n\t</body>\n\t```\n\n#### 2. rem css3中新增的\n\nroot emphasize\n\nrem是css3的属性，基准点是相对于html根元素的。\n\nrem布局方式\n\t```js\n\teg:\n\thtml{\n    \tfont-size:20px;\n\t}\n\t.btn {\n    \twidth: 6rem;\n    \theight: 3rem;\n    \tline-height: 3rem;\n    \tfont-size: 1.2rem;\n    \tdisplay: inline-block;\n    \tbackground: #06c;\n    \tcolor: #fff;\n    \tborder-radius: .5rem;\n    \ttext-decoration: none;\n    \ttext-align: center;    \n\t}\n\t```\n**rem的优点：**\n\n- 只修改根元素就成比例地调整所有字体大小\n- 可以避免字体大小逐层复合的连锁反应\t\n\n#### 3. px 像素\n\npx(pixel)指的是像素，是**屏幕上显示数据的最基本的点**，表示**相对大小**。不同分辨率下相同长度的px元素显示会不一样，\n\n相同的屏幕大小，分辨率越大，那么每一个像素就越小。\n\n比如同样是14px大小的字，在**分辨率为1366 * 768**显示屏下会显示的小，在**分辨率1024 * 768**尺寸的显示器下会相对大点\n\n#### 4. pt \n\n印刷行业常用的单位，表示绝对长度\n\n#### 5. vw和vh\n\n\t```js\n    vw:屏幕宽度相关，1vw是屏幕宽度的1%\n    vh:屏幕高度相关，1vh是屏幕高度的1%\n    vmin，vmax 分别表示两者中较小和较大的部分。\n\t```\n\n可以使用vw实现一个正方形\n\n```\n<div class=\"vw\">hello,viewport</div>\n\n.vw {\n        width: 50%;\n        height: 50vw;\n        background: #ccc;\n    }\n```","slug":"2016-05-17-css中的像素","published":1,"updated":"2016-09-07T07:53:08.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgt006pd5u8fg0xsimv","content":"<ul>\n<li>em</li>\n<li>rem</li>\n<li>px</li>\n<li>pt</li>\n<li>vw/vh</li>\n</ul>\n<h4 id=\"1-em\"><a href=\"#1-em\" class=\"headerlink\" title=\"1. em\"></a>1. em</h4><p>em是相对单位，基准点是父元素的font-size。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:14px\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:2em\"</span>&gt;</span>我这里的字体显示大小是28px(14px*2)<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:18px\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:2em\"</span>&gt;</span>我这里显示字体大小是36px(18px*2),而不是上面计算的28px<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-rem-css3中新增的\"><a href=\"#2-rem-css3中新增的\" class=\"headerlink\" title=\"2. rem css3中新增的\"></a>2. rem css3中新增的</h4><p>root emphasize</p>\n<p>rem是css3的属性，基准点是相对于html根元素的。</p>\n<p>rem布局方式<br>    <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">html&#123;</span><br><span class=\"line\">   \tfont-size:20px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.btn &#123;</span><br><span class=\"line\">   \twidth: 6rem;</span><br><span class=\"line\">   \theight: 3rem;</span><br><span class=\"line\">   \tline-height: 3rem;</span><br><span class=\"line\">   \tfont-size: 1.2rem;</span><br><span class=\"line\">   \tdisplay: inline-block;</span><br><span class=\"line\">   \tbackground: #06c;</span><br><span class=\"line\">   \tcolor: #fff;</span><br><span class=\"line\">   \tborder-radius: .5rem;</span><br><span class=\"line\">   \ttext-decoration: none;</span><br><span class=\"line\">   \ttext-align: center;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>rem的优点：</strong></p>\n<ul>\n<li>只修改根元素就成比例地调整所有字体大小</li>\n<li>可以避免字体大小逐层复合的连锁反应    </li>\n</ul>\n<h4 id=\"3-px-像素\"><a href=\"#3-px-像素\" class=\"headerlink\" title=\"3. px 像素\"></a>3. px 像素</h4><p>px(pixel)指的是像素，是<strong>屏幕上显示数据的最基本的点</strong>，表示<strong>相对大小</strong>。不同分辨率下相同长度的px元素显示会不一样，</p>\n<p>相同的屏幕大小，分辨率越大，那么每一个像素就越小。</p>\n<p>比如同样是14px大小的字，在<strong>分辨率为1366 * 768</strong>显示屏下会显示的小，在<strong>分辨率1024 * 768</strong>尺寸的显示器下会相对大点</p>\n<h4 id=\"4-pt\"><a href=\"#4-pt\" class=\"headerlink\" title=\"4. pt\"></a>4. pt</h4><p>印刷行业常用的单位，表示绝对长度</p>\n<h4 id=\"5-vw和vh\"><a href=\"#5-vw和vh\" class=\"headerlink\" title=\"5. vw和vh\"></a>5. vw和vh</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vw:屏幕宽度相关，<span class=\"number\">1</span>vw是屏幕宽度的<span class=\"number\">1</span>%</span><br><span class=\"line\">vh:屏幕高度相关，<span class=\"number\">1</span>vh是屏幕高度的<span class=\"number\">1</span>%</span><br><span class=\"line\">vmin，vmax 分别表示两者中较小和较大的部分。</span><br></pre></td></tr></table></figure>\n</code></pre><p>可以使用vw实现一个正方形</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">\"vw\"</span>&gt;hello,viewport&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.vw</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">50vw</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<ul>\n<li>em</li>\n<li>rem</li>\n<li>px</li>\n<li>pt</li>\n<li>vw/vh</li>\n</ul>\n<h4 id=\"1-em\"><a href=\"#1-em\" class=\"headerlink\" title=\"1. em\"></a>1. em</h4><p>em是相对单位，基准点是父元素的font-size。<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:14px\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:2em\"</span>&gt;</span>我这里的字体显示大小是28px(14px*2)<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:18px\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:2em\"</span>&gt;</span>我这里显示字体大小是36px(18px*2),而不是上面计算的28px<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-rem-css3中新增的\"><a href=\"#2-rem-css3中新增的\" class=\"headerlink\" title=\"2. rem css3中新增的\"></a>2. rem css3中新增的</h4><p>root emphasize</p>\n<p>rem是css3的属性，基准点是相对于html根元素的。</p>\n<p>rem布局方式<br>    <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">html&#123;</span><br><span class=\"line\">   \tfont-size:20px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.btn &#123;</span><br><span class=\"line\">   \twidth: 6rem;</span><br><span class=\"line\">   \theight: 3rem;</span><br><span class=\"line\">   \tline-height: 3rem;</span><br><span class=\"line\">   \tfont-size: 1.2rem;</span><br><span class=\"line\">   \tdisplay: inline-block;</span><br><span class=\"line\">   \tbackground: #06c;</span><br><span class=\"line\">   \tcolor: #fff;</span><br><span class=\"line\">   \tborder-radius: .5rem;</span><br><span class=\"line\">   \ttext-decoration: none;</span><br><span class=\"line\">   \ttext-align: center;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>rem的优点：</strong></p>\n<ul>\n<li>只修改根元素就成比例地调整所有字体大小</li>\n<li>可以避免字体大小逐层复合的连锁反应    </li>\n</ul>\n<h4 id=\"3-px-像素\"><a href=\"#3-px-像素\" class=\"headerlink\" title=\"3. px 像素\"></a>3. px 像素</h4><p>px(pixel)指的是像素，是<strong>屏幕上显示数据的最基本的点</strong>，表示<strong>相对大小</strong>。不同分辨率下相同长度的px元素显示会不一样，</p>\n<p>相同的屏幕大小，分辨率越大，那么每一个像素就越小。</p>\n<p>比如同样是14px大小的字，在<strong>分辨率为1366 * 768</strong>显示屏下会显示的小，在<strong>分辨率1024 * 768</strong>尺寸的显示器下会相对大点</p>\n<h4 id=\"4-pt\"><a href=\"#4-pt\" class=\"headerlink\" title=\"4. pt\"></a>4. pt</h4><p>印刷行业常用的单位，表示绝对长度</p>\n<h4 id=\"5-vw和vh\"><a href=\"#5-vw和vh\" class=\"headerlink\" title=\"5. vw和vh\"></a>5. vw和vh</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vw:屏幕宽度相关，<span class=\"number\">1</span>vw是屏幕宽度的<span class=\"number\">1</span>%</span><br><span class=\"line\">vh:屏幕高度相关，<span class=\"number\">1</span>vh是屏幕高度的<span class=\"number\">1</span>%</span><br><span class=\"line\">vmin，vmax 分别表示两者中较小和较大的部分。</span><br></pre></td></tr></table></figure>\n</code></pre><p>可以使用vw实现一个正方形</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">\"vw\"</span>&gt;hello,viewport&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.vw</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">50vw</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"css3中的新属性","date":"2016-05-16T16:00:00.000Z","description":null,"_content":"\n## 一. css3中新增的特性\n\n- 新增选择器\n- 做出一些视觉效果（边框、文本、背景）\n- 弹性盒子布局\n- 媒体查询\n- 转换\n- 过渡\n- 动画\n\n### 1. css3中新增的选择器\n\n新增的选择器能够快速地指定到某一个HTML元素，能够更好地使表现与结构分离\n\n:nth-child()\n:not()\n:first-child()\n:last-child()\n\n:checked\n:disabled\n\n### 2. 使用css3可以做出一些视觉效果\n\n以前需要用图片来实现的一些效果，直接用css3可以实现\n\n例如：圆角、阴影、渐变背景、半透明、图片边框\n\n**边框**\n\n- border-radius 边框圆角\n- box-shadow  阴影\n- border-image 边框带图片\n\n**背景**\n\n- background-size 用来指定背景图片的大小\n\n- background-origin: border-box/padding-box/content-box\n\n与background-position配合使用，主要是指定从哪里开始计算position的x值和y值\n\n- background-clip: border-box/padding-box/content-box\n\n可以用来设置背景图的占盒子的哪几部分，默认是占border+padding+content\n \n**阴影**\n\ntext-shadow\nbox-shadow\n\n**文字**\n\n@Font-face 可以用来加载服务器上的字体样式\n\n```\n@font-face {\n\tfont-family: BorderWeb;\n\tsrc:url(...)\n}\n\n.class {\n\tfont-family: BorderWeb;\n}\n```\n\n文字截断 text-overflow:clip/ellipsis\n\n**颜色和透明度**\n\ncolor: rgba(255, 0, 0, 0.75); \n\n渐变\n\n### 4. 弹性盒子flex-box\n\n### 5. 盒容器的转换transform\n\ntransform: translate() 平移\ntransform: rotate() 旋转\ntransform: scale() 放大缩小\ntransform: skew()  翻转\n\n### 6. 过渡transition\n\ntransition：属性 时间 延迟执行的时间 过渡的类型\n\n通过给transition设置属性值，然后通过js修改那个属性值，就会呈现一种过渡的效果。\n\n可以将transform和transition结合起来，产生很多动画的效果\n\n### 7. 动画animation\n\nanimation: 动画名 动画执行一次的时间 变化的模式 动画重复次数 动画执行完一次后方向的变化方式 \n\nanimation-iteration-count: infinite; //可以定义动画无限次的播放\n\n利用关键帧keyframes定义动画\n\n**一个旋转的正方形**\n\n```\n\t<div class='circle'>\t\t\n\t</div>\n\n\t.circle {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground: red;\n\t\t\tanimation: myfirst 5s;\n\t\t}\n\n\t@keyframes myfirst {\n\t\t\tfrom {transform: rotate(0deg);}\n\t\t\tto {transform: rotate(360deg);}\n\t}\t\n```\n\n**使用纯CSS实现轮播图**\n\n```\n\t<div class='window'>\n\t\t<div class='slider'>\n\t\t\t<div class='item1'></div>\n\t\t\t<div class='item2'></div>\n\t\t\t<div class='item3'></div>\n\t\t</div>\n\t</div>\n\n\t.window {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\toverflow: hidden;\n\t\t}\n\n\t\t.slider{\n\t\t\twidth: 300px;\n\t\t\theight: 100px;\t\t\t\n\t\t\tanimation: myfirst 2s linear infinite alternate;\n\t\t}\n\n\t\t.item1, .item2, .item3 {\n\t\t\tfloat: left;\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t}\n\n\t\t.item1 {\n\t\t\tbackground: red;\n\t\t}\n\n\t\t.item2 {\n\t\t\tbackground: black;\n\t\t}\n\n\t\t.item3 {\n\t\t\tbackground: blue;\n\t\t}\n\n\t\t@keyframes myfirst\n\t\t{\n\t\t\t50% {transform: translateX(-100px);}\n\t\t\t100% {transform: translateX(-200px);}\n\t\t}\t\n\n```\n\n### 8. 媒体查询\n\n## 二. 使用css3的好处\n\n- 让页面看起来更加的绚丽\n- 使用css中的新特性代替之前需要使用图片才能完成的一些效果，减少开发和维护成本\n- 更少的脚本、图片使用户加载的内容减少，能够提高页面性能\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-05-17-css3中的新属性.md","raw":"---\nlayout: post\ntitle: css3中的新属性\ndate: 2016-05-17\ncategories: CSS\ntags: [css]\ndescription: \n---\n\n## 一. css3中新增的特性\n\n- 新增选择器\n- 做出一些视觉效果（边框、文本、背景）\n- 弹性盒子布局\n- 媒体查询\n- 转换\n- 过渡\n- 动画\n\n### 1. css3中新增的选择器\n\n新增的选择器能够快速地指定到某一个HTML元素，能够更好地使表现与结构分离\n\n:nth-child()\n:not()\n:first-child()\n:last-child()\n\n:checked\n:disabled\n\n### 2. 使用css3可以做出一些视觉效果\n\n以前需要用图片来实现的一些效果，直接用css3可以实现\n\n例如：圆角、阴影、渐变背景、半透明、图片边框\n\n**边框**\n\n- border-radius 边框圆角\n- box-shadow  阴影\n- border-image 边框带图片\n\n**背景**\n\n- background-size 用来指定背景图片的大小\n\n- background-origin: border-box/padding-box/content-box\n\n与background-position配合使用，主要是指定从哪里开始计算position的x值和y值\n\n- background-clip: border-box/padding-box/content-box\n\n可以用来设置背景图的占盒子的哪几部分，默认是占border+padding+content\n \n**阴影**\n\ntext-shadow\nbox-shadow\n\n**文字**\n\n@Font-face 可以用来加载服务器上的字体样式\n\n```\n@font-face {\n\tfont-family: BorderWeb;\n\tsrc:url(...)\n}\n\n.class {\n\tfont-family: BorderWeb;\n}\n```\n\n文字截断 text-overflow:clip/ellipsis\n\n**颜色和透明度**\n\ncolor: rgba(255, 0, 0, 0.75); \n\n渐变\n\n### 4. 弹性盒子flex-box\n\n### 5. 盒容器的转换transform\n\ntransform: translate() 平移\ntransform: rotate() 旋转\ntransform: scale() 放大缩小\ntransform: skew()  翻转\n\n### 6. 过渡transition\n\ntransition：属性 时间 延迟执行的时间 过渡的类型\n\n通过给transition设置属性值，然后通过js修改那个属性值，就会呈现一种过渡的效果。\n\n可以将transform和transition结合起来，产生很多动画的效果\n\n### 7. 动画animation\n\nanimation: 动画名 动画执行一次的时间 变化的模式 动画重复次数 动画执行完一次后方向的变化方式 \n\nanimation-iteration-count: infinite; //可以定义动画无限次的播放\n\n利用关键帧keyframes定义动画\n\n**一个旋转的正方形**\n\n```\n\t<div class='circle'>\t\t\n\t</div>\n\n\t.circle {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground: red;\n\t\t\tanimation: myfirst 5s;\n\t\t}\n\n\t@keyframes myfirst {\n\t\t\tfrom {transform: rotate(0deg);}\n\t\t\tto {transform: rotate(360deg);}\n\t}\t\n```\n\n**使用纯CSS实现轮播图**\n\n```\n\t<div class='window'>\n\t\t<div class='slider'>\n\t\t\t<div class='item1'></div>\n\t\t\t<div class='item2'></div>\n\t\t\t<div class='item3'></div>\n\t\t</div>\n\t</div>\n\n\t.window {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\toverflow: hidden;\n\t\t}\n\n\t\t.slider{\n\t\t\twidth: 300px;\n\t\t\theight: 100px;\t\t\t\n\t\t\tanimation: myfirst 2s linear infinite alternate;\n\t\t}\n\n\t\t.item1, .item2, .item3 {\n\t\t\tfloat: left;\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t}\n\n\t\t.item1 {\n\t\t\tbackground: red;\n\t\t}\n\n\t\t.item2 {\n\t\t\tbackground: black;\n\t\t}\n\n\t\t.item3 {\n\t\t\tbackground: blue;\n\t\t}\n\n\t\t@keyframes myfirst\n\t\t{\n\t\t\t50% {transform: translateX(-100px);}\n\t\t\t100% {transform: translateX(-200px);}\n\t\t}\t\n\n```\n\n### 8. 媒体查询\n\n## 二. 使用css3的好处\n\n- 让页面看起来更加的绚丽\n- 使用css中的新特性代替之前需要使用图片才能完成的一些效果，减少开发和维护成本\n- 更少的脚本、图片使用户加载的内容减少，能够提高页面性能\n\n\n\n\n\n\n\n\n\n","slug":"2016-05-17-css3中的新属性","published":1,"updated":"2016-09-07T07:38:58.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgv006td5u84coici1k","content":"<h2 id=\"一-css3中新增的特性\"><a href=\"#一-css3中新增的特性\" class=\"headerlink\" title=\"一. css3中新增的特性\"></a>一. css3中新增的特性</h2><ul>\n<li>新增选择器</li>\n<li>做出一些视觉效果（边框、文本、背景）</li>\n<li>弹性盒子布局</li>\n<li>媒体查询</li>\n<li>转换</li>\n<li>过渡</li>\n<li>动画</li>\n</ul>\n<h3 id=\"1-css3中新增的选择器\"><a href=\"#1-css3中新增的选择器\" class=\"headerlink\" title=\"1. css3中新增的选择器\"></a>1. css3中新增的选择器</h3><p>新增的选择器能够快速地指定到某一个HTML元素，能够更好地使表现与结构分离</p>\n<p>:nth-child()<br>:not()<br>:first-child()<br>:last-child()</p>\n<p>:checked<br>:disabled</p>\n<h3 id=\"2-使用css3可以做出一些视觉效果\"><a href=\"#2-使用css3可以做出一些视觉效果\" class=\"headerlink\" title=\"2. 使用css3可以做出一些视觉效果\"></a>2. 使用css3可以做出一些视觉效果</h3><p>以前需要用图片来实现的一些效果，直接用css3可以实现</p>\n<p>例如：圆角、阴影、渐变背景、半透明、图片边框</p>\n<p><strong>边框</strong></p>\n<ul>\n<li>border-radius 边框圆角</li>\n<li>box-shadow  阴影</li>\n<li>border-image 边框带图片</li>\n</ul>\n<p><strong>背景</strong></p>\n<ul>\n<li><p>background-size 用来指定背景图片的大小</p>\n</li>\n<li><p>background-origin: border-box/padding-box/content-box</p>\n</li>\n</ul>\n<p>与background-position配合使用，主要是指定从哪里开始计算position的x值和y值</p>\n<ul>\n<li>background-clip: border-box/padding-box/content-box</li>\n</ul>\n<p>可以用来设置背景图的占盒子的哪几部分，默认是占border+padding+content</p>\n<p><strong>阴影</strong></p>\n<p>text-shadow<br>box-shadow</p>\n<p><strong>文字</strong></p>\n<p>@Font-face 可以用来加载服务器上的字体样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">font-face</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>: BorderWeb;</span><br><span class=\"line\">\t<span class=\"attribute\">src</span>:<span class=\"built_in\">url</span>(...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.class</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>: BorderWeb;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>文字截断 text-overflow:clip/ellipsis</p>\n<p><strong>颜色和透明度</strong></p>\n<p>color: rgba(255, 0, 0, 0.75); </p>\n<p>渐变</p>\n<h3 id=\"4-弹性盒子flex-box\"><a href=\"#4-弹性盒子flex-box\" class=\"headerlink\" title=\"4. 弹性盒子flex-box\"></a>4. 弹性盒子flex-box</h3><h3 id=\"5-盒容器的转换transform\"><a href=\"#5-盒容器的转换transform\" class=\"headerlink\" title=\"5. 盒容器的转换transform\"></a>5. 盒容器的转换transform</h3><p>transform: translate() 平移<br>transform: rotate() 旋转<br>transform: scale() 放大缩小<br>transform: skew()  翻转</p>\n<h3 id=\"6-过渡transition\"><a href=\"#6-过渡transition\" class=\"headerlink\" title=\"6. 过渡transition\"></a>6. 过渡transition</h3><p>transition：属性 时间 延迟执行的时间 过渡的类型</p>\n<p>通过给transition设置属性值，然后通过js修改那个属性值，就会呈现一种过渡的效果。</p>\n<p>可以将transform和transition结合起来，产生很多动画的效果</p>\n<h3 id=\"7-动画animation\"><a href=\"#7-动画animation\" class=\"headerlink\" title=\"7. 动画animation\"></a>7. 动画animation</h3><p>animation: 动画名 动画执行一次的时间 变化的模式 动画重复次数 动画执行完一次后方向的变化方式 </p>\n<p>animation-iteration-count: infinite; //可以定义动画无限次的播放</p>\n<p>利用关键帧keyframes定义动画</p>\n<p><strong>一个旋转的正方形</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'circle'</span>&gt;\t\t</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.circle</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">\t\t<span class=\"attribute\">animation</span>: myfirst <span class=\"number\">5s</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes myfirst &#123;</span><br><span class=\"line\">\t\tfrom &#123;<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">0deg</span>);&#125;</span><br><span class=\"line\">\t\tto &#123;<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用纯CSS实现轮播图</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'window'</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'slider'</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'item1'</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'item2'</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'item3'</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.window</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t.slider&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;\t\t\t</span><br><span class=\"line\">\t\t<span class=\"attribute\">animation</span>: myfirst <span class=\"number\">2s</span> linear infinite alternate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item1</span>, <span class=\"selector-class\">.item2</span>, <span class=\"selector-class\">.item3</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item3</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@keyframes myfirst</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">50%</span> &#123;<span class=\"attribute\">transform</span>: translateX(-<span class=\"number\">100px</span>);&#125;</span><br><span class=\"line\">\t\t<span class=\"number\">100%</span> &#123;<span class=\"attribute\">transform</span>: translateX(-<span class=\"number\">200px</span>);&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-媒体查询\"><a href=\"#8-媒体查询\" class=\"headerlink\" title=\"8. 媒体查询\"></a>8. 媒体查询</h3><h2 id=\"二-使用css3的好处\"><a href=\"#二-使用css3的好处\" class=\"headerlink\" title=\"二. 使用css3的好处\"></a>二. 使用css3的好处</h2><ul>\n<li>让页面看起来更加的绚丽</li>\n<li>使用css中的新特性代替之前需要使用图片才能完成的一些效果，减少开发和维护成本</li>\n<li>更少的脚本、图片使用户加载的内容减少，能够提高页面性能</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"一-css3中新增的特性\"><a href=\"#一-css3中新增的特性\" class=\"headerlink\" title=\"一. css3中新增的特性\"></a>一. css3中新增的特性</h2><ul>\n<li>新增选择器</li>\n<li>做出一些视觉效果（边框、文本、背景）</li>\n<li>弹性盒子布局</li>\n<li>媒体查询</li>\n<li>转换</li>\n<li>过渡</li>\n<li>动画</li>\n</ul>\n<h3 id=\"1-css3中新增的选择器\"><a href=\"#1-css3中新增的选择器\" class=\"headerlink\" title=\"1. css3中新增的选择器\"></a>1. css3中新增的选择器</h3><p>新增的选择器能够快速地指定到某一个HTML元素，能够更好地使表现与结构分离</p>\n<p>:nth-child()<br>:not()<br>:first-child()<br>:last-child()</p>\n<p>:checked<br>:disabled</p>\n<h3 id=\"2-使用css3可以做出一些视觉效果\"><a href=\"#2-使用css3可以做出一些视觉效果\" class=\"headerlink\" title=\"2. 使用css3可以做出一些视觉效果\"></a>2. 使用css3可以做出一些视觉效果</h3><p>以前需要用图片来实现的一些效果，直接用css3可以实现</p>\n<p>例如：圆角、阴影、渐变背景、半透明、图片边框</p>\n<p><strong>边框</strong></p>\n<ul>\n<li>border-radius 边框圆角</li>\n<li>box-shadow  阴影</li>\n<li>border-image 边框带图片</li>\n</ul>\n<p><strong>背景</strong></p>\n<ul>\n<li><p>background-size 用来指定背景图片的大小</p>\n</li>\n<li><p>background-origin: border-box/padding-box/content-box</p>\n</li>\n</ul>\n<p>与background-position配合使用，主要是指定从哪里开始计算position的x值和y值</p>\n<ul>\n<li>background-clip: border-box/padding-box/content-box</li>\n</ul>\n<p>可以用来设置背景图的占盒子的哪几部分，默认是占border+padding+content</p>\n<p><strong>阴影</strong></p>\n<p>text-shadow<br>box-shadow</p>\n<p><strong>文字</strong></p>\n<p>@Font-face 可以用来加载服务器上的字体样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">font-face</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>: BorderWeb;</span><br><span class=\"line\">\t<span class=\"attribute\">src</span>:<span class=\"built_in\">url</span>(...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.class</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>: BorderWeb;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>文字截断 text-overflow:clip/ellipsis</p>\n<p><strong>颜色和透明度</strong></p>\n<p>color: rgba(255, 0, 0, 0.75); </p>\n<p>渐变</p>\n<h3 id=\"4-弹性盒子flex-box\"><a href=\"#4-弹性盒子flex-box\" class=\"headerlink\" title=\"4. 弹性盒子flex-box\"></a>4. 弹性盒子flex-box</h3><h3 id=\"5-盒容器的转换transform\"><a href=\"#5-盒容器的转换transform\" class=\"headerlink\" title=\"5. 盒容器的转换transform\"></a>5. 盒容器的转换transform</h3><p>transform: translate() 平移<br>transform: rotate() 旋转<br>transform: scale() 放大缩小<br>transform: skew()  翻转</p>\n<h3 id=\"6-过渡transition\"><a href=\"#6-过渡transition\" class=\"headerlink\" title=\"6. 过渡transition\"></a>6. 过渡transition</h3><p>transition：属性 时间 延迟执行的时间 过渡的类型</p>\n<p>通过给transition设置属性值，然后通过js修改那个属性值，就会呈现一种过渡的效果。</p>\n<p>可以将transform和transition结合起来，产生很多动画的效果</p>\n<h3 id=\"7-动画animation\"><a href=\"#7-动画animation\" class=\"headerlink\" title=\"7. 动画animation\"></a>7. 动画animation</h3><p>animation: 动画名 动画执行一次的时间 变化的模式 动画重复次数 动画执行完一次后方向的变化方式 </p>\n<p>animation-iteration-count: infinite; //可以定义动画无限次的播放</p>\n<p>利用关键帧keyframes定义动画</p>\n<p><strong>一个旋转的正方形</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'circle'</span>&gt;\t\t</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.circle</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">\t\t<span class=\"attribute\">animation</span>: myfirst <span class=\"number\">5s</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes myfirst &#123;</span><br><span class=\"line\">\t\tfrom &#123;<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">0deg</span>);&#125;</span><br><span class=\"line\">\t\tto &#123;<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用纯CSS实现轮播图</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'window'</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'slider'</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'item1'</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'item2'</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"selector-tag\">div</span> class=<span class=\"string\">'item3'</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.window</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t.slider&#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;\t\t\t</span><br><span class=\"line\">\t\t<span class=\"attribute\">animation</span>: myfirst <span class=\"number\">2s</span> linear infinite alternate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item1</span>, <span class=\"selector-class\">.item2</span>, <span class=\"selector-class\">.item3</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.item3</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@keyframes myfirst</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">50%</span> &#123;<span class=\"attribute\">transform</span>: translateX(-<span class=\"number\">100px</span>);&#125;</span><br><span class=\"line\">\t\t<span class=\"number\">100%</span> &#123;<span class=\"attribute\">transform</span>: translateX(-<span class=\"number\">200px</span>);&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-媒体查询\"><a href=\"#8-媒体查询\" class=\"headerlink\" title=\"8. 媒体查询\"></a>8. 媒体查询</h3><h2 id=\"二-使用css3的好处\"><a href=\"#二-使用css3的好处\" class=\"headerlink\" title=\"二. 使用css3的好处\"></a>二. 使用css3的好处</h2><ul>\n<li>让页面看起来更加的绚丽</li>\n<li>使用css中的新特性代替之前需要使用图片才能完成的一些效果，减少开发和维护成本</li>\n<li>更少的脚本、图片使用户加载的内容减少，能够提高页面性能</li>\n</ul>\n"},{"layout":"post","title":"一个旋转的圆","date":"2016-05-17T16:00:00.000Z","description":null,"_content":"\n一个旋转的圆\n```js\n.div{border-radius:50px;\nwidth:50px;\nheight:50px;\nanimation:mycircle 2s linear;\n}\n\n@keyframes mycircle\n{\n\tfrom { transform: rotate(0deg); }  \n    to { transform: rotate(360deg); }  \n}\n```\n\n","source":"_posts/2016-05-18-一个旋转的圆.md","raw":"---\nlayout: post\ntitle: 一个旋转的圆\ndate: 2016-05-18\ncategories: 前端笔记\ntags: [css]\ndescription: \n---\n\n一个旋转的圆\n```js\n.div{border-radius:50px;\nwidth:50px;\nheight:50px;\nanimation:mycircle 2s linear;\n}\n\n@keyframes mycircle\n{\n\tfrom { transform: rotate(0deg); }  \n    to { transform: rotate(360deg); }  \n}\n```\n\n","slug":"2016-05-18-一个旋转的圆","published":1,"updated":"2016-07-03T13:48:56.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocgz006wd5u8ii0dhnll","content":"<p>一个旋转的圆<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.div&#123;border-radius:<span class=\"number\">50</span>px;</span><br><span class=\"line\">width:<span class=\"number\">50</span>px;</span><br><span class=\"line\">height:<span class=\"number\">50</span>px;</span><br><span class=\"line\">animation:mycircle <span class=\"number\">2</span>s linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes mycircle</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> &#123; transform: rotate(<span class=\"number\">0</span>deg); &#125;  </span><br><span class=\"line\">    to &#123; transform: rotate(<span class=\"number\">360</span>deg); &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>一个旋转的圆<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.div&#123;border-radius:<span class=\"number\">50</span>px;</span><br><span class=\"line\">width:<span class=\"number\">50</span>px;</span><br><span class=\"line\">height:<span class=\"number\">50</span>px;</span><br><span class=\"line\">animation:mycircle <span class=\"number\">2</span>s linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes mycircle</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> &#123; transform: rotate(<span class=\"number\">0</span>deg); &#125;  </span><br><span class=\"line\">    to &#123; transform: rotate(<span class=\"number\">360</span>deg); &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"订阅发布模式","date":"2016-05-17T16:00:00.000Z","description":null,"_content":"\n今天面试让手写了一个类似jquery里面的on、trigger的程序\n\n\t```\n\t$(\".ele\").on(\"click\",function(){\n\t    console.log(\"clicking\");//监听事件（订阅）\n\t});\n\n\t$(\".ele\").trigger(\"click\");//触发事件（发布）\n\t```\n\n程序实现如下：\n\n\t\t```\n\t\tvar callbacks = {};\n        function on(type,func){\n            if(!callbacks[type]){\n                callbacks[type] = [];\n            }\n            callbacks[type].push(func);\n        }\n\n        function trigger(type){\n            var args = Array.prototype.slice.apply(arguments,1);\n            if(!callbacks[type]){\n                return;\n            }else{\n                for(var i = 0;i < callbacks[type].length;i++){\n                    callbacks[type][i].apply(this,args);\n                }\n            }\n        }\n\t\t```\n\n这个程序就是一个**订阅/发布模式**的程序。\n\n注意：\n\n一个type类型可以使用on来监听若干个事件，所以在trigger里面需要使用循环来调用这个type上的所有的事件处理程序\n\ntrigger还可以传入参数给事件处理程序\n\n```\n\t$(\".ele\").on(\"click\",function(a){\n\t    console.log(\"clicking\" + a);//监听事件（订阅）\n\t});\n\n\t$(\".ele\").trigger(\"click\", '1');//触发事件（发布）\n\t```","source":"_posts/2016-05-18-订阅发布模式.md","raw":"---\nlayout: post\ntitle: 订阅发布模式\ndate: 2016-05-18\ncategories: 算法学习\ntags: [算法,设计模式]\ndescription: \n---\n\n今天面试让手写了一个类似jquery里面的on、trigger的程序\n\n\t```\n\t$(\".ele\").on(\"click\",function(){\n\t    console.log(\"clicking\");//监听事件（订阅）\n\t});\n\n\t$(\".ele\").trigger(\"click\");//触发事件（发布）\n\t```\n\n程序实现如下：\n\n\t\t```\n\t\tvar callbacks = {};\n        function on(type,func){\n            if(!callbacks[type]){\n                callbacks[type] = [];\n            }\n            callbacks[type].push(func);\n        }\n\n        function trigger(type){\n            var args = Array.prototype.slice.apply(arguments,1);\n            if(!callbacks[type]){\n                return;\n            }else{\n                for(var i = 0;i < callbacks[type].length;i++){\n                    callbacks[type][i].apply(this,args);\n                }\n            }\n        }\n\t\t```\n\n这个程序就是一个**订阅/发布模式**的程序。\n\n注意：\n\n一个type类型可以使用on来监听若干个事件，所以在trigger里面需要使用循环来调用这个type上的所有的事件处理程序\n\ntrigger还可以传入参数给事件处理程序\n\n```\n\t$(\".ele\").on(\"click\",function(a){\n\t    console.log(\"clicking\" + a);//监听事件（订阅）\n\t});\n\n\t$(\".ele\").trigger(\"click\", '1');//触发事件（发布）\n\t```","slug":"2016-05-18-订阅发布模式","published":1,"updated":"2016-08-23T14:23:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035och10070d5u89pdt8dxj","content":"<p>今天面试让手写了一个类似jquery里面的on、trigger的程序</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicking\"</span>);<span class=\"comment\">//监听事件（订阅）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).trigger(<span class=\"string\">\"click\"</span>);<span class=\"comment\">//触发事件（发布）</span></span><br></pre></td></tr></table></figure>\n</code></pre><p>程序实现如下：</p>\n<pre><code><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> callbacks = &#123;&#125;;</span><br><span class=\"line\">      function on(<span class=\"class\"><span class=\"keyword\">type</span>,<span class=\"title\">func</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!callbacks[<span class=\"class\"><span class=\"keyword\">type</span>])</span>&#123;</span><br><span class=\"line\">              callbacks[<span class=\"class\"><span class=\"keyword\">type</span>] </span>= [];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          callbacks[<span class=\"class\"><span class=\"keyword\">type</span>].<span class=\"title\">push</span>(<span class=\"params\">func</span>)</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      function trigger(<span class=\"class\"><span class=\"keyword\">type</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> args = <span class=\"type\">Array</span>.prototype.slice.apply(arguments,<span class=\"number\">1</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!callbacks[<span class=\"class\"><span class=\"keyword\">type</span>])</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; callbacks[<span class=\"class\"><span class=\"keyword\">type</span>].<span class=\"title\">length</span></span>;i++)&#123;</span><br><span class=\"line\">                  callbacks[<span class=\"class\"><span class=\"keyword\">type</span>][i].<span class=\"title\">apply</span>(<span class=\"params\">this,args</span>)</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p>这个程序就是一个<strong>订阅/发布模式</strong>的程序。</p>\n<p>注意：</p>\n<p>一个type类型可以使用on来监听若干个事件，所以在trigger里面需要使用循环来调用这个type上的所有的事件处理程序</p>\n<p>trigger还可以传入参数给事件处理程序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicking\"</span> + a);<span class=\"comment\">//监听事件（订阅）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).trigger(<span class=\"string\">\"click\"</span>, <span class=\"string\">'1'</span>);<span class=\"comment\">//触发事件（发布）</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>今天面试让手写了一个类似jquery里面的on、trigger的程序</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicking\"</span>);<span class=\"comment\">//监听事件（订阅）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).trigger(<span class=\"string\">\"click\"</span>);<span class=\"comment\">//触发事件（发布）</span></span><br></pre></td></tr></table></figure>\n</code></pre><p>程序实现如下：</p>\n<pre><code><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> callbacks = &#123;&#125;;</span><br><span class=\"line\">      function on(<span class=\"class\"><span class=\"keyword\">type</span>,<span class=\"title\">func</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!callbacks[<span class=\"class\"><span class=\"keyword\">type</span>])</span>&#123;</span><br><span class=\"line\">              callbacks[<span class=\"class\"><span class=\"keyword\">type</span>] </span>= [];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          callbacks[<span class=\"class\"><span class=\"keyword\">type</span>].<span class=\"title\">push</span>(<span class=\"params\">func</span>)</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      function trigger(<span class=\"class\"><span class=\"keyword\">type</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> args = <span class=\"type\">Array</span>.prototype.slice.apply(arguments,<span class=\"number\">1</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!callbacks[<span class=\"class\"><span class=\"keyword\">type</span>])</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; callbacks[<span class=\"class\"><span class=\"keyword\">type</span>].<span class=\"title\">length</span></span>;i++)&#123;</span><br><span class=\"line\">                  callbacks[<span class=\"class\"><span class=\"keyword\">type</span>][i].<span class=\"title\">apply</span>(<span class=\"params\">this,args</span>)</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p>这个程序就是一个<strong>订阅/发布模式</strong>的程序。</p>\n<p>注意：</p>\n<p>一个type类型可以使用on来监听若干个事件，所以在trigger里面需要使用循环来调用这个type上的所有的事件处理程序</p>\n<p>trigger还可以传入参数给事件处理程序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).on(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicking\"</span> + a);<span class=\"comment\">//监听事件（订阅）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">\".ele\"</span>).trigger(<span class=\"string\">\"click\"</span>, <span class=\"string\">'1'</span>);<span class=\"comment\">//触发事件（发布）</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"数据库安全与防护","date":"2016-05-18T16:00:00.000Z","description":null,"_content":"\n### 一. 数据库安全性\n\n数据库系统中的数据共享不能是无条件的共享\n\n数据库安全性控制的常用方法：\n\n- 用户标识和鉴定：系统核对口令以鉴别用户身份，每个用户预先约定好一个计算过程或者函数\n \n- 存取控制：自主存取控制、强制存取控制\n\n**授权GRANT**\n\n用户权限组成：数据对象、操作类型\n\n定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作\n\n定义存取权限称为授权 \n\n\t  ```js\n\t  GRANT   SELECT //查询权限\n      ON   TABLE   Student //学生表\n      TO   U1;\t\t\t\t//给用户U1\n\t  这句SQL的意思是：把查询学生表的权限给用户U1\n\n\t  GRANT ALL PRIVILIGES //所有权利\n      ON TABLE Student, Course //学生表、课程表\n      TO U2, U3;\t\t\t//用户U2、U3\n\t  这句SQL的意思是：把对学生表、课程表的所有权限给用户U2、U3\n\n\t  GRANT SELECT //查询权限\n      ON TABLE SC  //选课表\n\t  TO PUBLIC;\t//所有用户\n\t  这句SQL的意思是：把对学生表的查询权限给用户U1\n\n\t  WITH GRANT OPTION;//允许将此权限授予给其他用户\n\t  ```\n\n**回收REVOKE**\n\n授予的权限可以由DBA或其他授权者用REVOKE语句收回\n\n\t  ```js\n\t  REVOKE UPDATE(Sno) //对学号的修改权限\n\t  ON TABLE Student \t//学生表\n\t  FROM U4;\t\t\t//用户U4\n\t  这句SQL的意思是：将用户U4的修改权限收回\n\n\t  REVOKE SELECT \n\t  ON TABLE SC \n\t  FROM PUBLIC;\n\t  这句SQL的意思是：收回所有用户对表SC的查询权限\n\n\t  REVOKE INSERT \n\t  ON TABLE SC \n\t  FROM U5 CASCADE ;//CASCADE 级联\n\t  ```\n\n**数据库角色**\n\n角色是权限的集合；可以为一组具有相同权限的用户创建一个角色\n；简化授权的过程\n\n- 创建角色 `CREATE  ROLE  <角色名> `\n\n- 给角色授权 \n\n- 将一个角色授予其他的角色或者用户\n\n- 角色权限的收回\n\n\t```js\n\teg:\n\n    通过角色来实现将一组权限授予一个用户。\n    步骤如下：\n    1. 首先创建一个角色 R1\n    CREATE  ROLE  R1；\n\n    2. 然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限\n    GRANT SELECT，UPDATE，INSERT \n    ON TABLE Student \n    TO R1；\n\n    3. 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限\n    GRANT  R1 \n    TO 王平，张明，赵玲；\n\n    4. 可以一次性通过R1来回收王平的这3个权限\n     REVOKE  R1 \n     FROM 王平；\n\t```\n\n\n\n- 视图\n\n- 审计\n\n审计日志（Audit Log)：将用户对数据库的所有操作记录在上面\n\n\t```js\n    AUDIT ALTER，UPDATE  \n    ON  SC；\n\t对修改SC表结构或修改SC表数据的操作进行审计\n\n\tNOAUDIT  ALTER，UPDATE  \n    ON  SC；\n\t取消对SC表的一切审计\n\t```\n\n- 密码存储\n\n\n","source":"_posts/2016-05-19-数据库安全与防护.md","raw":"---\nlayout: post\ntitle: 数据库安全与防护\ndate: 2016-05-19\ncategories: 数据库\ntags: [数据库]\ndescription: \n---\n\n### 一. 数据库安全性\n\n数据库系统中的数据共享不能是无条件的共享\n\n数据库安全性控制的常用方法：\n\n- 用户标识和鉴定：系统核对口令以鉴别用户身份，每个用户预先约定好一个计算过程或者函数\n \n- 存取控制：自主存取控制、强制存取控制\n\n**授权GRANT**\n\n用户权限组成：数据对象、操作类型\n\n定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作\n\n定义存取权限称为授权 \n\n\t  ```js\n\t  GRANT   SELECT //查询权限\n      ON   TABLE   Student //学生表\n      TO   U1;\t\t\t\t//给用户U1\n\t  这句SQL的意思是：把查询学生表的权限给用户U1\n\n\t  GRANT ALL PRIVILIGES //所有权利\n      ON TABLE Student, Course //学生表、课程表\n      TO U2, U3;\t\t\t//用户U2、U3\n\t  这句SQL的意思是：把对学生表、课程表的所有权限给用户U2、U3\n\n\t  GRANT SELECT //查询权限\n      ON TABLE SC  //选课表\n\t  TO PUBLIC;\t//所有用户\n\t  这句SQL的意思是：把对学生表的查询权限给用户U1\n\n\t  WITH GRANT OPTION;//允许将此权限授予给其他用户\n\t  ```\n\n**回收REVOKE**\n\n授予的权限可以由DBA或其他授权者用REVOKE语句收回\n\n\t  ```js\n\t  REVOKE UPDATE(Sno) //对学号的修改权限\n\t  ON TABLE Student \t//学生表\n\t  FROM U4;\t\t\t//用户U4\n\t  这句SQL的意思是：将用户U4的修改权限收回\n\n\t  REVOKE SELECT \n\t  ON TABLE SC \n\t  FROM PUBLIC;\n\t  这句SQL的意思是：收回所有用户对表SC的查询权限\n\n\t  REVOKE INSERT \n\t  ON TABLE SC \n\t  FROM U5 CASCADE ;//CASCADE 级联\n\t  ```\n\n**数据库角色**\n\n角色是权限的集合；可以为一组具有相同权限的用户创建一个角色\n；简化授权的过程\n\n- 创建角色 `CREATE  ROLE  <角色名> `\n\n- 给角色授权 \n\n- 将一个角色授予其他的角色或者用户\n\n- 角色权限的收回\n\n\t```js\n\teg:\n\n    通过角色来实现将一组权限授予一个用户。\n    步骤如下：\n    1. 首先创建一个角色 R1\n    CREATE  ROLE  R1；\n\n    2. 然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限\n    GRANT SELECT，UPDATE，INSERT \n    ON TABLE Student \n    TO R1；\n\n    3. 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限\n    GRANT  R1 \n    TO 王平，张明，赵玲；\n\n    4. 可以一次性通过R1来回收王平的这3个权限\n     REVOKE  R1 \n     FROM 王平；\n\t```\n\n\n\n- 视图\n\n- 审计\n\n审计日志（Audit Log)：将用户对数据库的所有操作记录在上面\n\n\t```js\n    AUDIT ALTER，UPDATE  \n    ON  SC；\n\t对修改SC表结构或修改SC表数据的操作进行审计\n\n\tNOAUDIT  ALTER，UPDATE  \n    ON  SC；\n\t取消对SC表的一切审计\n\t```\n\n- 密码存储\n\n\n","slug":"2016-05-19-数据库安全与防护","published":1,"updated":"2016-05-30T09:23:08.000Z","comments":1,"photos":[],"link":"","_id":"cj035och20073d5u8tcyy88qo","content":"<h3 id=\"一-数据库安全性\"><a href=\"#一-数据库安全性\" class=\"headerlink\" title=\"一. 数据库安全性\"></a>一. 数据库安全性</h3><p>数据库系统中的数据共享不能是无条件的共享</p>\n<p>数据库安全性控制的常用方法：</p>\n<ul>\n<li><p>用户标识和鉴定：系统核对口令以鉴别用户身份，每个用户预先约定好一个计算过程或者函数</p>\n</li>\n<li><p>存取控制：自主存取控制、强制存取控制</p>\n</li>\n</ul>\n<p><strong>授权GRANT</strong></p>\n<p>用户权限组成：数据对象、操作类型</p>\n<p>定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作</p>\n<p>定义存取权限称为授权 </p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT   SELECT <span class=\"comment\">//查询权限</span></span><br><span class=\"line\">   ON   TABLE   Student <span class=\"comment\">//学生表</span></span><br><span class=\"line\">   TO   U1;\t\t\t\t<span class=\"comment\">//给用户U1</span></span><br><span class=\"line\">这句SQL的意思是：把查询学生表的权限给用户U1</span><br><span class=\"line\"></span><br><span class=\"line\">GRANT ALL PRIVILIGES <span class=\"comment\">//所有权利</span></span><br><span class=\"line\">   ON TABLE Student, Course <span class=\"comment\">//学生表、课程表</span></span><br><span class=\"line\">   TO U2, U3;\t\t\t<span class=\"comment\">//用户U2、U3</span></span><br><span class=\"line\">这句SQL的意思是：把对学生表、课程表的所有权限给用户U2、U3</span><br><span class=\"line\"></span><br><span class=\"line\">GRANT SELECT <span class=\"comment\">//查询权限</span></span><br><span class=\"line\">   ON TABLE SC  <span class=\"comment\">//选课表</span></span><br><span class=\"line\">TO PUBLIC;\t<span class=\"comment\">//所有用户</span></span><br><span class=\"line\">这句SQL的意思是：把对学生表的查询权限给用户U1</span><br><span class=\"line\"></span><br><span class=\"line\">WITH GRANT OPTION;<span class=\"comment\">//允许将此权限授予给其他用户</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>回收REVOKE</strong></p>\n<p>授予的权限可以由DBA或其他授权者用REVOKE语句收回</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REVOKE UPDATE(Sno) <span class=\"comment\">//对学号的修改权限</span></span><br><span class=\"line\">ON TABLE Student \t<span class=\"comment\">//学生表</span></span><br><span class=\"line\">FROM U4;\t\t\t<span class=\"comment\">//用户U4</span></span><br><span class=\"line\">这句SQL的意思是：将用户U4的修改权限收回</span><br><span class=\"line\"></span><br><span class=\"line\">REVOKE SELECT </span><br><span class=\"line\">ON TABLE SC </span><br><span class=\"line\">FROM PUBLIC;</span><br><span class=\"line\">这句SQL的意思是：收回所有用户对表SC的查询权限</span><br><span class=\"line\"></span><br><span class=\"line\">REVOKE INSERT </span><br><span class=\"line\">ON TABLE SC </span><br><span class=\"line\">FROM U5 CASCADE ;<span class=\"comment\">//CASCADE 级联</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>数据库角色</strong></p>\n<p>角色是权限的集合；可以为一组具有相同权限的用户创建一个角色<br>；简化授权的过程</p>\n<ul>\n<li><p>创建角色 <code>CREATE  ROLE  &lt;角色名&gt;</code></p>\n</li>\n<li><p>给角色授权 </p>\n</li>\n<li><p>将一个角色授予其他的角色或者用户</p>\n</li>\n<li><p>角色权限的收回</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">   通过角色来实现将一组权限授予一个用户。</span><br><span class=\"line\">   步骤如下：</span><br><span class=\"line\">   <span class=\"number\">1.</span> 首先创建一个角色 R1</span><br><span class=\"line\">   CREATE  ROLE  R1；</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">2.</span> 然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限</span><br><span class=\"line\">   GRANT SELECT，UPDATE，INSERT </span><br><span class=\"line\">   ON TABLE Student </span><br><span class=\"line\">   TO R1；</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">3.</span> 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限</span><br><span class=\"line\">   GRANT  R1 </span><br><span class=\"line\">   TO 王平，张明，赵玲；</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">4.</span> 可以一次性通过R1来回收王平的这<span class=\"number\">3</span>个权限</span><br><span class=\"line\">    REVOKE  R1 </span><br><span class=\"line\">    FROM 王平；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>视图</p>\n</li>\n<li><p>审计</p>\n</li>\n</ul>\n<p>审计日志（Audit Log)：将用户对数据库的所有操作记录在上面</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   AUDIT ALTER，UPDATE  </span><br><span class=\"line\">   ON  SC；</span><br><span class=\"line\">对修改SC表结构或修改SC表数据的操作进行审计</span><br><span class=\"line\"></span><br><span class=\"line\">NOAUDIT  ALTER，UPDATE  </span><br><span class=\"line\">   ON  SC；</span><br><span class=\"line\">取消对SC表的一切审计</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>密码存储</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-数据库安全性\"><a href=\"#一-数据库安全性\" class=\"headerlink\" title=\"一. 数据库安全性\"></a>一. 数据库安全性</h3><p>数据库系统中的数据共享不能是无条件的共享</p>\n<p>数据库安全性控制的常用方法：</p>\n<ul>\n<li><p>用户标识和鉴定：系统核对口令以鉴别用户身份，每个用户预先约定好一个计算过程或者函数</p>\n</li>\n<li><p>存取控制：自主存取控制、强制存取控制</p>\n</li>\n</ul>\n<p><strong>授权GRANT</strong></p>\n<p>用户权限组成：数据对象、操作类型</p>\n<p>定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作</p>\n<p>定义存取权限称为授权 </p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT   SELECT <span class=\"comment\">//查询权限</span></span><br><span class=\"line\">   ON   TABLE   Student <span class=\"comment\">//学生表</span></span><br><span class=\"line\">   TO   U1;\t\t\t\t<span class=\"comment\">//给用户U1</span></span><br><span class=\"line\">这句SQL的意思是：把查询学生表的权限给用户U1</span><br><span class=\"line\"></span><br><span class=\"line\">GRANT ALL PRIVILIGES <span class=\"comment\">//所有权利</span></span><br><span class=\"line\">   ON TABLE Student, Course <span class=\"comment\">//学生表、课程表</span></span><br><span class=\"line\">   TO U2, U3;\t\t\t<span class=\"comment\">//用户U2、U3</span></span><br><span class=\"line\">这句SQL的意思是：把对学生表、课程表的所有权限给用户U2、U3</span><br><span class=\"line\"></span><br><span class=\"line\">GRANT SELECT <span class=\"comment\">//查询权限</span></span><br><span class=\"line\">   ON TABLE SC  <span class=\"comment\">//选课表</span></span><br><span class=\"line\">TO PUBLIC;\t<span class=\"comment\">//所有用户</span></span><br><span class=\"line\">这句SQL的意思是：把对学生表的查询权限给用户U1</span><br><span class=\"line\"></span><br><span class=\"line\">WITH GRANT OPTION;<span class=\"comment\">//允许将此权限授予给其他用户</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>回收REVOKE</strong></p>\n<p>授予的权限可以由DBA或其他授权者用REVOKE语句收回</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REVOKE UPDATE(Sno) <span class=\"comment\">//对学号的修改权限</span></span><br><span class=\"line\">ON TABLE Student \t<span class=\"comment\">//学生表</span></span><br><span class=\"line\">FROM U4;\t\t\t<span class=\"comment\">//用户U4</span></span><br><span class=\"line\">这句SQL的意思是：将用户U4的修改权限收回</span><br><span class=\"line\"></span><br><span class=\"line\">REVOKE SELECT </span><br><span class=\"line\">ON TABLE SC </span><br><span class=\"line\">FROM PUBLIC;</span><br><span class=\"line\">这句SQL的意思是：收回所有用户对表SC的查询权限</span><br><span class=\"line\"></span><br><span class=\"line\">REVOKE INSERT </span><br><span class=\"line\">ON TABLE SC </span><br><span class=\"line\">FROM U5 CASCADE ;<span class=\"comment\">//CASCADE 级联</span></span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>数据库角色</strong></p>\n<p>角色是权限的集合；可以为一组具有相同权限的用户创建一个角色<br>；简化授权的过程</p>\n<ul>\n<li><p>创建角色 <code>CREATE  ROLE  &lt;角色名&gt;</code></p>\n</li>\n<li><p>给角色授权 </p>\n</li>\n<li><p>将一个角色授予其他的角色或者用户</p>\n</li>\n<li><p>角色权限的收回</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">   通过角色来实现将一组权限授予一个用户。</span><br><span class=\"line\">   步骤如下：</span><br><span class=\"line\">   <span class=\"number\">1.</span> 首先创建一个角色 R1</span><br><span class=\"line\">   CREATE  ROLE  R1；</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">2.</span> 然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限</span><br><span class=\"line\">   GRANT SELECT，UPDATE，INSERT </span><br><span class=\"line\">   ON TABLE Student </span><br><span class=\"line\">   TO R1；</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">3.</span> 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限</span><br><span class=\"line\">   GRANT  R1 </span><br><span class=\"line\">   TO 王平，张明，赵玲；</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"number\">4.</span> 可以一次性通过R1来回收王平的这<span class=\"number\">3</span>个权限</span><br><span class=\"line\">    REVOKE  R1 </span><br><span class=\"line\">    FROM 王平；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>视图</p>\n</li>\n<li><p>审计</p>\n</li>\n</ul>\n<p>审计日志（Audit Log)：将用户对数据库的所有操作记录在上面</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   AUDIT ALTER，UPDATE  </span><br><span class=\"line\">   ON  SC；</span><br><span class=\"line\">对修改SC表结构或修改SC表数据的操作进行审计</span><br><span class=\"line\"></span><br><span class=\"line\">NOAUDIT  ALTER，UPDATE  </span><br><span class=\"line\">   ON  SC；</span><br><span class=\"line\">取消对SC表的一切审计</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>密码存储</li>\n</ul>\n"},{"layout":"post","title":"数据库技术","date":"2016-05-18T16:00:00.000Z","description":null,"_content":"\n最近在看数据库的书，觉得只看书效率不高，于是想边看边写。\n\n**数据库的四个基本概念：**\n\n- 数据\n- 数据库\n- 数据库管理系统\n- 数据库系统\n\n### 1.数据\n\n数据(Data)是数据库中存储的基本对象\n\n数据和其语义是不可分的\n\n### 2.数据库DB\n\n数据库DataBase，是数据的集合，长期存在计算机内，有组织、可共享。\n\n### 3.数据库管理系统DBMS\n\n组织、存储、管理数据\n\n### 4.数据库系统\n\n包括：\n\n- 数据库\n- 数据库管理系统\n- 应用系统\n- 数据库管理员\n\n**数据库的发展过程：**\n\n- 人工管理阶段\n- 文件系统阶段\n- 数据库系统阶段\n\n**数据库系统的特点：**\n\n- 数据结构化\n- 数据的共享性高，冗余度低，易扩充\n- 数据独立性高\n- 数据由DBMS统一管理和控制\n\n**两大数据模型：**\n\n- 概念模型\n- 逻辑模型——>物理模型\n\n**概念模型中的基本概念：**\n\n实体、属性、码（能唯一标识实体的属性集）、域、实体型、实体集、联系\n\n实体内部的联系通常是指组成实体的各属性之间的联系\n实体之间的联系通常是指不同实体集之间的联系\n\n**两个实体之间的联系：**\n\n一对一、一对多、多对多\n\n实体-联系方法：E-R方法\n\nE-R图：实体（矩形）、属性（椭圆）、联系（菱形）\n\n\n\n","source":"_posts/2016-05-19-数据库技术.md","raw":"---\nlayout: post\ntitle: 数据库技术\ndate: 2016-05-19\ncategories: 数据库\ntags: [数据库]\ndescription: \n---\n\n最近在看数据库的书，觉得只看书效率不高，于是想边看边写。\n\n**数据库的四个基本概念：**\n\n- 数据\n- 数据库\n- 数据库管理系统\n- 数据库系统\n\n### 1.数据\n\n数据(Data)是数据库中存储的基本对象\n\n数据和其语义是不可分的\n\n### 2.数据库DB\n\n数据库DataBase，是数据的集合，长期存在计算机内，有组织、可共享。\n\n### 3.数据库管理系统DBMS\n\n组织、存储、管理数据\n\n### 4.数据库系统\n\n包括：\n\n- 数据库\n- 数据库管理系统\n- 应用系统\n- 数据库管理员\n\n**数据库的发展过程：**\n\n- 人工管理阶段\n- 文件系统阶段\n- 数据库系统阶段\n\n**数据库系统的特点：**\n\n- 数据结构化\n- 数据的共享性高，冗余度低，易扩充\n- 数据独立性高\n- 数据由DBMS统一管理和控制\n\n**两大数据模型：**\n\n- 概念模型\n- 逻辑模型——>物理模型\n\n**概念模型中的基本概念：**\n\n实体、属性、码（能唯一标识实体的属性集）、域、实体型、实体集、联系\n\n实体内部的联系通常是指组成实体的各属性之间的联系\n实体之间的联系通常是指不同实体集之间的联系\n\n**两个实体之间的联系：**\n\n一对一、一对多、多对多\n\n实体-联系方法：E-R方法\n\nE-R图：实体（矩形）、属性（椭圆）、联系（菱形）\n\n\n\n","slug":"2016-05-19-数据库技术","published":1,"updated":"2016-05-30T09:21:58.000Z","comments":1,"photos":[],"link":"","_id":"cj035och40077d5u8uolufaiv","content":"<p>最近在看数据库的书，觉得只看书效率不高，于是想边看边写。</p>\n<p><strong>数据库的四个基本概念：</strong></p>\n<ul>\n<li>数据</li>\n<li>数据库</li>\n<li>数据库管理系统</li>\n<li>数据库系统</li>\n</ul>\n<h3 id=\"1-数据\"><a href=\"#1-数据\" class=\"headerlink\" title=\"1.数据\"></a>1.数据</h3><p>数据(Data)是数据库中存储的基本对象</p>\n<p>数据和其语义是不可分的</p>\n<h3 id=\"2-数据库DB\"><a href=\"#2-数据库DB\" class=\"headerlink\" title=\"2.数据库DB\"></a>2.数据库DB</h3><p>数据库DataBase，是数据的集合，长期存在计算机内，有组织、可共享。</p>\n<h3 id=\"3-数据库管理系统DBMS\"><a href=\"#3-数据库管理系统DBMS\" class=\"headerlink\" title=\"3.数据库管理系统DBMS\"></a>3.数据库管理系统DBMS</h3><p>组织、存储、管理数据</p>\n<h3 id=\"4-数据库系统\"><a href=\"#4-数据库系统\" class=\"headerlink\" title=\"4.数据库系统\"></a>4.数据库系统</h3><p>包括：</p>\n<ul>\n<li>数据库</li>\n<li>数据库管理系统</li>\n<li>应用系统</li>\n<li>数据库管理员</li>\n</ul>\n<p><strong>数据库的发展过程：</strong></p>\n<ul>\n<li>人工管理阶段</li>\n<li>文件系统阶段</li>\n<li>数据库系统阶段</li>\n</ul>\n<p><strong>数据库系统的特点：</strong></p>\n<ul>\n<li>数据结构化</li>\n<li>数据的共享性高，冗余度低，易扩充</li>\n<li>数据独立性高</li>\n<li>数据由DBMS统一管理和控制</li>\n</ul>\n<p><strong>两大数据模型：</strong></p>\n<ul>\n<li>概念模型</li>\n<li>逻辑模型——&gt;物理模型</li>\n</ul>\n<p><strong>概念模型中的基本概念：</strong></p>\n<p>实体、属性、码（能唯一标识实体的属性集）、域、实体型、实体集、联系</p>\n<p>实体内部的联系通常是指组成实体的各属性之间的联系<br>实体之间的联系通常是指不同实体集之间的联系</p>\n<p><strong>两个实体之间的联系：</strong></p>\n<p>一对一、一对多、多对多</p>\n<p>实体-联系方法：E-R方法</p>\n<p>E-R图：实体（矩形）、属性（椭圆）、联系（菱形）</p>\n","excerpt":"","more":"<p>最近在看数据库的书，觉得只看书效率不高，于是想边看边写。</p>\n<p><strong>数据库的四个基本概念：</strong></p>\n<ul>\n<li>数据</li>\n<li>数据库</li>\n<li>数据库管理系统</li>\n<li>数据库系统</li>\n</ul>\n<h3 id=\"1-数据\"><a href=\"#1-数据\" class=\"headerlink\" title=\"1.数据\"></a>1.数据</h3><p>数据(Data)是数据库中存储的基本对象</p>\n<p>数据和其语义是不可分的</p>\n<h3 id=\"2-数据库DB\"><a href=\"#2-数据库DB\" class=\"headerlink\" title=\"2.数据库DB\"></a>2.数据库DB</h3><p>数据库DataBase，是数据的集合，长期存在计算机内，有组织、可共享。</p>\n<h3 id=\"3-数据库管理系统DBMS\"><a href=\"#3-数据库管理系统DBMS\" class=\"headerlink\" title=\"3.数据库管理系统DBMS\"></a>3.数据库管理系统DBMS</h3><p>组织、存储、管理数据</p>\n<h3 id=\"4-数据库系统\"><a href=\"#4-数据库系统\" class=\"headerlink\" title=\"4.数据库系统\"></a>4.数据库系统</h3><p>包括：</p>\n<ul>\n<li>数据库</li>\n<li>数据库管理系统</li>\n<li>应用系统</li>\n<li>数据库管理员</li>\n</ul>\n<p><strong>数据库的发展过程：</strong></p>\n<ul>\n<li>人工管理阶段</li>\n<li>文件系统阶段</li>\n<li>数据库系统阶段</li>\n</ul>\n<p><strong>数据库系统的特点：</strong></p>\n<ul>\n<li>数据结构化</li>\n<li>数据的共享性高，冗余度低，易扩充</li>\n<li>数据独立性高</li>\n<li>数据由DBMS统一管理和控制</li>\n</ul>\n<p><strong>两大数据模型：</strong></p>\n<ul>\n<li>概念模型</li>\n<li>逻辑模型——&gt;物理模型</li>\n</ul>\n<p><strong>概念模型中的基本概念：</strong></p>\n<p>实体、属性、码（能唯一标识实体的属性集）、域、实体型、实体集、联系</p>\n<p>实体内部的联系通常是指组成实体的各属性之间的联系<br>实体之间的联系通常是指不同实体集之间的联系</p>\n<p><strong>两个实体之间的联系：</strong></p>\n<p>一对一、一对多、多对多</p>\n<p>实体-联系方法：E-R方法</p>\n<p>E-R图：实体（矩形）、属性（椭圆）、联系（菱形）</p>\n"},{"layout":"post","title":"数据库SQL","date":"2016-05-18T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是SQL\n\n**结构化查询语言Structured Query Language**\n\n**SQL的功能**\n\n- 数据查询\n- 数据定义\n- 数据操纵\n- 数据控制\n\n**SQL的特点**\n\n- 非过程\n- 面向集合\n- 类似英语的自然语言\n\n\n**基本表：**\n\n- 一个关系对应一个基本表\n- 一个或多个基本表对应一个存储文件\n\n**视图：**\n\n- 视图是从一个或几个基本表导出的表，是一个虚拟的表\n\n### 二. 创建与使用数据库\n\n#### 1. 创建数据库\n\n\t```js\n    CREATE DATABASE Teach\n    ON\n    (\tNAME=Teach_Data,\n    \tFILENAME='D:\\TeachData.mdf',\n    \tSIZE=10,\n    \tMAXSIZE=50,\n    \tFILEGROWTH=5)\n    LOG ON\n    (\tNAME=Teach_Log,\n    \tFILENAME='D:\\TeachLog.ldf',\n    \tSIZE=5,\n    \tMAXSIZE=25,\n    \tFILEGROWTH=5) \n\t```\n\n#### 2. 修改数据库\n\n\t```js\n    ALTER DATABASE Northwind\n    MODIFY FILE\n    (\tNAME = Northwind,\n     \tFILEGROWTH = 2mb \n    ) \n\t```\n\n#### 3. 删除数据库\n\n\t```js\n    DROP DATABASE Teach \n\t```\n\n#### 4. 查看数据库信息\n\n用系统存储过程显示数据库结构\n\n\t```js\n    Sp_helpdb[[@dbname=]'name']\n\t```\n\n用系统存储过程显示文件信息\n\n\t```js\n    Sp_helpfile [[@filename =] 'name'] \n\t```\n\n用系统存储过程显示文件组信息\n\n\t```js\n    Sp_helpfilegroup [[@filegroupname =] 'name']\n\t```\n\n### 三. 创建和使用数据表\n\n#### 1. 数据类型\n\n#### 2. 创建数据表\n\n\t```js\n\teg:\n\n\t用SQL命令建立一个学生表S。\n\tCREATE TABLE S\n\t(\tSNo CHAR(6),\n\t   SN VARCHAR(8),\n\t   Sex CHAR(2) DEFAULT '男',\n\t   Age INT,\n\t   Dept VARCHAR(20))\n\t```\n\n#### 3. 定义数据表的约束\n\n`[CONSTRAINT <约束名> ] <约束类型>` \n\n约束类型：\n\n- NULL/NOT NULL：NULL 是空值；NOT NULL 是不允许出现空值 \n- UNIQUE：取值唯一\n- PRIMARY KEY ：主键。主键不能为NULL、不能重复\n- FOREIGN KEY ：外键\n- CHECK：检查字段值所允许的范围 \n\n#### 4. 修改数据表\n\n添加\n\n\t```js\n    ALTER TABLE <表名>\n    ADD <列定义> | <完整性约束定义>\n\t```\n\n修改\n\t```js\n    ALTER TABLE <表名>\n    ALTER COLUMN <列名> <数据类型> [NULL|NOT NULL] \n\t```\n\n删除某一列\n\t\n\t```js\n    ALTER TABLE <表名>\n    DROP COLUMN <列名> \n\t```\n\n#### 5. 删除基本表\n\n\t```js\n    DROP TABLE <表名>\n\t```js\n\n只能删除自己建立的表，不能删除其他用户所建的表 \n\n### 三. 创建和使用索引\n\n**为什么要用索引？**\n\n索引可以看成是我们一本书的目录，使用索引会加快查询的速度。\n\n索引的分类：聚集索引/非聚集索引、唯一索引、复合索引\n\n#### 1. 创建索引\n\n\t```js\n    CREATE [UNIQUE] [CLUSTERED] INDEX <索引名> ON <表名> (<列名> [次序] [{,<列名>}] [次序]…)\n\t```js\n\n#### 2. 查看修改索引\n\n   `EXEC Sp_helpindex [@objname =] 'name'` \n\n#### 3. 删除索引\n\n\tDROP INDEX数据表名.索引名 \n\n### 四. 数据查询\n\n    SELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n    \t〈列名〉[AS 别名1] [{，〈列名〉[ AS 别名2]}]\n    \t[INTO 新表名]\n    FROM〈表名1或视图名1〉[[AS] 表1别名] [{，〈表名2或视图名2〉[[AS] 表2别名]}]\n    [WHERE〈检索条件〉]\n    [GROUP BY <列名1>[HAVING <条件表达式>]]\n    [ORDER BY <列名2>[ASC|DESC]] \n\n**条件查询**\n\n    优先级 NOT > AND > OR \n    \n    范围查询 BETWEEN\n    \n    是否在某一个集合内 IN\n    \n    模糊查询 LIKE或NOT LIKE\n    \n    空值查询 IS NULL \n\n**常用数据库函数（聚集函数）**\n\n    AVG：按列计算平均值 \n    \n    SUM：按列计算值的总和\n    \n    MAX：求一列中的最大值\n    \n    MIN：求一列中的最小值\n    \n    COUNT：按列值计个数\n\n**分组查询**\n\n    GROUP BY\n    \n    HAVING 分组后还要按照一定的条件进行筛选\n\n**对查询的结果进行排序**\n\n    ORDER BY\n    \n    DESC为降序，ASC为升序，缺省时为升序\n\n**连接查询**\n\n若查询涉及到两个以上的表，则称为连接查询\n\n**子查询（嵌套查询）**\n\n    在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询。\n\n**集合操作**\n\n- UNION 并\n- INTERSECT 交\n- EXCEPT 差\n\n### 五. 视图\n\n视图是虚表，其数据不进行存储，其记录来自基本表，只在数据库中存储其定义 。\n\n#### 1. 创建视图\n\n\tCREATE VIEW <视图名>[(<视图列表>)]\n\t\t\tAS <子查询> \n\n#### 2. 修改视图\n\n\tALTER VIEW <视图名>[(<视图列表>)]\n\t\t\tAS <子查询> \n\n#### 3. 删除视图\n\n\tDROP VIEW <视图名>\n\n#### 4. 更新视图\n\nINSERT\nUPDATE\nDELETE\n\n### 六. SQL数据控制\n\n**权限：**系统权限、对象权限\n\n**角色：**是多种权限的集合  \n\n**系统权限**\n\n\t系统权限授予\n\n    GRANT <系统权限>|<角色> [,<系统权限>|<角色>]…\n    TO <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n    [WITH ADMIN OPTION]\n\n\t系统权限收回\n\n    REVOKE <系统权限>|<角色> [,<系统权限>|<角色>]…\n    FROM <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n\n**对象权限**\n\n    对象权限授予\n    \n    GRANT ALL|<对象权限>[(列名[,列名]…)][,<对象权限>]…ON <对象名>\n    TO <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n    [WITH GRANT OPTION] \n    \n    对象权限收回\n    \n    REVOKE <对象权限>|<角色> [,<对象权限>|<角色>]…\n    FROM <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n\n","source":"_posts/2016-05-19-数据库SQL语言.md","raw":"---\nlayout: post\ntitle: 数据库SQL\ndate: 2016-05-19\ncategories: 数据库\ntags: [数据库]\ndescription: \n---\n\n### 一. 什么是SQL\n\n**结构化查询语言Structured Query Language**\n\n**SQL的功能**\n\n- 数据查询\n- 数据定义\n- 数据操纵\n- 数据控制\n\n**SQL的特点**\n\n- 非过程\n- 面向集合\n- 类似英语的自然语言\n\n\n**基本表：**\n\n- 一个关系对应一个基本表\n- 一个或多个基本表对应一个存储文件\n\n**视图：**\n\n- 视图是从一个或几个基本表导出的表，是一个虚拟的表\n\n### 二. 创建与使用数据库\n\n#### 1. 创建数据库\n\n\t```js\n    CREATE DATABASE Teach\n    ON\n    (\tNAME=Teach_Data,\n    \tFILENAME='D:\\TeachData.mdf',\n    \tSIZE=10,\n    \tMAXSIZE=50,\n    \tFILEGROWTH=5)\n    LOG ON\n    (\tNAME=Teach_Log,\n    \tFILENAME='D:\\TeachLog.ldf',\n    \tSIZE=5,\n    \tMAXSIZE=25,\n    \tFILEGROWTH=5) \n\t```\n\n#### 2. 修改数据库\n\n\t```js\n    ALTER DATABASE Northwind\n    MODIFY FILE\n    (\tNAME = Northwind,\n     \tFILEGROWTH = 2mb \n    ) \n\t```\n\n#### 3. 删除数据库\n\n\t```js\n    DROP DATABASE Teach \n\t```\n\n#### 4. 查看数据库信息\n\n用系统存储过程显示数据库结构\n\n\t```js\n    Sp_helpdb[[@dbname=]'name']\n\t```\n\n用系统存储过程显示文件信息\n\n\t```js\n    Sp_helpfile [[@filename =] 'name'] \n\t```\n\n用系统存储过程显示文件组信息\n\n\t```js\n    Sp_helpfilegroup [[@filegroupname =] 'name']\n\t```\n\n### 三. 创建和使用数据表\n\n#### 1. 数据类型\n\n#### 2. 创建数据表\n\n\t```js\n\teg:\n\n\t用SQL命令建立一个学生表S。\n\tCREATE TABLE S\n\t(\tSNo CHAR(6),\n\t   SN VARCHAR(8),\n\t   Sex CHAR(2) DEFAULT '男',\n\t   Age INT,\n\t   Dept VARCHAR(20))\n\t```\n\n#### 3. 定义数据表的约束\n\n`[CONSTRAINT <约束名> ] <约束类型>` \n\n约束类型：\n\n- NULL/NOT NULL：NULL 是空值；NOT NULL 是不允许出现空值 \n- UNIQUE：取值唯一\n- PRIMARY KEY ：主键。主键不能为NULL、不能重复\n- FOREIGN KEY ：外键\n- CHECK：检查字段值所允许的范围 \n\n#### 4. 修改数据表\n\n添加\n\n\t```js\n    ALTER TABLE <表名>\n    ADD <列定义> | <完整性约束定义>\n\t```\n\n修改\n\t```js\n    ALTER TABLE <表名>\n    ALTER COLUMN <列名> <数据类型> [NULL|NOT NULL] \n\t```\n\n删除某一列\n\t\n\t```js\n    ALTER TABLE <表名>\n    DROP COLUMN <列名> \n\t```\n\n#### 5. 删除基本表\n\n\t```js\n    DROP TABLE <表名>\n\t```js\n\n只能删除自己建立的表，不能删除其他用户所建的表 \n\n### 三. 创建和使用索引\n\n**为什么要用索引？**\n\n索引可以看成是我们一本书的目录，使用索引会加快查询的速度。\n\n索引的分类：聚集索引/非聚集索引、唯一索引、复合索引\n\n#### 1. 创建索引\n\n\t```js\n    CREATE [UNIQUE] [CLUSTERED] INDEX <索引名> ON <表名> (<列名> [次序] [{,<列名>}] [次序]…)\n\t```js\n\n#### 2. 查看修改索引\n\n   `EXEC Sp_helpindex [@objname =] 'name'` \n\n#### 3. 删除索引\n\n\tDROP INDEX数据表名.索引名 \n\n### 四. 数据查询\n\n    SELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n    \t〈列名〉[AS 别名1] [{，〈列名〉[ AS 别名2]}]\n    \t[INTO 新表名]\n    FROM〈表名1或视图名1〉[[AS] 表1别名] [{，〈表名2或视图名2〉[[AS] 表2别名]}]\n    [WHERE〈检索条件〉]\n    [GROUP BY <列名1>[HAVING <条件表达式>]]\n    [ORDER BY <列名2>[ASC|DESC]] \n\n**条件查询**\n\n    优先级 NOT > AND > OR \n    \n    范围查询 BETWEEN\n    \n    是否在某一个集合内 IN\n    \n    模糊查询 LIKE或NOT LIKE\n    \n    空值查询 IS NULL \n\n**常用数据库函数（聚集函数）**\n\n    AVG：按列计算平均值 \n    \n    SUM：按列计算值的总和\n    \n    MAX：求一列中的最大值\n    \n    MIN：求一列中的最小值\n    \n    COUNT：按列值计个数\n\n**分组查询**\n\n    GROUP BY\n    \n    HAVING 分组后还要按照一定的条件进行筛选\n\n**对查询的结果进行排序**\n\n    ORDER BY\n    \n    DESC为降序，ASC为升序，缺省时为升序\n\n**连接查询**\n\n若查询涉及到两个以上的表，则称为连接查询\n\n**子查询（嵌套查询）**\n\n    在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询。\n\n**集合操作**\n\n- UNION 并\n- INTERSECT 交\n- EXCEPT 差\n\n### 五. 视图\n\n视图是虚表，其数据不进行存储，其记录来自基本表，只在数据库中存储其定义 。\n\n#### 1. 创建视图\n\n\tCREATE VIEW <视图名>[(<视图列表>)]\n\t\t\tAS <子查询> \n\n#### 2. 修改视图\n\n\tALTER VIEW <视图名>[(<视图列表>)]\n\t\t\tAS <子查询> \n\n#### 3. 删除视图\n\n\tDROP VIEW <视图名>\n\n#### 4. 更新视图\n\nINSERT\nUPDATE\nDELETE\n\n### 六. SQL数据控制\n\n**权限：**系统权限、对象权限\n\n**角色：**是多种权限的集合  \n\n**系统权限**\n\n\t系统权限授予\n\n    GRANT <系统权限>|<角色> [,<系统权限>|<角色>]…\n    TO <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n    [WITH ADMIN OPTION]\n\n\t系统权限收回\n\n    REVOKE <系统权限>|<角色> [,<系统权限>|<角色>]…\n    FROM <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n\n**对象权限**\n\n    对象权限授予\n    \n    GRANT ALL|<对象权限>[(列名[,列名]…)][,<对象权限>]…ON <对象名>\n    TO <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n    [WITH GRANT OPTION] \n    \n    对象权限收回\n    \n    REVOKE <对象权限>|<角色> [,<对象权限>|<角色>]…\n    FROM <用户名>|<角色>|PUBLIC[,<用户名>|<角色>]…\n\n","slug":"2016-05-19-数据库SQL语言","published":1,"updated":"2016-05-31T13:43:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035och6007bd5u86oslch4d","content":"<h3 id=\"一-什么是SQL\"><a href=\"#一-什么是SQL\" class=\"headerlink\" title=\"一. 什么是SQL\"></a>一. 什么是SQL</h3><p><strong>结构化查询语言Structured Query Language</strong></p>\n<p><strong>SQL的功能</strong></p>\n<ul>\n<li>数据查询</li>\n<li>数据定义</li>\n<li>数据操纵</li>\n<li>数据控制</li>\n</ul>\n<p><strong>SQL的特点</strong></p>\n<ul>\n<li>非过程</li>\n<li>面向集合</li>\n<li>类似英语的自然语言</li>\n</ul>\n<p><strong>基本表：</strong></p>\n<ul>\n<li>一个关系对应一个基本表</li>\n<li>一个或多个基本表对应一个存储文件</li>\n</ul>\n<p><strong>视图：</strong></p>\n<ul>\n<li>视图是从一个或几个基本表导出的表，是一个虚拟的表</li>\n</ul>\n<h3 id=\"二-创建与使用数据库\"><a href=\"#二-创建与使用数据库\" class=\"headerlink\" title=\"二. 创建与使用数据库\"></a>二. 创建与使用数据库</h3><h4 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1. 创建数据库\"></a>1. 创建数据库</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE Teach</span><br><span class=\"line\">ON</span><br><span class=\"line\">(\tNAME=Teach_Data,</span><br><span class=\"line\">\tFILENAME=<span class=\"string\">'D:\\TeachData.mdf'</span>,</span><br><span class=\"line\">\tSIZE=<span class=\"number\">10</span>,</span><br><span class=\"line\">\tMAXSIZE=<span class=\"number\">50</span>,</span><br><span class=\"line\">\tFILEGROWTH=<span class=\"number\">5</span>)</span><br><span class=\"line\">LOG ON</span><br><span class=\"line\">(\tNAME=Teach_Log,</span><br><span class=\"line\">\tFILENAME=<span class=\"string\">'D:\\TeachLog.ldf'</span>,</span><br><span class=\"line\">\tSIZE=<span class=\"number\">5</span>,</span><br><span class=\"line\">\tMAXSIZE=<span class=\"number\">25</span>,</span><br><span class=\"line\">\tFILEGROWTH=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"2-修改数据库\"><a href=\"#2-修改数据库\" class=\"headerlink\" title=\"2. 修改数据库\"></a>2. 修改数据库</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE Northwind</span><br><span class=\"line\">MODIFY FILE</span><br><span class=\"line\">(\tNAME = Northwind,</span><br><span class=\"line\"> \tFILEGROWTH = <span class=\"number\">2</span>mb </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"3-删除数据库\"><a href=\"#3-删除数据库\" class=\"headerlink\" title=\"3. 删除数据库\"></a>3. 删除数据库</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP DATABASE Teach</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"4-查看数据库信息\"><a href=\"#4-查看数据库信息\" class=\"headerlink\" title=\"4. 查看数据库信息\"></a>4. 查看数据库信息</h4><p>用系统存储过程显示数据库结构</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sp_helpdb[[@dbname=]<span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n</code></pre><p>用系统存储过程显示文件信息</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sp_helpfile [[@filename =] <span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n</code></pre><p>用系统存储过程显示文件组信息</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sp_helpfilegroup [[@filegroupname =] <span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"三-创建和使用数据表\"><a href=\"#三-创建和使用数据表\" class=\"headerlink\" title=\"三. 创建和使用数据表\"></a>三. 创建和使用数据表</h3><h4 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h4><h4 id=\"2-创建数据表\"><a href=\"#2-创建数据表\" class=\"headerlink\" title=\"2. 创建数据表\"></a>2. 创建数据表</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">用SQL命令建立一个学生表S。</span><br><span class=\"line\">CREATE TABLE S</span><br><span class=\"line\">(\tSNo CHAR(<span class=\"number\">6</span>),</span><br><span class=\"line\">   SN VARCHAR(<span class=\"number\">8</span>),</span><br><span class=\"line\">   Sex CHAR(<span class=\"number\">2</span>) DEFAULT <span class=\"string\">'男'</span>,</span><br><span class=\"line\">   Age INT,</span><br><span class=\"line\">   Dept VARCHAR(<span class=\"number\">20</span>))</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"3-定义数据表的约束\"><a href=\"#3-定义数据表的约束\" class=\"headerlink\" title=\"3. 定义数据表的约束\"></a>3. 定义数据表的约束</h4><p><code>[CONSTRAINT &lt;约束名&gt; ] &lt;约束类型&gt;</code> </p>\n<p>约束类型：</p>\n<ul>\n<li>NULL/NOT NULL：NULL 是空值；NOT NULL 是不允许出现空值 </li>\n<li>UNIQUE：取值唯一</li>\n<li>PRIMARY KEY ：主键。主键不能为NULL、不能重复</li>\n<li>FOREIGN KEY ：外键</li>\n<li>CHECK：检查字段值所允许的范围 </li>\n</ul>\n<h4 id=\"4-修改数据表\"><a href=\"#4-修改数据表\" class=\"headerlink\" title=\"4. 修改数据表\"></a>4. 修改数据表</h4><p>添加</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &lt;表名&gt;</span><br><span class=\"line\">ADD &lt;列定义&gt; | <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">完整性约束定义</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</code></pre><p>修改<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &lt;表名&gt;</span><br><span class=\"line\">ALTER COLUMN &lt;列名&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">数据类型</span>&gt;</span> [NULL|NOT NULL]</span></span><br></pre></td></tr></table></figure></p>\n<p>删除某一列</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &lt;表名&gt;</span><br><span class=\"line\">DROP COLUMN &lt;列名&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"5-删除基本表\"><a href=\"#5-删除基本表\" class=\"headerlink\" title=\"5. 删除基本表\"></a>5. 删除基本表</h4><pre><code>```js\nDROP TABLE &lt;表名&gt;\n```js\n</code></pre><p>只能删除自己建立的表，不能删除其他用户所建的表 </p>\n<h3 id=\"三-创建和使用索引\"><a href=\"#三-创建和使用索引\" class=\"headerlink\" title=\"三. 创建和使用索引\"></a>三. 创建和使用索引</h3><p><strong>为什么要用索引？</strong></p>\n<p>索引可以看成是我们一本书的目录，使用索引会加快查询的速度。</p>\n<p>索引的分类：聚集索引/非聚集索引、唯一索引、复合索引</p>\n<h4 id=\"1-创建索引\"><a href=\"#1-创建索引\" class=\"headerlink\" title=\"1. 创建索引\"></a>1. 创建索引</h4><pre><code>```js\nCREATE [UNIQUE] [CLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [次序] [{,&lt;列名&gt;}] [次序]…)\n```js\n</code></pre><h4 id=\"2-查看修改索引\"><a href=\"#2-查看修改索引\" class=\"headerlink\" title=\"2. 查看修改索引\"></a>2. 查看修改索引</h4><p>   <code>EXEC Sp_helpindex [@objname =] &#39;name&#39;</code> </p>\n<h4 id=\"3-删除索引\"><a href=\"#3-删除索引\" class=\"headerlink\" title=\"3. 删除索引\"></a>3. 删除索引</h4><pre><code>DROP INDEX数据表名.索引名 \n</code></pre><h3 id=\"四-数据查询\"><a href=\"#四-数据查询\" class=\"headerlink\" title=\"四. 数据查询\"></a>四. 数据查询</h3><pre><code>SELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n    〈列名〉[AS 别名1] [{，〈列名〉[ AS 别名2]}]\n    [INTO 新表名]\nFROM〈表名1或视图名1〉[[AS] 表1别名] [{，〈表名2或视图名2〉[[AS] 表2别名]}]\n[WHERE〈检索条件〉]\n[GROUP BY &lt;列名1&gt;[HAVING &lt;条件表达式&gt;]]\n[ORDER BY &lt;列名2&gt;[ASC|DESC]] \n</code></pre><p><strong>条件查询</strong></p>\n<pre><code>优先级 NOT &gt; AND &gt; OR \n\n范围查询 BETWEEN\n\n是否在某一个集合内 IN\n\n模糊查询 LIKE或NOT LIKE\n\n空值查询 IS NULL \n</code></pre><p><strong>常用数据库函数（聚集函数）</strong></p>\n<pre><code>AVG：按列计算平均值 \n\nSUM：按列计算值的总和\n\nMAX：求一列中的最大值\n\nMIN：求一列中的最小值\n\nCOUNT：按列值计个数\n</code></pre><p><strong>分组查询</strong></p>\n<pre><code>GROUP BY\n\nHAVING 分组后还要按照一定的条件进行筛选\n</code></pre><p><strong>对查询的结果进行排序</strong></p>\n<pre><code>ORDER BY\n\nDESC为降序，ASC为升序，缺省时为升序\n</code></pre><p><strong>连接查询</strong></p>\n<p>若查询涉及到两个以上的表，则称为连接查询</p>\n<p><strong>子查询（嵌套查询）</strong></p>\n<pre><code>在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询。\n</code></pre><p><strong>集合操作</strong></p>\n<ul>\n<li>UNION 并</li>\n<li>INTERSECT 交</li>\n<li>EXCEPT 差</li>\n</ul>\n<h3 id=\"五-视图\"><a href=\"#五-视图\" class=\"headerlink\" title=\"五. 视图\"></a>五. 视图</h3><p>视图是虚表，其数据不进行存储，其记录来自基本表，只在数据库中存储其定义 。</p>\n<h4 id=\"1-创建视图\"><a href=\"#1-创建视图\" class=\"headerlink\" title=\"1. 创建视图\"></a>1. 创建视图</h4><pre><code>CREATE VIEW &lt;视图名&gt;[(&lt;视图列表&gt;)]\n        AS &lt;子查询&gt; \n</code></pre><h4 id=\"2-修改视图\"><a href=\"#2-修改视图\" class=\"headerlink\" title=\"2. 修改视图\"></a>2. 修改视图</h4><pre><code>ALTER VIEW &lt;视图名&gt;[(&lt;视图列表&gt;)]\n        AS &lt;子查询&gt; \n</code></pre><h4 id=\"3-删除视图\"><a href=\"#3-删除视图\" class=\"headerlink\" title=\"3. 删除视图\"></a>3. 删除视图</h4><pre><code>DROP VIEW &lt;视图名&gt;\n</code></pre><h4 id=\"4-更新视图\"><a href=\"#4-更新视图\" class=\"headerlink\" title=\"4. 更新视图\"></a>4. 更新视图</h4><p>INSERT<br>UPDATE<br>DELETE</p>\n<h3 id=\"六-SQL数据控制\"><a href=\"#六-SQL数据控制\" class=\"headerlink\" title=\"六. SQL数据控制\"></a>六. SQL数据控制</h3><p><strong>权限：</strong>系统权限、对象权限</p>\n<p><strong>角色：</strong>是多种权限的集合  </p>\n<p><strong>系统权限</strong></p>\n<pre><code>系统权限授予\n\nGRANT &lt;系统权限&gt;|&lt;角色&gt; [,&lt;系统权限&gt;|&lt;角色&gt;]…\nTO &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n[WITH ADMIN OPTION]\n\n系统权限收回\n\nREVOKE &lt;系统权限&gt;|&lt;角色&gt; [,&lt;系统权限&gt;|&lt;角色&gt;]…\nFROM &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n</code></pre><p><strong>对象权限</strong></p>\n<pre><code>对象权限授予\n\nGRANT ALL|&lt;对象权限&gt;[(列名[,列名]…)][,&lt;对象权限&gt;]…ON &lt;对象名&gt;\nTO &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n[WITH GRANT OPTION] \n\n对象权限收回\n\nREVOKE &lt;对象权限&gt;|&lt;角色&gt; [,&lt;对象权限&gt;|&lt;角色&gt;]…\nFROM &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n</code></pre>","excerpt":"","more":"<h3 id=\"一-什么是SQL\"><a href=\"#一-什么是SQL\" class=\"headerlink\" title=\"一. 什么是SQL\"></a>一. 什么是SQL</h3><p><strong>结构化查询语言Structured Query Language</strong></p>\n<p><strong>SQL的功能</strong></p>\n<ul>\n<li>数据查询</li>\n<li>数据定义</li>\n<li>数据操纵</li>\n<li>数据控制</li>\n</ul>\n<p><strong>SQL的特点</strong></p>\n<ul>\n<li>非过程</li>\n<li>面向集合</li>\n<li>类似英语的自然语言</li>\n</ul>\n<p><strong>基本表：</strong></p>\n<ul>\n<li>一个关系对应一个基本表</li>\n<li>一个或多个基本表对应一个存储文件</li>\n</ul>\n<p><strong>视图：</strong></p>\n<ul>\n<li>视图是从一个或几个基本表导出的表，是一个虚拟的表</li>\n</ul>\n<h3 id=\"二-创建与使用数据库\"><a href=\"#二-创建与使用数据库\" class=\"headerlink\" title=\"二. 创建与使用数据库\"></a>二. 创建与使用数据库</h3><h4 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1. 创建数据库\"></a>1. 创建数据库</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE Teach</span><br><span class=\"line\">ON</span><br><span class=\"line\">(\tNAME=Teach_Data,</span><br><span class=\"line\">\tFILENAME=<span class=\"string\">'D:\\TeachData.mdf'</span>,</span><br><span class=\"line\">\tSIZE=<span class=\"number\">10</span>,</span><br><span class=\"line\">\tMAXSIZE=<span class=\"number\">50</span>,</span><br><span class=\"line\">\tFILEGROWTH=<span class=\"number\">5</span>)</span><br><span class=\"line\">LOG ON</span><br><span class=\"line\">(\tNAME=Teach_Log,</span><br><span class=\"line\">\tFILENAME=<span class=\"string\">'D:\\TeachLog.ldf'</span>,</span><br><span class=\"line\">\tSIZE=<span class=\"number\">5</span>,</span><br><span class=\"line\">\tMAXSIZE=<span class=\"number\">25</span>,</span><br><span class=\"line\">\tFILEGROWTH=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"2-修改数据库\"><a href=\"#2-修改数据库\" class=\"headerlink\" title=\"2. 修改数据库\"></a>2. 修改数据库</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE Northwind</span><br><span class=\"line\">MODIFY FILE</span><br><span class=\"line\">(\tNAME = Northwind,</span><br><span class=\"line\"> \tFILEGROWTH = <span class=\"number\">2</span>mb </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"3-删除数据库\"><a href=\"#3-删除数据库\" class=\"headerlink\" title=\"3. 删除数据库\"></a>3. 删除数据库</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP DATABASE Teach</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"4-查看数据库信息\"><a href=\"#4-查看数据库信息\" class=\"headerlink\" title=\"4. 查看数据库信息\"></a>4. 查看数据库信息</h4><p>用系统存储过程显示数据库结构</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sp_helpdb[[@dbname=]<span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n</code></pre><p>用系统存储过程显示文件信息</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sp_helpfile [[@filename =] <span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n</code></pre><p>用系统存储过程显示文件组信息</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sp_helpfilegroup [[@filegroupname =] <span class=\"string\">'name'</span>]</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"三-创建和使用数据表\"><a href=\"#三-创建和使用数据表\" class=\"headerlink\" title=\"三. 创建和使用数据表\"></a>三. 创建和使用数据表</h3><h4 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h4><h4 id=\"2-创建数据表\"><a href=\"#2-创建数据表\" class=\"headerlink\" title=\"2. 创建数据表\"></a>2. 创建数据表</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">用SQL命令建立一个学生表S。</span><br><span class=\"line\">CREATE TABLE S</span><br><span class=\"line\">(\tSNo CHAR(<span class=\"number\">6</span>),</span><br><span class=\"line\">   SN VARCHAR(<span class=\"number\">8</span>),</span><br><span class=\"line\">   Sex CHAR(<span class=\"number\">2</span>) DEFAULT <span class=\"string\">'男'</span>,</span><br><span class=\"line\">   Age INT,</span><br><span class=\"line\">   Dept VARCHAR(<span class=\"number\">20</span>))</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"3-定义数据表的约束\"><a href=\"#3-定义数据表的约束\" class=\"headerlink\" title=\"3. 定义数据表的约束\"></a>3. 定义数据表的约束</h4><p><code>[CONSTRAINT &lt;约束名&gt; ] &lt;约束类型&gt;</code> </p>\n<p>约束类型：</p>\n<ul>\n<li>NULL/NOT NULL：NULL 是空值；NOT NULL 是不允许出现空值 </li>\n<li>UNIQUE：取值唯一</li>\n<li>PRIMARY KEY ：主键。主键不能为NULL、不能重复</li>\n<li>FOREIGN KEY ：外键</li>\n<li>CHECK：检查字段值所允许的范围 </li>\n</ul>\n<h4 id=\"4-修改数据表\"><a href=\"#4-修改数据表\" class=\"headerlink\" title=\"4. 修改数据表\"></a>4. 修改数据表</h4><p>添加</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &lt;表名&gt;</span><br><span class=\"line\">ADD &lt;列定义&gt; | <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">完整性约束定义</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</code></pre><p>修改<br>    <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &lt;表名&gt;</span><br><span class=\"line\">ALTER COLUMN &lt;列名&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">数据类型</span>&gt;</span> [NULL|NOT NULL]</span></span><br></pre></td></tr></table></figure></p>\n<p>删除某一列</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &lt;表名&gt;</span><br><span class=\"line\">DROP COLUMN &lt;列名&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><h4 id=\"5-删除基本表\"><a href=\"#5-删除基本表\" class=\"headerlink\" title=\"5. 删除基本表\"></a>5. 删除基本表</h4><pre><code>```js\nDROP TABLE &lt;表名&gt;\n```js\n</code></pre><p>只能删除自己建立的表，不能删除其他用户所建的表 </p>\n<h3 id=\"三-创建和使用索引\"><a href=\"#三-创建和使用索引\" class=\"headerlink\" title=\"三. 创建和使用索引\"></a>三. 创建和使用索引</h3><p><strong>为什么要用索引？</strong></p>\n<p>索引可以看成是我们一本书的目录，使用索引会加快查询的速度。</p>\n<p>索引的分类：聚集索引/非聚集索引、唯一索引、复合索引</p>\n<h4 id=\"1-创建索引\"><a href=\"#1-创建索引\" class=\"headerlink\" title=\"1. 创建索引\"></a>1. 创建索引</h4><pre><code>```js\nCREATE [UNIQUE] [CLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [次序] [{,&lt;列名&gt;}] [次序]…)\n```js\n</code></pre><h4 id=\"2-查看修改索引\"><a href=\"#2-查看修改索引\" class=\"headerlink\" title=\"2. 查看修改索引\"></a>2. 查看修改索引</h4><p>   <code>EXEC Sp_helpindex [@objname =] &#39;name&#39;</code> </p>\n<h4 id=\"3-删除索引\"><a href=\"#3-删除索引\" class=\"headerlink\" title=\"3. 删除索引\"></a>3. 删除索引</h4><pre><code>DROP INDEX数据表名.索引名 \n</code></pre><h3 id=\"四-数据查询\"><a href=\"#四-数据查询\" class=\"headerlink\" title=\"四. 数据查询\"></a>四. 数据查询</h3><pre><code>SELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n    〈列名〉[AS 别名1] [{，〈列名〉[ AS 别名2]}]\n    [INTO 新表名]\nFROM〈表名1或视图名1〉[[AS] 表1别名] [{，〈表名2或视图名2〉[[AS] 表2别名]}]\n[WHERE〈检索条件〉]\n[GROUP BY &lt;列名1&gt;[HAVING &lt;条件表达式&gt;]]\n[ORDER BY &lt;列名2&gt;[ASC|DESC]] \n</code></pre><p><strong>条件查询</strong></p>\n<pre><code>优先级 NOT &gt; AND &gt; OR \n\n范围查询 BETWEEN\n\n是否在某一个集合内 IN\n\n模糊查询 LIKE或NOT LIKE\n\n空值查询 IS NULL \n</code></pre><p><strong>常用数据库函数（聚集函数）</strong></p>\n<pre><code>AVG：按列计算平均值 \n\nSUM：按列计算值的总和\n\nMAX：求一列中的最大值\n\nMIN：求一列中的最小值\n\nCOUNT：按列值计个数\n</code></pre><p><strong>分组查询</strong></p>\n<pre><code>GROUP BY\n\nHAVING 分组后还要按照一定的条件进行筛选\n</code></pre><p><strong>对查询的结果进行排序</strong></p>\n<pre><code>ORDER BY\n\nDESC为降序，ASC为升序，缺省时为升序\n</code></pre><p><strong>连接查询</strong></p>\n<p>若查询涉及到两个以上的表，则称为连接查询</p>\n<p><strong>子查询（嵌套查询）</strong></p>\n<pre><code>在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询。\n</code></pre><p><strong>集合操作</strong></p>\n<ul>\n<li>UNION 并</li>\n<li>INTERSECT 交</li>\n<li>EXCEPT 差</li>\n</ul>\n<h3 id=\"五-视图\"><a href=\"#五-视图\" class=\"headerlink\" title=\"五. 视图\"></a>五. 视图</h3><p>视图是虚表，其数据不进行存储，其记录来自基本表，只在数据库中存储其定义 。</p>\n<h4 id=\"1-创建视图\"><a href=\"#1-创建视图\" class=\"headerlink\" title=\"1. 创建视图\"></a>1. 创建视图</h4><pre><code>CREATE VIEW &lt;视图名&gt;[(&lt;视图列表&gt;)]\n        AS &lt;子查询&gt; \n</code></pre><h4 id=\"2-修改视图\"><a href=\"#2-修改视图\" class=\"headerlink\" title=\"2. 修改视图\"></a>2. 修改视图</h4><pre><code>ALTER VIEW &lt;视图名&gt;[(&lt;视图列表&gt;)]\n        AS &lt;子查询&gt; \n</code></pre><h4 id=\"3-删除视图\"><a href=\"#3-删除视图\" class=\"headerlink\" title=\"3. 删除视图\"></a>3. 删除视图</h4><pre><code>DROP VIEW &lt;视图名&gt;\n</code></pre><h4 id=\"4-更新视图\"><a href=\"#4-更新视图\" class=\"headerlink\" title=\"4. 更新视图\"></a>4. 更新视图</h4><p>INSERT<br>UPDATE<br>DELETE</p>\n<h3 id=\"六-SQL数据控制\"><a href=\"#六-SQL数据控制\" class=\"headerlink\" title=\"六. SQL数据控制\"></a>六. SQL数据控制</h3><p><strong>权限：</strong>系统权限、对象权限</p>\n<p><strong>角色：</strong>是多种权限的集合  </p>\n<p><strong>系统权限</strong></p>\n<pre><code>系统权限授予\n\nGRANT &lt;系统权限&gt;|&lt;角色&gt; [,&lt;系统权限&gt;|&lt;角色&gt;]…\nTO &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n[WITH ADMIN OPTION]\n\n系统权限收回\n\nREVOKE &lt;系统权限&gt;|&lt;角色&gt; [,&lt;系统权限&gt;|&lt;角色&gt;]…\nFROM &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n</code></pre><p><strong>对象权限</strong></p>\n<pre><code>对象权限授予\n\nGRANT ALL|&lt;对象权限&gt;[(列名[,列名]…)][,&lt;对象权限&gt;]…ON &lt;对象名&gt;\nTO &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n[WITH GRANT OPTION] \n\n对象权限收回\n\nREVOKE &lt;对象权限&gt;|&lt;角色&gt; [,&lt;对象权限&gt;|&lt;角色&gt;]…\nFROM &lt;用户名&gt;|&lt;角色&gt;|PUBLIC[,&lt;用户名&gt;|&lt;角色&gt;]…\n</code></pre>"},{"layout":"post","title":"nodejs的模块机制","date":"2016-05-22T16:00:00.000Z","description":null,"_content":"\n### 一. nodejs的模块定义与使用\n\n**使用require**\n\n举个栗子\n\n\t```js\n    //circle.js\n\tvar PI = Math.PI;\n    exports.area = function(r){\n    \treturn PI * r * r;\n    };\n    exports.circle = function(r){\n    \treturn 2 * PI * r;\n    };\n\n\t//app.js\n\tvar circle = require(\"./circle.js\");\n\tconsole.log(\"The area is\" + clrcle.area(4));\n\n\tnode app.js\n\t```\n","source":"_posts/2016-05-23-node.js的模块机制.md","raw":"---\nlayout: post\ntitle: nodejs的模块机制\ndate: 2016-05-23\ncategories: nodejs\ntags: [nodejs]\ndescription: \n---\n\n### 一. nodejs的模块定义与使用\n\n**使用require**\n\n举个栗子\n\n\t```js\n    //circle.js\n\tvar PI = Math.PI;\n    exports.area = function(r){\n    \treturn PI * r * r;\n    };\n    exports.circle = function(r){\n    \treturn 2 * PI * r;\n    };\n\n\t//app.js\n\tvar circle = require(\"./circle.js\");\n\tconsole.log(\"The area is\" + clrcle.area(4));\n\n\tnode app.js\n\t```\n","slug":"2016-05-23-node.js的模块机制","published":1,"updated":"2016-05-30T09:20:20.000Z","comments":1,"photos":[],"link":"","_id":"cj035och7007ed5u85531dk5g","content":"<h3 id=\"一-nodejs的模块定义与使用\"><a href=\"#一-nodejs的模块定义与使用\" class=\"headerlink\" title=\"一. nodejs的模块定义与使用\"></a>一. nodejs的模块定义与使用</h3><p><strong>使用require</strong></p>\n<p>举个栗子</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//circle.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> PI = <span class=\"built_in\">Math</span>.PI;</span><br><span class=\"line\">   exports.area = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> PI * r * r;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   exports.circle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> <span class=\"number\">2</span> * PI * r;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> circle = <span class=\"built_in\">require</span>(<span class=\"string\">\"./circle.js\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"The area is\"</span> + clrcle.area(<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">node app.js</span><br></pre></td></tr></table></figure>\n</code></pre>","excerpt":"","more":"<h3 id=\"一-nodejs的模块定义与使用\"><a href=\"#一-nodejs的模块定义与使用\" class=\"headerlink\" title=\"一. nodejs的模块定义与使用\"></a>一. nodejs的模块定义与使用</h3><p><strong>使用require</strong></p>\n<p>举个栗子</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//circle.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> PI = <span class=\"built_in\">Math</span>.PI;</span><br><span class=\"line\">   exports.area = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> PI * r * r;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   exports.circle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> <span class=\"number\">2</span> * PI * r;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> circle = <span class=\"built_in\">require</span>(<span class=\"string\">\"./circle.js\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"The area is\"</span> + clrcle.area(<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">node app.js</span><br></pre></td></tr></table></figure>\n</code></pre>"},{"layout":"post","title":"什么是nodejs","date":"2016-05-22T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是nodejs？\n\nnodejs是对于需要独立运行的js的一个解析器。nodejs是用C++语言编写的。\n\n脚本语言都需要一个**解析器**才能运行，对于写在HTML页面里面的js，浏览器充当了解析器的角色。\n\n这里插叙一点**脚本语言**和**编程语言**的区别：\n\n    1. 脚本语言（scripting language）：脚本语言不需要编译，可以直接用，由解释器来负责解释。 \n    \n    编程语言可分为：机器语言、汇编语言、高级语言（一般的java、c、c++等都是指的高级语言）。\n    \n    编程语言都需要经过编写-编译-链接-运行 这四个步骤。\n    \n    2. 编程语言的语法和规则更加严格和复杂一些。\n\n每一种解析器都提供了一些内置对象和方法，允许js对其进行操作。\n\n例如运行在浏览器中的JS的用途是**操作DOM**，浏览器就提供了**document**之类的内置对象。\n\n而运行在NodeJS中的JS的用途是**操作磁盘文件**或**搭建HTTP服务器**，NodeJS就相应提供了**fs、http**等内置对象。\n\n    NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器。\n\n### 二. 如何在nodejs里面运行js\n\n#### 1. 直接像浏览器控制台一样输入代码\n\n    打开cmd\n    输入node(这时是不需要指定到哪一个文件夹里的)\n    输入代码，例如：console.log('Hello World!')\n\n#### 2. 用nodejs运行单独的js文件\n\n    打开cmd\n    进入需要运行的js文件的文件夹\n    输入node 文件名.js\n\n### 三. 什么是npm\n\nnpm的全称是Node Package Manager，是nodejs的包管理器。\n\n","source":"_posts/2016-05-23-什么是node.js.md","raw":"---\nlayout: post\ntitle: 什么是nodejs\ndate: 2016-05-23\ncategories: nodejs\ntags: [nodejs]\ndescription: \n---\n\n### 一. 什么是nodejs？\n\nnodejs是对于需要独立运行的js的一个解析器。nodejs是用C++语言编写的。\n\n脚本语言都需要一个**解析器**才能运行，对于写在HTML页面里面的js，浏览器充当了解析器的角色。\n\n这里插叙一点**脚本语言**和**编程语言**的区别：\n\n    1. 脚本语言（scripting language）：脚本语言不需要编译，可以直接用，由解释器来负责解释。 \n    \n    编程语言可分为：机器语言、汇编语言、高级语言（一般的java、c、c++等都是指的高级语言）。\n    \n    编程语言都需要经过编写-编译-链接-运行 这四个步骤。\n    \n    2. 编程语言的语法和规则更加严格和复杂一些。\n\n每一种解析器都提供了一些内置对象和方法，允许js对其进行操作。\n\n例如运行在浏览器中的JS的用途是**操作DOM**，浏览器就提供了**document**之类的内置对象。\n\n而运行在NodeJS中的JS的用途是**操作磁盘文件**或**搭建HTTP服务器**，NodeJS就相应提供了**fs、http**等内置对象。\n\n    NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器。\n\n### 二. 如何在nodejs里面运行js\n\n#### 1. 直接像浏览器控制台一样输入代码\n\n    打开cmd\n    输入node(这时是不需要指定到哪一个文件夹里的)\n    输入代码，例如：console.log('Hello World!')\n\n#### 2. 用nodejs运行单独的js文件\n\n    打开cmd\n    进入需要运行的js文件的文件夹\n    输入node 文件名.js\n\n### 三. 什么是npm\n\nnpm的全称是Node Package Manager，是nodejs的包管理器。\n\n","slug":"2016-05-23-什么是node.js","published":1,"updated":"2016-05-23T12:00:34.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocha007id5u8sgrw0kej","content":"<h3 id=\"一-什么是nodejs？\"><a href=\"#一-什么是nodejs？\" class=\"headerlink\" title=\"一. 什么是nodejs？\"></a>一. 什么是nodejs？</h3><p>nodejs是对于需要独立运行的js的一个解析器。nodejs是用C++语言编写的。</p>\n<p>脚本语言都需要一个<strong>解析器</strong>才能运行，对于写在HTML页面里面的js，浏览器充当了解析器的角色。</p>\n<p>这里插叙一点<strong>脚本语言</strong>和<strong>编程语言</strong>的区别：</p>\n<pre><code>1. 脚本语言（scripting language）：脚本语言不需要编译，可以直接用，由解释器来负责解释。 \n\n编程语言可分为：机器语言、汇编语言、高级语言（一般的java、c、c++等都是指的高级语言）。\n\n编程语言都需要经过编写-编译-链接-运行 这四个步骤。\n\n2. 编程语言的语法和规则更加严格和复杂一些。\n</code></pre><p>每一种解析器都提供了一些内置对象和方法，允许js对其进行操作。</p>\n<p>例如运行在浏览器中的JS的用途是<strong>操作DOM</strong>，浏览器就提供了<strong>document</strong>之类的内置对象。</p>\n<p>而运行在NodeJS中的JS的用途是<strong>操作磁盘文件</strong>或<strong>搭建HTTP服务器</strong>，NodeJS就相应提供了<strong>fs、http</strong>等内置对象。</p>\n<pre><code>NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器。\n</code></pre><h3 id=\"二-如何在nodejs里面运行js\"><a href=\"#二-如何在nodejs里面运行js\" class=\"headerlink\" title=\"二. 如何在nodejs里面运行js\"></a>二. 如何在nodejs里面运行js</h3><h4 id=\"1-直接像浏览器控制台一样输入代码\"><a href=\"#1-直接像浏览器控制台一样输入代码\" class=\"headerlink\" title=\"1. 直接像浏览器控制台一样输入代码\"></a>1. 直接像浏览器控制台一样输入代码</h4><pre><code>打开cmd\n输入node(这时是不需要指定到哪一个文件夹里的)\n输入代码，例如：console.log(&apos;Hello World!&apos;)\n</code></pre><h4 id=\"2-用nodejs运行单独的js文件\"><a href=\"#2-用nodejs运行单独的js文件\" class=\"headerlink\" title=\"2. 用nodejs运行单独的js文件\"></a>2. 用nodejs运行单独的js文件</h4><pre><code>打开cmd\n进入需要运行的js文件的文件夹\n输入node 文件名.js\n</code></pre><h3 id=\"三-什么是npm\"><a href=\"#三-什么是npm\" class=\"headerlink\" title=\"三. 什么是npm\"></a>三. 什么是npm</h3><p>npm的全称是Node Package Manager，是nodejs的包管理器。</p>\n","excerpt":"","more":"<h3 id=\"一-什么是nodejs？\"><a href=\"#一-什么是nodejs？\" class=\"headerlink\" title=\"一. 什么是nodejs？\"></a>一. 什么是nodejs？</h3><p>nodejs是对于需要独立运行的js的一个解析器。nodejs是用C++语言编写的。</p>\n<p>脚本语言都需要一个<strong>解析器</strong>才能运行，对于写在HTML页面里面的js，浏览器充当了解析器的角色。</p>\n<p>这里插叙一点<strong>脚本语言</strong>和<strong>编程语言</strong>的区别：</p>\n<pre><code>1. 脚本语言（scripting language）：脚本语言不需要编译，可以直接用，由解释器来负责解释。 \n\n编程语言可分为：机器语言、汇编语言、高级语言（一般的java、c、c++等都是指的高级语言）。\n\n编程语言都需要经过编写-编译-链接-运行 这四个步骤。\n\n2. 编程语言的语法和规则更加严格和复杂一些。\n</code></pre><p>每一种解析器都提供了一些内置对象和方法，允许js对其进行操作。</p>\n<p>例如运行在浏览器中的JS的用途是<strong>操作DOM</strong>，浏览器就提供了<strong>document</strong>之类的内置对象。</p>\n<p>而运行在NodeJS中的JS的用途是<strong>操作磁盘文件</strong>或<strong>搭建HTTP服务器</strong>，NodeJS就相应提供了<strong>fs、http</strong>等内置对象。</p>\n<pre><code>NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器。\n</code></pre><h3 id=\"二-如何在nodejs里面运行js\"><a href=\"#二-如何在nodejs里面运行js\" class=\"headerlink\" title=\"二. 如何在nodejs里面运行js\"></a>二. 如何在nodejs里面运行js</h3><h4 id=\"1-直接像浏览器控制台一样输入代码\"><a href=\"#1-直接像浏览器控制台一样输入代码\" class=\"headerlink\" title=\"1. 直接像浏览器控制台一样输入代码\"></a>1. 直接像浏览器控制台一样输入代码</h4><pre><code>打开cmd\n输入node(这时是不需要指定到哪一个文件夹里的)\n输入代码，例如：console.log(&apos;Hello World!&apos;)\n</code></pre><h4 id=\"2-用nodejs运行单独的js文件\"><a href=\"#2-用nodejs运行单独的js文件\" class=\"headerlink\" title=\"2. 用nodejs运行单独的js文件\"></a>2. 用nodejs运行单独的js文件</h4><pre><code>打开cmd\n进入需要运行的js文件的文件夹\n输入node 文件名.js\n</code></pre><h3 id=\"三-什么是npm\"><a href=\"#三-什么是npm\" class=\"headerlink\" title=\"三. 什么是npm\"></a>三. 什么是npm</h3><p>npm的全称是Node Package Manager，是nodejs的包管理器。</p>\n"},{"layout":"post","title":"计算机网络七层模型","date":"2016-05-16T16:00:00.000Z","description":null,"_content":"\n### 一. 计算机网络七层协议模型\n\nOSI模型 open system interconnection 开放式通信系统互联参考模型\n\n从底层 ——> 高层依次为：\n\n- 物理层\n- 数据链路层\n- 网络层：IP协议\n- 传输层：传输层协议的代表包括：TCP、UDP、SPX等。\n- 会话层\n- 表示层\n- 应用层：超文本传输协议HTTP（Hypertext Transfer Protocol），端口号为80；FTP协议\n\n\n\n\n","source":"_posts/2016-05-17-计算机网络7层协议.md","raw":"---\nlayout: post\ntitle: 计算机网络七层模型\ndate: 2016-05-17\ncategories: http协议\ntags: [计算机网络]\ndescription: \n---\n\n### 一. 计算机网络七层协议模型\n\nOSI模型 open system interconnection 开放式通信系统互联参考模型\n\n从底层 ——> 高层依次为：\n\n- 物理层\n- 数据链路层\n- 网络层：IP协议\n- 传输层：传输层协议的代表包括：TCP、UDP、SPX等。\n- 会话层\n- 表示层\n- 应用层：超文本传输协议HTTP（Hypertext Transfer Protocol），端口号为80；FTP协议\n\n\n\n\n","slug":"2016-05-17-计算机网络7层协议","published":1,"updated":"2016-08-20T07:55:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochc007md5u8u88l7qhh","content":"<h3 id=\"一-计算机网络七层协议模型\"><a href=\"#一-计算机网络七层协议模型\" class=\"headerlink\" title=\"一. 计算机网络七层协议模型\"></a>一. 计算机网络七层协议模型</h3><p>OSI模型 open system interconnection 开放式通信系统互联参考模型</p>\n<p>从底层 ——&gt; 高层依次为：</p>\n<ul>\n<li>物理层</li>\n<li>数据链路层</li>\n<li>网络层：IP协议</li>\n<li>传输层：传输层协议的代表包括：TCP、UDP、SPX等。</li>\n<li>会话层</li>\n<li>表示层</li>\n<li>应用层：超文本传输协议HTTP（Hypertext Transfer Protocol），端口号为80；FTP协议</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-计算机网络七层协议模型\"><a href=\"#一-计算机网络七层协议模型\" class=\"headerlink\" title=\"一. 计算机网络七层协议模型\"></a>一. 计算机网络七层协议模型</h3><p>OSI模型 open system interconnection 开放式通信系统互联参考模型</p>\n<p>从底层 ——&gt; 高层依次为：</p>\n<ul>\n<li>物理层</li>\n<li>数据链路层</li>\n<li>网络层：IP协议</li>\n<li>传输层：传输层协议的代表包括：TCP、UDP、SPX等。</li>\n<li>会话层</li>\n<li>表示层</li>\n<li>应用层：超文本传输协议HTTP（Hypertext Transfer Protocol），端口号为80；FTP协议</li>\n</ul>\n"},{"layout":"post","title":"数据库设计","date":"2016-05-18T16:00:00.000Z","description":null,"_content":"\n### 一. 数据库设计\n\n任务：根据用户需求研制数据库结构\n\n内容：结构设计、行为设计\n\n特点：结构设计与行为设计相结合\n\n### 二. 数据库设计方法\n\n**规范设计法：**\n\n- 基于E-R模型的数据库设计方法\n- 基于3NF的数据库设计方法 \n- 基于视图的数据库设计方法 \n\n**数据库设计的步骤：**\n\n- 系统需求分析阶段：自顶向下、自底向上\n- 概念结构设计阶段\n- 逻辑结构设计阶段\n- 物理结构设计阶段\n- 数据库实施阶段\n- 数据库运行与维护阶段\n\n\n\n","source":"_posts/2016-05-19-数据库设计.md","raw":"---\nlayout: post\ntitle: 数据库设计\ndate: 2016-05-19\ncategories: 数据库\ntags: [数据库]\ndescription: \n---\n\n### 一. 数据库设计\n\n任务：根据用户需求研制数据库结构\n\n内容：结构设计、行为设计\n\n特点：结构设计与行为设计相结合\n\n### 二. 数据库设计方法\n\n**规范设计法：**\n\n- 基于E-R模型的数据库设计方法\n- 基于3NF的数据库设计方法 \n- 基于视图的数据库设计方法 \n\n**数据库设计的步骤：**\n\n- 系统需求分析阶段：自顶向下、自底向上\n- 概念结构设计阶段\n- 逻辑结构设计阶段\n- 物理结构设计阶段\n- 数据库实施阶段\n- 数据库运行与维护阶段\n\n\n\n","slug":"2016-05-19-数据库设计","published":1,"updated":"2016-05-23T09:32:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochh007qd5u8eyc38osj","content":"<h3 id=\"一-数据库设计\"><a href=\"#一-数据库设计\" class=\"headerlink\" title=\"一. 数据库设计\"></a>一. 数据库设计</h3><p>任务：根据用户需求研制数据库结构</p>\n<p>内容：结构设计、行为设计</p>\n<p>特点：结构设计与行为设计相结合</p>\n<h3 id=\"二-数据库设计方法\"><a href=\"#二-数据库设计方法\" class=\"headerlink\" title=\"二. 数据库设计方法\"></a>二. 数据库设计方法</h3><p><strong>规范设计法：</strong></p>\n<ul>\n<li>基于E-R模型的数据库设计方法</li>\n<li>基于3NF的数据库设计方法 </li>\n<li>基于视图的数据库设计方法 </li>\n</ul>\n<p><strong>数据库设计的步骤：</strong></p>\n<ul>\n<li>系统需求分析阶段：自顶向下、自底向上</li>\n<li>概念结构设计阶段</li>\n<li>逻辑结构设计阶段</li>\n<li>物理结构设计阶段</li>\n<li>数据库实施阶段</li>\n<li>数据库运行与维护阶段</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-数据库设计\"><a href=\"#一-数据库设计\" class=\"headerlink\" title=\"一. 数据库设计\"></a>一. 数据库设计</h3><p>任务：根据用户需求研制数据库结构</p>\n<p>内容：结构设计、行为设计</p>\n<p>特点：结构设计与行为设计相结合</p>\n<h3 id=\"二-数据库设计方法\"><a href=\"#二-数据库设计方法\" class=\"headerlink\" title=\"二. 数据库设计方法\"></a>二. 数据库设计方法</h3><p><strong>规范设计法：</strong></p>\n<ul>\n<li>基于E-R模型的数据库设计方法</li>\n<li>基于3NF的数据库设计方法 </li>\n<li>基于视图的数据库设计方法 </li>\n</ul>\n<p><strong>数据库设计的步骤：</strong></p>\n<ul>\n<li>系统需求分析阶段：自顶向下、自底向上</li>\n<li>概念结构设计阶段</li>\n<li>逻辑结构设计阶段</li>\n<li>物理结构设计阶段</li>\n<li>数据库实施阶段</li>\n<li>数据库运行与维护阶段</li>\n</ul>\n"},{"layout":"post","title":"输入url浏览器所做的工作","date":"2016-05-24T16:00:00.000Z","description":null,"_content":"\n### 一. 根据url请求页面的过程\n\n#### 1. 浏览器查找域名对应的IP地址\n\n- **IP 地址**：用来标识每个主机，类似于门牌号码\n- **域名（ DN —— domain name ）**:容易记住的与ip对应的地址， 一个域名对应一个或多个提供相同服务服务器的 IP 地址\n- **DNS（domain name system）**：，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。\n\n<font color=\"red\">注意：IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限</font>\n\n**根据域名查找ip地址的过程：**\n\n    （1）浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n    （2）搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n    （3）搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n    （4）操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；\n    \tLDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；\n    \tLDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；\n    \tLDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；\n    （5）LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；\n    （6）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n    （7）至此，浏览器已经得到了域名对应的 IP 地址。\n\n#### 2. 建立连接\n\n由1中知道了域名所对应的ip地址，便开始与服务器建立连接\n\n**建立连接的过程如下（TCP协议-三次握手）：**\n\n    （1）客户端向服务器发送一个建立连接的请求（您好，我想认识您）\n    （2）服务器接到请求后发送同意连接的信号（好的，我同意认识您）\n    （3）客户端接收到同意连接的信号之后，再次向服务器发送确认信号（我也很高兴认识您），自此，主机和服务器建立了连接。\n\n#### 3. 网页请求与显示\n\n在2中，主机与服务器建立了连接之后，便是主机与服务器进行通信。\n\n    （1）浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n    （2）服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n    （3）服务器将得到的 HTML 文件发送给浏览器；\n    （4）在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n    （5）在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n\n**HTML页面加载和解析流程**\n    \n    （1）用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 \n    \n    （2）浏览器开始载入html代码，发现<head>标签内有一个<link>标签引用外部CSS文件。 \n    \n    （3）浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 \n    \n    （4）浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 \n    \n    （5）浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 \n    \n    （6）服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 \n    \n    （7）浏览器发现了一个包含一行Javascript代码的<script>标签，赶快运行它。 \n    \n    （8）Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<style>（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 \n    \n    （9）终于等到了</html>的到来，浏览器泪流满面…… \n    \n    （10） 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。 \n    \n    （11）浏览器召集了在座的各位<div><span><ul><li>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n#### 4.断开连接（TCP-四次挥手）\n\n    （1）浏览器向服务器发送一个断开连接的请求（不早了，我该走了）；\n    （2）服务器接到请求后发送确认收到请求的信号（知道了）；\n    （3）服务器向主机发送断开通知（我也该走了）；\n    （4）浏览器接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；\n\n为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。\n\n### 二. 从浏览器中输入url到页面展示用到了哪些协议\n\n- Ip协议（网络层）\n- TCP协议（传输层）\n- HTTP协议（应用层）\n\n\n\n\n\n\n\n\n","source":"_posts/2016-05-25-浏览器输入url之后.md","raw":"---\nlayout: post\ntitle: 输入url浏览器所做的工作\ndate: 2016-05-25\ncategories: 浏览器\ntags: [浏览器]\ndescription: \n---\n\n### 一. 根据url请求页面的过程\n\n#### 1. 浏览器查找域名对应的IP地址\n\n- **IP 地址**：用来标识每个主机，类似于门牌号码\n- **域名（ DN —— domain name ）**:容易记住的与ip对应的地址， 一个域名对应一个或多个提供相同服务服务器的 IP 地址\n- **DNS（domain name system）**：，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。\n\n<font color=\"red\">注意：IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限</font>\n\n**根据域名查找ip地址的过程：**\n\n    （1）浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n    （2）搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n    （3）搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n    （4）操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；\n    \tLDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；\n    \tLDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；\n    \tLDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；\n    （5）LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；\n    （6）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n    （7）至此，浏览器已经得到了域名对应的 IP 地址。\n\n#### 2. 建立连接\n\n由1中知道了域名所对应的ip地址，便开始与服务器建立连接\n\n**建立连接的过程如下（TCP协议-三次握手）：**\n\n    （1）客户端向服务器发送一个建立连接的请求（您好，我想认识您）\n    （2）服务器接到请求后发送同意连接的信号（好的，我同意认识您）\n    （3）客户端接收到同意连接的信号之后，再次向服务器发送确认信号（我也很高兴认识您），自此，主机和服务器建立了连接。\n\n#### 3. 网页请求与显示\n\n在2中，主机与服务器建立了连接之后，便是主机与服务器进行通信。\n\n    （1）浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n    （2）服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n    （3）服务器将得到的 HTML 文件发送给浏览器；\n    （4）在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n    （5）在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n\n**HTML页面加载和解析流程**\n    \n    （1）用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 \n    \n    （2）浏览器开始载入html代码，发现<head>标签内有一个<link>标签引用外部CSS文件。 \n    \n    （3）浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 \n    \n    （4）浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 \n    \n    （5）浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 \n    \n    （6）服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 \n    \n    （7）浏览器发现了一个包含一行Javascript代码的<script>标签，赶快运行它。 \n    \n    （8）Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<style>（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 \n    \n    （9）终于等到了</html>的到来，浏览器泪流满面…… \n    \n    （10） 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。 \n    \n    （11）浏览器召集了在座的各位<div><span><ul><li>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n#### 4.断开连接（TCP-四次挥手）\n\n    （1）浏览器向服务器发送一个断开连接的请求（不早了，我该走了）；\n    （2）服务器接到请求后发送确认收到请求的信号（知道了）；\n    （3）服务器向主机发送断开通知（我也该走了）；\n    （4）浏览器接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；\n\n为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。\n\n### 二. 从浏览器中输入url到页面展示用到了哪些协议\n\n- Ip协议（网络层）\n- TCP协议（传输层）\n- HTTP协议（应用层）\n\n\n\n\n\n\n\n\n","slug":"2016-05-25-浏览器输入url之后","published":1,"updated":"2016-08-20T09:22:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochj007ud5u8nrdmev5t","content":"<h3 id=\"一-根据url请求页面的过程\"><a href=\"#一-根据url请求页面的过程\" class=\"headerlink\" title=\"一. 根据url请求页面的过程\"></a>一. 根据url请求页面的过程</h3><h4 id=\"1-浏览器查找域名对应的IP地址\"><a href=\"#1-浏览器查找域名对应的IP地址\" class=\"headerlink\" title=\"1. 浏览器查找域名对应的IP地址\"></a>1. 浏览器查找域名对应的IP地址</h4><ul>\n<li><strong>IP 地址</strong>：用来标识每个主机，类似于门牌号码</li>\n<li><strong>域名（ DN —— domain name ）</strong>:容易记住的与ip对应的地址， 一个域名对应一个或多个提供相同服务服务器的 IP 地址</li>\n<li><strong>DNS（domain name system）</strong>：，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</li>\n</ul>\n<font color=\"red\">注意：IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限</font>\n\n<p><strong>根据域名查找ip地址的过程：</strong></p>\n<pre><code>（1）浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n（2）搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n（3）搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n（4）操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；\n    LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；\n    LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；\n    LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；\n（5）LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；\n（6）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n（7）至此，浏览器已经得到了域名对应的 IP 地址。\n</code></pre><h4 id=\"2-建立连接\"><a href=\"#2-建立连接\" class=\"headerlink\" title=\"2. 建立连接\"></a>2. 建立连接</h4><p>由1中知道了域名所对应的ip地址，便开始与服务器建立连接</p>\n<p><strong>建立连接的过程如下（TCP协议-三次握手）：</strong></p>\n<pre><code>（1）客户端向服务器发送一个建立连接的请求（您好，我想认识您）\n（2）服务器接到请求后发送同意连接的信号（好的，我同意认识您）\n（3）客户端接收到同意连接的信号之后，再次向服务器发送确认信号（我也很高兴认识您），自此，主机和服务器建立了连接。\n</code></pre><h4 id=\"3-网页请求与显示\"><a href=\"#3-网页请求与显示\" class=\"headerlink\" title=\"3. 网页请求与显示\"></a>3. 网页请求与显示</h4><p>在2中，主机与服务器建立了连接之后，便是主机与服务器进行通信。</p>\n<pre><code>（1）浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n（2）服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n（3）服务器将得到的 HTML 文件发送给浏览器；\n（4）在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n（5）在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n</code></pre><p><strong>HTML页面加载和解析流程</strong></p>\n<pre><code>（1）用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 \n\n（2）浏览器开始载入html代码，发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件。 \n\n（3）浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 \n\n（4）浏览器继续载入html中&lt;body&gt;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 \n\n（5）浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 \n\n（6）服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 \n\n（7）浏览器发现了一个包含一行Javascript代码的&lt;script&gt;标签，赶快运行它。 \n\n（8）Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个&lt;style&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 \n\n（9）终于等到了&lt;/html&gt;的到来，浏览器泪流满面…… \n\n（10） 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。 \n\n（11）浏览器召集了在座的各位&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n</code></pre><h4 id=\"4-断开连接（TCP-四次挥手）\"><a href=\"#4-断开连接（TCP-四次挥手）\" class=\"headerlink\" title=\"4.断开连接（TCP-四次挥手）\"></a>4.断开连接（TCP-四次挥手）</h4><pre><code>（1）浏览器向服务器发送一个断开连接的请求（不早了，我该走了）；\n（2）服务器接到请求后发送确认收到请求的信号（知道了）；\n（3）服务器向主机发送断开通知（我也该走了）；\n（4）浏览器接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；\n</code></pre><p>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。</p>\n<h3 id=\"二-从浏览器中输入url到页面展示用到了哪些协议\"><a href=\"#二-从浏览器中输入url到页面展示用到了哪些协议\" class=\"headerlink\" title=\"二. 从浏览器中输入url到页面展示用到了哪些协议\"></a>二. 从浏览器中输入url到页面展示用到了哪些协议</h3><ul>\n<li>Ip协议（网络层）</li>\n<li>TCP协议（传输层）</li>\n<li>HTTP协议（应用层）</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-根据url请求页面的过程\"><a href=\"#一-根据url请求页面的过程\" class=\"headerlink\" title=\"一. 根据url请求页面的过程\"></a>一. 根据url请求页面的过程</h3><h4 id=\"1-浏览器查找域名对应的IP地址\"><a href=\"#1-浏览器查找域名对应的IP地址\" class=\"headerlink\" title=\"1. 浏览器查找域名对应的IP地址\"></a>1. 浏览器查找域名对应的IP地址</h4><ul>\n<li><strong>IP 地址</strong>：用来标识每个主机，类似于门牌号码</li>\n<li><strong>域名（ DN —— domain name ）</strong>:容易记住的与ip对应的地址， 一个域名对应一个或多个提供相同服务服务器的 IP 地址</li>\n<li><strong>DNS（domain name system）</strong>：，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</li>\n</ul>\n<font color=\"red\">注意：IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限</font>\n\n<p><strong>根据域名查找ip地址的过程：</strong></p>\n<pre><code>（1）浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n（2）搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；\n（3）搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；\n（4）操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；\n    LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；\n    LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；\n    LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；\n（5）LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；\n（6）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n（7）至此，浏览器已经得到了域名对应的 IP 地址。\n</code></pre><h4 id=\"2-建立连接\"><a href=\"#2-建立连接\" class=\"headerlink\" title=\"2. 建立连接\"></a>2. 建立连接</h4><p>由1中知道了域名所对应的ip地址，便开始与服务器建立连接</p>\n<p><strong>建立连接的过程如下（TCP协议-三次握手）：</strong></p>\n<pre><code>（1）客户端向服务器发送一个建立连接的请求（您好，我想认识您）\n（2）服务器接到请求后发送同意连接的信号（好的，我同意认识您）\n（3）客户端接收到同意连接的信号之后，再次向服务器发送确认信号（我也很高兴认识您），自此，主机和服务器建立了连接。\n</code></pre><h4 id=\"3-网页请求与显示\"><a href=\"#3-网页请求与显示\" class=\"headerlink\" title=\"3. 网页请求与显示\"></a>3. 网页请求与显示</h4><p>在2中，主机与服务器建立了连接之后，便是主机与服务器进行通信。</p>\n<pre><code>（1）浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；\n（2）服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n（3）服务器将得到的 HTML 文件发送给浏览器；\n（4）在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；\n（5）在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；\n</code></pre><p><strong>HTML页面加载和解析流程</strong></p>\n<pre><code>（1）用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 \n\n（2）浏览器开始载入html代码，发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件。 \n\n（3）浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 \n\n（4）浏览器继续载入html中&lt;body&gt;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 \n\n（5）浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 \n\n（6）服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 \n\n（7）浏览器发现了一个包含一行Javascript代码的&lt;script&gt;标签，赶快运行它。 \n\n（8）Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个&lt;style&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 \n\n（9）终于等到了&lt;/html&gt;的到来，浏览器泪流满面…… \n\n（10） 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。 \n\n（11）浏览器召集了在座的各位&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n</code></pre><h4 id=\"4-断开连接（TCP-四次挥手）\"><a href=\"#4-断开连接（TCP-四次挥手）\" class=\"headerlink\" title=\"4.断开连接（TCP-四次挥手）\"></a>4.断开连接（TCP-四次挥手）</h4><pre><code>（1）浏览器向服务器发送一个断开连接的请求（不早了，我该走了）；\n（2）服务器接到请求后发送确认收到请求的信号（知道了）；\n（3）服务器向主机发送断开通知（我也该走了）；\n（4）浏览器接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；\n</code></pre><p>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。</p>\n<h3 id=\"二-从浏览器中输入url到页面展示用到了哪些协议\"><a href=\"#二-从浏览器中输入url到页面展示用到了哪些协议\" class=\"headerlink\" title=\"二. 从浏览器中输入url到页面展示用到了哪些协议\"></a>二. 从浏览器中输入url到页面展示用到了哪些协议</h3><ul>\n<li>Ip协议（网络层）</li>\n<li>TCP协议（传输层）</li>\n<li>HTTP协议（应用层）</li>\n</ul>\n"},{"layout":"post","title":"js中的DOM操作","date":"2016-05-23T16:00:00.000Z","description":null,"_content":"\n### 一. 节点类型\n\n#### 1. 节点的分类\n\nHTML页面中，总共有**12**种节点：\n\n- 文档节点 document类型\n- 元素节点 element类型\n- 特性节点 Attr类型\n- 文本节点 Text类型\n- 注释节点 Comment类型\n- 文档类型节点 DocumentType类型\n- 文档片段类型 DocumentFragment类型\n- CDATASection类型 只有XML文档有\n\n#### 2. 所有节点的公共属性\n\n上述节点都继承自Node类型\n\n**（1）. 节点的类型 nodeType**\n\n判断一个节点的类型\n\n\t```js\n    eg:\n    \n    if(someNode.nodeType == 1)\n    {\n    \talert(\"Node is an element\")\n    }\n\t```\n\n**（2）. 若节点为元素节点，获得节点的标签名 nodeName**\n\n\t```js\n\teg:\n    \n    if(someNode.nodeType == 1)//首先要判断节点是否为元素节点\n    {\n    \tconsole.log(someNode.nodeName);\n    }\n\t```\n\n<font color=\"red\">注意：由nodeName获得的节点名称是大写！！！</font>\n\n**（3）. 节点的直接子节点 childNodes firstChild lastChild**\n\nchildNodes是一个NodeList对象，NodeList是一种**类数组对象**（类似arguments对象）。\n\nchildNodes里面保存了该节点的所有**直接子节点**\n\n注意：不同浏览器处理空白符的方式不一样，IE9版本之前不会为空白符创建节点。\n\n\t```js\n\teg:\n\n\t\t<div id=\"myid\">\n            <a></a>\n            <div>\n                <a></a>\n            </div>\n        </div>\n\n\tvar my = document.getElementById(\"myid\");\n    console.log(my.childNodes.length);//会输出5，而不是2\n\t```\n\n解决方法：通过判断一下nodeType属性\n\n\t```js\n    for(var i=0,len=element.childNodes.length;i<len;i++){\n    \tif(element.childNodes[i].nodeType == 1){\n    \t\t//执行某些操作\n    \t}\n    }\n\t```\n\n可通过[]或者item()来访问某一个子节点\n\n\t```js\n    访问第一个子节点\n    my.childNodes[0]\n    my.childNodes.item(0)\n\t```\n\n**firstChild**指向子节点列表中的第一个子节点\n\n**lastChild**指向子节点列表中的最后一个子节点\n\n**（4）. 节点的父节点 parentNode**\n\n**（5）. 节点的上一个兄弟节点 previousSibling**\n\n若节点为第一个节点，则node.previousSibling为null\n\n**（6）. 节点的下一个兄弟节点 nextSibling**\n\n若节点为最后一个节点，则node.nextSibling为null\n\n#### 2. 操作节点\n\n**（1）. 在子节点列表中插入节点 appendChild()**\n\n\t```js\n    向childNodes列表的末尾添加一个节点，并且会返回插入的节点\n\t```\n\n**（2）. 在子节点列表中某一个节点的前面插入一个节点 insertBefore()**\n\n    ```js\n\tinsertBefore(要插入的节点，参照节点)\n\t同时返回要插入的节点\n\t```\n\n**（3）. 替换子节点 replaceChild()**\n\n\t```js\n    replaceChild(替换节点，被替换的节点)\n\t同时返回被替换的节点\n\t```\n\n**（4）. 移除子节点 removeChild()**\n\n\t```js\n    removeChild(被移除的子节点)\n    同时返回被移除的子节点\n\t```\n\n**（5）. 复制节点 cloneNode()**\n\n\t```js\n    cloneNode(bool)\n    bool为true时，深复制，复制节点以及节点的所有子节点\n    bool为false时，浅复制，只复制节点本身\n\t```\n\n**（6）. 规范化文本节点 normalize()**\n\n\t```js\n\t如果在一个包含两个或多个文本节点的父元素上调用normalize()，则会将所有文本节点合并成一个节点\n\t```\n\n**（7）. 分割文本节点 splitText()**\n\n### 二. document类型\n\n文档的子节点（直接）可能有的类型如下：\n\n\t```js\n    文档类型节点：document.doctype  指的是<!DOCTYPE HTM>\n    文档元素节点：document.documentElement 指的是<html>\n    processingInstruction 或者 注释\n\t```\n    \ndocument对象的属性：\n\n\t```js\n    body属性：document.body 指向body元素\n    title属性：document.title\n    URL属性：页面的URL值（地址栏中显示的 http://panpanfish.com/myblog/index.html）\n    domain属性：域名（panpanfish.com）\n    referrer属性\n\tdocument.anchors 所有带name特性的a\n\tdocument.forms 所有的表单\n\tdocument.images 所有的图片\n\t```\n\ndocument对象的方法：\n\t\n\t```js\n\t获取节点:\n    document.getElementById() 如果有两个id一样的节点，只返回第一次出现的那个节点\n    document.getElementByTagName() 返回一个集合，可以用item()和[]来访问（与NodeList类似）\n    document.getElementByName() 返回带有给定name的所有元素\n\t\n\t向文档中动态添加内容：\n\tdocument.write(\"字符串\") 文档写入，直接将字符串写入文档\n\tdocument.writeln(\"字符串\") 文档写入，会在字符串末尾自动添加换行符\\n\n\n\t创建元素节点\n\tdocument.createElement():接收一个参数，要创建的元素标签名\n\n\t创建文本节点\n\tdocument.createTextNode()\n\n\t创建注释节点\n\tdocument.createComment()\n\n\t创建特性节点\n\tdocument.createAttribute()\n\t```\n\t\n### 三. Element类型\n\nElement类型的属性：\n\n    1.id\n    2.title\n    3.className\n\t4.attributes\n\telement类型的attributes属性是一个NamedNodeMap（包含一系列节点）\n\n\tnodeName是属性的名称\n\tnodeValue是属性的值\n\nElemant类型的方法：\n\n- getAttribute()\n- setAttribute()\n- removeAttribute()\n\n**getAttribute()访问元素的属性** \n\n对于html标签本身就有的属性，可以通过`.`来访问，也可以通过`getAttribute()`来访问。一般情况下，两种访问方式得到的属性值是相同的，但是`style`和`onclick`得到的不一样，建议使用`.操作符`。\n\n对于自定义属性，只能通过`getAttribute()`访问。\n\n**setAttribute()设置属性**\n\t\n\t```js\n\teg:\n\t<div id=\"myid\"></div>\n    \n    var mydiv = document.getElementById(\"myid\");\n    mydiv.setAttribute(\"id\",\"myid2\");\n\n\t如果是已经存在的属性名，则修改属性；如果不存在的属性名，则创建属性。\n\t```\n\n**removeAttribute()删除属性**\n\n### 四. DOM操作技术\n\n#### 1. 动态脚本\n\n\t```js\n    function loadScript(url){\n    \tvar script = document.creatElement(\"script\");\n    \tscript.type = \"text/javascript\";\n    \tscript.src = url;\n    \tdocument.body.appendChild(script);\n    }\n    \n    loadScript(\"myjs.js\");\n\t```\n\n \n\n\n\n\n\n\n","source":"_posts/2016-05-24-js中的DOM操作.md","raw":"---\nlayout: post\ntitle: js中的DOM操作\ndate: 2016-05-24\ncategories: javaScript\ntags: [javaScript,DOM]\ndescription: \n---\n\n### 一. 节点类型\n\n#### 1. 节点的分类\n\nHTML页面中，总共有**12**种节点：\n\n- 文档节点 document类型\n- 元素节点 element类型\n- 特性节点 Attr类型\n- 文本节点 Text类型\n- 注释节点 Comment类型\n- 文档类型节点 DocumentType类型\n- 文档片段类型 DocumentFragment类型\n- CDATASection类型 只有XML文档有\n\n#### 2. 所有节点的公共属性\n\n上述节点都继承自Node类型\n\n**（1）. 节点的类型 nodeType**\n\n判断一个节点的类型\n\n\t```js\n    eg:\n    \n    if(someNode.nodeType == 1)\n    {\n    \talert(\"Node is an element\")\n    }\n\t```\n\n**（2）. 若节点为元素节点，获得节点的标签名 nodeName**\n\n\t```js\n\teg:\n    \n    if(someNode.nodeType == 1)//首先要判断节点是否为元素节点\n    {\n    \tconsole.log(someNode.nodeName);\n    }\n\t```\n\n<font color=\"red\">注意：由nodeName获得的节点名称是大写！！！</font>\n\n**（3）. 节点的直接子节点 childNodes firstChild lastChild**\n\nchildNodes是一个NodeList对象，NodeList是一种**类数组对象**（类似arguments对象）。\n\nchildNodes里面保存了该节点的所有**直接子节点**\n\n注意：不同浏览器处理空白符的方式不一样，IE9版本之前不会为空白符创建节点。\n\n\t```js\n\teg:\n\n\t\t<div id=\"myid\">\n            <a></a>\n            <div>\n                <a></a>\n            </div>\n        </div>\n\n\tvar my = document.getElementById(\"myid\");\n    console.log(my.childNodes.length);//会输出5，而不是2\n\t```\n\n解决方法：通过判断一下nodeType属性\n\n\t```js\n    for(var i=0,len=element.childNodes.length;i<len;i++){\n    \tif(element.childNodes[i].nodeType == 1){\n    \t\t//执行某些操作\n    \t}\n    }\n\t```\n\n可通过[]或者item()来访问某一个子节点\n\n\t```js\n    访问第一个子节点\n    my.childNodes[0]\n    my.childNodes.item(0)\n\t```\n\n**firstChild**指向子节点列表中的第一个子节点\n\n**lastChild**指向子节点列表中的最后一个子节点\n\n**（4）. 节点的父节点 parentNode**\n\n**（5）. 节点的上一个兄弟节点 previousSibling**\n\n若节点为第一个节点，则node.previousSibling为null\n\n**（6）. 节点的下一个兄弟节点 nextSibling**\n\n若节点为最后一个节点，则node.nextSibling为null\n\n#### 2. 操作节点\n\n**（1）. 在子节点列表中插入节点 appendChild()**\n\n\t```js\n    向childNodes列表的末尾添加一个节点，并且会返回插入的节点\n\t```\n\n**（2）. 在子节点列表中某一个节点的前面插入一个节点 insertBefore()**\n\n    ```js\n\tinsertBefore(要插入的节点，参照节点)\n\t同时返回要插入的节点\n\t```\n\n**（3）. 替换子节点 replaceChild()**\n\n\t```js\n    replaceChild(替换节点，被替换的节点)\n\t同时返回被替换的节点\n\t```\n\n**（4）. 移除子节点 removeChild()**\n\n\t```js\n    removeChild(被移除的子节点)\n    同时返回被移除的子节点\n\t```\n\n**（5）. 复制节点 cloneNode()**\n\n\t```js\n    cloneNode(bool)\n    bool为true时，深复制，复制节点以及节点的所有子节点\n    bool为false时，浅复制，只复制节点本身\n\t```\n\n**（6）. 规范化文本节点 normalize()**\n\n\t```js\n\t如果在一个包含两个或多个文本节点的父元素上调用normalize()，则会将所有文本节点合并成一个节点\n\t```\n\n**（7）. 分割文本节点 splitText()**\n\n### 二. document类型\n\n文档的子节点（直接）可能有的类型如下：\n\n\t```js\n    文档类型节点：document.doctype  指的是<!DOCTYPE HTM>\n    文档元素节点：document.documentElement 指的是<html>\n    processingInstruction 或者 注释\n\t```\n    \ndocument对象的属性：\n\n\t```js\n    body属性：document.body 指向body元素\n    title属性：document.title\n    URL属性：页面的URL值（地址栏中显示的 http://panpanfish.com/myblog/index.html）\n    domain属性：域名（panpanfish.com）\n    referrer属性\n\tdocument.anchors 所有带name特性的a\n\tdocument.forms 所有的表单\n\tdocument.images 所有的图片\n\t```\n\ndocument对象的方法：\n\t\n\t```js\n\t获取节点:\n    document.getElementById() 如果有两个id一样的节点，只返回第一次出现的那个节点\n    document.getElementByTagName() 返回一个集合，可以用item()和[]来访问（与NodeList类似）\n    document.getElementByName() 返回带有给定name的所有元素\n\t\n\t向文档中动态添加内容：\n\tdocument.write(\"字符串\") 文档写入，直接将字符串写入文档\n\tdocument.writeln(\"字符串\") 文档写入，会在字符串末尾自动添加换行符\\n\n\n\t创建元素节点\n\tdocument.createElement():接收一个参数，要创建的元素标签名\n\n\t创建文本节点\n\tdocument.createTextNode()\n\n\t创建注释节点\n\tdocument.createComment()\n\n\t创建特性节点\n\tdocument.createAttribute()\n\t```\n\t\n### 三. Element类型\n\nElement类型的属性：\n\n    1.id\n    2.title\n    3.className\n\t4.attributes\n\telement类型的attributes属性是一个NamedNodeMap（包含一系列节点）\n\n\tnodeName是属性的名称\n\tnodeValue是属性的值\n\nElemant类型的方法：\n\n- getAttribute()\n- setAttribute()\n- removeAttribute()\n\n**getAttribute()访问元素的属性** \n\n对于html标签本身就有的属性，可以通过`.`来访问，也可以通过`getAttribute()`来访问。一般情况下，两种访问方式得到的属性值是相同的，但是`style`和`onclick`得到的不一样，建议使用`.操作符`。\n\n对于自定义属性，只能通过`getAttribute()`访问。\n\n**setAttribute()设置属性**\n\t\n\t```js\n\teg:\n\t<div id=\"myid\"></div>\n    \n    var mydiv = document.getElementById(\"myid\");\n    mydiv.setAttribute(\"id\",\"myid2\");\n\n\t如果是已经存在的属性名，则修改属性；如果不存在的属性名，则创建属性。\n\t```\n\n**removeAttribute()删除属性**\n\n### 四. DOM操作技术\n\n#### 1. 动态脚本\n\n\t```js\n    function loadScript(url){\n    \tvar script = document.creatElement(\"script\");\n    \tscript.type = \"text/javascript\";\n    \tscript.src = url;\n    \tdocument.body.appendChild(script);\n    }\n    \n    loadScript(\"myjs.js\");\n\t```\n\n \n\n\n\n\n\n\n","slug":"2016-05-24-js中的DOM操作","published":1,"updated":"2016-09-12T07:17:26.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochk007yd5u8359ljaxm","content":"<h3 id=\"一-节点类型\"><a href=\"#一-节点类型\" class=\"headerlink\" title=\"一. 节点类型\"></a>一. 节点类型</h3><h4 id=\"1-节点的分类\"><a href=\"#1-节点的分类\" class=\"headerlink\" title=\"1. 节点的分类\"></a>1. 节点的分类</h4><p>HTML页面中，总共有<strong>12</strong>种节点：</p>\n<ul>\n<li>文档节点 document类型</li>\n<li>元素节点 element类型</li>\n<li>特性节点 Attr类型</li>\n<li>文本节点 Text类型</li>\n<li>注释节点 Comment类型</li>\n<li>文档类型节点 DocumentType类型</li>\n<li>文档片段类型 DocumentFragment类型</li>\n<li>CDATASection类型 只有XML文档有</li>\n</ul>\n<h4 id=\"2-所有节点的公共属性\"><a href=\"#2-所有节点的公共属性\" class=\"headerlink\" title=\"2. 所有节点的公共属性\"></a>2. 所有节点的公共属性</h4><p>上述节点都继承自Node类型</p>\n<p><strong>（1）. 节点的类型 nodeType</strong></p>\n<p>判断一个节点的类型</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(someNode.nodeType == <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Node is an element\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（2）. 若节点为元素节点，获得节点的标签名 nodeName</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span>(someNode.nodeType == <span class=\"number\">1</span>)<span class=\"comment\">//首先要判断节点是否为元素节点</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(someNode.nodeName);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><font color=\"red\">注意：由nodeName获得的节点名称是大写！！！</font>\n\n<p><strong>（3）. 节点的直接子节点 childNodes firstChild lastChild</strong></p>\n<p>childNodes是一个NodeList对象，NodeList是一种<strong>类数组对象</strong>（类似arguments对象）。</p>\n<p>childNodes里面保存了该节点的所有<strong>直接子节点</strong></p>\n<p>注意：不同浏览器处理空白符的方式不一样，IE9版本之前不会为空白符创建节点。</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myid\"</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> my = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myid\"</span>);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(my.childNodes.length);<span class=\"comment\">//会输出5，而不是2</span></span><br></pre></td></tr></table></figure>\n</code></pre><p>解决方法：通过判断一下nodeType属性</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,len=element.childNodes.length;i&lt;len;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(element.childNodes[i].nodeType == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//执行某些操作</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p>可通过[]或者item()来访问某一个子节点</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问第一个子节点</span><br><span class=\"line\">my.childNodes[<span class=\"number\">0</span>]</span><br><span class=\"line\">my.childNodes.item(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>firstChild</strong>指向子节点列表中的第一个子节点</p>\n<p><strong>lastChild</strong>指向子节点列表中的最后一个子节点</p>\n<p><strong>（4）. 节点的父节点 parentNode</strong></p>\n<p><strong>（5）. 节点的上一个兄弟节点 previousSibling</strong></p>\n<p>若节点为第一个节点，则node.previousSibling为null</p>\n<p><strong>（6）. 节点的下一个兄弟节点 nextSibling</strong></p>\n<p>若节点为最后一个节点，则node.nextSibling为null</p>\n<h4 id=\"2-操作节点\"><a href=\"#2-操作节点\" class=\"headerlink\" title=\"2. 操作节点\"></a>2. 操作节点</h4><p><strong>（1）. 在子节点列表中插入节点 appendChild()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">向childNodes列表的末尾添加一个节点，并且会返回插入的节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（2）. 在子节点列表中某一个节点的前面插入一个节点 insertBefore()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insertBefore(要插入的节点，参照节点)</span><br><span class=\"line\">同时返回要插入的节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（3）. 替换子节点 replaceChild()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   replaceChild(替换节点，被替换的节点)</span><br><span class=\"line\">同时返回被替换的节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（4）. 移除子节点 removeChild()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">removeChild(被移除的子节点)</span><br><span class=\"line\">同时返回被移除的子节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（5）. 复制节点 cloneNode()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cloneNode(bool)</span><br><span class=\"line\">bool为<span class=\"literal\">true</span>时，深复制，复制节点以及节点的所有子节点</span><br><span class=\"line\">bool为<span class=\"literal\">false</span>时，浅复制，只复制节点本身</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（6）. 规范化文本节点 normalize()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果在一个包含两个或多个文本节点的父元素上调用normalize()，则会将所有文本节点合并成一个节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（7）. 分割文本节点 splitText()</strong></p>\n<h3 id=\"二-document类型\"><a href=\"#二-document类型\" class=\"headerlink\" title=\"二. document类型\"></a>二. document类型</h3><p>文档的子节点（直接）可能有的类型如下：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文档类型节点：<span class=\"built_in\">document</span>.doctype  指的是&lt;!DOCTYPE HTM&gt;</span><br><span class=\"line\">文档元素节点：<span class=\"built_in\">document</span>.documentElement 指的是&lt;html&gt;</span><br><span class=\"line\">processingInstruction 或者 注释</span><br></pre></td></tr></table></figure>\n</code></pre><p>document对象的属性：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   body属性：<span class=\"built_in\">document</span>.body 指向body元素</span><br><span class=\"line\">   title属性：<span class=\"built_in\">document</span>.title</span><br><span class=\"line\">   URL属性：页面的URL值（地址栏中显示的 http:<span class=\"comment\">//panpanfish.com/myblog/index.html）</span></span><br><span class=\"line\">   domain属性：域名（panpanfish.com）</span><br><span class=\"line\">   referrer属性</span><br><span class=\"line\"><span class=\"built_in\">document</span>.anchors 所有带name特性的a</span><br><span class=\"line\"><span class=\"built_in\">document</span>.forms 所有的表单</span><br><span class=\"line\"><span class=\"built_in\">document</span>.images 所有的图片</span><br></pre></td></tr></table></figure>\n</code></pre><p>document对象的方法：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获取节点:</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById() 如果有两个id一样的节点，只返回第一次出现的那个节点</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementByTagName() 返回一个集合，可以用item()和[]来访问（与NodeList类似）</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementByName() 返回带有给定name的所有元素</span><br><span class=\"line\"></span><br><span class=\"line\">向文档中动态添加内容：</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"字符串\"</span>) 文档写入，直接将字符串写入文档</span><br><span class=\"line\"><span class=\"built_in\">document</span>.writeln(<span class=\"string\">\"字符串\"</span>) 文档写入，会在字符串末尾自动添加换行符\\n</span><br><span class=\"line\"></span><br><span class=\"line\">创建元素节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createElement():接收一个参数，要创建的元素标签名</span><br><span class=\"line\"></span><br><span class=\"line\">创建文本节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createTextNode()</span><br><span class=\"line\"></span><br><span class=\"line\">创建注释节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createComment()</span><br><span class=\"line\"></span><br><span class=\"line\">创建特性节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createAttribute()</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"三-Element类型\"><a href=\"#三-Element类型\" class=\"headerlink\" title=\"三. Element类型\"></a>三. Element类型</h3><p>Element类型的属性：</p>\n<pre><code>1.id\n2.title\n3.className\n4.attributes\nelement类型的attributes属性是一个NamedNodeMap（包含一系列节点）\n\nnodeName是属性的名称\nnodeValue是属性的值\n</code></pre><p>Elemant类型的方法：</p>\n<ul>\n<li>getAttribute()</li>\n<li>setAttribute()</li>\n<li>removeAttribute()</li>\n</ul>\n<p><strong>getAttribute()访问元素的属性</strong> </p>\n<p>对于html标签本身就有的属性，可以通过<code>.</code>来访问，也可以通过<code>getAttribute()</code>来访问。一般情况下，两种访问方式得到的属性值是相同的，但是<code>style</code>和<code>onclick</code>得到的不一样，建议使用<code>.操作符</code>。</p>\n<p>对于自定义属性，只能通过<code>getAttribute()</code>访问。</p>\n<p><strong>setAttribute()设置属性</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myid\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myid\"</span>);</span><br><span class=\"line\">   mydiv.setAttribute(<span class=\"string\">\"id\"</span>,<span class=\"string\">\"myid2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">如果是已经存在的属性名，则修改属性；如果不存在的属性名，则创建属性。</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>removeAttribute()删除属性</strong></p>\n<h3 id=\"四-DOM操作技术\"><a href=\"#四-DOM操作技术\" class=\"headerlink\" title=\"四. DOM操作技术\"></a>四. DOM操作技术</h3><h4 id=\"1-动态脚本\"><a href=\"#1-动态脚本\" class=\"headerlink\" title=\"1. 动态脚本\"></a>1. 动态脚本</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">\tscript.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">\tscript.src = url;</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.body.appendChild(script);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadScript(<span class=\"string\">\"myjs.js\"</span>);</span><br></pre></td></tr></table></figure>\n</code></pre>","excerpt":"","more":"<h3 id=\"一-节点类型\"><a href=\"#一-节点类型\" class=\"headerlink\" title=\"一. 节点类型\"></a>一. 节点类型</h3><h4 id=\"1-节点的分类\"><a href=\"#1-节点的分类\" class=\"headerlink\" title=\"1. 节点的分类\"></a>1. 节点的分类</h4><p>HTML页面中，总共有<strong>12</strong>种节点：</p>\n<ul>\n<li>文档节点 document类型</li>\n<li>元素节点 element类型</li>\n<li>特性节点 Attr类型</li>\n<li>文本节点 Text类型</li>\n<li>注释节点 Comment类型</li>\n<li>文档类型节点 DocumentType类型</li>\n<li>文档片段类型 DocumentFragment类型</li>\n<li>CDATASection类型 只有XML文档有</li>\n</ul>\n<h4 id=\"2-所有节点的公共属性\"><a href=\"#2-所有节点的公共属性\" class=\"headerlink\" title=\"2. 所有节点的公共属性\"></a>2. 所有节点的公共属性</h4><p>上述节点都继承自Node类型</p>\n<p><strong>（1）. 节点的类型 nodeType</strong></p>\n<p>判断一个节点的类型</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(someNode.nodeType == <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Node is an element\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（2）. 若节点为元素节点，获得节点的标签名 nodeName</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span>(someNode.nodeType == <span class=\"number\">1</span>)<span class=\"comment\">//首先要判断节点是否为元素节点</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(someNode.nodeName);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><font color=\"red\">注意：由nodeName获得的节点名称是大写！！！</font>\n\n<p><strong>（3）. 节点的直接子节点 childNodes firstChild lastChild</strong></p>\n<p>childNodes是一个NodeList对象，NodeList是一种<strong>类数组对象</strong>（类似arguments对象）。</p>\n<p>childNodes里面保存了该节点的所有<strong>直接子节点</strong></p>\n<p>注意：不同浏览器处理空白符的方式不一样，IE9版本之前不会为空白符创建节点。</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myid\"</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> my = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myid\"</span>);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(my.childNodes.length);<span class=\"comment\">//会输出5，而不是2</span></span><br></pre></td></tr></table></figure>\n</code></pre><p>解决方法：通过判断一下nodeType属性</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,len=element.childNodes.length;i&lt;len;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(element.childNodes[i].nodeType == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//执行某些操作</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p>可通过[]或者item()来访问某一个子节点</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问第一个子节点</span><br><span class=\"line\">my.childNodes[<span class=\"number\">0</span>]</span><br><span class=\"line\">my.childNodes.item(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>firstChild</strong>指向子节点列表中的第一个子节点</p>\n<p><strong>lastChild</strong>指向子节点列表中的最后一个子节点</p>\n<p><strong>（4）. 节点的父节点 parentNode</strong></p>\n<p><strong>（5）. 节点的上一个兄弟节点 previousSibling</strong></p>\n<p>若节点为第一个节点，则node.previousSibling为null</p>\n<p><strong>（6）. 节点的下一个兄弟节点 nextSibling</strong></p>\n<p>若节点为最后一个节点，则node.nextSibling为null</p>\n<h4 id=\"2-操作节点\"><a href=\"#2-操作节点\" class=\"headerlink\" title=\"2. 操作节点\"></a>2. 操作节点</h4><p><strong>（1）. 在子节点列表中插入节点 appendChild()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">向childNodes列表的末尾添加一个节点，并且会返回插入的节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（2）. 在子节点列表中某一个节点的前面插入一个节点 insertBefore()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insertBefore(要插入的节点，参照节点)</span><br><span class=\"line\">同时返回要插入的节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（3）. 替换子节点 replaceChild()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   replaceChild(替换节点，被替换的节点)</span><br><span class=\"line\">同时返回被替换的节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（4）. 移除子节点 removeChild()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">removeChild(被移除的子节点)</span><br><span class=\"line\">同时返回被移除的子节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（5）. 复制节点 cloneNode()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cloneNode(bool)</span><br><span class=\"line\">bool为<span class=\"literal\">true</span>时，深复制，复制节点以及节点的所有子节点</span><br><span class=\"line\">bool为<span class=\"literal\">false</span>时，浅复制，只复制节点本身</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（6）. 规范化文本节点 normalize()</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果在一个包含两个或多个文本节点的父元素上调用normalize()，则会将所有文本节点合并成一个节点</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>（7）. 分割文本节点 splitText()</strong></p>\n<h3 id=\"二-document类型\"><a href=\"#二-document类型\" class=\"headerlink\" title=\"二. document类型\"></a>二. document类型</h3><p>文档的子节点（直接）可能有的类型如下：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文档类型节点：<span class=\"built_in\">document</span>.doctype  指的是&lt;!DOCTYPE HTM&gt;</span><br><span class=\"line\">文档元素节点：<span class=\"built_in\">document</span>.documentElement 指的是&lt;html&gt;</span><br><span class=\"line\">processingInstruction 或者 注释</span><br></pre></td></tr></table></figure>\n</code></pre><p>document对象的属性：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   body属性：<span class=\"built_in\">document</span>.body 指向body元素</span><br><span class=\"line\">   title属性：<span class=\"built_in\">document</span>.title</span><br><span class=\"line\">   URL属性：页面的URL值（地址栏中显示的 http:<span class=\"comment\">//panpanfish.com/myblog/index.html）</span></span><br><span class=\"line\">   domain属性：域名（panpanfish.com）</span><br><span class=\"line\">   referrer属性</span><br><span class=\"line\"><span class=\"built_in\">document</span>.anchors 所有带name特性的a</span><br><span class=\"line\"><span class=\"built_in\">document</span>.forms 所有的表单</span><br><span class=\"line\"><span class=\"built_in\">document</span>.images 所有的图片</span><br></pre></td></tr></table></figure>\n</code></pre><p>document对象的方法：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获取节点:</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementById() 如果有两个id一样的节点，只返回第一次出现的那个节点</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementByTagName() 返回一个集合，可以用item()和[]来访问（与NodeList类似）</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.getElementByName() 返回带有给定name的所有元素</span><br><span class=\"line\"></span><br><span class=\"line\">向文档中动态添加内容：</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"字符串\"</span>) 文档写入，直接将字符串写入文档</span><br><span class=\"line\"><span class=\"built_in\">document</span>.writeln(<span class=\"string\">\"字符串\"</span>) 文档写入，会在字符串末尾自动添加换行符\\n</span><br><span class=\"line\"></span><br><span class=\"line\">创建元素节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createElement():接收一个参数，要创建的元素标签名</span><br><span class=\"line\"></span><br><span class=\"line\">创建文本节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createTextNode()</span><br><span class=\"line\"></span><br><span class=\"line\">创建注释节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createComment()</span><br><span class=\"line\"></span><br><span class=\"line\">创建特性节点</span><br><span class=\"line\"><span class=\"built_in\">document</span>.createAttribute()</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"三-Element类型\"><a href=\"#三-Element类型\" class=\"headerlink\" title=\"三. Element类型\"></a>三. Element类型</h3><p>Element类型的属性：</p>\n<pre><code>1.id\n2.title\n3.className\n4.attributes\nelement类型的attributes属性是一个NamedNodeMap（包含一系列节点）\n\nnodeName是属性的名称\nnodeValue是属性的值\n</code></pre><p>Elemant类型的方法：</p>\n<ul>\n<li>getAttribute()</li>\n<li>setAttribute()</li>\n<li>removeAttribute()</li>\n</ul>\n<p><strong>getAttribute()访问元素的属性</strong> </p>\n<p>对于html标签本身就有的属性，可以通过<code>.</code>来访问，也可以通过<code>getAttribute()</code>来访问。一般情况下，两种访问方式得到的属性值是相同的，但是<code>style</code>和<code>onclick</code>得到的不一样，建议使用<code>.操作符</code>。</p>\n<p>对于自定义属性，只能通过<code>getAttribute()</code>访问。</p>\n<p><strong>setAttribute()设置属性</strong></p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myid\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myid\"</span>);</span><br><span class=\"line\">   mydiv.setAttribute(<span class=\"string\">\"id\"</span>,<span class=\"string\">\"myid2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">如果是已经存在的属性名，则修改属性；如果不存在的属性名，则创建属性。</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>removeAttribute()删除属性</strong></p>\n<h3 id=\"四-DOM操作技术\"><a href=\"#四-DOM操作技术\" class=\"headerlink\" title=\"四. DOM操作技术\"></a>四. DOM操作技术</h3><h4 id=\"1-动态脚本\"><a href=\"#1-动态脚本\" class=\"headerlink\" title=\"1. 动态脚本\"></a>1. 动态脚本</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadScript</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.creatElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">\tscript.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">\tscript.src = url;</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.body.appendChild(script);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadScript(<span class=\"string\">\"myjs.js\"</span>);</span><br></pre></td></tr></table></figure>\n</code></pre>"},{"layout":"post","title":"http协议","date":"2016-05-26T16:00:00.000Z","description":null,"_content":"\n### 一. url的组成部分\n\n\thttp://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name\n    传输协议 + 域名 + 端口 + 虚拟目录 + 文件名 + 参数 + 锚部分\n\n    传输协议：若URL的协议部分为“http：”，这代表网页使用的是HTTP协议。\n\t域名：也可以使用IP地址作为域名\n\t端口：若不写端口，则采用默认端口\n\n### 二. http协议\n\n超文本传输协议，保证客户端和服务端的通信。\n\t\n### 三. HTTP请求报文和响应报文\n\nhttp的报文都是纯文本。报文主要包括三部分：**请求行**、**请求头部**、**消息主体**\n\n#### 1. http请求报文\n\n- 请求行（request line）\n- 请求头部（header）\n- 空行: 告诉服务器一下不再有请求头\n- 请求数据\n\n**请求行：请求方法字段、URL字段、HTTP协议版本字段**\n\n    eg:\n    \n    GET /tools.html HTTP/1.1\n    \n    - 请求方法：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT\n    - URL字段\n    - HTTP协议版本：HTTP/1.1\n    \n**请求头部：关键字/值组成，每行一对**\n\n例如：\n\n- User-Agent：产生请求的浏览器类型。\n- Accept：客户端可识别的内容类型列表。\n- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。\n\n**空行：告诉服务器一下不再有请求头**\n\n**请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。**\n\nPOST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n#### 2. http响应报文\n\n- 状态行\n- 消息报头\n- 空行：告诉服务器一下不再有请求头\n- 响应数据\n\n**状态行：HTTP协议版本、状态码、状态码的文本描述**\n\n    `eg: HTTP/1.0 200 OK`\n    \n**消息报头：关键字/值组成，每行一对**\n\n    eg:\n    \n    Date: Sat, 31 Dec 2005 23:59:59 GMT\n    Content-Type: text/html;charset=ISO-8859-1\n    Content-Length: 122\n\n**响应数据：返回给客户端的数据**\n\n#### 3. 状态码的意思    \n  \n- 1XX： 消息\n- 2XX： 请求成功 \n- 3XX： 请求重定向\n- 4XX： 客户端错误 \n- 5XX： 服务器错误\n\n**几个常见的状态码：**\n   \n   \t200 OK：客户端请求成功。\n   \t \n   \t3XX：请求重定向\n    301 所请求的页面已经转移至新的url，永久性转移，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址\n    302 所请求的页面已经临时转移至新的url，暂时性转移，搜索引擎会抓取新的内容而保留旧的网址   \n    \n    304 未按照预期修改文档。可以使用缓存的文档。\n    304触发的条件：本地的缓存文件和服务器上的文件的最后一次修改时间一致，则触发http状态码返回304\n    客户端有缓存的文档\n    发出了一个条件性的请求（一般是提供If-Modified-Since头表示上一次获取的文件的修改时间）。\n    服务器告诉客户，原来缓冲的文档还可以继续使用。\n    \n    If-Modified-Since http请求头部 存放的是浏览器中缓存页面的最近一次的修改时间\n    在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。\n\n\t如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。\n\n\t如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。\n\n\n    400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n    401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n    403 Forbidden：服务器收到请求，但是拒绝提供服务。\n    404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n    \n    500 Internal Server Error：服务器发生不可预期的错误。\n    503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n\n","source":"_posts/2016-05-27-http协议.md","raw":"---\nlayout: post\ntitle: http协议\ndate: 2016-05-27\ncategories: http协议\ntags: [http]\ndescription: \n---\n\n### 一. url的组成部分\n\n\thttp://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name\n    传输协议 + 域名 + 端口 + 虚拟目录 + 文件名 + 参数 + 锚部分\n\n    传输协议：若URL的协议部分为“http：”，这代表网页使用的是HTTP协议。\n\t域名：也可以使用IP地址作为域名\n\t端口：若不写端口，则采用默认端口\n\n### 二. http协议\n\n超文本传输协议，保证客户端和服务端的通信。\n\t\n### 三. HTTP请求报文和响应报文\n\nhttp的报文都是纯文本。报文主要包括三部分：**请求行**、**请求头部**、**消息主体**\n\n#### 1. http请求报文\n\n- 请求行（request line）\n- 请求头部（header）\n- 空行: 告诉服务器一下不再有请求头\n- 请求数据\n\n**请求行：请求方法字段、URL字段、HTTP协议版本字段**\n\n    eg:\n    \n    GET /tools.html HTTP/1.1\n    \n    - 请求方法：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT\n    - URL字段\n    - HTTP协议版本：HTTP/1.1\n    \n**请求头部：关键字/值组成，每行一对**\n\n例如：\n\n- User-Agent：产生请求的浏览器类型。\n- Accept：客户端可识别的内容类型列表。\n- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。\n\n**空行：告诉服务器一下不再有请求头**\n\n**请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。**\n\nPOST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n#### 2. http响应报文\n\n- 状态行\n- 消息报头\n- 空行：告诉服务器一下不再有请求头\n- 响应数据\n\n**状态行：HTTP协议版本、状态码、状态码的文本描述**\n\n    `eg: HTTP/1.0 200 OK`\n    \n**消息报头：关键字/值组成，每行一对**\n\n    eg:\n    \n    Date: Sat, 31 Dec 2005 23:59:59 GMT\n    Content-Type: text/html;charset=ISO-8859-1\n    Content-Length: 122\n\n**响应数据：返回给客户端的数据**\n\n#### 3. 状态码的意思    \n  \n- 1XX： 消息\n- 2XX： 请求成功 \n- 3XX： 请求重定向\n- 4XX： 客户端错误 \n- 5XX： 服务器错误\n\n**几个常见的状态码：**\n   \n   \t200 OK：客户端请求成功。\n   \t \n   \t3XX：请求重定向\n    301 所请求的页面已经转移至新的url，永久性转移，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址\n    302 所请求的页面已经临时转移至新的url，暂时性转移，搜索引擎会抓取新的内容而保留旧的网址   \n    \n    304 未按照预期修改文档。可以使用缓存的文档。\n    304触发的条件：本地的缓存文件和服务器上的文件的最后一次修改时间一致，则触发http状态码返回304\n    客户端有缓存的文档\n    发出了一个条件性的请求（一般是提供If-Modified-Since头表示上一次获取的文件的修改时间）。\n    服务器告诉客户，原来缓冲的文档还可以继续使用。\n    \n    If-Modified-Since http请求头部 存放的是浏览器中缓存页面的最近一次的修改时间\n    在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。\n\n\t如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。\n\n\t如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。\n\n\n    400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n    401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n    403 Forbidden：服务器收到请求，但是拒绝提供服务。\n    404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n    \n    500 Internal Server Error：服务器发生不可预期的错误。\n    503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n\n","slug":"2016-05-27-http协议","published":1,"updated":"2016-10-15T14:29:50.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochm0082d5u8clo74qcp","content":"<h3 id=\"一-url的组成部分\"><a href=\"#一-url的组成部分\" class=\"headerlink\" title=\"一. url的组成部分\"></a>一. url的组成部分</h3><pre><code>http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name\n传输协议 + 域名 + 端口 + 虚拟目录 + 文件名 + 参数 + 锚部分\n\n传输协议：若URL的协议部分为“http：”，这代表网页使用的是HTTP协议。\n域名：也可以使用IP地址作为域名\n端口：若不写端口，则采用默认端口\n</code></pre><h3 id=\"二-http协议\"><a href=\"#二-http协议\" class=\"headerlink\" title=\"二. http协议\"></a>二. http协议</h3><p>超文本传输协议，保证客户端和服务端的通信。</p>\n<h3 id=\"三-HTTP请求报文和响应报文\"><a href=\"#三-HTTP请求报文和响应报文\" class=\"headerlink\" title=\"三. HTTP请求报文和响应报文\"></a>三. HTTP请求报文和响应报文</h3><p>http的报文都是纯文本。报文主要包括三部分：<strong>请求行</strong>、<strong>请求头部</strong>、<strong>消息主体</strong></p>\n<h4 id=\"1-http请求报文\"><a href=\"#1-http请求报文\" class=\"headerlink\" title=\"1. http请求报文\"></a>1. http请求报文</h4><ul>\n<li>请求行（request line）</li>\n<li>请求头部（header）</li>\n<li>空行: 告诉服务器一下不再有请求头</li>\n<li>请求数据</li>\n</ul>\n<p><strong>请求行：请求方法字段、URL字段、HTTP协议版本字段</strong></p>\n<pre><code>eg:\n\nGET /tools.html HTTP/1.1\n\n- 请求方法：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT\n- URL字段\n- HTTP协议版本：HTTP/1.1\n</code></pre><p><strong>请求头部：关键字/值组成，每行一对</strong></p>\n<p>例如：</p>\n<ul>\n<li>User-Agent：产生请求的浏览器类型。</li>\n<li>Accept：客户端可识别的内容类型列表。</li>\n<li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li>\n</ul>\n<p><strong>空行：告诉服务器一下不再有请求头</strong></p>\n<p><strong>请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。</strong></p>\n<p>POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h4 id=\"2-http响应报文\"><a href=\"#2-http响应报文\" class=\"headerlink\" title=\"2. http响应报文\"></a>2. http响应报文</h4><ul>\n<li>状态行</li>\n<li>消息报头</li>\n<li>空行：告诉服务器一下不再有请求头</li>\n<li>响应数据</li>\n</ul>\n<p><strong>状态行：HTTP协议版本、状态码、状态码的文本描述</strong></p>\n<pre><code>`eg: HTTP/1.0 200 OK`\n</code></pre><p><strong>消息报头：关键字/值组成，每行一对</strong></p>\n<pre><code>eg:\n\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n</code></pre><p><strong>响应数据：返回给客户端的数据</strong></p>\n<h4 id=\"3-状态码的意思\"><a href=\"#3-状态码的意思\" class=\"headerlink\" title=\"3. 状态码的意思\"></a>3. 状态码的意思</h4><ul>\n<li>1XX： 消息</li>\n<li>2XX： 请求成功 </li>\n<li>3XX： 请求重定向</li>\n<li>4XX： 客户端错误 </li>\n<li>5XX： 服务器错误</li>\n</ul>\n<p><strong>几个常见的状态码：</strong></p>\n<pre><code>   200 OK：客户端请求成功。\n\n   3XX：请求重定向\n301 所请求的页面已经转移至新的url，永久性转移，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址\n302 所请求的页面已经临时转移至新的url，暂时性转移，搜索引擎会抓取新的内容而保留旧的网址   \n\n304 未按照预期修改文档。可以使用缓存的文档。\n304触发的条件：本地的缓存文件和服务器上的文件的最后一次修改时间一致，则触发http状态码返回304\n客户端有缓存的文档\n发出了一个条件性的请求（一般是提供If-Modified-Since头表示上一次获取的文件的修改时间）。\n服务器告诉客户，原来缓冲的文档还可以继续使用。\n\nIf-Modified-Since http请求头部 存放的是浏览器中缓存页面的最近一次的修改时间\n在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。\n\n如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。\n\n如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。\n\n\n400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n403 Forbidden：服务器收到请求，但是拒绝提供服务。\n404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n\n500 Internal Server Error：服务器发生不可预期的错误。\n503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n</code></pre>","excerpt":"","more":"<h3 id=\"一-url的组成部分\"><a href=\"#一-url的组成部分\" class=\"headerlink\" title=\"一. url的组成部分\"></a>一. url的组成部分</h3><pre><code>http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name\n传输协议 + 域名 + 端口 + 虚拟目录 + 文件名 + 参数 + 锚部分\n\n传输协议：若URL的协议部分为“http：”，这代表网页使用的是HTTP协议。\n域名：也可以使用IP地址作为域名\n端口：若不写端口，则采用默认端口\n</code></pre><h3 id=\"二-http协议\"><a href=\"#二-http协议\" class=\"headerlink\" title=\"二. http协议\"></a>二. http协议</h3><p>超文本传输协议，保证客户端和服务端的通信。</p>\n<h3 id=\"三-HTTP请求报文和响应报文\"><a href=\"#三-HTTP请求报文和响应报文\" class=\"headerlink\" title=\"三. HTTP请求报文和响应报文\"></a>三. HTTP请求报文和响应报文</h3><p>http的报文都是纯文本。报文主要包括三部分：<strong>请求行</strong>、<strong>请求头部</strong>、<strong>消息主体</strong></p>\n<h4 id=\"1-http请求报文\"><a href=\"#1-http请求报文\" class=\"headerlink\" title=\"1. http请求报文\"></a>1. http请求报文</h4><ul>\n<li>请求行（request line）</li>\n<li>请求头部（header）</li>\n<li>空行: 告诉服务器一下不再有请求头</li>\n<li>请求数据</li>\n</ul>\n<p><strong>请求行：请求方法字段、URL字段、HTTP协议版本字段</strong></p>\n<pre><code>eg:\n\nGET /tools.html HTTP/1.1\n\n- 请求方法：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT\n- URL字段\n- HTTP协议版本：HTTP/1.1\n</code></pre><p><strong>请求头部：关键字/值组成，每行一对</strong></p>\n<p>例如：</p>\n<ul>\n<li>User-Agent：产生请求的浏览器类型。</li>\n<li>Accept：客户端可识别的内容类型列表。</li>\n<li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li>\n</ul>\n<p><strong>空行：告诉服务器一下不再有请求头</strong></p>\n<p><strong>请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。</strong></p>\n<p>POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h4 id=\"2-http响应报文\"><a href=\"#2-http响应报文\" class=\"headerlink\" title=\"2. http响应报文\"></a>2. http响应报文</h4><ul>\n<li>状态行</li>\n<li>消息报头</li>\n<li>空行：告诉服务器一下不再有请求头</li>\n<li>响应数据</li>\n</ul>\n<p><strong>状态行：HTTP协议版本、状态码、状态码的文本描述</strong></p>\n<pre><code>`eg: HTTP/1.0 200 OK`\n</code></pre><p><strong>消息报头：关键字/值组成，每行一对</strong></p>\n<pre><code>eg:\n\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n</code></pre><p><strong>响应数据：返回给客户端的数据</strong></p>\n<h4 id=\"3-状态码的意思\"><a href=\"#3-状态码的意思\" class=\"headerlink\" title=\"3. 状态码的意思\"></a>3. 状态码的意思</h4><ul>\n<li>1XX： 消息</li>\n<li>2XX： 请求成功 </li>\n<li>3XX： 请求重定向</li>\n<li>4XX： 客户端错误 </li>\n<li>5XX： 服务器错误</li>\n</ul>\n<p><strong>几个常见的状态码：</strong></p>\n<pre><code>   200 OK：客户端请求成功。\n\n   3XX：请求重定向\n301 所请求的页面已经转移至新的url，永久性转移，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址\n302 所请求的页面已经临时转移至新的url，暂时性转移，搜索引擎会抓取新的内容而保留旧的网址   \n\n304 未按照预期修改文档。可以使用缓存的文档。\n304触发的条件：本地的缓存文件和服务器上的文件的最后一次修改时间一致，则触发http状态码返回304\n客户端有缓存的文档\n发出了一个条件性的请求（一般是提供If-Modified-Since头表示上一次获取的文件的修改时间）。\n服务器告诉客户，原来缓冲的文档还可以继续使用。\n\nIf-Modified-Since http请求头部 存放的是浏览器中缓存页面的最近一次的修改时间\n在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。\n\n如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。\n\n如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。\n\n\n400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n403 Forbidden：服务器收到请求，但是拒绝提供服务。\n404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n\n500 Internal Server Error：服务器发生不可预期的错误。\n503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n</code></pre>"},{"layout":"post","title":"Web Sockets协议","date":"2016-05-31T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是Web Sockets?\n\nWeb Sockets是一个实现双向实时通信的**协议**\n\nWeb Sockets的目的是：\n\n> 在一个单独持久的连接上提供全双工、双向通信\n\n### 二. web sockets 使用\n\n#### 1. 创建一个WebSocket实例\n\n```js\nvar socket = new WebSocket(\"ws://www.example.com/server.php\");\n```\n\n注意：传入的参数是一个绝对的URL，websocket协议不受同源策略的影响。\n\n#### 2. 向服务器发送数据 send()方法\n\n```js\nsocket.send(\"Hello world\");\n```\n注意：websocket只能通过send发送纯文本数据，对于复杂的数据结构，需要在发送之前进行序列化。\n\n例如：发送JSON数据\n\n```js\nvar message = {\n\ttime: new Date(),\n\ttext: \"hello world\",\n\tclientId: \"asdfp8734rew\"\n}\n\nsocket.send(JSON.stringify(message));\n```\n\n插叙一点关于JSON的知识：\n\nJSON是一种轻量级的文本数据交换格式，在语法上与js对象的代码相同。\n\n**JSON.parse()**和**JSON.stringify()**比较\n\n- JSON.parse()：从一个字符串中解析出json对象\n- JSON.stringify()：将对象变成字符串\n\n#### 3. 从服务器接收数据\n\n当服务器向客户端发送消息时，websocket对象会触发**message事件**，返回的数据保存在event.data属性中。\n\n```js\nsocket.onmessage = function(event){\n\tvar data = event.data;\n\t//然后处理获得的数据data\n}\n```\nevent.data中保存的也是字符串\n\n### 三. websocket对象\n\n#### 1. websocket对象的属性\n\nWebSocket属性**readState**取值：\n\n- WebSocket.OPENING(0):正在建立连接\n- WebSocket.OPEN(1):已经建立连接\n- WebSocket.CLOSING(2):正在关闭连接\n- WebSocket.CLOSE(3):已经关闭连接\n\n#### 2. websocket对象的方法\n\n- send()\n- close()\n\n#### 3. websocket对象的事件\n\n- message：服务器向客户端发送消息时会触发\n- open：客户端与服务器成功建立连接时触发\n- error：在发生错误时触发，连接不能持续\n- close：在连接关闭时触发\n\n**close事件的event有额外的信息：**\n\n- wasClean:布尔值，是否明确地关闭\n- code：服务器返回的数值状态码\n- reason：字符串，包含服务器发回的消息\n\n\n\n\n","source":"_posts/2016-06-01-web sovkets协议.md","raw":"---\nlayout: post\ntitle: Web Sockets协议\ndate: 2016-06-01\ncategories: HTML\ntags: [HTML5]\ndescription: \n---\n\n### 一. 什么是Web Sockets?\n\nWeb Sockets是一个实现双向实时通信的**协议**\n\nWeb Sockets的目的是：\n\n> 在一个单独持久的连接上提供全双工、双向通信\n\n### 二. web sockets 使用\n\n#### 1. 创建一个WebSocket实例\n\n```js\nvar socket = new WebSocket(\"ws://www.example.com/server.php\");\n```\n\n注意：传入的参数是一个绝对的URL，websocket协议不受同源策略的影响。\n\n#### 2. 向服务器发送数据 send()方法\n\n```js\nsocket.send(\"Hello world\");\n```\n注意：websocket只能通过send发送纯文本数据，对于复杂的数据结构，需要在发送之前进行序列化。\n\n例如：发送JSON数据\n\n```js\nvar message = {\n\ttime: new Date(),\n\ttext: \"hello world\",\n\tclientId: \"asdfp8734rew\"\n}\n\nsocket.send(JSON.stringify(message));\n```\n\n插叙一点关于JSON的知识：\n\nJSON是一种轻量级的文本数据交换格式，在语法上与js对象的代码相同。\n\n**JSON.parse()**和**JSON.stringify()**比较\n\n- JSON.parse()：从一个字符串中解析出json对象\n- JSON.stringify()：将对象变成字符串\n\n#### 3. 从服务器接收数据\n\n当服务器向客户端发送消息时，websocket对象会触发**message事件**，返回的数据保存在event.data属性中。\n\n```js\nsocket.onmessage = function(event){\n\tvar data = event.data;\n\t//然后处理获得的数据data\n}\n```\nevent.data中保存的也是字符串\n\n### 三. websocket对象\n\n#### 1. websocket对象的属性\n\nWebSocket属性**readState**取值：\n\n- WebSocket.OPENING(0):正在建立连接\n- WebSocket.OPEN(1):已经建立连接\n- WebSocket.CLOSING(2):正在关闭连接\n- WebSocket.CLOSE(3):已经关闭连接\n\n#### 2. websocket对象的方法\n\n- send()\n- close()\n\n#### 3. websocket对象的事件\n\n- message：服务器向客户端发送消息时会触发\n- open：客户端与服务器成功建立连接时触发\n- error：在发生错误时触发，连接不能持续\n- close：在连接关闭时触发\n\n**close事件的event有额外的信息：**\n\n- wasClean:布尔值，是否明确地关闭\n- code：服务器返回的数值状态码\n- reason：字符串，包含服务器发回的消息\n\n\n\n\n","slug":"2016-06-01-web sovkets协议","published":1,"updated":"2016-06-01T09:05:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochp0086d5u8uqu6s8sf","content":"<h3 id=\"一-什么是Web-Sockets\"><a href=\"#一-什么是Web-Sockets\" class=\"headerlink\" title=\"一. 什么是Web Sockets?\"></a>一. 什么是Web Sockets?</h3><p>Web Sockets是一个实现双向实时通信的<strong>协议</strong></p>\n<p>Web Sockets的目的是：</p>\n<blockquote>\n<p>在一个单独持久的连接上提供全双工、双向通信</p>\n</blockquote>\n<h3 id=\"二-web-sockets-使用\"><a href=\"#二-web-sockets-使用\" class=\"headerlink\" title=\"二. web sockets 使用\"></a>二. web sockets 使用</h3><h4 id=\"1-创建一个WebSocket实例\"><a href=\"#1-创建一个WebSocket实例\" class=\"headerlink\" title=\"1. 创建一个WebSocket实例\"></a>1. 创建一个WebSocket实例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">\"ws://www.example.com/server.php\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：传入的参数是一个绝对的URL，websocket协议不受同源策略的影响。</p>\n<h4 id=\"2-向服务器发送数据-send-方法\"><a href=\"#2-向服务器发送数据-send-方法\" class=\"headerlink\" title=\"2. 向服务器发送数据 send()方法\"></a>2. 向服务器发送数据 send()方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.send(<span class=\"string\">\"Hello world\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：websocket只能通过send发送纯文本数据，对于复杂的数据结构，需要在发送之前进行序列化。</p>\n<p>例如：发送JSON数据</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = &#123;</span><br><span class=\"line\">\ttime: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">\ttext: <span class=\"string\">\"hello world\"</span>,</span><br><span class=\"line\">\tclientId: <span class=\"string\">\"asdfp8734rew\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">socket.send(<span class=\"built_in\">JSON</span>.stringify(message));</span><br></pre></td></tr></table></figure>\n<p>插叙一点关于JSON的知识：</p>\n<p>JSON是一种轻量级的文本数据交换格式，在语法上与js对象的代码相同。</p>\n<p><strong>JSON.parse()</strong>和<strong>JSON.stringify()</strong>比较</p>\n<ul>\n<li>JSON.parse()：从一个字符串中解析出json对象</li>\n<li>JSON.stringify()：将对象变成字符串</li>\n</ul>\n<h4 id=\"3-从服务器接收数据\"><a href=\"#3-从服务器接收数据\" class=\"headerlink\" title=\"3. 从服务器接收数据\"></a>3. 从服务器接收数据</h4><p>当服务器向客户端发送消息时，websocket对象会触发<strong>message事件</strong>，返回的数据保存在event.data属性中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> data = event.data;</span><br><span class=\"line\">\t<span class=\"comment\">//然后处理获得的数据data</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>event.data中保存的也是字符串</p>\n<h3 id=\"三-websocket对象\"><a href=\"#三-websocket对象\" class=\"headerlink\" title=\"三. websocket对象\"></a>三. websocket对象</h3><h4 id=\"1-websocket对象的属性\"><a href=\"#1-websocket对象的属性\" class=\"headerlink\" title=\"1. websocket对象的属性\"></a>1. websocket对象的属性</h4><p>WebSocket属性<strong>readState</strong>取值：</p>\n<ul>\n<li>WebSocket.OPENING(0):正在建立连接</li>\n<li>WebSocket.OPEN(1):已经建立连接</li>\n<li>WebSocket.CLOSING(2):正在关闭连接</li>\n<li>WebSocket.CLOSE(3):已经关闭连接</li>\n</ul>\n<h4 id=\"2-websocket对象的方法\"><a href=\"#2-websocket对象的方法\" class=\"headerlink\" title=\"2. websocket对象的方法\"></a>2. websocket对象的方法</h4><ul>\n<li>send()</li>\n<li>close()</li>\n</ul>\n<h4 id=\"3-websocket对象的事件\"><a href=\"#3-websocket对象的事件\" class=\"headerlink\" title=\"3. websocket对象的事件\"></a>3. websocket对象的事件</h4><ul>\n<li>message：服务器向客户端发送消息时会触发</li>\n<li>open：客户端与服务器成功建立连接时触发</li>\n<li>error：在发生错误时触发，连接不能持续</li>\n<li>close：在连接关闭时触发</li>\n</ul>\n<p><strong>close事件的event有额外的信息：</strong></p>\n<ul>\n<li>wasClean:布尔值，是否明确地关闭</li>\n<li>code：服务器返回的数值状态码</li>\n<li>reason：字符串，包含服务器发回的消息</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-什么是Web-Sockets\"><a href=\"#一-什么是Web-Sockets\" class=\"headerlink\" title=\"一. 什么是Web Sockets?\"></a>一. 什么是Web Sockets?</h3><p>Web Sockets是一个实现双向实时通信的<strong>协议</strong></p>\n<p>Web Sockets的目的是：</p>\n<blockquote>\n<p>在一个单独持久的连接上提供全双工、双向通信</p>\n</blockquote>\n<h3 id=\"二-web-sockets-使用\"><a href=\"#二-web-sockets-使用\" class=\"headerlink\" title=\"二. web sockets 使用\"></a>二. web sockets 使用</h3><h4 id=\"1-创建一个WebSocket实例\"><a href=\"#1-创建一个WebSocket实例\" class=\"headerlink\" title=\"1. 创建一个WebSocket实例\"></a>1. 创建一个WebSocket实例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">\"ws://www.example.com/server.php\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：传入的参数是一个绝对的URL，websocket协议不受同源策略的影响。</p>\n<h4 id=\"2-向服务器发送数据-send-方法\"><a href=\"#2-向服务器发送数据-send-方法\" class=\"headerlink\" title=\"2. 向服务器发送数据 send()方法\"></a>2. 向服务器发送数据 send()方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.send(<span class=\"string\">\"Hello world\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：websocket只能通过send发送纯文本数据，对于复杂的数据结构，需要在发送之前进行序列化。</p>\n<p>例如：发送JSON数据</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = &#123;</span><br><span class=\"line\">\ttime: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">\ttext: <span class=\"string\">\"hello world\"</span>,</span><br><span class=\"line\">\tclientId: <span class=\"string\">\"asdfp8734rew\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">socket.send(<span class=\"built_in\">JSON</span>.stringify(message));</span><br></pre></td></tr></table></figure>\n<p>插叙一点关于JSON的知识：</p>\n<p>JSON是一种轻量级的文本数据交换格式，在语法上与js对象的代码相同。</p>\n<p><strong>JSON.parse()</strong>和<strong>JSON.stringify()</strong>比较</p>\n<ul>\n<li>JSON.parse()：从一个字符串中解析出json对象</li>\n<li>JSON.stringify()：将对象变成字符串</li>\n</ul>\n<h4 id=\"3-从服务器接收数据\"><a href=\"#3-从服务器接收数据\" class=\"headerlink\" title=\"3. 从服务器接收数据\"></a>3. 从服务器接收数据</h4><p>当服务器向客户端发送消息时，websocket对象会触发<strong>message事件</strong>，返回的数据保存在event.data属性中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> data = event.data;</span><br><span class=\"line\">\t<span class=\"comment\">//然后处理获得的数据data</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>event.data中保存的也是字符串</p>\n<h3 id=\"三-websocket对象\"><a href=\"#三-websocket对象\" class=\"headerlink\" title=\"三. websocket对象\"></a>三. websocket对象</h3><h4 id=\"1-websocket对象的属性\"><a href=\"#1-websocket对象的属性\" class=\"headerlink\" title=\"1. websocket对象的属性\"></a>1. websocket对象的属性</h4><p>WebSocket属性<strong>readState</strong>取值：</p>\n<ul>\n<li>WebSocket.OPENING(0):正在建立连接</li>\n<li>WebSocket.OPEN(1):已经建立连接</li>\n<li>WebSocket.CLOSING(2):正在关闭连接</li>\n<li>WebSocket.CLOSE(3):已经关闭连接</li>\n</ul>\n<h4 id=\"2-websocket对象的方法\"><a href=\"#2-websocket对象的方法\" class=\"headerlink\" title=\"2. websocket对象的方法\"></a>2. websocket对象的方法</h4><ul>\n<li>send()</li>\n<li>close()</li>\n</ul>\n<h4 id=\"3-websocket对象的事件\"><a href=\"#3-websocket对象的事件\" class=\"headerlink\" title=\"3. websocket对象的事件\"></a>3. websocket对象的事件</h4><ul>\n<li>message：服务器向客户端发送消息时会触发</li>\n<li>open：客户端与服务器成功建立连接时触发</li>\n<li>error：在发生错误时触发，连接不能持续</li>\n<li>close：在连接关闭时触发</li>\n</ul>\n<p><strong>close事件的event有额外的信息：</strong></p>\n<ul>\n<li>wasClean:布尔值，是否明确地关闭</li>\n<li>code：服务器返回的数值状态码</li>\n<li>reason：字符串，包含服务器发回的消息</li>\n</ul>\n"},{"layout":"post","title":"配置PHP环境","date":"2016-05-31T16:00:00.000Z","description":null,"_content":"###  一. 安装php运行环境\n\n#### 1. 在官网上下载，解压\n\n#### 2. 将php.ini-development改为php.ini\n\n#### 3. 将解压的目录添加至环境变量\n\n例如：我解压到**D盘**的**php文件夹**中，`D:\\php`\n\n将`D:\\php`添加至环境变量\n\n右键计算机->属性->高级系统设置->环境变量->系统变量->找到PATH，双击->将`D:\\php`添加到**变量值**的末尾，各个环境变量之间用`;`隔开\n\n#### 4. 在命令行中运行`php -v`\n\n如果出现版本号，即为正确安装\n\n如果没有出现，那么php环境配置错误\n\n### 二. 在安装过程中出现的问题\n\n由于我安装的是php-7.0.7版本，在启动php时，\n\n> 弹出窗口提示：无法启动此程序，因为计算机中丢失 VCRUNTIME140.dll。尝试重新安装改程序以解决此问题。\n\n原来在Windows下运行php7需要`Visual C++Redistributable 2015`而之前的版本不需要那么高的，安装一次即可解决环境问题，去微软官网下载安装即可。\n\n有64位版和32位版，根据计算机配置进行下载，下面是下载链接：\n\n　　**64位版下载地址：**\n\n  http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x64/vc_redist.x64.exe\n\n　　**32位版下载地址：**\n\n  http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x86/vc_redist.x86.exe\n\n### 三. 运行本地的php文件\n\n然后在**当前目录下**（安装php环境的目录）新建test.php，输入简单的代码：\n\n```php\n <?php\n echo \"Hello world!\";\n ?>\n```\n\n然后打开cmd进入该目录，输入以下代码即可运行：\n\n```php\nphp test.php\n```","source":"_posts/2016-06-02-配置PHP环境.md","raw":"---\nlayout: post\ntitle: 配置PHP环境\ndate: 2016-06-01\ncategories: php\ntags: [php]\ndescription: \n---\n###  一. 安装php运行环境\n\n#### 1. 在官网上下载，解压\n\n#### 2. 将php.ini-development改为php.ini\n\n#### 3. 将解压的目录添加至环境变量\n\n例如：我解压到**D盘**的**php文件夹**中，`D:\\php`\n\n将`D:\\php`添加至环境变量\n\n右键计算机->属性->高级系统设置->环境变量->系统变量->找到PATH，双击->将`D:\\php`添加到**变量值**的末尾，各个环境变量之间用`;`隔开\n\n#### 4. 在命令行中运行`php -v`\n\n如果出现版本号，即为正确安装\n\n如果没有出现，那么php环境配置错误\n\n### 二. 在安装过程中出现的问题\n\n由于我安装的是php-7.0.7版本，在启动php时，\n\n> 弹出窗口提示：无法启动此程序，因为计算机中丢失 VCRUNTIME140.dll。尝试重新安装改程序以解决此问题。\n\n原来在Windows下运行php7需要`Visual C++Redistributable 2015`而之前的版本不需要那么高的，安装一次即可解决环境问题，去微软官网下载安装即可。\n\n有64位版和32位版，根据计算机配置进行下载，下面是下载链接：\n\n　　**64位版下载地址：**\n\n  http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x64/vc_redist.x64.exe\n\n　　**32位版下载地址：**\n\n  http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x86/vc_redist.x86.exe\n\n### 三. 运行本地的php文件\n\n然后在**当前目录下**（安装php环境的目录）新建test.php，输入简单的代码：\n\n```php\n <?php\n echo \"Hello world!\";\n ?>\n```\n\n然后打开cmd进入该目录，输入以下代码即可运行：\n\n```php\nphp test.php\n```","slug":"2016-06-02-配置PHP环境","published":1,"updated":"2016-06-02T13:13:40.000Z","comments":1,"photos":[],"link":"","_id":"cj035ochr008ad5u86d65tsn5","content":"<h3 id=\"一-安装php运行环境\"><a href=\"#一-安装php运行环境\" class=\"headerlink\" title=\"一. 安装php运行环境\"></a>一. 安装php运行环境</h3><h4 id=\"1-在官网上下载，解压\"><a href=\"#1-在官网上下载，解压\" class=\"headerlink\" title=\"1. 在官网上下载，解压\"></a>1. 在官网上下载，解压</h4><h4 id=\"2-将php-ini-development改为php-ini\"><a href=\"#2-将php-ini-development改为php-ini\" class=\"headerlink\" title=\"2. 将php.ini-development改为php.ini\"></a>2. 将php.ini-development改为php.ini</h4><h4 id=\"3-将解压的目录添加至环境变量\"><a href=\"#3-将解压的目录添加至环境变量\" class=\"headerlink\" title=\"3. 将解压的目录添加至环境变量\"></a>3. 将解压的目录添加至环境变量</h4><p>例如：我解压到<strong>D盘</strong>的<strong>php文件夹</strong>中，<code>D:\\php</code></p>\n<p>将<code>D:\\php</code>添加至环境变量</p>\n<p>右键计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;找到PATH，双击-&gt;将<code>D:\\php</code>添加到<strong>变量值</strong>的末尾，各个环境变量之间用<code>;</code>隔开</p>\n<h4 id=\"4-在命令行中运行php-v\"><a href=\"#4-在命令行中运行php-v\" class=\"headerlink\" title=\"4. 在命令行中运行php -v\"></a>4. 在命令行中运行<code>php -v</code></h4><p>如果出现版本号，即为正确安装</p>\n<p>如果没有出现，那么php环境配置错误</p>\n<h3 id=\"二-在安装过程中出现的问题\"><a href=\"#二-在安装过程中出现的问题\" class=\"headerlink\" title=\"二. 在安装过程中出现的问题\"></a>二. 在安装过程中出现的问题</h3><p>由于我安装的是php-7.0.7版本，在启动php时，</p>\n<blockquote>\n<p>弹出窗口提示：无法启动此程序，因为计算机中丢失 VCRUNTIME140.dll。尝试重新安装改程序以解决此问题。</p>\n</blockquote>\n<p>原来在Windows下运行php7需要<code>Visual C++Redistributable 2015</code>而之前的版本不需要那么高的，安装一次即可解决环境问题，去微软官网下载安装即可。</p>\n<p>有64位版和32位版，根据计算机配置进行下载，下面是下载链接：</p>\n<p>　　<strong>64位版下载地址：</strong></p>\n<p>  <a href=\"http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x64/vc_redist.x64.exe\" target=\"_blank\" rel=\"external\">http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x64/vc_redist.x64.exe</a></p>\n<p>　　<strong>32位版下载地址：</strong></p>\n<p>  <a href=\"http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x86/vc_redist.x86.exe\" target=\"_blank\" rel=\"external\">http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x86/vc_redist.x86.exe</a></p>\n<h3 id=\"三-运行本地的php文件\"><a href=\"#三-运行本地的php文件\" class=\"headerlink\" title=\"三. 运行本地的php文件\"></a>三. 运行本地的php文件</h3><p>然后在<strong>当前目录下</strong>（安装php环境的目录）新建test.php，输入简单的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"Hello world!\"</span>;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后打开cmd进入该目录，输入以下代码即可运行：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php test.php</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-安装php运行环境\"><a href=\"#一-安装php运行环境\" class=\"headerlink\" title=\"一. 安装php运行环境\"></a>一. 安装php运行环境</h3><h4 id=\"1-在官网上下载，解压\"><a href=\"#1-在官网上下载，解压\" class=\"headerlink\" title=\"1. 在官网上下载，解压\"></a>1. 在官网上下载，解压</h4><h4 id=\"2-将php-ini-development改为php-ini\"><a href=\"#2-将php-ini-development改为php-ini\" class=\"headerlink\" title=\"2. 将php.ini-development改为php.ini\"></a>2. 将php.ini-development改为php.ini</h4><h4 id=\"3-将解压的目录添加至环境变量\"><a href=\"#3-将解压的目录添加至环境变量\" class=\"headerlink\" title=\"3. 将解压的目录添加至环境变量\"></a>3. 将解压的目录添加至环境变量</h4><p>例如：我解压到<strong>D盘</strong>的<strong>php文件夹</strong>中，<code>D:\\php</code></p>\n<p>将<code>D:\\php</code>添加至环境变量</p>\n<p>右键计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;找到PATH，双击-&gt;将<code>D:\\php</code>添加到<strong>变量值</strong>的末尾，各个环境变量之间用<code>;</code>隔开</p>\n<h4 id=\"4-在命令行中运行php-v\"><a href=\"#4-在命令行中运行php-v\" class=\"headerlink\" title=\"4. 在命令行中运行php -v\"></a>4. 在命令行中运行<code>php -v</code></h4><p>如果出现版本号，即为正确安装</p>\n<p>如果没有出现，那么php环境配置错误</p>\n<h3 id=\"二-在安装过程中出现的问题\"><a href=\"#二-在安装过程中出现的问题\" class=\"headerlink\" title=\"二. 在安装过程中出现的问题\"></a>二. 在安装过程中出现的问题</h3><p>由于我安装的是php-7.0.7版本，在启动php时，</p>\n<blockquote>\n<p>弹出窗口提示：无法启动此程序，因为计算机中丢失 VCRUNTIME140.dll。尝试重新安装改程序以解决此问题。</p>\n</blockquote>\n<p>原来在Windows下运行php7需要<code>Visual C++Redistributable 2015</code>而之前的版本不需要那么高的，安装一次即可解决环境问题，去微软官网下载安装即可。</p>\n<p>有64位版和32位版，根据计算机配置进行下载，下面是下载链接：</p>\n<p>　　<strong>64位版下载地址：</strong></p>\n<p>  <a href=\"http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x64/vc_redist.x64.exe\">http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x64/vc_redist.x64.exe</a></p>\n<p>　　<strong>32位版下载地址：</strong></p>\n<p>  <a href=\"http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x86/vc_redist.x86.exe\">http://download.microsoft.com/download/9/E/1/9E1FA77A-9E95-4F3D-8BE1-4D2D0C947BA2/enu_INREL/vcredistd14x86/vc_redist.x86.exe</a></p>\n<h3 id=\"三-运行本地的php文件\"><a href=\"#三-运行本地的php文件\" class=\"headerlink\" title=\"三. 运行本地的php文件\"></a>三. 运行本地的php文件</h3><p>然后在<strong>当前目录下</strong>（安装php环境的目录）新建test.php，输入简单的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"Hello world!\"</span>;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后打开cmd进入该目录，输入以下代码即可运行：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php test.php</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"js模块化编程","date":"2016-06-02T16:00:00.000Z","description":null,"_content":"###  一. 什么是模块？\n\njs本身不是一个模块化语言，随着js的领域越来越大，所做的事情越来越多，我们需要对js代码进行一些模块化组织。\n\n将不同的功能的函数放在一起，组成实现某一特定功能的整体就是一个模块。\n\n模块可以让我们很方便地使用别人的代码。\n\n#### 1. 最原始的写法\n\n例如：\n\n```js\nfunction add(a,b){\n\treturn a + b;\n}\n\nfunction divide(a,b){\n\treturn a/b;\n}\n```\n\n**这样写的缺点：**会污染全局变量，需要保证每个模块之间的名字不冲突，也看不出模块之间的关系。\n\n#### 2. 写在一个对象中\n\n将函数包裹在一个对象中：\n\n```js\nvar math = {\n\t_flag: 0,\n\n\tadd: function(a,b){\n\t\treturn a + b;\n\t},\n\t\n\tdevide: function(a,b){\n\t\treturn a/b;\n\t}\n}\n```\n**这样写的缺点：**这样写虽然将模块放在一起了，但是对象里面的变量会被外部改变。\n\n例如：\n\n```js\nvar math = {\n\t_flag: 0,\n\n\tadd: function(a,b){\n\t\treturn a + b;\n\t},\n\t\n\tdevide: function(a,b){\n\t\treturn a/b;\n\t}\n}；\n\nmath._flag = 2;\nconsole.log(math._flag);//2\n```\n#### 3.写在一个自执行函数中\n\n例如：\n\n```js\nvar math = (function(){\n\tvar _flag = 0;\n\t\n\treturn {\n\t\tadd: function(a,b){\n\t\t\treturn a + b;\n\t\t},\n\n\t\tdevide: function(a,b){\n\t\t\treturn a/b;\n\t\t}\n\t}\n\n})();\n\nconsole.log(typeof math);//object\n```\n这样写外部就不会访问到模块内部的私有变量。\n\n放大模式 ———— 给模块添加新的方法、一个模块依赖另一个模块\n\n```js\nvar math = (function(math){\n\tmath.sub = function(a,b){\n\t\treturn a - b;\n\t};\n\n\treturn math;\n})(math);\n```\n\n宽放大模式 ———— 避免传入一个空的模块\n\n```js\nvar math = (function(math){\n\tmath.sub = function(a,b){\n\t\treturn a - b;\n\t};\n\n\treturn math;\n})(window.math||{});\n```\n\n**将模块全局变量名作为参数传入模块 **\n\n很多模块会用同一个符号作为自己的简写，例如：$\n\n```js\nvar math = (function($){\n\t//在模块内部用$代替math\n})(math);\n//将模块math的全局变量名作为参数传入模块\n```\n\n### 二. js模块化编程的规范\n\n- CommonJs：服务器模块的规范，浏览器使用 —— browserify\n- AMD：asynchornous module definition\n- CMD：common module definition\n\n#### 1. browserify\n\nbrowserify是commonJs规范用于**浏览器**的一个工具，实现js的模块与依赖管理。\n\nCommonJs是同步加载模块的，需要等到一个模块加载完毕之后才能使用。\n\n**browserify中规定：**\n\n用`require()`引入模块\n\n用`module.exports`来引出模块\n\n举个栗子：\n\n有两个模块：a和b，在b中引入a\n\n```js\n// a.js\nmodule.exports = function () {\n    console.log('This is a.js');\n};\n\n//b.js\nvar $ = require(\"./a\");\na();\nconsole.log(\"This is b.js\");\n```\n\n**browserify如何使用**\n\n(1)安装browserify\n\n首先要安装npm和nodejs\n\n然后在命令行中输入\n\n    npm install -g browserify //在全局变量中安装browserify\n\n(2)使用browserify\n\n进入到需要运行的js文件的文件夹里，然后执行\n\n    browserify b.js -o bundle.js\n\n编译后生成的bundle.js文件中，所有的js模块都合并在一起了并建立好了依赖关系。\n\n(3)在nodejs里运行编译后的bundle.js\n\n\t进入需要运行的js文件的文件夹\n\t\n\t在命令行中输入：\n\t\n\tnode b.js\n\n(4)在前端页面引用bundle.js\n\n    <script src=\"bundle.js\"></script>\n\n**bondle.js**\n\n```js\n(function e(t,n,r){\n\t\n\t//...自执行函数内容\n\n})({\n\t1:[function(require,module,exports){\n\t\t\n\t\t// a.js\n\t\tmodule.exports = function () {\n\t\t    console.log('This is a.js');\n\t\t};\n\n\t},{}],\n\n\t2:[function(require,module,exports){\n\t\t//b.js\n\t\tvar a = require('./a');\n\t\ta();\n\t\tconsole.log('This is b.js');\n\t},{\"./a\":1}]\n},{},[2]);\n```\nbondle.js是一个自执行函数，这个自执行函数接收3个参数。\n\n**第一个参数**是一个object，它的每一个key都是数字，作为模块的id，每一个数字key对应的值是长度为2的数组。\n\n数组的第一项是一个函数`function(require, module, exports){}`函数里面的内容就是我们写的js代码；\n\n数组的第二项是一个对象，里面放的是该模块依赖的模块，叫做模块map。\n\n例如： b模块依赖a模块，那么b模块的数组的第二项中就是`{\"./a\":1}`\n\n**第二个参数**是一个object,表示本次编译之前被加载进来的来自于其他地方的内容,也是一个模块map。\n\n**第三个参数**是一个数组，定义的是入口模块。\n\n#### 2. AMD规范\n\nCommonJs是**服务器端的**模块规范，由于服务器的模块都是存在服务器上，因此**同步加载模块**不会带来问题，但是如果浏览器端也采用同步加载，当网速很慢时，就会等待很久。因此**浏览器端**需要**异步加载模块**。\n\nAMD的特点是**异步加载**，模块的加载不影响其他代码的运行。\n\n`require.js`是使用AMD规范的一个前端模块化管理工具。\n\n**AMD模块的定义规则：**\n\n    define(id,dependencies,factory)；\n    \n    id指的是模块的名字；\n\t模块名是用正斜杠分割的有意义单词的字符串\n\t1.单词须为驼峰形式，或者\".\"，\"..\"\n\t2.模块名不允许文件扩展名的形式，如“.js”\n\t3.模块名可以为 \"相对的\" 或 \"顶级的\"。如果首字符为“.”或“..”则为相对的模块名\n\t4.顶级的模块名从根命名空间的概念模块解析\n\t5.相对的模块名从 \"require\" 书写和调用的模块解析\n    \n    dependencies是此模块依赖的模块，是一个数组；\n    \n    factory是一个工场方法：表示模块初始化要执行的函数或对象，如果为函数，只被执行一次；如果为对象，此对象应该为模块的输出值。\n\n**模块的加载**\n\n```js\n//require([module],callback)\n//[module]里面是需要加载的模块\n//callback是模块加载完之后需要执行的函数\n\nrequire([\"math\"],function(math){\n\tmath.add(1,3);\n});\n```\n\n#### 3. CMD规范\n\nCMD与CommonJs是兼容的。sea.js是利用CMD规则。\n\n**CMD模块定义规则**\n\ndefine()\n\n**CMD获取模块接口**\n\n```js\nrequire(\"math\",function(){});//同步加载模块\nrequire.async(\"math\",function(){});//异步加载模块\n```\n\n**CMD对外提供接口**\n\nexports\n\n#### 4. AMD和CMD模块规范的区别\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n \n2. CMD 推崇依赖就近，AMD 推崇依赖前置。例如：\n\n```js\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()\n    // 此处略去 100 行\n    var b = require('./b') // 依赖可以就近书写\n    b.doSomething()\n    // ...\n})\n\n// AMD 默认推荐的是\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n    a.doSomething()\n    // 此处略去 100 行\n    b.doSomething()\n    // ...\n})\n```\n\n3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。","source":"_posts/2016-06-03-js模块化编程.md","raw":"---\nlayout: post\ntitle: js模块化编程\ndate: 2016-06-03\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n###  一. 什么是模块？\n\njs本身不是一个模块化语言，随着js的领域越来越大，所做的事情越来越多，我们需要对js代码进行一些模块化组织。\n\n将不同的功能的函数放在一起，组成实现某一特定功能的整体就是一个模块。\n\n模块可以让我们很方便地使用别人的代码。\n\n#### 1. 最原始的写法\n\n例如：\n\n```js\nfunction add(a,b){\n\treturn a + b;\n}\n\nfunction divide(a,b){\n\treturn a/b;\n}\n```\n\n**这样写的缺点：**会污染全局变量，需要保证每个模块之间的名字不冲突，也看不出模块之间的关系。\n\n#### 2. 写在一个对象中\n\n将函数包裹在一个对象中：\n\n```js\nvar math = {\n\t_flag: 0,\n\n\tadd: function(a,b){\n\t\treturn a + b;\n\t},\n\t\n\tdevide: function(a,b){\n\t\treturn a/b;\n\t}\n}\n```\n**这样写的缺点：**这样写虽然将模块放在一起了，但是对象里面的变量会被外部改变。\n\n例如：\n\n```js\nvar math = {\n\t_flag: 0,\n\n\tadd: function(a,b){\n\t\treturn a + b;\n\t},\n\t\n\tdevide: function(a,b){\n\t\treturn a/b;\n\t}\n}；\n\nmath._flag = 2;\nconsole.log(math._flag);//2\n```\n#### 3.写在一个自执行函数中\n\n例如：\n\n```js\nvar math = (function(){\n\tvar _flag = 0;\n\t\n\treturn {\n\t\tadd: function(a,b){\n\t\t\treturn a + b;\n\t\t},\n\n\t\tdevide: function(a,b){\n\t\t\treturn a/b;\n\t\t}\n\t}\n\n})();\n\nconsole.log(typeof math);//object\n```\n这样写外部就不会访问到模块内部的私有变量。\n\n放大模式 ———— 给模块添加新的方法、一个模块依赖另一个模块\n\n```js\nvar math = (function(math){\n\tmath.sub = function(a,b){\n\t\treturn a - b;\n\t};\n\n\treturn math;\n})(math);\n```\n\n宽放大模式 ———— 避免传入一个空的模块\n\n```js\nvar math = (function(math){\n\tmath.sub = function(a,b){\n\t\treturn a - b;\n\t};\n\n\treturn math;\n})(window.math||{});\n```\n\n**将模块全局变量名作为参数传入模块 **\n\n很多模块会用同一个符号作为自己的简写，例如：$\n\n```js\nvar math = (function($){\n\t//在模块内部用$代替math\n})(math);\n//将模块math的全局变量名作为参数传入模块\n```\n\n### 二. js模块化编程的规范\n\n- CommonJs：服务器模块的规范，浏览器使用 —— browserify\n- AMD：asynchornous module definition\n- CMD：common module definition\n\n#### 1. browserify\n\nbrowserify是commonJs规范用于**浏览器**的一个工具，实现js的模块与依赖管理。\n\nCommonJs是同步加载模块的，需要等到一个模块加载完毕之后才能使用。\n\n**browserify中规定：**\n\n用`require()`引入模块\n\n用`module.exports`来引出模块\n\n举个栗子：\n\n有两个模块：a和b，在b中引入a\n\n```js\n// a.js\nmodule.exports = function () {\n    console.log('This is a.js');\n};\n\n//b.js\nvar $ = require(\"./a\");\na();\nconsole.log(\"This is b.js\");\n```\n\n**browserify如何使用**\n\n(1)安装browserify\n\n首先要安装npm和nodejs\n\n然后在命令行中输入\n\n    npm install -g browserify //在全局变量中安装browserify\n\n(2)使用browserify\n\n进入到需要运行的js文件的文件夹里，然后执行\n\n    browserify b.js -o bundle.js\n\n编译后生成的bundle.js文件中，所有的js模块都合并在一起了并建立好了依赖关系。\n\n(3)在nodejs里运行编译后的bundle.js\n\n\t进入需要运行的js文件的文件夹\n\t\n\t在命令行中输入：\n\t\n\tnode b.js\n\n(4)在前端页面引用bundle.js\n\n    <script src=\"bundle.js\"></script>\n\n**bondle.js**\n\n```js\n(function e(t,n,r){\n\t\n\t//...自执行函数内容\n\n})({\n\t1:[function(require,module,exports){\n\t\t\n\t\t// a.js\n\t\tmodule.exports = function () {\n\t\t    console.log('This is a.js');\n\t\t};\n\n\t},{}],\n\n\t2:[function(require,module,exports){\n\t\t//b.js\n\t\tvar a = require('./a');\n\t\ta();\n\t\tconsole.log('This is b.js');\n\t},{\"./a\":1}]\n},{},[2]);\n```\nbondle.js是一个自执行函数，这个自执行函数接收3个参数。\n\n**第一个参数**是一个object，它的每一个key都是数字，作为模块的id，每一个数字key对应的值是长度为2的数组。\n\n数组的第一项是一个函数`function(require, module, exports){}`函数里面的内容就是我们写的js代码；\n\n数组的第二项是一个对象，里面放的是该模块依赖的模块，叫做模块map。\n\n例如： b模块依赖a模块，那么b模块的数组的第二项中就是`{\"./a\":1}`\n\n**第二个参数**是一个object,表示本次编译之前被加载进来的来自于其他地方的内容,也是一个模块map。\n\n**第三个参数**是一个数组，定义的是入口模块。\n\n#### 2. AMD规范\n\nCommonJs是**服务器端的**模块规范，由于服务器的模块都是存在服务器上，因此**同步加载模块**不会带来问题，但是如果浏览器端也采用同步加载，当网速很慢时，就会等待很久。因此**浏览器端**需要**异步加载模块**。\n\nAMD的特点是**异步加载**，模块的加载不影响其他代码的运行。\n\n`require.js`是使用AMD规范的一个前端模块化管理工具。\n\n**AMD模块的定义规则：**\n\n    define(id,dependencies,factory)；\n    \n    id指的是模块的名字；\n\t模块名是用正斜杠分割的有意义单词的字符串\n\t1.单词须为驼峰形式，或者\".\"，\"..\"\n\t2.模块名不允许文件扩展名的形式，如“.js”\n\t3.模块名可以为 \"相对的\" 或 \"顶级的\"。如果首字符为“.”或“..”则为相对的模块名\n\t4.顶级的模块名从根命名空间的概念模块解析\n\t5.相对的模块名从 \"require\" 书写和调用的模块解析\n    \n    dependencies是此模块依赖的模块，是一个数组；\n    \n    factory是一个工场方法：表示模块初始化要执行的函数或对象，如果为函数，只被执行一次；如果为对象，此对象应该为模块的输出值。\n\n**模块的加载**\n\n```js\n//require([module],callback)\n//[module]里面是需要加载的模块\n//callback是模块加载完之后需要执行的函数\n\nrequire([\"math\"],function(math){\n\tmath.add(1,3);\n});\n```\n\n#### 3. CMD规范\n\nCMD与CommonJs是兼容的。sea.js是利用CMD规则。\n\n**CMD模块定义规则**\n\ndefine()\n\n**CMD获取模块接口**\n\n```js\nrequire(\"math\",function(){});//同步加载模块\nrequire.async(\"math\",function(){});//异步加载模块\n```\n\n**CMD对外提供接口**\n\nexports\n\n#### 4. AMD和CMD模块规范的区别\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n \n2. CMD 推崇依赖就近，AMD 推崇依赖前置。例如：\n\n```js\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()\n    // 此处略去 100 行\n    var b = require('./b') // 依赖可以就近书写\n    b.doSomething()\n    // ...\n})\n\n// AMD 默认推荐的是\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n    a.doSomething()\n    // 此处略去 100 行\n    b.doSomething()\n    // ...\n})\n```\n\n3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。","slug":"2016-06-03-js模块化编程","published":1,"updated":"2016-06-04T02:45:56.000Z","comments":1,"photos":[],"link":"","_id":"cj035oci0008ed5u8mzoyo64k","content":"<h3 id=\"一-什么是模块？\"><a href=\"#一-什么是模块？\" class=\"headerlink\" title=\"一. 什么是模块？\"></a>一. 什么是模块？</h3><p>js本身不是一个模块化语言，随着js的领域越来越大，所做的事情越来越多，我们需要对js代码进行一些模块化组织。</p>\n<p>将不同的功能的函数放在一起，组成实现某一特定功能的整体就是一个模块。</p>\n<p>模块可以让我们很方便地使用别人的代码。</p>\n<h4 id=\"1-最原始的写法\"><a href=\"#1-最原始的写法\" class=\"headerlink\" title=\"1. 最原始的写法\"></a>1. 最原始的写法</h4><p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divide</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>这样写的缺点：</strong>会污染全局变量，需要保证每个模块之间的名字不冲突，也看不出模块之间的关系。</p>\n<h4 id=\"2-写在一个对象中\"><a href=\"#2-写在一个对象中\" class=\"headerlink\" title=\"2. 写在一个对象中\"></a>2. 写在一个对象中</h4><p>将函数包裹在一个对象中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = &#123;</span><br><span class=\"line\">\t_flag: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\tadd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdevide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>这样写的缺点：</strong>这样写虽然将模块放在一起了，但是对象里面的变量会被外部改变。</p>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = &#123;</span><br><span class=\"line\">\t_flag: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\tadd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdevide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;；</span><br><span class=\"line\"></span><br><span class=\"line\">math._flag = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(math._flag);<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-写在一个自执行函数中\"><a href=\"#3-写在一个自执行函数中\" class=\"headerlink\" title=\"3.写在一个自执行函数中\"></a>3.写在一个自执行函数中</h4><p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> _flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tadd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdevide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> math);<span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n<p>这样写外部就不会访问到模块内部的私有变量。</p>\n<p>放大模式 ———— 给模块添加新的方法、一个模块依赖另一个模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>)</span>&#123;</span><br><span class=\"line\">\tmath.sub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math;</span><br><span class=\"line\">&#125;)(math);</span><br></pre></td></tr></table></figure>\n<p>宽放大模式 ———— 避免传入一个空的模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>)</span>&#123;</span><br><span class=\"line\">\tmath.sub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>.math||&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>将模块全局变量名作为参数传入模块 </strong></p>\n<p>很多模块会用同一个符号作为自己的简写，例如：$</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//在模块内部用$代替math</span></span><br><span class=\"line\">&#125;)(math);</span><br><span class=\"line\"><span class=\"comment\">//将模块math的全局变量名作为参数传入模块</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-js模块化编程的规范\"><a href=\"#二-js模块化编程的规范\" class=\"headerlink\" title=\"二. js模块化编程的规范\"></a>二. js模块化编程的规范</h3><ul>\n<li>CommonJs：服务器模块的规范，浏览器使用 —— browserify</li>\n<li>AMD：asynchornous module definition</li>\n<li>CMD：common module definition</li>\n</ul>\n<h4 id=\"1-browserify\"><a href=\"#1-browserify\" class=\"headerlink\" title=\"1. browserify\"></a>1. browserify</h4><p>browserify是commonJs规范用于<strong>浏览器</strong>的一个工具，实现js的模块与依赖管理。</p>\n<p>CommonJs是同步加载模块的，需要等到一个模块加载完毕之后才能使用。</p>\n<p><strong>browserify中规定：</strong></p>\n<p>用<code>require()</code>引入模块</p>\n<p>用<code>module.exports</code>来引出模块</p>\n<p>举个栗子：</p>\n<p>有两个模块：a和b，在b中引入a</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is a.js'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//b.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>);</span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"This is b.js\"</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>browserify如何使用</strong></p>\n<p>(1)安装browserify</p>\n<p>首先要安装npm和nodejs</p>\n<p>然后在命令行中输入</p>\n<pre><code>npm install -g browserify //在全局变量中安装browserify\n</code></pre><p>(2)使用browserify</p>\n<p>进入到需要运行的js文件的文件夹里，然后执行</p>\n<pre><code>browserify b.js -o bundle.js\n</code></pre><p>编译后生成的bundle.js文件中，所有的js模块都合并在一起了并建立好了依赖关系。</p>\n<p>(3)在nodejs里运行编译后的bundle.js</p>\n<pre><code>进入需要运行的js文件的文件夹\n\n在命令行中输入：\n\nnode b.js\n</code></pre><p>(4)在前端页面引用bundle.js</p>\n<pre><code>&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n</code></pre><p><strong>bondle.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\">t,n,r</span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//...自执行函数内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,module,exports</span>)</span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// a.js</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is a.js'</span>);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;,&#123;&#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"number\">2</span>:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,module,exports</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//b.js</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</span><br><span class=\"line\">\t\ta();</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'This is b.js'</span>);</span><br><span class=\"line\">\t&#125;,&#123;<span class=\"string\">\"./a\"</span>:<span class=\"number\">1</span>&#125;]</span><br><span class=\"line\">&#125;,&#123;&#125;,[<span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n<p>bondle.js是一个自执行函数，这个自执行函数接收3个参数。</p>\n<p><strong>第一个参数</strong>是一个object，它的每一个key都是数字，作为模块的id，每一个数字key对应的值是长度为2的数组。</p>\n<p>数组的第一项是一个函数<code>function(require, module, exports){}</code>函数里面的内容就是我们写的js代码；</p>\n<p>数组的第二项是一个对象，里面放的是该模块依赖的模块，叫做模块map。</p>\n<p>例如： b模块依赖a模块，那么b模块的数组的第二项中就是<code>{&quot;./a&quot;:1}</code></p>\n<p><strong>第二个参数</strong>是一个object,表示本次编译之前被加载进来的来自于其他地方的内容,也是一个模块map。</p>\n<p><strong>第三个参数</strong>是一个数组，定义的是入口模块。</p>\n<h4 id=\"2-AMD规范\"><a href=\"#2-AMD规范\" class=\"headerlink\" title=\"2. AMD规范\"></a>2. AMD规范</h4><p>CommonJs是<strong>服务器端的</strong>模块规范，由于服务器的模块都是存在服务器上，因此<strong>同步加载模块</strong>不会带来问题，但是如果浏览器端也采用同步加载，当网速很慢时，就会等待很久。因此<strong>浏览器端</strong>需要<strong>异步加载模块</strong>。</p>\n<p>AMD的特点是<strong>异步加载</strong>，模块的加载不影响其他代码的运行。</p>\n<p><code>require.js</code>是使用AMD规范的一个前端模块化管理工具。</p>\n<p><strong>AMD模块的定义规则：</strong></p>\n<pre><code>define(id,dependencies,factory)；\n\nid指的是模块的名字；\n模块名是用正斜杠分割的有意义单词的字符串\n1.单词须为驼峰形式，或者&quot;.&quot;，&quot;..&quot;\n2.模块名不允许文件扩展名的形式，如“.js”\n3.模块名可以为 &quot;相对的&quot; 或 &quot;顶级的&quot;。如果首字符为“.”或“..”则为相对的模块名\n4.顶级的模块名从根命名空间的概念模块解析\n5.相对的模块名从 &quot;require&quot; 书写和调用的模块解析\n\ndependencies是此模块依赖的模块，是一个数组；\n\nfactory是一个工场方法：表示模块初始化要执行的函数或对象，如果为函数，只被执行一次；如果为对象，此对象应该为模块的输出值。\n</code></pre><p><strong>模块的加载</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//require([module],callback)</span></span><br><span class=\"line\"><span class=\"comment\">//[module]里面是需要加载的模块</span></span><br><span class=\"line\"><span class=\"comment\">//callback是模块加载完之后需要执行的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"math\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>)</span>&#123;</span><br><span class=\"line\">\tmath.add(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-CMD规范\"><a href=\"#3-CMD规范\" class=\"headerlink\" title=\"3. CMD规范\"></a>3. CMD规范</h4><p>CMD与CommonJs是兼容的。sea.js是利用CMD规则。</p>\n<p><strong>CMD模块定义规则</strong></p>\n<p>define()</p>\n<p><strong>CMD获取模块接口</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"math\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);<span class=\"comment\">//同步加载模块</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>.async(<span class=\"string\">\"math\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);<span class=\"comment\">//异步加载模块</span></span><br></pre></td></tr></table></figure>\n<p><strong>CMD对外提供接口</strong></p>\n<p>exports</p>\n<h4 id=\"4-AMD和CMD模块规范的区别\"><a href=\"#4-AMD和CMD模块规范的区别\" class=\"headerlink\" title=\"4. AMD和CMD模块规范的区别\"></a>4. AMD和CMD模块规范的区别</h4><ol>\n<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置。例如：</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖可以就近书写</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AMD 默认推荐的是</span></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123; <span class=\"comment\">// 依赖必须一开始就写好</span></span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"一-什么是模块？\"><a href=\"#一-什么是模块？\" class=\"headerlink\" title=\"一. 什么是模块？\"></a>一. 什么是模块？</h3><p>js本身不是一个模块化语言，随着js的领域越来越大，所做的事情越来越多，我们需要对js代码进行一些模块化组织。</p>\n<p>将不同的功能的函数放在一起，组成实现某一特定功能的整体就是一个模块。</p>\n<p>模块可以让我们很方便地使用别人的代码。</p>\n<h4 id=\"1-最原始的写法\"><a href=\"#1-最原始的写法\" class=\"headerlink\" title=\"1. 最原始的写法\"></a>1. 最原始的写法</h4><p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divide</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>这样写的缺点：</strong>会污染全局变量，需要保证每个模块之间的名字不冲突，也看不出模块之间的关系。</p>\n<h4 id=\"2-写在一个对象中\"><a href=\"#2-写在一个对象中\" class=\"headerlink\" title=\"2. 写在一个对象中\"></a>2. 写在一个对象中</h4><p>将函数包裹在一个对象中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = &#123;</span><br><span class=\"line\">\t_flag: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\tadd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdevide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>这样写的缺点：</strong>这样写虽然将模块放在一起了，但是对象里面的变量会被外部改变。</p>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = &#123;</span><br><span class=\"line\">\t_flag: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\tadd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdevide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;；</span><br><span class=\"line\"></span><br><span class=\"line\">math._flag = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(math._flag);<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-写在一个自执行函数中\"><a href=\"#3-写在一个自执行函数中\" class=\"headerlink\" title=\"3.写在一个自执行函数中\"></a>3.写在一个自执行函数中</h4><p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> _flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tadd: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdevide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> math);<span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n<p>这样写外部就不会访问到模块内部的私有变量。</p>\n<p>放大模式 ———— 给模块添加新的方法、一个模块依赖另一个模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>)</span>&#123;</span><br><span class=\"line\">\tmath.sub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math;</span><br><span class=\"line\">&#125;)(math);</span><br></pre></td></tr></table></figure>\n<p>宽放大模式 ———— 避免传入一个空的模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>)</span>&#123;</span><br><span class=\"line\">\tmath.sub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>.math||&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>将模块全局变量名作为参数传入模块 </strong></p>\n<p>很多模块会用同一个符号作为自己的简写，例如：$</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//在模块内部用$代替math</span></span><br><span class=\"line\">&#125;)(math);</span><br><span class=\"line\"><span class=\"comment\">//将模块math的全局变量名作为参数传入模块</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-js模块化编程的规范\"><a href=\"#二-js模块化编程的规范\" class=\"headerlink\" title=\"二. js模块化编程的规范\"></a>二. js模块化编程的规范</h3><ul>\n<li>CommonJs：服务器模块的规范，浏览器使用 —— browserify</li>\n<li>AMD：asynchornous module definition</li>\n<li>CMD：common module definition</li>\n</ul>\n<h4 id=\"1-browserify\"><a href=\"#1-browserify\" class=\"headerlink\" title=\"1. browserify\"></a>1. browserify</h4><p>browserify是commonJs规范用于<strong>浏览器</strong>的一个工具，实现js的模块与依赖管理。</p>\n<p>CommonJs是同步加载模块的，需要等到一个模块加载完毕之后才能使用。</p>\n<p><strong>browserify中规定：</strong></p>\n<p>用<code>require()</code>引入模块</p>\n<p>用<code>module.exports</code>来引出模块</p>\n<p>举个栗子：</p>\n<p>有两个模块：a和b，在b中引入a</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is a.js'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//b.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>);</span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"This is b.js\"</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>browserify如何使用</strong></p>\n<p>(1)安装browserify</p>\n<p>首先要安装npm和nodejs</p>\n<p>然后在命令行中输入</p>\n<pre><code>npm install -g browserify //在全局变量中安装browserify\n</code></pre><p>(2)使用browserify</p>\n<p>进入到需要运行的js文件的文件夹里，然后执行</p>\n<pre><code>browserify b.js -o bundle.js\n</code></pre><p>编译后生成的bundle.js文件中，所有的js模块都合并在一起了并建立好了依赖关系。</p>\n<p>(3)在nodejs里运行编译后的bundle.js</p>\n<pre><code>进入需要运行的js文件的文件夹\n\n在命令行中输入：\n\nnode b.js\n</code></pre><p>(4)在前端页面引用bundle.js</p>\n<pre><code>&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n</code></pre><p><strong>bondle.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\">t,n,r</span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//...自执行函数内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,module,exports</span>)</span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// a.js</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is a.js'</span>);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;,&#123;&#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"number\">2</span>:[<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,module,exports</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//b.js</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</span><br><span class=\"line\">\t\ta();</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'This is b.js'</span>);</span><br><span class=\"line\">\t&#125;,&#123;<span class=\"string\">\"./a\"</span>:<span class=\"number\">1</span>&#125;]</span><br><span class=\"line\">&#125;,&#123;&#125;,[<span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n<p>bondle.js是一个自执行函数，这个自执行函数接收3个参数。</p>\n<p><strong>第一个参数</strong>是一个object，它的每一个key都是数字，作为模块的id，每一个数字key对应的值是长度为2的数组。</p>\n<p>数组的第一项是一个函数<code>function(require, module, exports){}</code>函数里面的内容就是我们写的js代码；</p>\n<p>数组的第二项是一个对象，里面放的是该模块依赖的模块，叫做模块map。</p>\n<p>例如： b模块依赖a模块，那么b模块的数组的第二项中就是<code>{&quot;./a&quot;:1}</code></p>\n<p><strong>第二个参数</strong>是一个object,表示本次编译之前被加载进来的来自于其他地方的内容,也是一个模块map。</p>\n<p><strong>第三个参数</strong>是一个数组，定义的是入口模块。</p>\n<h4 id=\"2-AMD规范\"><a href=\"#2-AMD规范\" class=\"headerlink\" title=\"2. AMD规范\"></a>2. AMD规范</h4><p>CommonJs是<strong>服务器端的</strong>模块规范，由于服务器的模块都是存在服务器上，因此<strong>同步加载模块</strong>不会带来问题，但是如果浏览器端也采用同步加载，当网速很慢时，就会等待很久。因此<strong>浏览器端</strong>需要<strong>异步加载模块</strong>。</p>\n<p>AMD的特点是<strong>异步加载</strong>，模块的加载不影响其他代码的运行。</p>\n<p><code>require.js</code>是使用AMD规范的一个前端模块化管理工具。</p>\n<p><strong>AMD模块的定义规则：</strong></p>\n<pre><code>define(id,dependencies,factory)；\n\nid指的是模块的名字；\n模块名是用正斜杠分割的有意义单词的字符串\n1.单词须为驼峰形式，或者&quot;.&quot;，&quot;..&quot;\n2.模块名不允许文件扩展名的形式，如“.js”\n3.模块名可以为 &quot;相对的&quot; 或 &quot;顶级的&quot;。如果首字符为“.”或“..”则为相对的模块名\n4.顶级的模块名从根命名空间的概念模块解析\n5.相对的模块名从 &quot;require&quot; 书写和调用的模块解析\n\ndependencies是此模块依赖的模块，是一个数组；\n\nfactory是一个工场方法：表示模块初始化要执行的函数或对象，如果为函数，只被执行一次；如果为对象，此对象应该为模块的输出值。\n</code></pre><p><strong>模块的加载</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//require([module],callback)</span></span><br><span class=\"line\"><span class=\"comment\">//[module]里面是需要加载的模块</span></span><br><span class=\"line\"><span class=\"comment\">//callback是模块加载完之后需要执行的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"math\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">math</span>)</span>&#123;</span><br><span class=\"line\">\tmath.add(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-CMD规范\"><a href=\"#3-CMD规范\" class=\"headerlink\" title=\"3. CMD规范\"></a>3. CMD规范</h4><p>CMD与CommonJs是兼容的。sea.js是利用CMD规则。</p>\n<p><strong>CMD模块定义规则</strong></p>\n<p>define()</p>\n<p><strong>CMD获取模块接口</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"math\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);<span class=\"comment\">//同步加载模块</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>.async(<span class=\"string\">\"math\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);<span class=\"comment\">//异步加载模块</span></span><br></pre></td></tr></table></figure>\n<p><strong>CMD对外提供接口</strong></p>\n<p>exports</p>\n<h4 id=\"4-AMD和CMD模块规范的区别\"><a href=\"#4-AMD和CMD模块规范的区别\" class=\"headerlink\" title=\"4. AMD和CMD模块规范的区别\"></a>4. AMD和CMD模块规范的区别</h4><ol>\n<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置。例如：</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖可以就近书写</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AMD 默认推荐的是</span></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123; <span class=\"comment\">// 依赖必须一开始就写好</span></span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</li>\n</ol>\n"},{"layout":"post","title":"HTML5中的元素的拖放","date":"2016-06-06T16:00:00.000Z","description":null,"_content":"\n### 一. 拖放过程中所涉及到的事件\n\n- 针对被拖放的元素：dragstart、drag、dragend\n\n\tdragstart事件：按下鼠标键并开始移动时触发\n\tdrag事件：元素在被拖动过程中一直触发\n\tdragend事件：拖动停止时触发\n\n- 针对放置目标：dragenter、dragover、dragleave/drop\n\n\tdragenter事件：有元素被拖动到放置目标上触发\n\tdragover：被拖动的元素在放置目标范围内移动\n\tdragleave：元素被拖出放置目标时触发\n\tdrop：元素被放到放置目标内时触发\n\n### 二. 将一个元素变成可以拖放的元素\n\n设置元素的属性draggable为true\n\n### 三. 将一个元素变成拖放的目标元素\n\ndragenter、dragover事件的默认行为是不允许元素成为被放置的元素\n\n因此为了让一个元素成为放置目标，需要阻止这个两个事件的默认行为\n\n```js\n    //获得拖放的目标元素\n\tvar target = document.getElementById(\"trash\");\n\t//关闭默认处理；\n\ttarget.ondragenter = function(event){\n\t\tevent.preventDefault();//阻止默认事件的默认行为\n\t}\n\ttarget.ondragover = function(event){\n\t\tevent.preventDefault(); \n\t}\n```\n\n### 四. 拖放元素的数据交换\n\n实现拖放的原理就是，删除原来的元素，在目标元素里添加这个元素\n\n因此需要使用id获取这个被拖放的元素\n\n**数据交换dataTransfer**\n\ndataTransfer对象是事件对象event的属性\n\ndataTransfer对象有两个方法：\n\n- setData(\"数据保存类型\"，\"保存的值\")\n- getData(\"数据保存类型\")\n\ndataTransfer对象有两个属性：\n\n- dropEffect：被拖动的元素能够执行哪种放置行为\n- effectAllowed：被拖动的元素允许哪种dropEffect\n\n### 五. 举个栗子\n\neg:\n\n```js\n<!DOCTYPE HTML>\n<html>\n\t<head>\n\t\t<title>HTML5实现拖拽操作</title>\n\t\t<meta charset=\"utf-8\"/>\n\t\t<style>\n\t\t\t.album {\n\t\t\t\tborder: 3px dashed #ccc;\n\t\t\t\tfloat: left;\n\t\t\t\tmargin: 10px;\n\t\t\t\tmin-height: 400px;\n\t\t\t\tpadding: 10px;\n\t\t\t\twidth: 220px;\n\t\t\t}\n\t\t\t.dragImg {\n\t\t\t\twidth: 200px;\n\t\t\t\theight: 200px;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div id=\"info\">\n\t\t\t<h2>温馨提示：可将照片直接拖到垃圾箱中</h2>\n\t\t</div>\n\t\t<div id=\"album\" class=\"album\">\n\t\t\t<h2>相册</h2>\n\t\t\t<img draggable=\"true\" class=\"dragImg\" id=\"img1\" src=\"img/img1.jpg\" />\n\t\t\t<img draggable=\"true\" class=\"dragImg\" id=\"img2\" src=\"img/img1.jpg\" />\n\t\t\t<img draggable=\"true\" class=\"dragImg\" id=\"img3\" src=\"img/img1.jpg\" />\n\t\t</div>\n\t\t<div id=\"trash\" class=\"album\">\n\t\t\t<h2>垃圾箱</h2>\n\t\t</div>\n\n\t\t<script>\n\t\t\tfunction init() {\n\t\t\t\tvar info = document.getElementById(\"info\");\n\t\t\t\t//获得被拖放的元素，本示例为相册所在的DIV\n\t\t\t\tvar src = document.getElementById(\"album\");\n\t\t\t\t//开始拖放操作\n\t\t\t\tsrc.ondragstart = function (e) {\n\t\t\t\t\t//获得被拖放的照片ID\n\t\t\t\t\tvar dragImgId = e.target.id;\n\t\t\t\t\t//获得被拖动元素\n\t\t\t\t\tvar dragImg = document.getElementById(dragImgId);\n\t\t\t\t\t//拖放操作结束\n\t\t\t\t\tdragImg.ondragend = function(e){\n\t\t\t\t\t\t//恢复提醒信息\n\t\t\t\t\t\tinfo.innerHTML=\"<h2>温馨提示：可将照片直接拖到垃圾箱中</h2>\";\n\t\t\t\t\t};\n\t\t\t\t\te.dataTransfer.setData(\"text\",dragImgId);//将拖动的元素的id保存下来\n\t\t\t\t};\n\n\t\t\t\t//拖放过程中\n\t\t\t\tsrc.ondrag = function(e){ \n\t\t\t\t\tinfo.innerHTML=\"<h2>--照片正在被拖动--</h2>\";\n\t\t\t\t}\n\n\t\t\t\t//获得拖放的目标元素\n\t\t\t\tvar target = document.getElementById(\"trash\");\n\t\t\t\t//关闭默认处理；\n\t\t\t\ttarget.ondragenter = function(e){\n\t\t\t\t\te.preventDefault();//阻止默认事件.比如当你点击带有href值的a标签时,元素响应click事件后,还会发生页面跳转.如果加上这个方法(属性)后,浏览器只会响应click事件,不会发生跳转.\n\t\t\t\t}\n\t\t\t\ttarget.ondragover = function(e){\n\t\t\t\t\te.preventDefault(); \n\t\t\t\t}\n\t\t\t\t//有东西拖放到了目标元素\n\t\t\t\ttarget.ondrop = function (e) {\n\t\t\t\t\tvar draggedID = e.dataTransfer.getData(\"text\");\n\t\t\t\t\t//获取相册中的DOM对象\n\t\t\t\t\tvar oldElem = document.getElementById(draggedID);\n\t\t\t\t\t//从相册DIV中删除该照片的节点\n\t\t\t\t\toldElem.parentNode.removeChild(oldElem);\n\t\t\t\t\t//将被拖动的照片DOM节点添加到垃圾桶DIV中；\n\t\t\t\t\ttarget.appendChild(oldElem);\n\t\t\t\t\tinfo.innerHTML=\"<h2>温馨提示：可将照片直接拖到垃圾箱中</h2>\";\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t\tinit();\n\t\t</script>\n</body>\n</html>\n```","source":"_posts/2016-06-07-HTML5中的元素的拖放.md","raw":"---\nlayout: post\ntitle: HTML5中的元素的拖放\ndate: 2016-06-07\ncategories: HTML\ntags: [HTML5]\ndescription: \n---\n\n### 一. 拖放过程中所涉及到的事件\n\n- 针对被拖放的元素：dragstart、drag、dragend\n\n\tdragstart事件：按下鼠标键并开始移动时触发\n\tdrag事件：元素在被拖动过程中一直触发\n\tdragend事件：拖动停止时触发\n\n- 针对放置目标：dragenter、dragover、dragleave/drop\n\n\tdragenter事件：有元素被拖动到放置目标上触发\n\tdragover：被拖动的元素在放置目标范围内移动\n\tdragleave：元素被拖出放置目标时触发\n\tdrop：元素被放到放置目标内时触发\n\n### 二. 将一个元素变成可以拖放的元素\n\n设置元素的属性draggable为true\n\n### 三. 将一个元素变成拖放的目标元素\n\ndragenter、dragover事件的默认行为是不允许元素成为被放置的元素\n\n因此为了让一个元素成为放置目标，需要阻止这个两个事件的默认行为\n\n```js\n    //获得拖放的目标元素\n\tvar target = document.getElementById(\"trash\");\n\t//关闭默认处理；\n\ttarget.ondragenter = function(event){\n\t\tevent.preventDefault();//阻止默认事件的默认行为\n\t}\n\ttarget.ondragover = function(event){\n\t\tevent.preventDefault(); \n\t}\n```\n\n### 四. 拖放元素的数据交换\n\n实现拖放的原理就是，删除原来的元素，在目标元素里添加这个元素\n\n因此需要使用id获取这个被拖放的元素\n\n**数据交换dataTransfer**\n\ndataTransfer对象是事件对象event的属性\n\ndataTransfer对象有两个方法：\n\n- setData(\"数据保存类型\"，\"保存的值\")\n- getData(\"数据保存类型\")\n\ndataTransfer对象有两个属性：\n\n- dropEffect：被拖动的元素能够执行哪种放置行为\n- effectAllowed：被拖动的元素允许哪种dropEffect\n\n### 五. 举个栗子\n\neg:\n\n```js\n<!DOCTYPE HTML>\n<html>\n\t<head>\n\t\t<title>HTML5实现拖拽操作</title>\n\t\t<meta charset=\"utf-8\"/>\n\t\t<style>\n\t\t\t.album {\n\t\t\t\tborder: 3px dashed #ccc;\n\t\t\t\tfloat: left;\n\t\t\t\tmargin: 10px;\n\t\t\t\tmin-height: 400px;\n\t\t\t\tpadding: 10px;\n\t\t\t\twidth: 220px;\n\t\t\t}\n\t\t\t.dragImg {\n\t\t\t\twidth: 200px;\n\t\t\t\theight: 200px;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div id=\"info\">\n\t\t\t<h2>温馨提示：可将照片直接拖到垃圾箱中</h2>\n\t\t</div>\n\t\t<div id=\"album\" class=\"album\">\n\t\t\t<h2>相册</h2>\n\t\t\t<img draggable=\"true\" class=\"dragImg\" id=\"img1\" src=\"img/img1.jpg\" />\n\t\t\t<img draggable=\"true\" class=\"dragImg\" id=\"img2\" src=\"img/img1.jpg\" />\n\t\t\t<img draggable=\"true\" class=\"dragImg\" id=\"img3\" src=\"img/img1.jpg\" />\n\t\t</div>\n\t\t<div id=\"trash\" class=\"album\">\n\t\t\t<h2>垃圾箱</h2>\n\t\t</div>\n\n\t\t<script>\n\t\t\tfunction init() {\n\t\t\t\tvar info = document.getElementById(\"info\");\n\t\t\t\t//获得被拖放的元素，本示例为相册所在的DIV\n\t\t\t\tvar src = document.getElementById(\"album\");\n\t\t\t\t//开始拖放操作\n\t\t\t\tsrc.ondragstart = function (e) {\n\t\t\t\t\t//获得被拖放的照片ID\n\t\t\t\t\tvar dragImgId = e.target.id;\n\t\t\t\t\t//获得被拖动元素\n\t\t\t\t\tvar dragImg = document.getElementById(dragImgId);\n\t\t\t\t\t//拖放操作结束\n\t\t\t\t\tdragImg.ondragend = function(e){\n\t\t\t\t\t\t//恢复提醒信息\n\t\t\t\t\t\tinfo.innerHTML=\"<h2>温馨提示：可将照片直接拖到垃圾箱中</h2>\";\n\t\t\t\t\t};\n\t\t\t\t\te.dataTransfer.setData(\"text\",dragImgId);//将拖动的元素的id保存下来\n\t\t\t\t};\n\n\t\t\t\t//拖放过程中\n\t\t\t\tsrc.ondrag = function(e){ \n\t\t\t\t\tinfo.innerHTML=\"<h2>--照片正在被拖动--</h2>\";\n\t\t\t\t}\n\n\t\t\t\t//获得拖放的目标元素\n\t\t\t\tvar target = document.getElementById(\"trash\");\n\t\t\t\t//关闭默认处理；\n\t\t\t\ttarget.ondragenter = function(e){\n\t\t\t\t\te.preventDefault();//阻止默认事件.比如当你点击带有href值的a标签时,元素响应click事件后,还会发生页面跳转.如果加上这个方法(属性)后,浏览器只会响应click事件,不会发生跳转.\n\t\t\t\t}\n\t\t\t\ttarget.ondragover = function(e){\n\t\t\t\t\te.preventDefault(); \n\t\t\t\t}\n\t\t\t\t//有东西拖放到了目标元素\n\t\t\t\ttarget.ondrop = function (e) {\n\t\t\t\t\tvar draggedID = e.dataTransfer.getData(\"text\");\n\t\t\t\t\t//获取相册中的DOM对象\n\t\t\t\t\tvar oldElem = document.getElementById(draggedID);\n\t\t\t\t\t//从相册DIV中删除该照片的节点\n\t\t\t\t\toldElem.parentNode.removeChild(oldElem);\n\t\t\t\t\t//将被拖动的照片DOM节点添加到垃圾桶DIV中；\n\t\t\t\t\ttarget.appendChild(oldElem);\n\t\t\t\t\tinfo.innerHTML=\"<h2>温馨提示：可将照片直接拖到垃圾箱中</h2>\";\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t\tinit();\n\t\t</script>\n</body>\n</html>\n```","slug":"2016-06-07-HTML5中的元素的拖放","published":1,"updated":"2016-06-07T02:19:08.000Z","comments":1,"photos":[],"link":"","_id":"cj035oci1008id5u8xtsrkexg","content":"<h3 id=\"一-拖放过程中所涉及到的事件\"><a href=\"#一-拖放过程中所涉及到的事件\" class=\"headerlink\" title=\"一. 拖放过程中所涉及到的事件\"></a>一. 拖放过程中所涉及到的事件</h3><ul>\n<li><p>针对被拖放的元素：dragstart、drag、dragend</p>\n<p>  dragstart事件：按下鼠标键并开始移动时触发<br>  drag事件：元素在被拖动过程中一直触发<br>  dragend事件：拖动停止时触发</p>\n</li>\n<li><p>针对放置目标：dragenter、dragover、dragleave/drop</p>\n<p>  dragenter事件：有元素被拖动到放置目标上触发<br>  dragover：被拖动的元素在放置目标范围内移动<br>  dragleave：元素被拖出放置目标时触发<br>  drop：元素被放到放置目标内时触发</p>\n</li>\n</ul>\n<h3 id=\"二-将一个元素变成可以拖放的元素\"><a href=\"#二-将一个元素变成可以拖放的元素\" class=\"headerlink\" title=\"二. 将一个元素变成可以拖放的元素\"></a>二. 将一个元素变成可以拖放的元素</h3><p>设置元素的属性draggable为true</p>\n<h3 id=\"三-将一个元素变成拖放的目标元素\"><a href=\"#三-将一个元素变成拖放的目标元素\" class=\"headerlink\" title=\"三. 将一个元素变成拖放的目标元素\"></a>三. 将一个元素变成拖放的目标元素</h3><p>dragenter、dragover事件的默认行为是不允许元素成为被放置的元素</p>\n<p>因此为了让一个元素成为放置目标，需要阻止这个两个事件的默认行为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//获得拖放的目标元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> target = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"trash\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//关闭默认处理；</span></span><br><span class=\"line\">target.ondragenter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\tevent.preventDefault();<span class=\"comment\">//阻止默认事件的默认行为</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">target.ondragover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\tevent.preventDefault(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-拖放元素的数据交换\"><a href=\"#四-拖放元素的数据交换\" class=\"headerlink\" title=\"四. 拖放元素的数据交换\"></a>四. 拖放元素的数据交换</h3><p>实现拖放的原理就是，删除原来的元素，在目标元素里添加这个元素</p>\n<p>因此需要使用id获取这个被拖放的元素</p>\n<p><strong>数据交换dataTransfer</strong></p>\n<p>dataTransfer对象是事件对象event的属性</p>\n<p>dataTransfer对象有两个方法：</p>\n<ul>\n<li>setData(“数据保存类型”，”保存的值”)</li>\n<li>getData(“数据保存类型”)</li>\n</ul>\n<p>dataTransfer对象有两个属性：</p>\n<ul>\n<li>dropEffect：被拖动的元素能够执行哪种放置行为</li>\n<li>effectAllowed：被拖动的元素允许哪种dropEffect</li>\n</ul>\n<h3 id=\"五-举个栗子\"><a href=\"#五-举个栗子\" class=\"headerlink\" title=\"五. 举个栗子\"></a>五. 举个栗子</h3><p>eg:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;HTML5实现拖拽操作&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=\"utf-8\"/&gt;</span><br><span class=\"line\">\t\t&lt;style&gt;</span><br><span class=\"line\">\t\t\t.album &#123;</span><br><span class=\"line\">\t\t\t\tborder: 3px dashed #ccc;</span><br><span class=\"line\">\t\t\t\tfloat: left;</span><br><span class=\"line\">\t\t\t\tmargin: 10px;</span><br><span class=\"line\">\t\t\t\tmin-height: 400px;</span><br><span class=\"line\">\t\t\t\tpadding: 10px;</span><br><span class=\"line\">\t\t\t\twidth: 220px;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t.dragImg &#123;</span><br><span class=\"line\">\t\t\t\twidth: 200px;</span><br><span class=\"line\">\t\t\t\theight: 200px;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&lt;/style&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;div id=\"info\"&gt;</span><br><span class=\"line\">\t\t\t&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;div id=\"album\" class=\"album\"&gt;</span><br><span class=\"line\">\t\t\t&lt;h2&gt;相册&lt;/h2&gt;</span><br><span class=\"line\">\t\t\t&lt;img draggable=\"true\" class=\"dragImg\" id=\"img1\" src=\"img/img1.jpg\" /&gt;</span><br><span class=\"line\">\t\t\t&lt;img draggable=\"true\" class=\"dragImg\" id=\"img2\" src=\"img/img1.jpg\" /&gt;</span><br><span class=\"line\">\t\t\t&lt;img draggable=\"true\" class=\"dragImg\" id=\"img3\" src=\"img/img1.jpg\" /&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;div id=\"trash\" class=\"album\"&gt;</span><br><span class=\"line\">\t\t\t&lt;h2&gt;垃圾箱&lt;/h2&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;script&gt;</span><br><span class=\"line\">\t\t\tfunction init() &#123;</span><br><span class=\"line\">\t\t\t\tvar info = document.getElementById(\"info\");</span><br><span class=\"line\">\t\t\t\t//获得被拖放的元素，本示例为相册所在的DIV</span><br><span class=\"line\">\t\t\t\tvar src = document.getElementById(\"album\");</span><br><span class=\"line\">\t\t\t\t//开始拖放操作</span><br><span class=\"line\">\t\t\t\tsrc.ondragstart = function (e) &#123;</span><br><span class=\"line\">\t\t\t\t\t//获得被拖放的照片ID</span><br><span class=\"line\">\t\t\t\t\tvar dragImgId = e.target.id;</span><br><span class=\"line\">\t\t\t\t\t//获得被拖动元素</span><br><span class=\"line\">\t\t\t\t\tvar dragImg = document.getElementById(dragImgId);</span><br><span class=\"line\">\t\t\t\t\t//拖放操作结束</span><br><span class=\"line\">\t\t\t\t\tdragImg.ondragend = function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t//恢复提醒信息</span><br><span class=\"line\">\t\t\t\t\t\tinfo.innerHTML=\"&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;\";</span><br><span class=\"line\">\t\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t\t\te.dataTransfer.setData(\"text\",dragImgId);//将拖动的元素的id保存下来</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//拖放过程中</span><br><span class=\"line\">\t\t\t\tsrc.ondrag = function(e)&#123; </span><br><span class=\"line\">\t\t\t\t\tinfo.innerHTML=\"&lt;h2&gt;--照片正在被拖动--&lt;/h2&gt;\";</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//获得拖放的目标元素</span><br><span class=\"line\">\t\t\t\tvar target = document.getElementById(\"trash\");</span><br><span class=\"line\">\t\t\t\t//关闭默认处理；</span><br><span class=\"line\">\t\t\t\ttarget.ondragenter = function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\te.preventDefault();//阻止默认事件.比如当你点击带有href值的a标签时,元素响应click事件后,还会发生页面跳转.如果加上这个方法(属性)后,浏览器只会响应click事件,不会发生跳转.</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ttarget.ondragover = function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\te.preventDefault(); </span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t//有东西拖放到了目标元素</span><br><span class=\"line\">\t\t\t\ttarget.ondrop = function (e) &#123;</span><br><span class=\"line\">\t\t\t\t\tvar draggedID = e.dataTransfer.getData(\"text\");</span><br><span class=\"line\">\t\t\t\t\t//获取相册中的DOM对象</span><br><span class=\"line\">\t\t\t\t\tvar oldElem = document.getElementById(draggedID);</span><br><span class=\"line\">\t\t\t\t\t//从相册DIV中删除该照片的节点</span><br><span class=\"line\">\t\t\t\t\toldElem.parentNode.removeChild(oldElem);</span><br><span class=\"line\">\t\t\t\t\t//将被拖动的照片DOM节点添加到垃圾桶DIV中；</span><br><span class=\"line\">\t\t\t\t\ttarget.appendChild(oldElem);</span><br><span class=\"line\">\t\t\t\t\tinfo.innerHTML=\"&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;\";</span><br><span class=\"line\">\t\t\t\t\te.preventDefault();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tinit();</span><br><span class=\"line\">\t\t&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-拖放过程中所涉及到的事件\"><a href=\"#一-拖放过程中所涉及到的事件\" class=\"headerlink\" title=\"一. 拖放过程中所涉及到的事件\"></a>一. 拖放过程中所涉及到的事件</h3><ul>\n<li><p>针对被拖放的元素：dragstart、drag、dragend</p>\n<p>  dragstart事件：按下鼠标键并开始移动时触发<br>  drag事件：元素在被拖动过程中一直触发<br>  dragend事件：拖动停止时触发</p>\n</li>\n<li><p>针对放置目标：dragenter、dragover、dragleave/drop</p>\n<p>  dragenter事件：有元素被拖动到放置目标上触发<br>  dragover：被拖动的元素在放置目标范围内移动<br>  dragleave：元素被拖出放置目标时触发<br>  drop：元素被放到放置目标内时触发</p>\n</li>\n</ul>\n<h3 id=\"二-将一个元素变成可以拖放的元素\"><a href=\"#二-将一个元素变成可以拖放的元素\" class=\"headerlink\" title=\"二. 将一个元素变成可以拖放的元素\"></a>二. 将一个元素变成可以拖放的元素</h3><p>设置元素的属性draggable为true</p>\n<h3 id=\"三-将一个元素变成拖放的目标元素\"><a href=\"#三-将一个元素变成拖放的目标元素\" class=\"headerlink\" title=\"三. 将一个元素变成拖放的目标元素\"></a>三. 将一个元素变成拖放的目标元素</h3><p>dragenter、dragover事件的默认行为是不允许元素成为被放置的元素</p>\n<p>因此为了让一个元素成为放置目标，需要阻止这个两个事件的默认行为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//获得拖放的目标元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> target = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"trash\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//关闭默认处理；</span></span><br><span class=\"line\">target.ondragenter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\tevent.preventDefault();<span class=\"comment\">//阻止默认事件的默认行为</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">target.ondragover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\tevent.preventDefault(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-拖放元素的数据交换\"><a href=\"#四-拖放元素的数据交换\" class=\"headerlink\" title=\"四. 拖放元素的数据交换\"></a>四. 拖放元素的数据交换</h3><p>实现拖放的原理就是，删除原来的元素，在目标元素里添加这个元素</p>\n<p>因此需要使用id获取这个被拖放的元素</p>\n<p><strong>数据交换dataTransfer</strong></p>\n<p>dataTransfer对象是事件对象event的属性</p>\n<p>dataTransfer对象有两个方法：</p>\n<ul>\n<li>setData(“数据保存类型”，”保存的值”)</li>\n<li>getData(“数据保存类型”)</li>\n</ul>\n<p>dataTransfer对象有两个属性：</p>\n<ul>\n<li>dropEffect：被拖动的元素能够执行哪种放置行为</li>\n<li>effectAllowed：被拖动的元素允许哪种dropEffect</li>\n</ul>\n<h3 id=\"五-举个栗子\"><a href=\"#五-举个栗子\" class=\"headerlink\" title=\"五. 举个栗子\"></a>五. 举个栗子</h3><p>eg:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;HTML5实现拖拽操作&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=\"utf-8\"/&gt;</span><br><span class=\"line\">\t\t&lt;style&gt;</span><br><span class=\"line\">\t\t\t.album &#123;</span><br><span class=\"line\">\t\t\t\tborder: 3px dashed #ccc;</span><br><span class=\"line\">\t\t\t\tfloat: left;</span><br><span class=\"line\">\t\t\t\tmargin: 10px;</span><br><span class=\"line\">\t\t\t\tmin-height: 400px;</span><br><span class=\"line\">\t\t\t\tpadding: 10px;</span><br><span class=\"line\">\t\t\t\twidth: 220px;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t.dragImg &#123;</span><br><span class=\"line\">\t\t\t\twidth: 200px;</span><br><span class=\"line\">\t\t\t\theight: 200px;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&lt;/style&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;div id=\"info\"&gt;</span><br><span class=\"line\">\t\t\t&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;div id=\"album\" class=\"album\"&gt;</span><br><span class=\"line\">\t\t\t&lt;h2&gt;相册&lt;/h2&gt;</span><br><span class=\"line\">\t\t\t&lt;img draggable=\"true\" class=\"dragImg\" id=\"img1\" src=\"img/img1.jpg\" /&gt;</span><br><span class=\"line\">\t\t\t&lt;img draggable=\"true\" class=\"dragImg\" id=\"img2\" src=\"img/img1.jpg\" /&gt;</span><br><span class=\"line\">\t\t\t&lt;img draggable=\"true\" class=\"dragImg\" id=\"img3\" src=\"img/img1.jpg\" /&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;div id=\"trash\" class=\"album\"&gt;</span><br><span class=\"line\">\t\t\t&lt;h2&gt;垃圾箱&lt;/h2&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;script&gt;</span><br><span class=\"line\">\t\t\tfunction init() &#123;</span><br><span class=\"line\">\t\t\t\tvar info = document.getElementById(\"info\");</span><br><span class=\"line\">\t\t\t\t//获得被拖放的元素，本示例为相册所在的DIV</span><br><span class=\"line\">\t\t\t\tvar src = document.getElementById(\"album\");</span><br><span class=\"line\">\t\t\t\t//开始拖放操作</span><br><span class=\"line\">\t\t\t\tsrc.ondragstart = function (e) &#123;</span><br><span class=\"line\">\t\t\t\t\t//获得被拖放的照片ID</span><br><span class=\"line\">\t\t\t\t\tvar dragImgId = e.target.id;</span><br><span class=\"line\">\t\t\t\t\t//获得被拖动元素</span><br><span class=\"line\">\t\t\t\t\tvar dragImg = document.getElementById(dragImgId);</span><br><span class=\"line\">\t\t\t\t\t//拖放操作结束</span><br><span class=\"line\">\t\t\t\t\tdragImg.ondragend = function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t//恢复提醒信息</span><br><span class=\"line\">\t\t\t\t\t\tinfo.innerHTML=\"&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;\";</span><br><span class=\"line\">\t\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t\t\te.dataTransfer.setData(\"text\",dragImgId);//将拖动的元素的id保存下来</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//拖放过程中</span><br><span class=\"line\">\t\t\t\tsrc.ondrag = function(e)&#123; </span><br><span class=\"line\">\t\t\t\t\tinfo.innerHTML=\"&lt;h2&gt;--照片正在被拖动--&lt;/h2&gt;\";</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//获得拖放的目标元素</span><br><span class=\"line\">\t\t\t\tvar target = document.getElementById(\"trash\");</span><br><span class=\"line\">\t\t\t\t//关闭默认处理；</span><br><span class=\"line\">\t\t\t\ttarget.ondragenter = function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\te.preventDefault();//阻止默认事件.比如当你点击带有href值的a标签时,元素响应click事件后,还会发生页面跳转.如果加上这个方法(属性)后,浏览器只会响应click事件,不会发生跳转.</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ttarget.ondragover = function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\te.preventDefault(); </span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t//有东西拖放到了目标元素</span><br><span class=\"line\">\t\t\t\ttarget.ondrop = function (e) &#123;</span><br><span class=\"line\">\t\t\t\t\tvar draggedID = e.dataTransfer.getData(\"text\");</span><br><span class=\"line\">\t\t\t\t\t//获取相册中的DOM对象</span><br><span class=\"line\">\t\t\t\t\tvar oldElem = document.getElementById(draggedID);</span><br><span class=\"line\">\t\t\t\t\t//从相册DIV中删除该照片的节点</span><br><span class=\"line\">\t\t\t\t\toldElem.parentNode.removeChild(oldElem);</span><br><span class=\"line\">\t\t\t\t\t//将被拖动的照片DOM节点添加到垃圾桶DIV中；</span><br><span class=\"line\">\t\t\t\t\ttarget.appendChild(oldElem);</span><br><span class=\"line\">\t\t\t\t\tinfo.innerHTML=\"&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;\";</span><br><span class=\"line\">\t\t\t\t\te.preventDefault();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tinit();</span><br><span class=\"line\">\t\t&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"js中获取元素的样式","date":"2016-06-06T16:00:00.000Z","description":null,"_content":"\n### 一. 给HTML中的元素添加样式的方法\n\n- 内嵌样式：通过`style`添加\n- 内联样式：通过写在`html`页面的`<style></style>`添加\n- 外部样式：通过引入一个外部的`css`文件`<link rel=\"stylesheet\" type=\"text/css\" href=\"/my.css\">`\n\n### 二. 针对这三种添加的样式，在js中获取的方法\n\n#### 1. 针对内嵌样式\n\n这个一般用得比较多\n\n先获取到DOM节点，再通过`.style.属性名`获得\n\n```js\nvar myDom = document.getElementById(\"id\");\nconsole.log(myDom.style.width);\n```\n\n#### 2. 针对内联样式和外部样式（计算后的样式）\n\n在ie中：使用`currentStyle.attr`或者`currentStyle[\"attr\"]`\n    \n其他浏览器中：使用`document.defaultView.getComputedStyle(obj,伪类元素).attr`或者`document.defaultView.getComputedStyle(obj,伪类元素)[attr]`\n\n如果不需要伪元素信息，第二个参数为null。\n\n    document.defaultView指的是文档当前关联的window对象：\n    \n    document.defaultView === window;//true\n\n这两个属性都是只读的，不能修改计算后的样式。","source":"_posts/2016-06-07-js中获取元素的样式.md","raw":"---\nlayout: post\ntitle: js中获取元素的样式\ndate: 2016-06-07\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 给HTML中的元素添加样式的方法\n\n- 内嵌样式：通过`style`添加\n- 内联样式：通过写在`html`页面的`<style></style>`添加\n- 外部样式：通过引入一个外部的`css`文件`<link rel=\"stylesheet\" type=\"text/css\" href=\"/my.css\">`\n\n### 二. 针对这三种添加的样式，在js中获取的方法\n\n#### 1. 针对内嵌样式\n\n这个一般用得比较多\n\n先获取到DOM节点，再通过`.style.属性名`获得\n\n```js\nvar myDom = document.getElementById(\"id\");\nconsole.log(myDom.style.width);\n```\n\n#### 2. 针对内联样式和外部样式（计算后的样式）\n\n在ie中：使用`currentStyle.attr`或者`currentStyle[\"attr\"]`\n    \n其他浏览器中：使用`document.defaultView.getComputedStyle(obj,伪类元素).attr`或者`document.defaultView.getComputedStyle(obj,伪类元素)[attr]`\n\n如果不需要伪元素信息，第二个参数为null。\n\n    document.defaultView指的是文档当前关联的window对象：\n    \n    document.defaultView === window;//true\n\n这两个属性都是只读的，不能修改计算后的样式。","slug":"2016-06-07-js中获取元素的样式","published":1,"updated":"2016-06-11T08:46:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035oci4008md5u8abojri34","content":"<h3 id=\"一-给HTML中的元素添加样式的方法\"><a href=\"#一-给HTML中的元素添加样式的方法\" class=\"headerlink\" title=\"一. 给HTML中的元素添加样式的方法\"></a>一. 给HTML中的元素添加样式的方法</h3><ul>\n<li>内嵌样式：通过<code>style</code>添加</li>\n<li>内联样式：通过写在<code>html</code>页面的<code>&lt;style&gt;&lt;/style&gt;</code>添加</li>\n<li>外部样式：通过引入一个外部的<code>css</code>文件<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/my.css&quot;&gt;</code></li>\n</ul>\n<h3 id=\"二-针对这三种添加的样式，在js中获取的方法\"><a href=\"#二-针对这三种添加的样式，在js中获取的方法\" class=\"headerlink\" title=\"二. 针对这三种添加的样式，在js中获取的方法\"></a>二. 针对这三种添加的样式，在js中获取的方法</h3><h4 id=\"1-针对内嵌样式\"><a href=\"#1-针对内嵌样式\" class=\"headerlink\" title=\"1. 针对内嵌样式\"></a>1. 针对内嵌样式</h4><p>这个一般用得比较多</p>\n<p>先获取到DOM节点，再通过<code>.style.属性名</code>获得</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myDom = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myDom.style.width);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-针对内联样式和外部样式（计算后的样式）\"><a href=\"#2-针对内联样式和外部样式（计算后的样式）\" class=\"headerlink\" title=\"2. 针对内联样式和外部样式（计算后的样式）\"></a>2. 针对内联样式和外部样式（计算后的样式）</h4><p>在ie中：使用<code>currentStyle.attr</code>或者<code>currentStyle[&quot;attr&quot;]</code></p>\n<p>其他浏览器中：使用<code>document.defaultView.getComputedStyle(obj,伪类元素).attr</code>或者<code>document.defaultView.getComputedStyle(obj,伪类元素)[attr]</code></p>\n<p>如果不需要伪元素信息，第二个参数为null。</p>\n<pre><code>document.defaultView指的是文档当前关联的window对象：\n\ndocument.defaultView === window;//true\n</code></pre><p>这两个属性都是只读的，不能修改计算后的样式。</p>\n","excerpt":"","more":"<h3 id=\"一-给HTML中的元素添加样式的方法\"><a href=\"#一-给HTML中的元素添加样式的方法\" class=\"headerlink\" title=\"一. 给HTML中的元素添加样式的方法\"></a>一. 给HTML中的元素添加样式的方法</h3><ul>\n<li>内嵌样式：通过<code>style</code>添加</li>\n<li>内联样式：通过写在<code>html</code>页面的<code>&lt;style&gt;&lt;/style&gt;</code>添加</li>\n<li>外部样式：通过引入一个外部的<code>css</code>文件<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/my.css&quot;&gt;</code></li>\n</ul>\n<h3 id=\"二-针对这三种添加的样式，在js中获取的方法\"><a href=\"#二-针对这三种添加的样式，在js中获取的方法\" class=\"headerlink\" title=\"二. 针对这三种添加的样式，在js中获取的方法\"></a>二. 针对这三种添加的样式，在js中获取的方法</h3><h4 id=\"1-针对内嵌样式\"><a href=\"#1-针对内嵌样式\" class=\"headerlink\" title=\"1. 针对内嵌样式\"></a>1. 针对内嵌样式</h4><p>这个一般用得比较多</p>\n<p>先获取到DOM节点，再通过<code>.style.属性名</code>获得</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myDom = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myDom.style.width);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-针对内联样式和外部样式（计算后的样式）\"><a href=\"#2-针对内联样式和外部样式（计算后的样式）\" class=\"headerlink\" title=\"2. 针对内联样式和外部样式（计算后的样式）\"></a>2. 针对内联样式和外部样式（计算后的样式）</h4><p>在ie中：使用<code>currentStyle.attr</code>或者<code>currentStyle[&quot;attr&quot;]</code></p>\n<p>其他浏览器中：使用<code>document.defaultView.getComputedStyle(obj,伪类元素).attr</code>或者<code>document.defaultView.getComputedStyle(obj,伪类元素)[attr]</code></p>\n<p>如果不需要伪元素信息，第二个参数为null。</p>\n<pre><code>document.defaultView指的是文档当前关联的window对象：\n\ndocument.defaultView === window;//true\n</code></pre><p>这两个属性都是只读的，不能修改计算后的样式。</p>\n"},{"layout":"post","title":"事件类型","date":"2016-06-07T16:00:00.000Z","description":null,"_content":"\n### 一. 事件类型\n\n- UI事件\n- 焦点事件\n- 鼠标事件\n- 滚轮事件\n- 文本事件\n- 键盘事件\n- 合成事件\n- 变动事件\n- 变动名称事件\n\n### 二. UI事件\n\nUI事件不一定与用户操作有关\n\n- load：页面完全加载后触发（包括图像、js、css）\n- unload：用户从一个页面切换到另一个页面时触发\n- resize：浏览器窗口宽度、高度改变时触发\n- scroll：浏览器的窗口滑动滚轮时触发\n\n### 三. 焦点事件\n\n页面获得或者失去焦点\n\n- **blur**：元素失去焦点时触发**（不冒泡！！！）**\n- **focus**：元素获得焦点时触发**（不冒泡！！！）**\n- focusin：元素获得焦点时触发\n- focusout：元素失去焦点时触发\n\n### 四. 鼠标事件\n\n用户用鼠标执行某些操作\n\n- click：单击鼠标按钮（左边的键），或者按下**回车键**\n- dbclick：双击鼠标按钮（左边的键）\n- mousedown：用户按下任意鼠标按钮\n- mouseenter：将鼠标光标首次移动到元素范围之内时触发**（不冒泡！！！）**\n- mouseleave：位于元素内的鼠标移出元素时触发**（不冒泡！！！）**\n- mousemove：鼠标指针在元素内部移动时重复触发\n- mouseout：鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发\n- mouseover：鼠标指针位于一个元素外部，用户将其首次移入另一个元素边界之内时触发\n- mouseup：用户释放鼠标按钮时触发\n\n**mouseenter和mouseover的区别：**\n\n若元素内部有子元素，鼠标进入该元素和该元素内部的子元素都会触发mouseover；鼠标进入**该元素整个范围之内**触发mouseenter\n\n举个栗子：\n```js\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <style type=\"text/css\">\n            #over {\n                background-color: lightgray;\n                padding: 20px;\n                width: 40%;\n                float: left;\n            }\n            \n            #enter {\n                background-color: lightgray;\n                padding: 20px;\n                width: 40%;\n                float: right;\n            }\n        </style>\n\n    </head>\n    <body>\n        <p>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。</p>\n        <p>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。</p>\n        <div id=\"over\">\n            <h2 style=\"background-color:white;\">被触发的 Mouseover 事件：\n                <span id=\"overNum\">0</span>\n            </h2>\n        </div>\n        <div id=\"enter\">\n            <h2 style=\"background-color:white;\">被触发的 Mouseenter 事件：\n                <span id=\"enterNum\">0</span>\n            </h2>\n        </div>\n\n        <script type=\"text/javascript\">\n            var divOver = document.getElementById(\"over\");\n            var divEnter = document.getElementById(\"enter\");\n            var overNum = document.getElementById(\"overNum\");\n            var enterNum = document.getElementById(\"enterNum\");\n            \n            divOver.onmouseover = function() {\n                overNum.innerHTML = parseInt(overNum.innerHTML) + 1;\n            }\n\n            divEnter.onmouseenter = function() {\n                enterNum.innerHTML = parseInt(enterNum.innerHTML) + 1;\n            }\n        </script>\n    </body>\n</html>\n```\n\n**相应的onmouseleave和onmouseout的区别类似**\n\n- onmouseenter对应onmouseleave\n- onmouseover对应onmouseout\n\n### 五. 滚轮事件\n\nmousewheel\n\nmousewheel事件有一个特殊的属性：wheelDelta，是120的倍数\n\n### 六. 键盘事件\n\n- keydown：按下键盘上的任意键触发，按住不放会重复触发\n- keypress：按下键盘上的字符键触发，按住不放会重复触发\n- keyup：释放键盘上的任意键触发\n- textInput：在可编辑区域内输入字符时触发\n\n","source":"_posts/2016-06-08-事件类型.md","raw":"---\nlayout: post\ntitle: 事件类型\ndate: 2016-06-08\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 事件类型\n\n- UI事件\n- 焦点事件\n- 鼠标事件\n- 滚轮事件\n- 文本事件\n- 键盘事件\n- 合成事件\n- 变动事件\n- 变动名称事件\n\n### 二. UI事件\n\nUI事件不一定与用户操作有关\n\n- load：页面完全加载后触发（包括图像、js、css）\n- unload：用户从一个页面切换到另一个页面时触发\n- resize：浏览器窗口宽度、高度改变时触发\n- scroll：浏览器的窗口滑动滚轮时触发\n\n### 三. 焦点事件\n\n页面获得或者失去焦点\n\n- **blur**：元素失去焦点时触发**（不冒泡！！！）**\n- **focus**：元素获得焦点时触发**（不冒泡！！！）**\n- focusin：元素获得焦点时触发\n- focusout：元素失去焦点时触发\n\n### 四. 鼠标事件\n\n用户用鼠标执行某些操作\n\n- click：单击鼠标按钮（左边的键），或者按下**回车键**\n- dbclick：双击鼠标按钮（左边的键）\n- mousedown：用户按下任意鼠标按钮\n- mouseenter：将鼠标光标首次移动到元素范围之内时触发**（不冒泡！！！）**\n- mouseleave：位于元素内的鼠标移出元素时触发**（不冒泡！！！）**\n- mousemove：鼠标指针在元素内部移动时重复触发\n- mouseout：鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发\n- mouseover：鼠标指针位于一个元素外部，用户将其首次移入另一个元素边界之内时触发\n- mouseup：用户释放鼠标按钮时触发\n\n**mouseenter和mouseover的区别：**\n\n若元素内部有子元素，鼠标进入该元素和该元素内部的子元素都会触发mouseover；鼠标进入**该元素整个范围之内**触发mouseenter\n\n举个栗子：\n```js\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <style type=\"text/css\">\n            #over {\n                background-color: lightgray;\n                padding: 20px;\n                width: 40%;\n                float: left;\n            }\n            \n            #enter {\n                background-color: lightgray;\n                padding: 20px;\n                width: 40%;\n                float: right;\n            }\n        </style>\n\n    </head>\n    <body>\n        <p>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。</p>\n        <p>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。</p>\n        <div id=\"over\">\n            <h2 style=\"background-color:white;\">被触发的 Mouseover 事件：\n                <span id=\"overNum\">0</span>\n            </h2>\n        </div>\n        <div id=\"enter\">\n            <h2 style=\"background-color:white;\">被触发的 Mouseenter 事件：\n                <span id=\"enterNum\">0</span>\n            </h2>\n        </div>\n\n        <script type=\"text/javascript\">\n            var divOver = document.getElementById(\"over\");\n            var divEnter = document.getElementById(\"enter\");\n            var overNum = document.getElementById(\"overNum\");\n            var enterNum = document.getElementById(\"enterNum\");\n            \n            divOver.onmouseover = function() {\n                overNum.innerHTML = parseInt(overNum.innerHTML) + 1;\n            }\n\n            divEnter.onmouseenter = function() {\n                enterNum.innerHTML = parseInt(enterNum.innerHTML) + 1;\n            }\n        </script>\n    </body>\n</html>\n```\n\n**相应的onmouseleave和onmouseout的区别类似**\n\n- onmouseenter对应onmouseleave\n- onmouseover对应onmouseout\n\n### 五. 滚轮事件\n\nmousewheel\n\nmousewheel事件有一个特殊的属性：wheelDelta，是120的倍数\n\n### 六. 键盘事件\n\n- keydown：按下键盘上的任意键触发，按住不放会重复触发\n- keypress：按下键盘上的字符键触发，按住不放会重复触发\n- keyup：释放键盘上的任意键触发\n- textInput：在可编辑区域内输入字符时触发\n\n","slug":"2016-06-08-事件类型","published":1,"updated":"2016-06-08T02:36:54.000Z","comments":1,"photos":[],"link":"","_id":"cj035oci5008pd5u8oumzeyqb","content":"<h3 id=\"一-事件类型\"><a href=\"#一-事件类型\" class=\"headerlink\" title=\"一. 事件类型\"></a>一. 事件类型</h3><ul>\n<li>UI事件</li>\n<li>焦点事件</li>\n<li>鼠标事件</li>\n<li>滚轮事件</li>\n<li>文本事件</li>\n<li>键盘事件</li>\n<li>合成事件</li>\n<li>变动事件</li>\n<li>变动名称事件</li>\n</ul>\n<h3 id=\"二-UI事件\"><a href=\"#二-UI事件\" class=\"headerlink\" title=\"二. UI事件\"></a>二. UI事件</h3><p>UI事件不一定与用户操作有关</p>\n<ul>\n<li>load：页面完全加载后触发（包括图像、js、css）</li>\n<li>unload：用户从一个页面切换到另一个页面时触发</li>\n<li>resize：浏览器窗口宽度、高度改变时触发</li>\n<li>scroll：浏览器的窗口滑动滚轮时触发</li>\n</ul>\n<h3 id=\"三-焦点事件\"><a href=\"#三-焦点事件\" class=\"headerlink\" title=\"三. 焦点事件\"></a>三. 焦点事件</h3><p>页面获得或者失去焦点</p>\n<ul>\n<li><strong>blur</strong>：元素失去焦点时触发<strong>（不冒泡！！！）</strong></li>\n<li><strong>focus</strong>：元素获得焦点时触发<strong>（不冒泡！！！）</strong></li>\n<li>focusin：元素获得焦点时触发</li>\n<li>focusout：元素失去焦点时触发</li>\n</ul>\n<h3 id=\"四-鼠标事件\"><a href=\"#四-鼠标事件\" class=\"headerlink\" title=\"四. 鼠标事件\"></a>四. 鼠标事件</h3><p>用户用鼠标执行某些操作</p>\n<ul>\n<li>click：单击鼠标按钮（左边的键），或者按下<strong>回车键</strong></li>\n<li>dbclick：双击鼠标按钮（左边的键）</li>\n<li>mousedown：用户按下任意鼠标按钮</li>\n<li>mouseenter：将鼠标光标首次移动到元素范围之内时触发<strong>（不冒泡！！！）</strong></li>\n<li>mouseleave：位于元素内的鼠标移出元素时触发<strong>（不冒泡！！！）</strong></li>\n<li>mousemove：鼠标指针在元素内部移动时重复触发</li>\n<li>mouseout：鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发</li>\n<li>mouseover：鼠标指针位于一个元素外部，用户将其首次移入另一个元素边界之内时触发</li>\n<li>mouseup：用户释放鼠标按钮时触发</li>\n</ul>\n<p><strong>mouseenter和mouseover的区别：</strong></p>\n<p>若元素内部有子元素，鼠标进入该元素和该元素内部的子元素都会触发mouseover；鼠标进入<strong>该元素整个范围之内</strong>触发mouseenter</p>\n<p>举个栗子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"css\"></span><br><span class=\"line\">            <span class=\"selector-id\">#over</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">background-color</span>: lightgray;</span><br><span class=\"line\">                <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">                <span class=\"attribute\">width</span>: <span class=\"number\">40%</span>;</span><br><span class=\"line\">                <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"selector-id\">#enter</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">background-color</span>: lightgray;</span><br><span class=\"line\">                <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">                <span class=\"attribute\">width</span>: <span class=\"number\">40%</span>;</span><br><span class=\"line\">                <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"over\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-color:white;\"</span>&gt;</span>被触发的 Mouseover 事件：</span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"overNum\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"enter\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-color:white;\"</span>&gt;</span>被触发的 Mouseenter 事件：</span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"enterNum\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> divOver = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"over\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> divEnter = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"enter\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> overNum = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"overNum\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> enterNum = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"enterNum\"</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            divOver.onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                overNum.innerHTML = <span class=\"built_in\">parseInt</span>(overNum.innerHTML) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            divEnter.onmouseenter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                enterNum.innerHTML = <span class=\"built_in\">parseInt</span>(enterNum.innerHTML) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>相应的onmouseleave和onmouseout的区别类似</strong></p>\n<ul>\n<li>onmouseenter对应onmouseleave</li>\n<li>onmouseover对应onmouseout</li>\n</ul>\n<h3 id=\"五-滚轮事件\"><a href=\"#五-滚轮事件\" class=\"headerlink\" title=\"五. 滚轮事件\"></a>五. 滚轮事件</h3><p>mousewheel</p>\n<p>mousewheel事件有一个特殊的属性：wheelDelta，是120的倍数</p>\n<h3 id=\"六-键盘事件\"><a href=\"#六-键盘事件\" class=\"headerlink\" title=\"六. 键盘事件\"></a>六. 键盘事件</h3><ul>\n<li>keydown：按下键盘上的任意键触发，按住不放会重复触发</li>\n<li>keypress：按下键盘上的字符键触发，按住不放会重复触发</li>\n<li>keyup：释放键盘上的任意键触发</li>\n<li>textInput：在可编辑区域内输入字符时触发</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-事件类型\"><a href=\"#一-事件类型\" class=\"headerlink\" title=\"一. 事件类型\"></a>一. 事件类型</h3><ul>\n<li>UI事件</li>\n<li>焦点事件</li>\n<li>鼠标事件</li>\n<li>滚轮事件</li>\n<li>文本事件</li>\n<li>键盘事件</li>\n<li>合成事件</li>\n<li>变动事件</li>\n<li>变动名称事件</li>\n</ul>\n<h3 id=\"二-UI事件\"><a href=\"#二-UI事件\" class=\"headerlink\" title=\"二. UI事件\"></a>二. UI事件</h3><p>UI事件不一定与用户操作有关</p>\n<ul>\n<li>load：页面完全加载后触发（包括图像、js、css）</li>\n<li>unload：用户从一个页面切换到另一个页面时触发</li>\n<li>resize：浏览器窗口宽度、高度改变时触发</li>\n<li>scroll：浏览器的窗口滑动滚轮时触发</li>\n</ul>\n<h3 id=\"三-焦点事件\"><a href=\"#三-焦点事件\" class=\"headerlink\" title=\"三. 焦点事件\"></a>三. 焦点事件</h3><p>页面获得或者失去焦点</p>\n<ul>\n<li><strong>blur</strong>：元素失去焦点时触发<strong>（不冒泡！！！）</strong></li>\n<li><strong>focus</strong>：元素获得焦点时触发<strong>（不冒泡！！！）</strong></li>\n<li>focusin：元素获得焦点时触发</li>\n<li>focusout：元素失去焦点时触发</li>\n</ul>\n<h3 id=\"四-鼠标事件\"><a href=\"#四-鼠标事件\" class=\"headerlink\" title=\"四. 鼠标事件\"></a>四. 鼠标事件</h3><p>用户用鼠标执行某些操作</p>\n<ul>\n<li>click：单击鼠标按钮（左边的键），或者按下<strong>回车键</strong></li>\n<li>dbclick：双击鼠标按钮（左边的键）</li>\n<li>mousedown：用户按下任意鼠标按钮</li>\n<li>mouseenter：将鼠标光标首次移动到元素范围之内时触发<strong>（不冒泡！！！）</strong></li>\n<li>mouseleave：位于元素内的鼠标移出元素时触发<strong>（不冒泡！！！）</strong></li>\n<li>mousemove：鼠标指针在元素内部移动时重复触发</li>\n<li>mouseout：鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发</li>\n<li>mouseover：鼠标指针位于一个元素外部，用户将其首次移入另一个元素边界之内时触发</li>\n<li>mouseup：用户释放鼠标按钮时触发</li>\n</ul>\n<p><strong>mouseenter和mouseover的区别：</strong></p>\n<p>若元素内部有子元素，鼠标进入该元素和该元素内部的子元素都会触发mouseover；鼠标进入<strong>该元素整个范围之内</strong>触发mouseenter</p>\n<p>举个栗子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"css\"></span><br><span class=\"line\">            <span class=\"selector-id\">#over</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">background-color</span>: lightgray;</span><br><span class=\"line\">                <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">                <span class=\"attribute\">width</span>: <span class=\"number\">40%</span>;</span><br><span class=\"line\">                <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"selector-id\">#enter</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">background-color</span>: lightgray;</span><br><span class=\"line\">                <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">                <span class=\"attribute\">width</span>: <span class=\"number\">40%</span>;</span><br><span class=\"line\">                <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"over\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-color:white;\"</span>&gt;</span>被触发的 Mouseover 事件：</span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"overNum\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"enter\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-color:white;\"</span>&gt;</span>被触发的 Mouseenter 事件：</span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"enterNum\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> divOver = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"over\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> divEnter = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"enter\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> overNum = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"overNum\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> enterNum = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"enterNum\"</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            divOver.onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                overNum.innerHTML = <span class=\"built_in\">parseInt</span>(overNum.innerHTML) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            divEnter.onmouseenter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                enterNum.innerHTML = <span class=\"built_in\">parseInt</span>(enterNum.innerHTML) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>相应的onmouseleave和onmouseout的区别类似</strong></p>\n<ul>\n<li>onmouseenter对应onmouseleave</li>\n<li>onmouseover对应onmouseout</li>\n</ul>\n<h3 id=\"五-滚轮事件\"><a href=\"#五-滚轮事件\" class=\"headerlink\" title=\"五. 滚轮事件\"></a>五. 滚轮事件</h3><p>mousewheel</p>\n<p>mousewheel事件有一个特殊的属性：wheelDelta，是120的倍数</p>\n<h3 id=\"六-键盘事件\"><a href=\"#六-键盘事件\" class=\"headerlink\" title=\"六. 键盘事件\"></a>六. 键盘事件</h3><ul>\n<li>keydown：按下键盘上的任意键触发，按住不放会重复触发</li>\n<li>keypress：按下键盘上的字符键触发，按住不放会重复触发</li>\n<li>keyup：释放键盘上的任意键触发</li>\n<li>textInput：在可编辑区域内输入字符时触发</li>\n</ul>\n"},{"layout":"post","title":"二维数组根据某一列进行排序","date":"2016-06-11T16:00:00.000Z","description":null,"_content":"\n### 一. 最基本的二维数组排序问题\n\n```\n     var arr = [\n\t\t\t\t[\"a\",7,10],\n\t\t\t\t[\"b\",2,2],\n\t\t\t\t[\"c\",4,3]\n\t\t\t   ];\n     \n     var arr1 = arr.sort(function(x, y) {\n          return x[1] - y[1];//根据第二列排序（升序）\n     });\n     console.log(arr1);\n\t//arr1 = [\t\t\t\n\t\t\t\t[\"b\",2,2],\n\t\t\t\t[\"c\",4,3],\n\t\t\t\t[\"a\",7,10]\n\t\t\t  ];\n```\n\n###  二. 数组里面是对象的排序问题\n\n```\n\tvar arr = [ \n          {name:'hdj', age:118}, \n          {name:'yim', age:25}, \n          {name:'hdq', age:26} \n     ]; \n\n\t按照age的值得大小排序：\n\n\tarr.sort(function(a,b){\n          return a.age - b.age;//升序\n    });\n\n\t输出结果为：\n\tarr = [ \n\t\t  {name:'yim', age:25}, \n          {name:'hdj', age:118},        \n          {name:'hdq', age:26} \n     ];\n```\t\n\n","source":"_posts/2016-06-12-二维数组根据某一列进行排序.md","raw":"---\nlayout: post\ntitle: 二维数组根据某一列进行排序\ndate: 2016-06-12\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一. 最基本的二维数组排序问题\n\n```\n     var arr = [\n\t\t\t\t[\"a\",7,10],\n\t\t\t\t[\"b\",2,2],\n\t\t\t\t[\"c\",4,3]\n\t\t\t   ];\n     \n     var arr1 = arr.sort(function(x, y) {\n          return x[1] - y[1];//根据第二列排序（升序）\n     });\n     console.log(arr1);\n\t//arr1 = [\t\t\t\n\t\t\t\t[\"b\",2,2],\n\t\t\t\t[\"c\",4,3],\n\t\t\t\t[\"a\",7,10]\n\t\t\t  ];\n```\n\n###  二. 数组里面是对象的排序问题\n\n```\n\tvar arr = [ \n          {name:'hdj', age:118}, \n          {name:'yim', age:25}, \n          {name:'hdq', age:26} \n     ]; \n\n\t按照age的值得大小排序：\n\n\tarr.sort(function(a,b){\n          return a.age - b.age;//升序\n    });\n\n\t输出结果为：\n\tarr = [ \n\t\t  {name:'yim', age:25}, \n          {name:'hdj', age:118},        \n          {name:'hdq', age:26} \n     ];\n```\t\n\n","slug":"2016-06-12-二维数组根据某一列进行排序","published":1,"updated":"2016-08-21T13:28:10.000Z","comments":1,"photos":[],"link":"","_id":"cj035oci7008td5u81mp8sasv","content":"<h3 id=\"一-最基本的二维数组排序问题\"><a href=\"#一-最基本的二维数组排序问题\" class=\"headerlink\" title=\"一. 最基本的二维数组排序问题\"></a>一. 最基本的二维数组排序问题</h3><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var arr = [</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"a\"</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"b\"</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"c\"</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">\t\t   ];</span><br><span class=\"line\">    </span><br><span class=\"line\">    var arr1 = arr.sort(function(x, y) &#123;</span><br><span class=\"line\">         return x[<span class=\"number\">1</span>] - y[<span class=\"number\">1</span>];//根据第二列排序（升序）</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(arr1);</span><br><span class=\"line\">//arr1 = [\t\t\t</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"b\"</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"c\"</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"a\"</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>]</span><br><span class=\"line\">\t\t  ];</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-数组里面是对象的排序问题\"><a href=\"#二-数组里面是对象的排序问题\" class=\"headerlink\" title=\"二. 数组里面是对象的排序问题\"></a>二. 数组里面是对象的排序问题</h3><pre><code>var arr = [ \n      {name:&apos;hdj&apos;, age:118}, \n      {name:&apos;yim&apos;, age:25}, \n      {name:&apos;hdq&apos;, age:26} \n ]; \n\n按照age的值得大小排序：\n\narr.sort(function(a,b){\n      return a.age - b.age;//升序\n});\n\n输出结果为：\narr = [ \n      {name:&apos;yim&apos;, age:25}, \n      {name:&apos;hdj&apos;, age:118},        \n      {name:&apos;hdq&apos;, age:26} \n ];\n</code></pre>","excerpt":"","more":"<h3 id=\"一-最基本的二维数组排序问题\"><a href=\"#一-最基本的二维数组排序问题\" class=\"headerlink\" title=\"一. 最基本的二维数组排序问题\"></a>一. 最基本的二维数组排序问题</h3><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var arr = [</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"a\"</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"b\"</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"c\"</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">\t\t   ];</span><br><span class=\"line\">    </span><br><span class=\"line\">    var arr1 = arr.sort(function(x, y) &#123;</span><br><span class=\"line\">         return x[<span class=\"number\">1</span>] - y[<span class=\"number\">1</span>];//根据第二列排序（升序）</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(arr1);</span><br><span class=\"line\">//arr1 = [\t\t\t</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"b\"</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"c\"</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">\t\t\t[<span class=\"string\">\"a\"</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>]</span><br><span class=\"line\">\t\t  ];</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-数组里面是对象的排序问题\"><a href=\"#二-数组里面是对象的排序问题\" class=\"headerlink\" title=\"二. 数组里面是对象的排序问题\"></a>二. 数组里面是对象的排序问题</h3><pre><code>var arr = [ \n      {name:&apos;hdj&apos;, age:118}, \n      {name:&apos;yim&apos;, age:25}, \n      {name:&apos;hdq&apos;, age:26} \n ]; \n\n按照age的值得大小排序：\n\narr.sort(function(a,b){\n      return a.age - b.age;//升序\n});\n\n输出结果为：\narr = [ \n      {name:&apos;yim&apos;, age:25}, \n      {name:&apos;hdj&apos;, age:118},        \n      {name:&apos;hdq&apos;, age:26} \n ];\n</code></pre>"},{"layout":"post","title":"微型调查问卷平台组件——冻结行列表格","date":"2016-06-11T16:00:00.000Z","description":null,"_content":"\n### 一. 冻结行列表格任务要求\n\n- 实现一个支持首行冻结的表格组件\n- 当页面向下滚动，使得第一行已经在屏幕外时，则第一行则变成始终固定在屏幕最上方\n- 当整个表格都滚动出屏幕时，固定的第一行也消失\n\n**demo地址：**[http://panpanfish.com/myDemo/research/fixedTable.html](http://panpanfish.com/myDemo/research/fixedTable.html \"排序表格\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html \"排序表格\")\n\n代码描述：\n\n在之前的排序表格的代码的基础上，给RankTable的原型添加了1个方法：fixedTop();\n\n实现思想：\n\n当滚轮滚动的距离在`[表格距离页面顶端的距离，表格距离页面顶端的距离+表格自身的高度]`这个区间范围内时，设置表格的首行的`position:fixed`;\n\n### 二. 实现过程中遇到的问题\n\n#### 1. 关于clientTop、scrollTop、offsetTop\n\n这一部分见博客《元素视图属性》\n\n#### 2. 文档类型声明和渲染模式\n\n这一部分见博客《文档类型声明》\n\n","source":"_posts/2016-06-12-微型调查问卷平台组件——冻结行列表格.md","raw":"---\nlayout: post\ntitle: 微型调查问卷平台组件——冻结行列表格\ndate: 2016-06-12\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n### 一. 冻结行列表格任务要求\n\n- 实现一个支持首行冻结的表格组件\n- 当页面向下滚动，使得第一行已经在屏幕外时，则第一行则变成始终固定在屏幕最上方\n- 当整个表格都滚动出屏幕时，固定的第一行也消失\n\n**demo地址：**[http://panpanfish.com/myDemo/research/fixedTable.html](http://panpanfish.com/myDemo/research/fixedTable.html \"排序表格\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html \"排序表格\")\n\n代码描述：\n\n在之前的排序表格的代码的基础上，给RankTable的原型添加了1个方法：fixedTop();\n\n实现思想：\n\n当滚轮滚动的距离在`[表格距离页面顶端的距离，表格距离页面顶端的距离+表格自身的高度]`这个区间范围内时，设置表格的首行的`position:fixed`;\n\n### 二. 实现过程中遇到的问题\n\n#### 1. 关于clientTop、scrollTop、offsetTop\n\n这一部分见博客《元素视图属性》\n\n#### 2. 文档类型声明和渲染模式\n\n这一部分见博客《文档类型声明》\n\n","slug":"2016-06-12-微型调查问卷平台组件——冻结行列表格","published":1,"updated":"2016-06-14T13:18:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035oci9008wd5u88ht5xnml","content":"<h3 id=\"一-冻结行列表格任务要求\"><a href=\"#一-冻结行列表格任务要求\" class=\"headerlink\" title=\"一. 冻结行列表格任务要求\"></a>一. 冻结行列表格任务要求</h3><ul>\n<li>实现一个支持首行冻结的表格组件</li>\n<li>当页面向下滚动，使得第一行已经在屏幕外时，则第一行则变成始终固定在屏幕最上方</li>\n<li>当整个表格都滚动出屏幕时，固定的第一行也消失</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/fixedTable.html\" title=\"排序表格\">http://panpanfish.com/myDemo/research/fixedTable.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html\" title=\"排序表格\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html</a></p>\n<p>代码描述：</p>\n<p>在之前的排序表格的代码的基础上，给RankTable的原型添加了1个方法：fixedTop();</p>\n<p>实现思想：</p>\n<p>当滚轮滚动的距离在<code>[表格距离页面顶端的距离，表格距离页面顶端的距离+表格自身的高度]</code>这个区间范围内时，设置表格的首行的<code>position:fixed</code>;</p>\n<h3 id=\"二-实现过程中遇到的问题\"><a href=\"#二-实现过程中遇到的问题\" class=\"headerlink\" title=\"二. 实现过程中遇到的问题\"></a>二. 实现过程中遇到的问题</h3><h4 id=\"1-关于clientTop、scrollTop、offsetTop\"><a href=\"#1-关于clientTop、scrollTop、offsetTop\" class=\"headerlink\" title=\"1. 关于clientTop、scrollTop、offsetTop\"></a>1. 关于clientTop、scrollTop、offsetTop</h4><p>这一部分见博客《元素视图属性》</p>\n<h4 id=\"2-文档类型声明和渲染模式\"><a href=\"#2-文档类型声明和渲染模式\" class=\"headerlink\" title=\"2. 文档类型声明和渲染模式\"></a>2. 文档类型声明和渲染模式</h4><p>这一部分见博客《文档类型声明》</p>\n","excerpt":"","more":"<h3 id=\"一-冻结行列表格任务要求\"><a href=\"#一-冻结行列表格任务要求\" class=\"headerlink\" title=\"一. 冻结行列表格任务要求\"></a>一. 冻结行列表格任务要求</h3><ul>\n<li>实现一个支持首行冻结的表格组件</li>\n<li>当页面向下滚动，使得第一行已经在屏幕外时，则第一行则变成始终固定在屏幕最上方</li>\n<li>当整个表格都滚动出屏幕时，固定的第一行也消失</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/fixedTable.html\" title=\"排序表格\">http://panpanfish.com/myDemo/research/fixedTable.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html\" title=\"排序表格\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/fixedTable.html</a></p>\n<p>代码描述：</p>\n<p>在之前的排序表格的代码的基础上，给RankTable的原型添加了1个方法：fixedTop();</p>\n<p>实现思想：</p>\n<p>当滚轮滚动的距离在<code>[表格距离页面顶端的距离，表格距离页面顶端的距离+表格自身的高度]</code>这个区间范围内时，设置表格的首行的<code>position:fixed</code>;</p>\n<h3 id=\"二-实现过程中遇到的问题\"><a href=\"#二-实现过程中遇到的问题\" class=\"headerlink\" title=\"二. 实现过程中遇到的问题\"></a>二. 实现过程中遇到的问题</h3><h4 id=\"1-关于clientTop、scrollTop、offsetTop\"><a href=\"#1-关于clientTop、scrollTop、offsetTop\" class=\"headerlink\" title=\"1. 关于clientTop、scrollTop、offsetTop\"></a>1. 关于clientTop、scrollTop、offsetTop</h4><p>这一部分见博客《元素视图属性》</p>\n<h4 id=\"2-文档类型声明和渲染模式\"><a href=\"#2-文档类型声明和渲染模式\" class=\"headerlink\" title=\"2. 文档类型声明和渲染模式\"></a>2. 文档类型声明和渲染模式</h4><p>这一部分见博客《文档类型声明》</p>\n"},{"layout":"post","title":"微型调查问卷平台组件——排序表格","date":"2016-06-11T16:00:00.000Z","description":null,"_content":"\n### 一. 排序表格任务要求\n\n- 实现一个支持列排序的表格组件\n- 提供生成表格的接口，表格中的数据，表格样式尽量低耦合\n- 可以配置对哪些列支持排序功能，并在表头进行排序按钮的显示，图中的样式为示意参考，可自行设定样式及交互方式\n- 提供点击排序按钮后的响应接口，并提供默认的排序方法，当提供的接口没有具体实现时，按默认的排序方法进行排序操作，并更新表格中的数据显示\n\n**demo地址：**[http://panpanfish.com/myDemo/research/sortTable.html](http://panpanfish.com/myDemo/research/sortTable.html \"排序表格\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html \"排序表格\")\n\n**代码描述：**\n\nRankTable的原型添加了3个方法：**init()**、**addThead()**、**addTbody()**\n\n**init()**初始化了表格\n\n**addThead()**根据提供的配置信息中的可以排序的列号，对可以排序的列进行设定，并绑定相应的事件监听函数,排序时，会调用addTbody()更新表格中的数据显示。\n\n**addTbody()**显示表格中的内容\n\n**表格头部和表格内容显示时，都涉及到两个问题：**\n\n- dom节点的添加\n- dom节点内容的添加\n\n### 二. 实现过程中遇到的问题\n\n#### 1. 往页面中插入dom节点的问题\n\n之前涉及到向页面中添加dom节点时，我都是通过`document.createElement()`;然后再通过`appendChild()`来实现。\n\n在这个demo中，使用的是**拼接字符串**的形式：\n```js\nvar item = \"<tr>\" + \"</tr>\";\nvar mydiv = document.getElementById(\"mydiv\");\nmydiv.innerHTML = item;\n```\n\n感觉这样会简单一些。\n\n#### 2. 巧妙地使用map()函数和join()\n\n使用拼接字符串的形式添加dom节点时，可以配合使用**map()**函数和**join()**\n\n**map()函数**的作用是将数组的每一项都执行map()里面的函数，并返回一个新的数组。\n\n**join()函数**的作用是将数组以某种特殊的符号连接起来，变成字符串（这里使用的是空字符串连接）\n\n```js\nfunction fn(con) {\n\treturn \"<td>\" + con + \"</td>\";\n}\n\nvar th = this.th.map(fn).join(\"\");\n```\n\n#### 3. children和childNodes的区别\n\n**childNodes：**是标准属性。返回指定元素的所有子节点的集合（包括HTML节点、属性节点、文本节点）\n\n可通过判断nodeType==1来判断是否为元素节点：\n\n```js\nfunction getFirst(elem){\n    for(var i=0,e;e=elem.childNodes[i++];){\n        if(e.nodeType==1)\n            return e;\n    }\n}\n```\n\n**children：**非标准属性。返回指定元素的所有元素节点的集合。（几乎得到了所有浏览器的支持）\n\n注意：children在IE中包含注释节点。\n\n#### 4. 表格中的border-spacing和border-collapse属性\n\n**border-spacing：**设置相邻单元格的边框间的距离。\n\n一般如果需要去掉表格默认的边框，可以设置`border-spacing:0;`\n\n**border-collapse：**设置表格的边框是否被合并为一个单一的边框。\n\n`border-collapse:collapse;`边框合并为一个单一的边框。\n\n#### 5. 二维数组按照某一列进行排序\n\n见博客\n","source":"_posts/2016-06-12-微型调查问卷平台组件——排序表格.md","raw":"---\nlayout: post\ntitle: 微型调查问卷平台组件——排序表格\ndate: 2016-06-12\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n### 一. 排序表格任务要求\n\n- 实现一个支持列排序的表格组件\n- 提供生成表格的接口，表格中的数据，表格样式尽量低耦合\n- 可以配置对哪些列支持排序功能，并在表头进行排序按钮的显示，图中的样式为示意参考，可自行设定样式及交互方式\n- 提供点击排序按钮后的响应接口，并提供默认的排序方法，当提供的接口没有具体实现时，按默认的排序方法进行排序操作，并更新表格中的数据显示\n\n**demo地址：**[http://panpanfish.com/myDemo/research/sortTable.html](http://panpanfish.com/myDemo/research/sortTable.html \"排序表格\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html \"排序表格\")\n\n**代码描述：**\n\nRankTable的原型添加了3个方法：**init()**、**addThead()**、**addTbody()**\n\n**init()**初始化了表格\n\n**addThead()**根据提供的配置信息中的可以排序的列号，对可以排序的列进行设定，并绑定相应的事件监听函数,排序时，会调用addTbody()更新表格中的数据显示。\n\n**addTbody()**显示表格中的内容\n\n**表格头部和表格内容显示时，都涉及到两个问题：**\n\n- dom节点的添加\n- dom节点内容的添加\n\n### 二. 实现过程中遇到的问题\n\n#### 1. 往页面中插入dom节点的问题\n\n之前涉及到向页面中添加dom节点时，我都是通过`document.createElement()`;然后再通过`appendChild()`来实现。\n\n在这个demo中，使用的是**拼接字符串**的形式：\n```js\nvar item = \"<tr>\" + \"</tr>\";\nvar mydiv = document.getElementById(\"mydiv\");\nmydiv.innerHTML = item;\n```\n\n感觉这样会简单一些。\n\n#### 2. 巧妙地使用map()函数和join()\n\n使用拼接字符串的形式添加dom节点时，可以配合使用**map()**函数和**join()**\n\n**map()函数**的作用是将数组的每一项都执行map()里面的函数，并返回一个新的数组。\n\n**join()函数**的作用是将数组以某种特殊的符号连接起来，变成字符串（这里使用的是空字符串连接）\n\n```js\nfunction fn(con) {\n\treturn \"<td>\" + con + \"</td>\";\n}\n\nvar th = this.th.map(fn).join(\"\");\n```\n\n#### 3. children和childNodes的区别\n\n**childNodes：**是标准属性。返回指定元素的所有子节点的集合（包括HTML节点、属性节点、文本节点）\n\n可通过判断nodeType==1来判断是否为元素节点：\n\n```js\nfunction getFirst(elem){\n    for(var i=0,e;e=elem.childNodes[i++];){\n        if(e.nodeType==1)\n            return e;\n    }\n}\n```\n\n**children：**非标准属性。返回指定元素的所有元素节点的集合。（几乎得到了所有浏览器的支持）\n\n注意：children在IE中包含注释节点。\n\n#### 4. 表格中的border-spacing和border-collapse属性\n\n**border-spacing：**设置相邻单元格的边框间的距离。\n\n一般如果需要去掉表格默认的边框，可以设置`border-spacing:0;`\n\n**border-collapse：**设置表格的边框是否被合并为一个单一的边框。\n\n`border-collapse:collapse;`边框合并为一个单一的边框。\n\n#### 5. 二维数组按照某一列进行排序\n\n见博客\n","slug":"2016-06-12-微型调查问卷平台组件——排序表格","published":1,"updated":"2016-06-13T06:39:24.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocib0090d5u8f63wr5w6","content":"<h3 id=\"一-排序表格任务要求\"><a href=\"#一-排序表格任务要求\" class=\"headerlink\" title=\"一. 排序表格任务要求\"></a>一. 排序表格任务要求</h3><ul>\n<li>实现一个支持列排序的表格组件</li>\n<li>提供生成表格的接口，表格中的数据，表格样式尽量低耦合</li>\n<li>可以配置对哪些列支持排序功能，并在表头进行排序按钮的显示，图中的样式为示意参考，可自行设定样式及交互方式</li>\n<li>提供点击排序按钮后的响应接口，并提供默认的排序方法，当提供的接口没有具体实现时，按默认的排序方法进行排序操作，并更新表格中的数据显示</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/sortTable.html\" title=\"排序表格\">http://panpanfish.com/myDemo/research/sortTable.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html\" title=\"排序表格\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html</a></p>\n<p><strong>代码描述：</strong></p>\n<p>RankTable的原型添加了3个方法：<strong>init()</strong>、<strong>addThead()</strong>、<strong>addTbody()</strong></p>\n<p><strong>init()</strong>初始化了表格</p>\n<p><strong>addThead()</strong>根据提供的配置信息中的可以排序的列号，对可以排序的列进行设定，并绑定相应的事件监听函数,排序时，会调用addTbody()更新表格中的数据显示。</p>\n<p><strong>addTbody()</strong>显示表格中的内容</p>\n<p><strong>表格头部和表格内容显示时，都涉及到两个问题：</strong></p>\n<ul>\n<li>dom节点的添加</li>\n<li>dom节点内容的添加</li>\n</ul>\n<h3 id=\"二-实现过程中遇到的问题\"><a href=\"#二-实现过程中遇到的问题\" class=\"headerlink\" title=\"二. 实现过程中遇到的问题\"></a>二. 实现过程中遇到的问题</h3><h4 id=\"1-往页面中插入dom节点的问题\"><a href=\"#1-往页面中插入dom节点的问题\" class=\"headerlink\" title=\"1. 往页面中插入dom节点的问题\"></a>1. 往页面中插入dom节点的问题</h4><p>之前涉及到向页面中添加dom节点时，我都是通过<code>document.createElement()</code>;然后再通过<code>appendChild()</code>来实现。</p>\n<p>在这个demo中，使用的是<strong>拼接字符串</strong>的形式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> item = <span class=\"string\">\"&lt;tr&gt;\"</span> + <span class=\"string\">\"&lt;/tr&gt;\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mydiv\"</span>);</span><br><span class=\"line\">mydiv.innerHTML = item;</span><br></pre></td></tr></table></figure></p>\n<p>感觉这样会简单一些。</p>\n<h4 id=\"2-巧妙地使用map-函数和join\"><a href=\"#2-巧妙地使用map-函数和join\" class=\"headerlink\" title=\"2. 巧妙地使用map()函数和join()\"></a>2. 巧妙地使用map()函数和join()</h4><p>使用拼接字符串的形式添加dom节点时，可以配合使用<strong>map()</strong>函数和<strong>join()</strong></p>\n<p><strong>map()函数</strong>的作用是将数组的每一项都执行map()里面的函数，并返回一个新的数组。</p>\n<p><strong>join()函数</strong>的作用是将数组以某种特殊的符号连接起来，变成字符串（这里使用的是空字符串连接）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">con</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"&lt;td&gt;\"</span> + con + <span class=\"string\">\"&lt;/td&gt;\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> th = <span class=\"keyword\">this</span>.th.map(fn).join(<span class=\"string\">\"\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-children和childNodes的区别\"><a href=\"#3-children和childNodes的区别\" class=\"headerlink\" title=\"3. children和childNodes的区别\"></a>3. children和childNodes的区别</h4><p><strong>childNodes：</strong>是标准属性。返回指定元素的所有子节点的集合（包括HTML节点、属性节点、文本节点）</p>\n<p>可通过判断nodeType==1来判断是否为元素节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFirst</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,e;e=elem.childNodes[i++];)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.nodeType==<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>children：</strong>非标准属性。返回指定元素的所有元素节点的集合。（几乎得到了所有浏览器的支持）</p>\n<p>注意：children在IE中包含注释节点。</p>\n<h4 id=\"4-表格中的border-spacing和border-collapse属性\"><a href=\"#4-表格中的border-spacing和border-collapse属性\" class=\"headerlink\" title=\"4. 表格中的border-spacing和border-collapse属性\"></a>4. 表格中的border-spacing和border-collapse属性</h4><p><strong>border-spacing：</strong>设置相邻单元格的边框间的距离。</p>\n<p>一般如果需要去掉表格默认的边框，可以设置<code>border-spacing:0;</code></p>\n<p><strong>border-collapse：</strong>设置表格的边框是否被合并为一个单一的边框。</p>\n<p><code>border-collapse:collapse;</code>边框合并为一个单一的边框。</p>\n<h4 id=\"5-二维数组按照某一列进行排序\"><a href=\"#5-二维数组按照某一列进行排序\" class=\"headerlink\" title=\"5. 二维数组按照某一列进行排序\"></a>5. 二维数组按照某一列进行排序</h4><p>见博客</p>\n","excerpt":"","more":"<h3 id=\"一-排序表格任务要求\"><a href=\"#一-排序表格任务要求\" class=\"headerlink\" title=\"一. 排序表格任务要求\"></a>一. 排序表格任务要求</h3><ul>\n<li>实现一个支持列排序的表格组件</li>\n<li>提供生成表格的接口，表格中的数据，表格样式尽量低耦合</li>\n<li>可以配置对哪些列支持排序功能，并在表头进行排序按钮的显示，图中的样式为示意参考，可自行设定样式及交互方式</li>\n<li>提供点击排序按钮后的响应接口，并提供默认的排序方法，当提供的接口没有具体实现时，按默认的排序方法进行排序操作，并更新表格中的数据显示</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/sortTable.html\" title=\"排序表格\">http://panpanfish.com/myDemo/research/sortTable.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html\" title=\"排序表格\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/sortTable.html</a></p>\n<p><strong>代码描述：</strong></p>\n<p>RankTable的原型添加了3个方法：<strong>init()</strong>、<strong>addThead()</strong>、<strong>addTbody()</strong></p>\n<p><strong>init()</strong>初始化了表格</p>\n<p><strong>addThead()</strong>根据提供的配置信息中的可以排序的列号，对可以排序的列进行设定，并绑定相应的事件监听函数,排序时，会调用addTbody()更新表格中的数据显示。</p>\n<p><strong>addTbody()</strong>显示表格中的内容</p>\n<p><strong>表格头部和表格内容显示时，都涉及到两个问题：</strong></p>\n<ul>\n<li>dom节点的添加</li>\n<li>dom节点内容的添加</li>\n</ul>\n<h3 id=\"二-实现过程中遇到的问题\"><a href=\"#二-实现过程中遇到的问题\" class=\"headerlink\" title=\"二. 实现过程中遇到的问题\"></a>二. 实现过程中遇到的问题</h3><h4 id=\"1-往页面中插入dom节点的问题\"><a href=\"#1-往页面中插入dom节点的问题\" class=\"headerlink\" title=\"1. 往页面中插入dom节点的问题\"></a>1. 往页面中插入dom节点的问题</h4><p>之前涉及到向页面中添加dom节点时，我都是通过<code>document.createElement()</code>;然后再通过<code>appendChild()</code>来实现。</p>\n<p>在这个demo中，使用的是<strong>拼接字符串</strong>的形式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> item = <span class=\"string\">\"&lt;tr&gt;\"</span> + <span class=\"string\">\"&lt;/tr&gt;\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> mydiv = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mydiv\"</span>);</span><br><span class=\"line\">mydiv.innerHTML = item;</span><br></pre></td></tr></table></figure></p>\n<p>感觉这样会简单一些。</p>\n<h4 id=\"2-巧妙地使用map-函数和join\"><a href=\"#2-巧妙地使用map-函数和join\" class=\"headerlink\" title=\"2. 巧妙地使用map()函数和join()\"></a>2. 巧妙地使用map()函数和join()</h4><p>使用拼接字符串的形式添加dom节点时，可以配合使用<strong>map()</strong>函数和<strong>join()</strong></p>\n<p><strong>map()函数</strong>的作用是将数组的每一项都执行map()里面的函数，并返回一个新的数组。</p>\n<p><strong>join()函数</strong>的作用是将数组以某种特殊的符号连接起来，变成字符串（这里使用的是空字符串连接）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">con</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"&lt;td&gt;\"</span> + con + <span class=\"string\">\"&lt;/td&gt;\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> th = <span class=\"keyword\">this</span>.th.map(fn).join(<span class=\"string\">\"\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-children和childNodes的区别\"><a href=\"#3-children和childNodes的区别\" class=\"headerlink\" title=\"3. children和childNodes的区别\"></a>3. children和childNodes的区别</h4><p><strong>childNodes：</strong>是标准属性。返回指定元素的所有子节点的集合（包括HTML节点、属性节点、文本节点）</p>\n<p>可通过判断nodeType==1来判断是否为元素节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFirst</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,e;e=elem.childNodes[i++];)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.nodeType==<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>children：</strong>非标准属性。返回指定元素的所有元素节点的集合。（几乎得到了所有浏览器的支持）</p>\n<p>注意：children在IE中包含注释节点。</p>\n<h4 id=\"4-表格中的border-spacing和border-collapse属性\"><a href=\"#4-表格中的border-spacing和border-collapse属性\" class=\"headerlink\" title=\"4. 表格中的border-spacing和border-collapse属性\"></a>4. 表格中的border-spacing和border-collapse属性</h4><p><strong>border-spacing：</strong>设置相邻单元格的边框间的距离。</p>\n<p>一般如果需要去掉表格默认的边框，可以设置<code>border-spacing:0;</code></p>\n<p><strong>border-collapse：</strong>设置表格的边框是否被合并为一个单一的边框。</p>\n<p><code>border-collapse:collapse;</code>边框合并为一个单一的边框。</p>\n<h4 id=\"5-二维数组按照某一列进行排序\"><a href=\"#5-二维数组按照某一列进行排序\" class=\"headerlink\" title=\"5. 二维数组按照某一列进行排序\"></a>5. 二维数组按照某一列进行排序</h4><p>见博客</p>\n"},{"layout":"post","title":"元素视图属性","date":"2016-06-13T16:00:00.000Z","description":null,"_content":"\n一直都分不清下面的属性分别指的是什么，网上的那张图太乱了，现在总结一下。\n\n- clientLeft/clientTop、clientWidth/clientHeight\n\n- offsetLeft/offsetTop、offsetWidth/offsetHeight\n- offsetParent\n\n- scrollLeft/scrollTop、scrollWidth/scrollHeight\n\n**上面几种属性，又分两种情况：**\n\n- 一种是对于document.body\n- 一种是对于某个元素\n\n其实，document.body也是页面中的一个元素\n\n### 一. 对于document.body而言\n\n**clientWidth/clientHeight**\n\n指的是可视区的宽和高，不包括浏览器的边框的白色部分。\n\n**offsetHeight/offsetWidth**\n\n用的较少\n`document.body.offsetWidth = body的width + padding + border;`\n\n**scrollWidth/scrollHeight**\n\n包括滚动隐藏的部分，可以看成是整个页面的宽和高（区别于浏览器可视区的宽和高）\n\n**scrollTop/scrollLeft**\n\ndocumen.body.scrollTop指的是页面上部被隐藏的部分，也就是滚动条向下滚动的距离\n\n如果将滚动条滚动到底部，那么`scrollTop + clientHeight = scrollHeight`\n\n关于获取**浏览器的滚动条距离顶端的距离**，有下面两种方法，存在兼容性问题：\n\n- document.body.scrollTop\n- document.documentElement.scrollTop\n\n**（1）文档处于混杂模式下：**\n\n所有浏览器使用`document.body.scrollTop`获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。\n\n**（2）文档处于标准模式下：**\n\n- chrome和safari：使用`document.body.scrollTop`获取\n- IE：使用`document.documentElement.scrollTop`获取\n\n考虑浏览器的兼容性：\n```js\nvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n```\n\n### 二. 对于页面中的某个元素\n\n#### 1. clientLeft/clientTop\n\n**元素的clientLeft和clientTop：**\n\n- clientLeft：表示的是元素内容距离元素左上角的水平距离。\n- clientTop：表示的是元素内容距离元素左上角的垂直距离。\n\n**参照点是：**元素盒模型左上角的那个点，这里的元素内容包括内部的padding\n\n\tclientLeft相当于元素的border-left大小\n\tclientTop相当于元素的border-top大小\n\n#### 2. clientWidth/clientHeight\n\n**元素的clientWidth和clientHeight：**\n\n- clientWidth：表示的是元素内容的宽度（包括padding的大小，不包括border和滚动条）\n- clientHeight：表示的是元素内容的高度（包括padding的大小，不包括border和滚动条）\n\n\tclientWidth相当于box-sizing取值为padding-box时的width\n\tclientHeight相当于box-sizing取值为padding-box时的height\n\n### 二. offset相关\n\n#### 1. offsetLeft/offsetTop\n\n- offsetLeft：表示距离最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）左上角的水平偏移值\n- offsetTop：表示距离最近的祖先定位元素（css position属性设置为relative、absolute、fixed的元素）左上角的垂直距离\n\n如果父元素没有定位元素，那么就是相对于**document.body**\n\n**参照点：**\n\n如果元素有最近的祖先定位元素，那么参照点是最近的祖先定位元素的左上角。\n\n如果元素没有最近的祖先定位元素，那么参照点是网页最上方的左边的那个点（**document.body**）。\n\n#### 2. offsetWidth/offsetHeight\n\n- offsetWidth：表示元素的宽度（包括内部元素、padding、border）\n- offsetHeight：表示元素的高度（包括内部元素、padding、border）\n\n#### 3. offsetParent\n\n元素的offsetParent返回的是一个对象，第一个祖先定位元素。\n\noffsetParent返回值可能取值：\n\n- body\n- 最近的祖先定位元素\n- td\n\n### 三. scroll相关\n\n元素的sroll相关的属性只有在元素有滚动的部分时才有效。\n\n#### 1. scrollLeft/scrollTop\n\nElement.scrollTop不是标准属性，但是已被大多数浏览器支持，当元素自己本身含有滚动条时才有这个属性。（也就是元素的内容滚动到元素的上边界）\n\n#### 2. scrollHeight/scrollWidth\n","source":"_posts/2016-06-14-元素视图属性.md","raw":"---\nlayout: post\ntitle: 元素视图属性\ndate: 2016-06-14\ncategories: 前端笔记\ntags: [javaScript]\ndescription: \n---\n\n一直都分不清下面的属性分别指的是什么，网上的那张图太乱了，现在总结一下。\n\n- clientLeft/clientTop、clientWidth/clientHeight\n\n- offsetLeft/offsetTop、offsetWidth/offsetHeight\n- offsetParent\n\n- scrollLeft/scrollTop、scrollWidth/scrollHeight\n\n**上面几种属性，又分两种情况：**\n\n- 一种是对于document.body\n- 一种是对于某个元素\n\n其实，document.body也是页面中的一个元素\n\n### 一. 对于document.body而言\n\n**clientWidth/clientHeight**\n\n指的是可视区的宽和高，不包括浏览器的边框的白色部分。\n\n**offsetHeight/offsetWidth**\n\n用的较少\n`document.body.offsetWidth = body的width + padding + border;`\n\n**scrollWidth/scrollHeight**\n\n包括滚动隐藏的部分，可以看成是整个页面的宽和高（区别于浏览器可视区的宽和高）\n\n**scrollTop/scrollLeft**\n\ndocumen.body.scrollTop指的是页面上部被隐藏的部分，也就是滚动条向下滚动的距离\n\n如果将滚动条滚动到底部，那么`scrollTop + clientHeight = scrollHeight`\n\n关于获取**浏览器的滚动条距离顶端的距离**，有下面两种方法，存在兼容性问题：\n\n- document.body.scrollTop\n- document.documentElement.scrollTop\n\n**（1）文档处于混杂模式下：**\n\n所有浏览器使用`document.body.scrollTop`获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。\n\n**（2）文档处于标准模式下：**\n\n- chrome和safari：使用`document.body.scrollTop`获取\n- IE：使用`document.documentElement.scrollTop`获取\n\n考虑浏览器的兼容性：\n```js\nvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n```\n\n### 二. 对于页面中的某个元素\n\n#### 1. clientLeft/clientTop\n\n**元素的clientLeft和clientTop：**\n\n- clientLeft：表示的是元素内容距离元素左上角的水平距离。\n- clientTop：表示的是元素内容距离元素左上角的垂直距离。\n\n**参照点是：**元素盒模型左上角的那个点，这里的元素内容包括内部的padding\n\n\tclientLeft相当于元素的border-left大小\n\tclientTop相当于元素的border-top大小\n\n#### 2. clientWidth/clientHeight\n\n**元素的clientWidth和clientHeight：**\n\n- clientWidth：表示的是元素内容的宽度（包括padding的大小，不包括border和滚动条）\n- clientHeight：表示的是元素内容的高度（包括padding的大小，不包括border和滚动条）\n\n\tclientWidth相当于box-sizing取值为padding-box时的width\n\tclientHeight相当于box-sizing取值为padding-box时的height\n\n### 二. offset相关\n\n#### 1. offsetLeft/offsetTop\n\n- offsetLeft：表示距离最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）左上角的水平偏移值\n- offsetTop：表示距离最近的祖先定位元素（css position属性设置为relative、absolute、fixed的元素）左上角的垂直距离\n\n如果父元素没有定位元素，那么就是相对于**document.body**\n\n**参照点：**\n\n如果元素有最近的祖先定位元素，那么参照点是最近的祖先定位元素的左上角。\n\n如果元素没有最近的祖先定位元素，那么参照点是网页最上方的左边的那个点（**document.body**）。\n\n#### 2. offsetWidth/offsetHeight\n\n- offsetWidth：表示元素的宽度（包括内部元素、padding、border）\n- offsetHeight：表示元素的高度（包括内部元素、padding、border）\n\n#### 3. offsetParent\n\n元素的offsetParent返回的是一个对象，第一个祖先定位元素。\n\noffsetParent返回值可能取值：\n\n- body\n- 最近的祖先定位元素\n- td\n\n### 三. scroll相关\n\n元素的sroll相关的属性只有在元素有滚动的部分时才有效。\n\n#### 1. scrollLeft/scrollTop\n\nElement.scrollTop不是标准属性，但是已被大多数浏览器支持，当元素自己本身含有滚动条时才有这个属性。（也就是元素的内容滚动到元素的上边界）\n\n#### 2. scrollHeight/scrollWidth\n","slug":"2016-06-14-元素视图属性","published":1,"updated":"2016-10-15T07:39:28.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocic0093d5u8nlc33ife","content":"<p>一直都分不清下面的属性分别指的是什么，网上的那张图太乱了，现在总结一下。</p>\n<ul>\n<li><p>clientLeft/clientTop、clientWidth/clientHeight</p>\n</li>\n<li><p>offsetLeft/offsetTop、offsetWidth/offsetHeight</p>\n</li>\n<li><p>offsetParent</p>\n</li>\n<li><p>scrollLeft/scrollTop、scrollWidth/scrollHeight</p>\n</li>\n</ul>\n<p><strong>上面几种属性，又分两种情况：</strong></p>\n<ul>\n<li>一种是对于document.body</li>\n<li>一种是对于某个元素</li>\n</ul>\n<p>其实，document.body也是页面中的一个元素</p>\n<h3 id=\"一-对于document-body而言\"><a href=\"#一-对于document-body而言\" class=\"headerlink\" title=\"一. 对于document.body而言\"></a>一. 对于document.body而言</h3><p><strong>clientWidth/clientHeight</strong></p>\n<p>指的是可视区的宽和高，不包括浏览器的边框的白色部分。</p>\n<p><strong>offsetHeight/offsetWidth</strong></p>\n<p>用的较少<br><code>document.body.offsetWidth = body的width + padding + border;</code></p>\n<p><strong>scrollWidth/scrollHeight</strong></p>\n<p>包括滚动隐藏的部分，可以看成是整个页面的宽和高（区别于浏览器可视区的宽和高）</p>\n<p><strong>scrollTop/scrollLeft</strong></p>\n<p>documen.body.scrollTop指的是页面上部被隐藏的部分，也就是滚动条向下滚动的距离</p>\n<p>如果将滚动条滚动到底部，那么<code>scrollTop + clientHeight = scrollHeight</code></p>\n<p>关于获取<strong>浏览器的滚动条距离顶端的距离</strong>，有下面两种方法，存在兼容性问题：</p>\n<ul>\n<li>document.body.scrollTop</li>\n<li>document.documentElement.scrollTop</li>\n</ul>\n<p><strong>（1）文档处于混杂模式下：</strong></p>\n<p>所有浏览器使用<code>document.body.scrollTop</code>获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。</p>\n<p><strong>（2）文档处于标准模式下：</strong></p>\n<ul>\n<li>chrome和safari：使用<code>document.body.scrollTop</code>获取</li>\n<li>IE：使用<code>document.documentElement.scrollTop</code>获取</li>\n</ul>\n<p>考虑浏览器的兼容性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二-对于页面中的某个元素\"><a href=\"#二-对于页面中的某个元素\" class=\"headerlink\" title=\"二. 对于页面中的某个元素\"></a>二. 对于页面中的某个元素</h3><h4 id=\"1-clientLeft-clientTop\"><a href=\"#1-clientLeft-clientTop\" class=\"headerlink\" title=\"1. clientLeft/clientTop\"></a>1. clientLeft/clientTop</h4><p><strong>元素的clientLeft和clientTop：</strong></p>\n<ul>\n<li>clientLeft：表示的是元素内容距离元素左上角的水平距离。</li>\n<li>clientTop：表示的是元素内容距离元素左上角的垂直距离。</li>\n</ul>\n<p><strong>参照点是：</strong>元素盒模型左上角的那个点，这里的元素内容包括内部的padding</p>\n<pre><code>clientLeft相当于元素的border-left大小\nclientTop相当于元素的border-top大小\n</code></pre><h4 id=\"2-clientWidth-clientHeight\"><a href=\"#2-clientWidth-clientHeight\" class=\"headerlink\" title=\"2. clientWidth/clientHeight\"></a>2. clientWidth/clientHeight</h4><p><strong>元素的clientWidth和clientHeight：</strong></p>\n<ul>\n<li>clientWidth：表示的是元素内容的宽度（包括padding的大小，不包括border和滚动条）</li>\n<li><p>clientHeight：表示的是元素内容的高度（包括padding的大小，不包括border和滚动条）</p>\n<p>  clientWidth相当于box-sizing取值为padding-box时的width<br>  clientHeight相当于box-sizing取值为padding-box时的height</p>\n</li>\n</ul>\n<h3 id=\"二-offset相关\"><a href=\"#二-offset相关\" class=\"headerlink\" title=\"二. offset相关\"></a>二. offset相关</h3><h4 id=\"1-offsetLeft-offsetTop\"><a href=\"#1-offsetLeft-offsetTop\" class=\"headerlink\" title=\"1. offsetLeft/offsetTop\"></a>1. offsetLeft/offsetTop</h4><ul>\n<li>offsetLeft：表示距离最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）左上角的水平偏移值</li>\n<li>offsetTop：表示距离最近的祖先定位元素（css position属性设置为relative、absolute、fixed的元素）左上角的垂直距离</li>\n</ul>\n<p>如果父元素没有定位元素，那么就是相对于<strong>document.body</strong></p>\n<p><strong>参照点：</strong></p>\n<p>如果元素有最近的祖先定位元素，那么参照点是最近的祖先定位元素的左上角。</p>\n<p>如果元素没有最近的祖先定位元素，那么参照点是网页最上方的左边的那个点（<strong>document.body</strong>）。</p>\n<h4 id=\"2-offsetWidth-offsetHeight\"><a href=\"#2-offsetWidth-offsetHeight\" class=\"headerlink\" title=\"2. offsetWidth/offsetHeight\"></a>2. offsetWidth/offsetHeight</h4><ul>\n<li>offsetWidth：表示元素的宽度（包括内部元素、padding、border）</li>\n<li>offsetHeight：表示元素的高度（包括内部元素、padding、border）</li>\n</ul>\n<h4 id=\"3-offsetParent\"><a href=\"#3-offsetParent\" class=\"headerlink\" title=\"3. offsetParent\"></a>3. offsetParent</h4><p>元素的offsetParent返回的是一个对象，第一个祖先定位元素。</p>\n<p>offsetParent返回值可能取值：</p>\n<ul>\n<li>body</li>\n<li>最近的祖先定位元素</li>\n<li>td</li>\n</ul>\n<h3 id=\"三-scroll相关\"><a href=\"#三-scroll相关\" class=\"headerlink\" title=\"三. scroll相关\"></a>三. scroll相关</h3><p>元素的sroll相关的属性只有在元素有滚动的部分时才有效。</p>\n<h4 id=\"1-scrollLeft-scrollTop\"><a href=\"#1-scrollLeft-scrollTop\" class=\"headerlink\" title=\"1. scrollLeft/scrollTop\"></a>1. scrollLeft/scrollTop</h4><p>Element.scrollTop不是标准属性，但是已被大多数浏览器支持，当元素自己本身含有滚动条时才有这个属性。（也就是元素的内容滚动到元素的上边界）</p>\n<h4 id=\"2-scrollHeight-scrollWidth\"><a href=\"#2-scrollHeight-scrollWidth\" class=\"headerlink\" title=\"2. scrollHeight/scrollWidth\"></a>2. scrollHeight/scrollWidth</h4>","excerpt":"","more":"<p>一直都分不清下面的属性分别指的是什么，网上的那张图太乱了，现在总结一下。</p>\n<ul>\n<li><p>clientLeft/clientTop、clientWidth/clientHeight</p>\n</li>\n<li><p>offsetLeft/offsetTop、offsetWidth/offsetHeight</p>\n</li>\n<li><p>offsetParent</p>\n</li>\n<li><p>scrollLeft/scrollTop、scrollWidth/scrollHeight</p>\n</li>\n</ul>\n<p><strong>上面几种属性，又分两种情况：</strong></p>\n<ul>\n<li>一种是对于document.body</li>\n<li>一种是对于某个元素</li>\n</ul>\n<p>其实，document.body也是页面中的一个元素</p>\n<h3 id=\"一-对于document-body而言\"><a href=\"#一-对于document-body而言\" class=\"headerlink\" title=\"一. 对于document.body而言\"></a>一. 对于document.body而言</h3><p><strong>clientWidth/clientHeight</strong></p>\n<p>指的是可视区的宽和高，不包括浏览器的边框的白色部分。</p>\n<p><strong>offsetHeight/offsetWidth</strong></p>\n<p>用的较少<br><code>document.body.offsetWidth = body的width + padding + border;</code></p>\n<p><strong>scrollWidth/scrollHeight</strong></p>\n<p>包括滚动隐藏的部分，可以看成是整个页面的宽和高（区别于浏览器可视区的宽和高）</p>\n<p><strong>scrollTop/scrollLeft</strong></p>\n<p>documen.body.scrollTop指的是页面上部被隐藏的部分，也就是滚动条向下滚动的距离</p>\n<p>如果将滚动条滚动到底部，那么<code>scrollTop + clientHeight = scrollHeight</code></p>\n<p>关于获取<strong>浏览器的滚动条距离顶端的距离</strong>，有下面两种方法，存在兼容性问题：</p>\n<ul>\n<li>document.body.scrollTop</li>\n<li>document.documentElement.scrollTop</li>\n</ul>\n<p><strong>（1）文档处于混杂模式下：</strong></p>\n<p>所有浏览器使用<code>document.body.scrollTop</code>获取，但一般文档都是会有文档类型声明的，因此这种情况几乎不存在。</p>\n<p><strong>（2）文档处于标准模式下：</strong></p>\n<ul>\n<li>chrome和safari：使用<code>document.body.scrollTop</code>获取</li>\n<li>IE：使用<code>document.documentElement.scrollTop</code>获取</li>\n</ul>\n<p>考虑浏览器的兼容性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二-对于页面中的某个元素\"><a href=\"#二-对于页面中的某个元素\" class=\"headerlink\" title=\"二. 对于页面中的某个元素\"></a>二. 对于页面中的某个元素</h3><h4 id=\"1-clientLeft-clientTop\"><a href=\"#1-clientLeft-clientTop\" class=\"headerlink\" title=\"1. clientLeft/clientTop\"></a>1. clientLeft/clientTop</h4><p><strong>元素的clientLeft和clientTop：</strong></p>\n<ul>\n<li>clientLeft：表示的是元素内容距离元素左上角的水平距离。</li>\n<li>clientTop：表示的是元素内容距离元素左上角的垂直距离。</li>\n</ul>\n<p><strong>参照点是：</strong>元素盒模型左上角的那个点，这里的元素内容包括内部的padding</p>\n<pre><code>clientLeft相当于元素的border-left大小\nclientTop相当于元素的border-top大小\n</code></pre><h4 id=\"2-clientWidth-clientHeight\"><a href=\"#2-clientWidth-clientHeight\" class=\"headerlink\" title=\"2. clientWidth/clientHeight\"></a>2. clientWidth/clientHeight</h4><p><strong>元素的clientWidth和clientHeight：</strong></p>\n<ul>\n<li>clientWidth：表示的是元素内容的宽度（包括padding的大小，不包括border和滚动条）</li>\n<li><p>clientHeight：表示的是元素内容的高度（包括padding的大小，不包括border和滚动条）</p>\n<p>  clientWidth相当于box-sizing取值为padding-box时的width<br>  clientHeight相当于box-sizing取值为padding-box时的height</p>\n</li>\n</ul>\n<h3 id=\"二-offset相关\"><a href=\"#二-offset相关\" class=\"headerlink\" title=\"二. offset相关\"></a>二. offset相关</h3><h4 id=\"1-offsetLeft-offsetTop\"><a href=\"#1-offsetLeft-offsetTop\" class=\"headerlink\" title=\"1. offsetLeft/offsetTop\"></a>1. offsetLeft/offsetTop</h4><ul>\n<li>offsetLeft：表示距离最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）左上角的水平偏移值</li>\n<li>offsetTop：表示距离最近的祖先定位元素（css position属性设置为relative、absolute、fixed的元素）左上角的垂直距离</li>\n</ul>\n<p>如果父元素没有定位元素，那么就是相对于<strong>document.body</strong></p>\n<p><strong>参照点：</strong></p>\n<p>如果元素有最近的祖先定位元素，那么参照点是最近的祖先定位元素的左上角。</p>\n<p>如果元素没有最近的祖先定位元素，那么参照点是网页最上方的左边的那个点（<strong>document.body</strong>）。</p>\n<h4 id=\"2-offsetWidth-offsetHeight\"><a href=\"#2-offsetWidth-offsetHeight\" class=\"headerlink\" title=\"2. offsetWidth/offsetHeight\"></a>2. offsetWidth/offsetHeight</h4><ul>\n<li>offsetWidth：表示元素的宽度（包括内部元素、padding、border）</li>\n<li>offsetHeight：表示元素的高度（包括内部元素、padding、border）</li>\n</ul>\n<h4 id=\"3-offsetParent\"><a href=\"#3-offsetParent\" class=\"headerlink\" title=\"3. offsetParent\"></a>3. offsetParent</h4><p>元素的offsetParent返回的是一个对象，第一个祖先定位元素。</p>\n<p>offsetParent返回值可能取值：</p>\n<ul>\n<li>body</li>\n<li>最近的祖先定位元素</li>\n<li>td</li>\n</ul>\n<h3 id=\"三-scroll相关\"><a href=\"#三-scroll相关\" class=\"headerlink\" title=\"三. scroll相关\"></a>三. scroll相关</h3><p>元素的sroll相关的属性只有在元素有滚动的部分时才有效。</p>\n<h4 id=\"1-scrollLeft-scrollTop\"><a href=\"#1-scrollLeft-scrollTop\" class=\"headerlink\" title=\"1. scrollLeft/scrollTop\"></a>1. scrollLeft/scrollTop</h4><p>Element.scrollTop不是标准属性，但是已被大多数浏览器支持，当元素自己本身含有滚动条时才有这个属性。（也就是元素的内容滚动到元素的上边界）</p>\n<h4 id=\"2-scrollHeight-scrollWidth\"><a href=\"#2-scrollHeight-scrollWidth\" class=\"headerlink\" title=\"2. scrollHeight/scrollWidth\"></a>2. scrollHeight/scrollWidth</h4>"},{"layout":"post","title":"文档类型声明","date":"2016-06-13T16:00:00.000Z","description":null,"_content":"\n之所以总结了这篇博客，是因为遇到了scrollTop的问题。\n\n在标准模式下，不同浏览器获取**页面滚动条滚动的高度值**的方法不一样。具体可以参考博客《元素视图属性》。\n\n那么什么是标准模式呢？\n\n### 一. 文档类型声明DOCTYPE\n\nDOCTYPE:document type declaration，文档类型声明，缩写为DTD\n\n通常位于一个HTML文档的最前面。\n\n浏览器根据一个文档的DTD来决定需要采用的解析模式。\n\n### 二. 不同的DOCTYPE对应的渲染模式\n\n- 混杂模式\n- 近似标准模式\n- 标准模式（严格模式）\n\n#### 1. 混杂模式\n\n**不声明DOCTYPE的文档**使用混杂模式进行渲染，这种不可取。\n\n#### 2. 近似标准模式\n\n尽可能遵循标准的基础上兼容部分非标准代码，比如一些弃用的标签。\n\n#### 3. 标准模式（严格模式）\n\n声明为：`<!DOCTYPE HTML>`\n \n### 三. 用js判断浏览器当前的模式\n\n\t获取浏览器当前的模式 document.compatMode \n\t\n\t标准模式：document.compatMode = CSS1Compat;\n\t混杂模式：document.compatMode = BackCompat;\n\n\n","source":"_posts/2016-06-14-文档类型声明.md","raw":"---\nlayout: post\ntitle: 文档类型声明\ndate: 2016-06-14\ncategories: HTML\ntags: [HTML]\ndescription: \n---\n\n之所以总结了这篇博客，是因为遇到了scrollTop的问题。\n\n在标准模式下，不同浏览器获取**页面滚动条滚动的高度值**的方法不一样。具体可以参考博客《元素视图属性》。\n\n那么什么是标准模式呢？\n\n### 一. 文档类型声明DOCTYPE\n\nDOCTYPE:document type declaration，文档类型声明，缩写为DTD\n\n通常位于一个HTML文档的最前面。\n\n浏览器根据一个文档的DTD来决定需要采用的解析模式。\n\n### 二. 不同的DOCTYPE对应的渲染模式\n\n- 混杂模式\n- 近似标准模式\n- 标准模式（严格模式）\n\n#### 1. 混杂模式\n\n**不声明DOCTYPE的文档**使用混杂模式进行渲染，这种不可取。\n\n#### 2. 近似标准模式\n\n尽可能遵循标准的基础上兼容部分非标准代码，比如一些弃用的标签。\n\n#### 3. 标准模式（严格模式）\n\n声明为：`<!DOCTYPE HTML>`\n \n### 三. 用js判断浏览器当前的模式\n\n\t获取浏览器当前的模式 document.compatMode \n\t\n\t标准模式：document.compatMode = CSS1Compat;\n\t混杂模式：document.compatMode = BackCompat;\n\n\n","slug":"2016-06-14-文档类型声明","published":1,"updated":"2016-06-18T06:31:00.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocie0097d5u8glgwxxlc","content":"<p>之所以总结了这篇博客，是因为遇到了scrollTop的问题。</p>\n<p>在标准模式下，不同浏览器获取<strong>页面滚动条滚动的高度值</strong>的方法不一样。具体可以参考博客《元素视图属性》。</p>\n<p>那么什么是标准模式呢？</p>\n<h3 id=\"一-文档类型声明DOCTYPE\"><a href=\"#一-文档类型声明DOCTYPE\" class=\"headerlink\" title=\"一. 文档类型声明DOCTYPE\"></a>一. 文档类型声明DOCTYPE</h3><p>DOCTYPE:document type declaration，文档类型声明，缩写为DTD</p>\n<p>通常位于一个HTML文档的最前面。</p>\n<p>浏览器根据一个文档的DTD来决定需要采用的解析模式。</p>\n<h3 id=\"二-不同的DOCTYPE对应的渲染模式\"><a href=\"#二-不同的DOCTYPE对应的渲染模式\" class=\"headerlink\" title=\"二. 不同的DOCTYPE对应的渲染模式\"></a>二. 不同的DOCTYPE对应的渲染模式</h3><ul>\n<li>混杂模式</li>\n<li>近似标准模式</li>\n<li>标准模式（严格模式）</li>\n</ul>\n<h4 id=\"1-混杂模式\"><a href=\"#1-混杂模式\" class=\"headerlink\" title=\"1. 混杂模式\"></a>1. 混杂模式</h4><p><strong>不声明DOCTYPE的文档</strong>使用混杂模式进行渲染，这种不可取。</p>\n<h4 id=\"2-近似标准模式\"><a href=\"#2-近似标准模式\" class=\"headerlink\" title=\"2. 近似标准模式\"></a>2. 近似标准模式</h4><p>尽可能遵循标准的基础上兼容部分非标准代码，比如一些弃用的标签。</p>\n<h4 id=\"3-标准模式（严格模式）\"><a href=\"#3-标准模式（严格模式）\" class=\"headerlink\" title=\"3. 标准模式（严格模式）\"></a>3. 标准模式（严格模式）</h4><p>声明为：<code>&lt;!DOCTYPE HTML&gt;</code></p>\n<h3 id=\"三-用js判断浏览器当前的模式\"><a href=\"#三-用js判断浏览器当前的模式\" class=\"headerlink\" title=\"三. 用js判断浏览器当前的模式\"></a>三. 用js判断浏览器当前的模式</h3><pre><code>获取浏览器当前的模式 document.compatMode \n\n标准模式：document.compatMode = CSS1Compat;\n混杂模式：document.compatMode = BackCompat;\n</code></pre>","excerpt":"","more":"<p>之所以总结了这篇博客，是因为遇到了scrollTop的问题。</p>\n<p>在标准模式下，不同浏览器获取<strong>页面滚动条滚动的高度值</strong>的方法不一样。具体可以参考博客《元素视图属性》。</p>\n<p>那么什么是标准模式呢？</p>\n<h3 id=\"一-文档类型声明DOCTYPE\"><a href=\"#一-文档类型声明DOCTYPE\" class=\"headerlink\" title=\"一. 文档类型声明DOCTYPE\"></a>一. 文档类型声明DOCTYPE</h3><p>DOCTYPE:document type declaration，文档类型声明，缩写为DTD</p>\n<p>通常位于一个HTML文档的最前面。</p>\n<p>浏览器根据一个文档的DTD来决定需要采用的解析模式。</p>\n<h3 id=\"二-不同的DOCTYPE对应的渲染模式\"><a href=\"#二-不同的DOCTYPE对应的渲染模式\" class=\"headerlink\" title=\"二. 不同的DOCTYPE对应的渲染模式\"></a>二. 不同的DOCTYPE对应的渲染模式</h3><ul>\n<li>混杂模式</li>\n<li>近似标准模式</li>\n<li>标准模式（严格模式）</li>\n</ul>\n<h4 id=\"1-混杂模式\"><a href=\"#1-混杂模式\" class=\"headerlink\" title=\"1. 混杂模式\"></a>1. 混杂模式</h4><p><strong>不声明DOCTYPE的文档</strong>使用混杂模式进行渲染，这种不可取。</p>\n<h4 id=\"2-近似标准模式\"><a href=\"#2-近似标准模式\" class=\"headerlink\" title=\"2. 近似标准模式\"></a>2. 近似标准模式</h4><p>尽可能遵循标准的基础上兼容部分非标准代码，比如一些弃用的标签。</p>\n<h4 id=\"3-标准模式（严格模式）\"><a href=\"#3-标准模式（严格模式）\" class=\"headerlink\" title=\"3. 标准模式（严格模式）\"></a>3. 标准模式（严格模式）</h4><p>声明为：<code>&lt;!DOCTYPE HTML&gt;</code></p>\n<h3 id=\"三-用js判断浏览器当前的模式\"><a href=\"#三-用js判断浏览器当前的模式\" class=\"headerlink\" title=\"三. 用js判断浏览器当前的模式\"></a>三. 用js判断浏览器当前的模式</h3><pre><code>获取浏览器当前的模式 document.compatMode \n\n标准模式：document.compatMode = CSS1Compat;\n混杂模式：document.compatMode = BackCompat;\n</code></pre>"},{"layout":"post","title":"表单脚本","date":"2016-06-14T16:00:00.000Z","description":null,"_content":"\n### 一. 表单独有的属性和方法\n\n**属性：**\n```js\nacceptCharset：服务器能够处理的字符集\naction：接受请求的URL\nelements：表单中所有控件的集合\nlength：表单中控件的数量\nenctype：请求的编码类型\nmethod：要发送的HTTP请求类型\ntarget：用于发送请求和接收响应的窗口名称\n```\n\n**方法：**\n```js\nreset()：将表单域重置为默认值\nsubmit()：提交表单\n```\n\n### 二. 获取表单元素的方法\n\n#### 1. 通过id值\n\n#### 2. 通过document.forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\n\n```js\neg:\nvar firstForm = document.forms[0];\nvar myForm = document.forms[\"表单的name值\"]\n```\n\n### 三. 提交表单的方法\n\n#### 1. 使用按钮`<input>`、`<button>`\n\n将`<input>`或者`<button>`的**type属性值设为submit**，那么**按下按钮**或者**按下回车键**都会提交表单。\n\n有一种特殊情况：图像按钮，将`<input>`的type值设为image\n```js\n<input type=\"submit\">\n<input type=\"image\" src=\"img.jpg\">\n<button type=\"submit\">\n```\n\n用这种方式提交表单时，会触发submit事件，这个事件的默认行为是将表单数据发送给服务器.\n\n<font color=\"red\">这种方法来提交表单时会触发表单的onsubmit()事件。</font>\n\n因此，可以在这个事件的监听函数里验证表单数据，如果数据无效，则取消事件的默认行为。\n\n```js\n    var form = document.getElementById(\"myForm\");\n    \n    form.addElementListener(\"submit\",function(event){\n    \t//验证表单的一些数据是否正确\n    \tevent.preventDefault(event);//阻止表单提交\n    })\n```\n或者\n\n```js\n<form onsubmit=\"return submitFun();\"> \n//注意此处不能写成 onsubmit=\"submitFun();\"否则将表单总是提交\n//原因：由于这个onsubmit是html中的事件属性，所以onsubmit的属性值应该为一个函数，写成 onsubmit=\"submitFun();\"那么每次提交表单都会触发 submitFun()函数\n</form> \n\n<script>  \n\tfunction submitFun(){  \n\t    //逻辑判断  \n\t    return true; //允许表单提交  \n\t    //逻辑判断  \n\t    return false;//不允许表单提交  \n\t}  \n</script> \n```\n  \n#### 2. 在js里使用submit()方法来提交表单\n\n```js\nvar form = document.getElementById(\"myForm\");\n//需要在提交之前验证表单数据\nform.submit();\n```\n\n<font color=\"red\">直接使用form.submit()方法提交表单时，不会触发表单的onsubmit()事件。</font>\n\n举个栗子验证一下：\n\n```js\n<form id=\"myForm\" onsubmit=\"fun()\">  \n    <input type=\"submit\" id=\"aaa\" value=\"submit\">//能弹出“触发了表单的onsubmit()事件”\n      \n\t<input type=\"button\" id=\"bbb\" value=\"oncliCk_submit\" onclick=\"document.forms[0].submit()\"> //不能出现弹出框\n  \n    <input type=\"button\" id=\"bb1\" value=\"oncliCk_onsubmit\" onclick=\"document.forms[0].onsubmit()\"> //能弹出“触发了表单的onsubmit()事件” \n</form>  \n\n<script>  \n    function fun(){  \n         alert(\"触发了表单的onsubmit()事件\");  \n    } \n</script> \n```","source":"_posts/2016-06-15-表单脚本.md","raw":"---\nlayout: post\ntitle: 表单脚本\ndate: 2016-06-15\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 表单独有的属性和方法\n\n**属性：**\n```js\nacceptCharset：服务器能够处理的字符集\naction：接受请求的URL\nelements：表单中所有控件的集合\nlength：表单中控件的数量\nenctype：请求的编码类型\nmethod：要发送的HTTP请求类型\ntarget：用于发送请求和接收响应的窗口名称\n```\n\n**方法：**\n```js\nreset()：将表单域重置为默认值\nsubmit()：提交表单\n```\n\n### 二. 获取表单元素的方法\n\n#### 1. 通过id值\n\n#### 2. 通过document.forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\n\n```js\neg:\nvar firstForm = document.forms[0];\nvar myForm = document.forms[\"表单的name值\"]\n```\n\n### 三. 提交表单的方法\n\n#### 1. 使用按钮`<input>`、`<button>`\n\n将`<input>`或者`<button>`的**type属性值设为submit**，那么**按下按钮**或者**按下回车键**都会提交表单。\n\n有一种特殊情况：图像按钮，将`<input>`的type值设为image\n```js\n<input type=\"submit\">\n<input type=\"image\" src=\"img.jpg\">\n<button type=\"submit\">\n```\n\n用这种方式提交表单时，会触发submit事件，这个事件的默认行为是将表单数据发送给服务器.\n\n<font color=\"red\">这种方法来提交表单时会触发表单的onsubmit()事件。</font>\n\n因此，可以在这个事件的监听函数里验证表单数据，如果数据无效，则取消事件的默认行为。\n\n```js\n    var form = document.getElementById(\"myForm\");\n    \n    form.addElementListener(\"submit\",function(event){\n    \t//验证表单的一些数据是否正确\n    \tevent.preventDefault(event);//阻止表单提交\n    })\n```\n或者\n\n```js\n<form onsubmit=\"return submitFun();\"> \n//注意此处不能写成 onsubmit=\"submitFun();\"否则将表单总是提交\n//原因：由于这个onsubmit是html中的事件属性，所以onsubmit的属性值应该为一个函数，写成 onsubmit=\"submitFun();\"那么每次提交表单都会触发 submitFun()函数\n</form> \n\n<script>  \n\tfunction submitFun(){  \n\t    //逻辑判断  \n\t    return true; //允许表单提交  \n\t    //逻辑判断  \n\t    return false;//不允许表单提交  \n\t}  \n</script> \n```\n  \n#### 2. 在js里使用submit()方法来提交表单\n\n```js\nvar form = document.getElementById(\"myForm\");\n//需要在提交之前验证表单数据\nform.submit();\n```\n\n<font color=\"red\">直接使用form.submit()方法提交表单时，不会触发表单的onsubmit()事件。</font>\n\n举个栗子验证一下：\n\n```js\n<form id=\"myForm\" onsubmit=\"fun()\">  \n    <input type=\"submit\" id=\"aaa\" value=\"submit\">//能弹出“触发了表单的onsubmit()事件”\n      \n\t<input type=\"button\" id=\"bbb\" value=\"oncliCk_submit\" onclick=\"document.forms[0].submit()\"> //不能出现弹出框\n  \n    <input type=\"button\" id=\"bb1\" value=\"oncliCk_onsubmit\" onclick=\"document.forms[0].onsubmit()\"> //能弹出“触发了表单的onsubmit()事件” \n</form>  \n\n<script>  \n    function fun(){  \n         alert(\"触发了表单的onsubmit()事件\");  \n    } \n</script> \n```","slug":"2016-06-15-表单脚本","published":1,"updated":"2016-10-15T08:42:34.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocig009ad5u8703fgpjp","content":"<h3 id=\"一-表单独有的属性和方法\"><a href=\"#一-表单独有的属性和方法\" class=\"headerlink\" title=\"一. 表单独有的属性和方法\"></a>一. 表单独有的属性和方法</h3><p><strong>属性：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acceptCharset：服务器能够处理的字符集</span><br><span class=\"line\">action：接受请求的URL</span><br><span class=\"line\">elements：表单中所有控件的集合</span><br><span class=\"line\">length：表单中控件的数量</span><br><span class=\"line\">enctype：请求的编码类型</span><br><span class=\"line\">method：要发送的HTTP请求类型</span><br><span class=\"line\">target：用于发送请求和接收响应的窗口名称</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reset()：将表单域重置为默认值</span><br><span class=\"line\">submit()：提交表单</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二-获取表单元素的方法\"><a href=\"#二-获取表单元素的方法\" class=\"headerlink\" title=\"二. 获取表单元素的方法\"></a>二. 获取表单元素的方法</h3><h4 id=\"1-通过id值\"><a href=\"#1-通过id值\" class=\"headerlink\" title=\"1. 通过id值\"></a>1. 通过id值</h4><h4 id=\"2-通过document-forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\"><a href=\"#2-通过document-forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\" class=\"headerlink\" title=\"2. 通过document.forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\"></a>2. 通过document.forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"keyword\">var</span> firstForm = <span class=\"built_in\">document</span>.forms[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> myForm = <span class=\"built_in\">document</span>.forms[<span class=\"string\">\"表单的name值\"</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-提交表单的方法\"><a href=\"#三-提交表单的方法\" class=\"headerlink\" title=\"三. 提交表单的方法\"></a>三. 提交表单的方法</h3><h4 id=\"1-使用按钮-lt-input-gt-、-lt-button-gt\"><a href=\"#1-使用按钮-lt-input-gt-、-lt-button-gt\" class=\"headerlink\" title=\"1. 使用按钮&lt;input&gt;、&lt;button&gt;\"></a>1. 使用按钮<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code></h4><p>将<code>&lt;input&gt;</code>或者<code>&lt;button&gt;</code>的<strong>type属性值设为submit</strong>，那么<strong>按下按钮</strong>或者<strong>按下回车键</strong>都会提交表单。</p>\n<p>有一种特殊情况：图像按钮，将<code>&lt;input&gt;</code>的type值设为image<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"submit\"</span>&gt;</span><br><span class=\"line\">&lt;input type=\"image\" src=\"img.jpg\"&gt;</span><br><span class=\"line\">&lt;button type=\"submit\"&gt;</span><br></pre></td></tr></table></figure></p>\n<p>用这种方式提交表单时，会触发submit事件，这个事件的默认行为是将表单数据发送给服务器.</p>\n<font color=\"red\">这种方法来提交表单时会触发表单的onsubmit()事件。</font>\n\n<p>因此，可以在这个事件的监听函数里验证表单数据，如果数据无效，则取消事件的默认行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myForm\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">form.addElementListener(<span class=\"string\">\"submit\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//验证表单的一些数据是否正确</span></span><br><span class=\"line\">\tevent.preventDefault(event);<span class=\"comment\">//阻止表单提交</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form onsubmit=\"return submitFun();\"&gt; </span><br><span class=\"line\">//注意此处不能写成 onsubmit=\"submitFun();\"否则将表单总是提交</span><br><span class=\"line\">//原因：由于这个onsubmit是html中的事件属性，所以onsubmit的属性值应该为一个函数，写成 onsubmit=\"submitFun();\"那么每次提交表单都会触发 submitFun()函数</span><br><span class=\"line\">&lt;/form&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;  </span><br><span class=\"line\">\tfunction submitFun()&#123;  </span><br><span class=\"line\">\t    //逻辑判断  </span><br><span class=\"line\">\t    return true; //允许表单提交  </span><br><span class=\"line\">\t    //逻辑判断  </span><br><span class=\"line\">\t    return false;//不允许表单提交  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-在js里使用submit-方法来提交表单\"><a href=\"#2-在js里使用submit-方法来提交表单\" class=\"headerlink\" title=\"2. 在js里使用submit()方法来提交表单\"></a>2. 在js里使用submit()方法来提交表单</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myForm\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//需要在提交之前验证表单数据</span></span><br><span class=\"line\">form.submit();</span><br></pre></td></tr></table></figure>\n<font color=\"red\">直接使用form.submit()方法提交表单时，不会触发表单的onsubmit()事件。</font>\n\n<p>举个栗子验证一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form id=<span class=\"string\">\"myForm\"</span> onsubmit=<span class=\"string\">\"fun()\"</span>&gt;  </span><br><span class=\"line\">    &lt;input type=\"submit\" id=\"aaa\" value=\"submit\"&gt;//能弹出“触发了表单的onsubmit()事件”</span><br><span class=\"line\">      </span><br><span class=\"line\">\t&lt;input type=\"button\" id=\"bbb\" value=\"oncliCk_submit\" onclick=\"document.forms[0].submit()\"&gt; //不能出现弹出框</span><br><span class=\"line\">  </span><br><span class=\"line\">    &lt;input type=\"button\" id=\"bb1\" value=\"oncliCk_onsubmit\" onclick=\"document.forms[0].onsubmit()\"&gt; //能弹出“触发了表单的onsubmit()事件” </span><br><span class=\"line\">&lt;/form&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;  </span><br><span class=\"line\">    function fun()&#123;  </span><br><span class=\"line\">         alert(\"触发了表单的onsubmit()事件\");  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-表单独有的属性和方法\"><a href=\"#一-表单独有的属性和方法\" class=\"headerlink\" title=\"一. 表单独有的属性和方法\"></a>一. 表单独有的属性和方法</h3><p><strong>属性：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acceptCharset：服务器能够处理的字符集</span><br><span class=\"line\">action：接受请求的URL</span><br><span class=\"line\">elements：表单中所有控件的集合</span><br><span class=\"line\">length：表单中控件的数量</span><br><span class=\"line\">enctype：请求的编码类型</span><br><span class=\"line\">method：要发送的HTTP请求类型</span><br><span class=\"line\">target：用于发送请求和接收响应的窗口名称</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reset()：将表单域重置为默认值</span><br><span class=\"line\">submit()：提交表单</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二-获取表单元素的方法\"><a href=\"#二-获取表单元素的方法\" class=\"headerlink\" title=\"二. 获取表单元素的方法\"></a>二. 获取表单元素的方法</h3><h4 id=\"1-通过id值\"><a href=\"#1-通过id值\" class=\"headerlink\" title=\"1. 通过id值\"></a>1. 通过id值</h4><h4 id=\"2-通过document-forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\"><a href=\"#2-通过document-forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\" class=\"headerlink\" title=\"2. 通过document.forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单\"></a>2. 通过document.forms可以获取页面中所有的表单，然后通过数值索引或者name属性来获取表单</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"keyword\">var</span> firstForm = <span class=\"built_in\">document</span>.forms[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> myForm = <span class=\"built_in\">document</span>.forms[<span class=\"string\">\"表单的name值\"</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-提交表单的方法\"><a href=\"#三-提交表单的方法\" class=\"headerlink\" title=\"三. 提交表单的方法\"></a>三. 提交表单的方法</h3><h4 id=\"1-使用按钮-lt-input-gt-、-lt-button-gt\"><a href=\"#1-使用按钮-lt-input-gt-、-lt-button-gt\" class=\"headerlink\" title=\"1. 使用按钮&lt;input&gt;、&lt;button&gt;\"></a>1. 使用按钮<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code></h4><p>将<code>&lt;input&gt;</code>或者<code>&lt;button&gt;</code>的<strong>type属性值设为submit</strong>，那么<strong>按下按钮</strong>或者<strong>按下回车键</strong>都会提交表单。</p>\n<p>有一种特殊情况：图像按钮，将<code>&lt;input&gt;</code>的type值设为image<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"submit\"</span>&gt;</span><br><span class=\"line\">&lt;input type=\"image\" src=\"img.jpg\"&gt;</span><br><span class=\"line\">&lt;button type=\"submit\"&gt;</span><br></pre></td></tr></table></figure></p>\n<p>用这种方式提交表单时，会触发submit事件，这个事件的默认行为是将表单数据发送给服务器.</p>\n<font color=\"red\">这种方法来提交表单时会触发表单的onsubmit()事件。</font>\n\n<p>因此，可以在这个事件的监听函数里验证表单数据，如果数据无效，则取消事件的默认行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myForm\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">form.addElementListener(<span class=\"string\">\"submit\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//验证表单的一些数据是否正确</span></span><br><span class=\"line\">\tevent.preventDefault(event);<span class=\"comment\">//阻止表单提交</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form onsubmit=\"return submitFun();\"&gt; </span><br><span class=\"line\">//注意此处不能写成 onsubmit=\"submitFun();\"否则将表单总是提交</span><br><span class=\"line\">//原因：由于这个onsubmit是html中的事件属性，所以onsubmit的属性值应该为一个函数，写成 onsubmit=\"submitFun();\"那么每次提交表单都会触发 submitFun()函数</span><br><span class=\"line\">&lt;/form&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;  </span><br><span class=\"line\">\tfunction submitFun()&#123;  </span><br><span class=\"line\">\t    //逻辑判断  </span><br><span class=\"line\">\t    return true; //允许表单提交  </span><br><span class=\"line\">\t    //逻辑判断  </span><br><span class=\"line\">\t    return false;//不允许表单提交  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-在js里使用submit-方法来提交表单\"><a href=\"#2-在js里使用submit-方法来提交表单\" class=\"headerlink\" title=\"2. 在js里使用submit()方法来提交表单\"></a>2. 在js里使用submit()方法来提交表单</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myForm\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//需要在提交之前验证表单数据</span></span><br><span class=\"line\">form.submit();</span><br></pre></td></tr></table></figure>\n<font color=\"red\">直接使用form.submit()方法提交表单时，不会触发表单的onsubmit()事件。</font>\n\n<p>举个栗子验证一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form id=<span class=\"string\">\"myForm\"</span> onsubmit=<span class=\"string\">\"fun()\"</span>&gt;  </span><br><span class=\"line\">    &lt;input type=\"submit\" id=\"aaa\" value=\"submit\"&gt;//能弹出“触发了表单的onsubmit()事件”</span><br><span class=\"line\">      </span><br><span class=\"line\">\t&lt;input type=\"button\" id=\"bbb\" value=\"oncliCk_submit\" onclick=\"document.forms[0].submit()\"&gt; //不能出现弹出框</span><br><span class=\"line\">  </span><br><span class=\"line\">    &lt;input type=\"button\" id=\"bb1\" value=\"oncliCk_onsubmit\" onclick=\"document.forms[0].onsubmit()\"&gt; //能弹出“触发了表单的onsubmit()事件” </span><br><span class=\"line\">&lt;/form&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;  </span><br><span class=\"line\">    function fun()&#123;  </span><br><span class=\"line\">         alert(\"触发了表单的onsubmit()事件\");  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"如何避免表单的重复提交","date":"2016-06-15T16:00:00.000Z","description":null,"_content":"\n### 一. 表单的重复提交问题\n\n什么是表单的重复提交：在网速比较慢的情况下，用户提交表单之后，发现服务器半天没有响应，那么用户可能就会以为自己没有提交表单，就会再次点击按钮重复提交表单。\n\n**三种重复提交表单的场景：**\n\n- 网络很慢时，用户多次点击提交按钮\n\n- 表单提交之后，用户点击刷新按钮\n\n- 表单提交之后，用户后退到表单页面再次提交\n\n### 二. 避免重复提交的方法\n\n#### 1. 针对场景一：网络慢，用户多次点击submit按钮\n\n在客户端利用js的方法：\n\n**(1)用一个变量来标识表单是否已经提交**\n\n```js\n<!DOCTYPE HTML>\n <html>\n   <head>\n     <title>Form表单</title>\n         <script type=\"text/javascript\">\n           var submitFlag = false;//表单是否已经提交标识，默认为false\n           function dosubmit(){\n              if(submitFlag == false){\n                 submitFlag = true;//提交表单后，将表单是否已经提交标识设置为true\n                 return true;//返回true让表单正常提交\n\t          }else{\n\t             return false;//返回false那么表单将不提交\n\t          }\n            }\n     \t</script>\n   </head>\n   \n   <body>\n       <form onsubmit=\"return dosubmit()\" method=\"post\">\n          用户名：\n          <input type=\"text\" name=\"username\">\n          <input type=\"submit\" value=\"提交\" id=\"submit\">\n       </form>\n   </body>\n </html>\n```\n\n这种方法适用于用户点击按钮提交表单（这种方式会触发表单的`onsubmit()`事件）\n\n**(2)在第一次提交表单后禁用该按钮**\n\n**首先**，前端应该对用户所有的输入进行判断，验证通过之后允许用户做提交处理；\n\n**然后**，第一次提交之后，将按钮的disabled属性置为disabled\n\n    <input disabled=\"disabled\">\n\t<button disabled=\"disabled\">\n\n同时，在向后台发送http请求时，前端页面添加一个div，显示正在加载中；当请求成功时，将这个div隐藏掉。\n\n<font color=\"red\">这种解决办法的缺点：不能屏蔽**回车键**触发的提交请求！！！</font>\n\n#### 2. 针对场景二和场景三的问题\n\n在服务器端使用**令牌机制（Token）**解决:\n\n> 首先，当表单页面向服务器发起请求时，在服务器端生成一个Token(令牌)————唯一的随机标识号，用来标识这个用户。\n\n> 在当前用户的Session域中保存这个Token，同时在请求被响应时，表单页面发送给浏览器，将Token写入表单中的隐藏字段（用表单中的隐藏域来保存这个Token值）。\n\n> 然后，用户录入信息后点击提交。\n\n> 用户提交表单时，会将这个Token一起提交到服务器端。\n\n> 在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致。\n\n> **如果相同**，则处理表单提交，处理完后清除当前用户的Session域中存储的Token。\n\n> **如果服务器中的session中不存在这个Token**，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。\n\n场景二，表单提交之后，用户点击刷新按钮，会重新发起HTTP请求，这时页面中的表单隐藏域已经有Token值，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。\n\n场景三，表单提交之后，用户回退到表单页面，再次提交表单，这种情况下回退到表单页面是不会重新发起HTTP请求的，访问的是浏览器中缓存的页面，因此，表单的Token值还是之前那个，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。\n\n**什么是表单的隐藏域？**\n\n指的是在form内声明一个type类型为hidden的input，使用value的属性值来存取数据。\n```js\n<input type=\"hidden\" name=\"field＿name\" value=\"value\">\n```\n\n### <font color=\"red\">扩展的小知识：</font>\n \n验证码的原理与上面的令牌机制类似。\n\n**1. 什么是验证码**\n\n> 验证码一般是一串随机产生的数字或者符号，生成一副图片，图片里面加上一些干扰元素，由用户肉眼识别其中的验证码信息，然后输入表单提交网站验证，验证成功后才能使用某种功能。\n\n**2. 验证码的作用**\n\n用来区别计算机和人类。\n\n**3. 验证原理及流程**\n\n    服务器生产验证码\n    \n    发送给客户端\n    \n    在客户端显示\n    \n    用户根据显示输入验证码\n    \n    提交表单数据信息\n    \n    服务器根据提交的验证码信息和服务器端保存的字符是否相同\n    \n    如果相同，则通过验证\n    \n    如果不相同，则提示没有通过验证信息\n\n","source":"_posts/2016-06-16-如何避免表单的重复提交.md","raw":"---\nlayout: post\ntitle: 如何避免表单的重复提交\ndate: 2016-06-16\ncategories: http协议\ntags: [http]\ndescription: \n---\n\n### 一. 表单的重复提交问题\n\n什么是表单的重复提交：在网速比较慢的情况下，用户提交表单之后，发现服务器半天没有响应，那么用户可能就会以为自己没有提交表单，就会再次点击按钮重复提交表单。\n\n**三种重复提交表单的场景：**\n\n- 网络很慢时，用户多次点击提交按钮\n\n- 表单提交之后，用户点击刷新按钮\n\n- 表单提交之后，用户后退到表单页面再次提交\n\n### 二. 避免重复提交的方法\n\n#### 1. 针对场景一：网络慢，用户多次点击submit按钮\n\n在客户端利用js的方法：\n\n**(1)用一个变量来标识表单是否已经提交**\n\n```js\n<!DOCTYPE HTML>\n <html>\n   <head>\n     <title>Form表单</title>\n         <script type=\"text/javascript\">\n           var submitFlag = false;//表单是否已经提交标识，默认为false\n           function dosubmit(){\n              if(submitFlag == false){\n                 submitFlag = true;//提交表单后，将表单是否已经提交标识设置为true\n                 return true;//返回true让表单正常提交\n\t          }else{\n\t             return false;//返回false那么表单将不提交\n\t          }\n            }\n     \t</script>\n   </head>\n   \n   <body>\n       <form onsubmit=\"return dosubmit()\" method=\"post\">\n          用户名：\n          <input type=\"text\" name=\"username\">\n          <input type=\"submit\" value=\"提交\" id=\"submit\">\n       </form>\n   </body>\n </html>\n```\n\n这种方法适用于用户点击按钮提交表单（这种方式会触发表单的`onsubmit()`事件）\n\n**(2)在第一次提交表单后禁用该按钮**\n\n**首先**，前端应该对用户所有的输入进行判断，验证通过之后允许用户做提交处理；\n\n**然后**，第一次提交之后，将按钮的disabled属性置为disabled\n\n    <input disabled=\"disabled\">\n\t<button disabled=\"disabled\">\n\n同时，在向后台发送http请求时，前端页面添加一个div，显示正在加载中；当请求成功时，将这个div隐藏掉。\n\n<font color=\"red\">这种解决办法的缺点：不能屏蔽**回车键**触发的提交请求！！！</font>\n\n#### 2. 针对场景二和场景三的问题\n\n在服务器端使用**令牌机制（Token）**解决:\n\n> 首先，当表单页面向服务器发起请求时，在服务器端生成一个Token(令牌)————唯一的随机标识号，用来标识这个用户。\n\n> 在当前用户的Session域中保存这个Token，同时在请求被响应时，表单页面发送给浏览器，将Token写入表单中的隐藏字段（用表单中的隐藏域来保存这个Token值）。\n\n> 然后，用户录入信息后点击提交。\n\n> 用户提交表单时，会将这个Token一起提交到服务器端。\n\n> 在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致。\n\n> **如果相同**，则处理表单提交，处理完后清除当前用户的Session域中存储的Token。\n\n> **如果服务器中的session中不存在这个Token**，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。\n\n场景二，表单提交之后，用户点击刷新按钮，会重新发起HTTP请求，这时页面中的表单隐藏域已经有Token值，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。\n\n场景三，表单提交之后，用户回退到表单页面，再次提交表单，这种情况下回退到表单页面是不会重新发起HTTP请求的，访问的是浏览器中缓存的页面，因此，表单的Token值还是之前那个，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。\n\n**什么是表单的隐藏域？**\n\n指的是在form内声明一个type类型为hidden的input，使用value的属性值来存取数据。\n```js\n<input type=\"hidden\" name=\"field＿name\" value=\"value\">\n```\n\n### <font color=\"red\">扩展的小知识：</font>\n \n验证码的原理与上面的令牌机制类似。\n\n**1. 什么是验证码**\n\n> 验证码一般是一串随机产生的数字或者符号，生成一副图片，图片里面加上一些干扰元素，由用户肉眼识别其中的验证码信息，然后输入表单提交网站验证，验证成功后才能使用某种功能。\n\n**2. 验证码的作用**\n\n用来区别计算机和人类。\n\n**3. 验证原理及流程**\n\n    服务器生产验证码\n    \n    发送给客户端\n    \n    在客户端显示\n    \n    用户根据显示输入验证码\n    \n    提交表单数据信息\n    \n    服务器根据提交的验证码信息和服务器端保存的字符是否相同\n    \n    如果相同，则通过验证\n    \n    如果不相同，则提示没有通过验证信息\n\n","slug":"2016-06-16-如何避免表单的重复提交","published":1,"updated":"2016-09-24T14:40:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocii009ed5u8wil1qu3y","content":"<h3 id=\"一-表单的重复提交问题\"><a href=\"#一-表单的重复提交问题\" class=\"headerlink\" title=\"一. 表单的重复提交问题\"></a>一. 表单的重复提交问题</h3><p>什么是表单的重复提交：在网速比较慢的情况下，用户提交表单之后，发现服务器半天没有响应，那么用户可能就会以为自己没有提交表单，就会再次点击按钮重复提交表单。</p>\n<p><strong>三种重复提交表单的场景：</strong></p>\n<ul>\n<li><p>网络很慢时，用户多次点击提交按钮</p>\n</li>\n<li><p>表单提交之后，用户点击刷新按钮</p>\n</li>\n<li><p>表单提交之后，用户后退到表单页面再次提交</p>\n</li>\n</ul>\n<h3 id=\"二-避免重复提交的方法\"><a href=\"#二-避免重复提交的方法\" class=\"headerlink\" title=\"二. 避免重复提交的方法\"></a>二. 避免重复提交的方法</h3><h4 id=\"1-针对场景一：网络慢，用户多次点击submit按钮\"><a href=\"#1-针对场景一：网络慢，用户多次点击submit按钮\" class=\"headerlink\" title=\"1. 针对场景一：网络慢，用户多次点击submit按钮\"></a>1. 针对场景一：网络慢，用户多次点击submit按钮</h4><p>在客户端利用js的方法：</p>\n<p><strong>(1)用一个变量来标识表单是否已经提交</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\"> &lt;html&gt;</span><br><span class=\"line\">   &lt;head&gt;</span><br><span class=\"line\">     &lt;title&gt;Form表单&lt;/title&gt;</span><br><span class=\"line\">         &lt;script type=\"text/javascript\"&gt;</span><br><span class=\"line\">           var submitFlag = false;//表单是否已经提交标识，默认为false</span><br><span class=\"line\">           function dosubmit()&#123;</span><br><span class=\"line\">              if(submitFlag == false)&#123;</span><br><span class=\"line\">                 submitFlag = true;//提交表单后，将表单是否已经提交标识设置为true</span><br><span class=\"line\">                 return true;//返回true让表单正常提交</span><br><span class=\"line\">\t          &#125;else&#123;</span><br><span class=\"line\">\t             return false;//返回false那么表单将不提交</span><br><span class=\"line\">\t          &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">     \t&lt;/script&gt;</span><br><span class=\"line\">   &lt;/head&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;body&gt;</span><br><span class=\"line\">       &lt;form onsubmit=\"return dosubmit()\" method=\"post\"&gt;</span><br><span class=\"line\">          用户名：</span><br><span class=\"line\">          &lt;input type=\"text\" name=\"username\"&gt;</span><br><span class=\"line\">          &lt;input type=\"submit\" value=\"提交\" id=\"submit\"&gt;</span><br><span class=\"line\">       &lt;/form&gt;</span><br><span class=\"line\">   &lt;/body&gt;</span><br><span class=\"line\"> &lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>这种方法适用于用户点击按钮提交表单（这种方式会触发表单的<code>onsubmit()</code>事件）</p>\n<p><strong>(2)在第一次提交表单后禁用该按钮</strong></p>\n<p><strong>首先</strong>，前端应该对用户所有的输入进行判断，验证通过之后允许用户做提交处理；</p>\n<p><strong>然后</strong>，第一次提交之后，将按钮的disabled属性置为disabled</p>\n<pre><code>&lt;input disabled=&quot;disabled&quot;&gt;\n&lt;button disabled=&quot;disabled&quot;&gt;\n</code></pre><p>同时，在向后台发送http请求时，前端页面添加一个div，显示正在加载中；当请求成功时，将这个div隐藏掉。</p>\n<font color=\"red\">这种解决办法的缺点：不能屏蔽<strong>回车键</strong>触发的提交请求！！！</font>\n\n<h4 id=\"2-针对场景二和场景三的问题\"><a href=\"#2-针对场景二和场景三的问题\" class=\"headerlink\" title=\"2. 针对场景二和场景三的问题\"></a>2. 针对场景二和场景三的问题</h4><p>在服务器端使用<strong>令牌机制（Token）</strong>解决:</p>\n<blockquote>\n<p>首先，当表单页面向服务器发起请求时，在服务器端生成一个Token(令牌)————唯一的随机标识号，用来标识这个用户。</p>\n<p>在当前用户的Session域中保存这个Token，同时在请求被响应时，表单页面发送给浏览器，将Token写入表单中的隐藏字段（用表单中的隐藏域来保存这个Token值）。</p>\n<p>然后，用户录入信息后点击提交。</p>\n<p>用户提交表单时，会将这个Token一起提交到服务器端。</p>\n<p>在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致。</p>\n<p><strong>如果相同</strong>，则处理表单提交，处理完后清除当前用户的Session域中存储的Token。</p>\n<p><strong>如果服务器中的session中不存在这个Token</strong>，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。</p>\n</blockquote>\n<p>场景二，表单提交之后，用户点击刷新按钮，会重新发起HTTP请求，这时页面中的表单隐藏域已经有Token值，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。</p>\n<p>场景三，表单提交之后，用户回退到表单页面，再次提交表单，这种情况下回退到表单页面是不会重新发起HTTP请求的，访问的是浏览器中缓存的页面，因此，表单的Token值还是之前那个，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。</p>\n<p><strong>什么是表单的隐藏域？</strong></p>\n<p>指的是在form内声明一个type类型为hidden的input，使用value的属性值来存取数据。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"hidden\"</span> name=<span class=\"string\">\"field＿name\"</span> value=<span class=\"string\">\"value\"</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展的小知识：\"><a href=\"#扩展的小知识：\" class=\"headerlink\" title=\"扩展的小知识：\"></a><font color=\"red\">扩展的小知识：</font></h3><p>验证码的原理与上面的令牌机制类似。</p>\n<p><strong>1. 什么是验证码</strong></p>\n<blockquote>\n<p>验证码一般是一串随机产生的数字或者符号，生成一副图片，图片里面加上一些干扰元素，由用户肉眼识别其中的验证码信息，然后输入表单提交网站验证，验证成功后才能使用某种功能。</p>\n</blockquote>\n<p><strong>2. 验证码的作用</strong></p>\n<p>用来区别计算机和人类。</p>\n<p><strong>3. 验证原理及流程</strong></p>\n<pre><code>服务器生产验证码\n\n发送给客户端\n\n在客户端显示\n\n用户根据显示输入验证码\n\n提交表单数据信息\n\n服务器根据提交的验证码信息和服务器端保存的字符是否相同\n\n如果相同，则通过验证\n\n如果不相同，则提示没有通过验证信息\n</code></pre>","excerpt":"","more":"<h3 id=\"一-表单的重复提交问题\"><a href=\"#一-表单的重复提交问题\" class=\"headerlink\" title=\"一. 表单的重复提交问题\"></a>一. 表单的重复提交问题</h3><p>什么是表单的重复提交：在网速比较慢的情况下，用户提交表单之后，发现服务器半天没有响应，那么用户可能就会以为自己没有提交表单，就会再次点击按钮重复提交表单。</p>\n<p><strong>三种重复提交表单的场景：</strong></p>\n<ul>\n<li><p>网络很慢时，用户多次点击提交按钮</p>\n</li>\n<li><p>表单提交之后，用户点击刷新按钮</p>\n</li>\n<li><p>表单提交之后，用户后退到表单页面再次提交</p>\n</li>\n</ul>\n<h3 id=\"二-避免重复提交的方法\"><a href=\"#二-避免重复提交的方法\" class=\"headerlink\" title=\"二. 避免重复提交的方法\"></a>二. 避免重复提交的方法</h3><h4 id=\"1-针对场景一：网络慢，用户多次点击submit按钮\"><a href=\"#1-针对场景一：网络慢，用户多次点击submit按钮\" class=\"headerlink\" title=\"1. 针对场景一：网络慢，用户多次点击submit按钮\"></a>1. 针对场景一：网络慢，用户多次点击submit按钮</h4><p>在客户端利用js的方法：</p>\n<p><strong>(1)用一个变量来标识表单是否已经提交</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\"> &lt;html&gt;</span><br><span class=\"line\">   &lt;head&gt;</span><br><span class=\"line\">     &lt;title&gt;Form表单&lt;/title&gt;</span><br><span class=\"line\">         &lt;script type=\"text/javascript\"&gt;</span><br><span class=\"line\">           var submitFlag = false;//表单是否已经提交标识，默认为false</span><br><span class=\"line\">           function dosubmit()&#123;</span><br><span class=\"line\">              if(submitFlag == false)&#123;</span><br><span class=\"line\">                 submitFlag = true;//提交表单后，将表单是否已经提交标识设置为true</span><br><span class=\"line\">                 return true;//返回true让表单正常提交</span><br><span class=\"line\">\t          &#125;else&#123;</span><br><span class=\"line\">\t             return false;//返回false那么表单将不提交</span><br><span class=\"line\">\t          &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">     \t&lt;/script&gt;</span><br><span class=\"line\">   &lt;/head&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;body&gt;</span><br><span class=\"line\">       &lt;form onsubmit=\"return dosubmit()\" method=\"post\"&gt;</span><br><span class=\"line\">          用户名：</span><br><span class=\"line\">          &lt;input type=\"text\" name=\"username\"&gt;</span><br><span class=\"line\">          &lt;input type=\"submit\" value=\"提交\" id=\"submit\"&gt;</span><br><span class=\"line\">       &lt;/form&gt;</span><br><span class=\"line\">   &lt;/body&gt;</span><br><span class=\"line\"> &lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>这种方法适用于用户点击按钮提交表单（这种方式会触发表单的<code>onsubmit()</code>事件）</p>\n<p><strong>(2)在第一次提交表单后禁用该按钮</strong></p>\n<p><strong>首先</strong>，前端应该对用户所有的输入进行判断，验证通过之后允许用户做提交处理；</p>\n<p><strong>然后</strong>，第一次提交之后，将按钮的disabled属性置为disabled</p>\n<pre><code>&lt;input disabled=&quot;disabled&quot;&gt;\n&lt;button disabled=&quot;disabled&quot;&gt;\n</code></pre><p>同时，在向后台发送http请求时，前端页面添加一个div，显示正在加载中；当请求成功时，将这个div隐藏掉。</p>\n<font color=\"red\">这种解决办法的缺点：不能屏蔽<strong>回车键</strong>触发的提交请求！！！</font>\n\n<h4 id=\"2-针对场景二和场景三的问题\"><a href=\"#2-针对场景二和场景三的问题\" class=\"headerlink\" title=\"2. 针对场景二和场景三的问题\"></a>2. 针对场景二和场景三的问题</h4><p>在服务器端使用<strong>令牌机制（Token）</strong>解决:</p>\n<blockquote>\n<p>首先，当表单页面向服务器发起请求时，在服务器端生成一个Token(令牌)————唯一的随机标识号，用来标识这个用户。</p>\n<p>在当前用户的Session域中保存这个Token，同时在请求被响应时，表单页面发送给浏览器，将Token写入表单中的隐藏字段（用表单中的隐藏域来保存这个Token值）。</p>\n<p>然后，用户录入信息后点击提交。</p>\n<p>用户提交表单时，会将这个Token一起提交到服务器端。</p>\n<p>在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致。</p>\n<p><strong>如果相同</strong>，则处理表单提交，处理完后清除当前用户的Session域中存储的Token。</p>\n<p><strong>如果服务器中的session中不存在这个Token</strong>，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。</p>\n</blockquote>\n<p>场景二，表单提交之后，用户点击刷新按钮，会重新发起HTTP请求，这时页面中的表单隐藏域已经有Token值，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。</p>\n<p>场景三，表单提交之后，用户回退到表单页面，再次提交表单，这种情况下回退到表单页面是不会重新发起HTTP请求的，访问的是浏览器中缓存的页面，因此，表单的Token值还是之前那个，这时服务器中的session中的Token已经被删掉了（由于已经提交了一次），所以服务器不会处理第二次提交的表单数据。</p>\n<p><strong>什么是表单的隐藏域？</strong></p>\n<p>指的是在form内声明一个type类型为hidden的input，使用value的属性值来存取数据。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"hidden\"</span> name=<span class=\"string\">\"field＿name\"</span> value=<span class=\"string\">\"value\"</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展的小知识：\"><a href=\"#扩展的小知识：\" class=\"headerlink\" title=\"扩展的小知识：\"></a><font color=\"red\">扩展的小知识：</font></h3><p>验证码的原理与上面的令牌机制类似。</p>\n<p><strong>1. 什么是验证码</strong></p>\n<blockquote>\n<p>验证码一般是一串随机产生的数字或者符号，生成一副图片，图片里面加上一些干扰元素，由用户肉眼识别其中的验证码信息，然后输入表单提交网站验证，验证成功后才能使用某种功能。</p>\n</blockquote>\n<p><strong>2. 验证码的作用</strong></p>\n<p>用来区别计算机和人类。</p>\n<p><strong>3. 验证原理及流程</strong></p>\n<pre><code>服务器生产验证码\n\n发送给客户端\n\n在客户端显示\n\n用户根据显示输入验证码\n\n提交表单数据信息\n\n服务器根据提交的验证码信息和服务器端保存的字符是否相同\n\n如果相同，则通过验证\n\n如果不相同，则提示没有通过验证信息\n</code></pre>"},{"layout":"post","title":"浏览器的标签页是用多进程还是多线程实现","date":"2016-06-16T16:00:00.000Z","description":null,"_content":"\n### 一. 进程和线程的区别\n\n下面是在网上看到的一个科普贴：\n\n> - 单进程单线程：一个人在一个桌子上吃菜。\n> - 单进程多线程：多个人在同一个桌子上一起吃菜。\n> - 多进程单线程：多个人每个人在自己的桌子上吃菜。\n> \n> **多线程**的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说**资源共享就会发生冲突争抢**。\n> \n> 对于 Windows 系统来说，【开桌子】的开销很大(创建进程的时间开销很大)，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。\n> \n> 对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。\n\n**什么是进程？**\n\n进程是一个应用程序在处理机上的一次执行过程，可以申请和拥有系统资源，是一个动态的概念。\n\n**什么是线程？**\n\n线程是进程中的一部分，进程包含多个线程在运行。\n\n通常把**进程**作为**分配资源的基本单位**，而把**线程**作为**独立运行和独立调度的基本单位**\n\n### 二. 浏览器的标签页是用多线程还是多进程实现\n\n不同浏览器采用的实现方法是不一样的。\n\n**多进程浏览器：**\n\n- IE 10\n- chrome\n- opera 15或以上\n\n**多线程浏览器：**\n\n- IE 6\n- oprea 12或以上\n- Firefox\n\n可在windows任务管理器中查看：\n\n![浏览器是多进程还是多线程](/uploads/post/20160617/process.jpg)\n\n### 三. 多进程和多线程的比较\n\n**采用多进程的优点：**\n\n- 安全：现代系统都有进程的安全机制，单个进程有自己独立的内存空间\n- 稳定：不会因为一个线程的崩溃导致整个应用的崩溃\n- 性能\n\n**采用多进程的缺点：**\n\n- 内存占用大\n- 进程间通讯的成本大\n- 进程启动的开销大\n\n<font color=\"red\">现代浏览器为啥会更多地采用多进程？</font>\n\n> 现在的页面越来越复杂,H5, Webapp,或者Hybrid App等等，它们执行的任务越来越重，不再像以前都是文档类型的页面，现在的页面更像是一个应用。\n> \n> 们对系统资源的需求变大，同时不稳定的机率也增大。如果同时开启多个页面，就会引入更长的操作延迟，严重影响用户体验。\n> \n> 它页面浏览中核心的功能是页面的渲染(从DOM Tree到Render Tree)，JS的执行, 它是一个需要集中运算的功能，相对独立于系统资源的使用。而系统资源的使用又可以集中起来共享使用，也有利于将不安全的页面与系统资源隔离开来（沙箱机制的需求）。","source":"_posts/2016-06-17-浏览器的标签页是用多线程还是多进程实现.md","raw":"---\nlayout: post\ntitle: 浏览器的标签页是用多进程还是多线程实现\ndate: 2016-06-17\ncategories: 浏览器\ntags: [浏览器]\ndescription: \n---\n\n### 一. 进程和线程的区别\n\n下面是在网上看到的一个科普贴：\n\n> - 单进程单线程：一个人在一个桌子上吃菜。\n> - 单进程多线程：多个人在同一个桌子上一起吃菜。\n> - 多进程单线程：多个人每个人在自己的桌子上吃菜。\n> \n> **多线程**的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说**资源共享就会发生冲突争抢**。\n> \n> 对于 Windows 系统来说，【开桌子】的开销很大(创建进程的时间开销很大)，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。\n> \n> 对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。\n\n**什么是进程？**\n\n进程是一个应用程序在处理机上的一次执行过程，可以申请和拥有系统资源，是一个动态的概念。\n\n**什么是线程？**\n\n线程是进程中的一部分，进程包含多个线程在运行。\n\n通常把**进程**作为**分配资源的基本单位**，而把**线程**作为**独立运行和独立调度的基本单位**\n\n### 二. 浏览器的标签页是用多线程还是多进程实现\n\n不同浏览器采用的实现方法是不一样的。\n\n**多进程浏览器：**\n\n- IE 10\n- chrome\n- opera 15或以上\n\n**多线程浏览器：**\n\n- IE 6\n- oprea 12或以上\n- Firefox\n\n可在windows任务管理器中查看：\n\n![浏览器是多进程还是多线程](/uploads/post/20160617/process.jpg)\n\n### 三. 多进程和多线程的比较\n\n**采用多进程的优点：**\n\n- 安全：现代系统都有进程的安全机制，单个进程有自己独立的内存空间\n- 稳定：不会因为一个线程的崩溃导致整个应用的崩溃\n- 性能\n\n**采用多进程的缺点：**\n\n- 内存占用大\n- 进程间通讯的成本大\n- 进程启动的开销大\n\n<font color=\"red\">现代浏览器为啥会更多地采用多进程？</font>\n\n> 现在的页面越来越复杂,H5, Webapp,或者Hybrid App等等，它们执行的任务越来越重，不再像以前都是文档类型的页面，现在的页面更像是一个应用。\n> \n> 们对系统资源的需求变大，同时不稳定的机率也增大。如果同时开启多个页面，就会引入更长的操作延迟，严重影响用户体验。\n> \n> 它页面浏览中核心的功能是页面的渲染(从DOM Tree到Render Tree)，JS的执行, 它是一个需要集中运算的功能，相对独立于系统资源的使用。而系统资源的使用又可以集中起来共享使用，也有利于将不安全的页面与系统资源隔离开来（沙箱机制的需求）。","slug":"2016-06-17-浏览器的标签页是用多线程还是多进程实现","published":1,"updated":"2016-06-17T08:12:48.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocik009hd5u8b9nn2rvs","content":"<h3 id=\"一-进程和线程的区别\"><a href=\"#一-进程和线程的区别\" class=\"headerlink\" title=\"一. 进程和线程的区别\"></a>一. 进程和线程的区别</h3><p>下面是在网上看到的一个科普贴：</p>\n<blockquote>\n<ul>\n<li>单进程单线程：一个人在一个桌子上吃菜。</li>\n<li>单进程多线程：多个人在同一个桌子上一起吃菜。</li>\n<li>多进程单线程：多个人每个人在自己的桌子上吃菜。</li>\n</ul>\n<p><strong>多线程</strong>的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说<strong>资源共享就会发生冲突争抢</strong>。</p>\n<p>对于 Windows 系统来说，【开桌子】的开销很大(创建进程的时间开销很大)，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。</p>\n<p>对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。</p>\n</blockquote>\n<p><strong>什么是进程？</strong></p>\n<p>进程是一个应用程序在处理机上的一次执行过程，可以申请和拥有系统资源，是一个动态的概念。</p>\n<p><strong>什么是线程？</strong></p>\n<p>线程是进程中的一部分，进程包含多个线程在运行。</p>\n<p>通常把<strong>进程</strong>作为<strong>分配资源的基本单位</strong>，而把<strong>线程</strong>作为<strong>独立运行和独立调度的基本单位</strong></p>\n<h3 id=\"二-浏览器的标签页是用多线程还是多进程实现\"><a href=\"#二-浏览器的标签页是用多线程还是多进程实现\" class=\"headerlink\" title=\"二. 浏览器的标签页是用多线程还是多进程实现\"></a>二. 浏览器的标签页是用多线程还是多进程实现</h3><p>不同浏览器采用的实现方法是不一样的。</p>\n<p><strong>多进程浏览器：</strong></p>\n<ul>\n<li>IE 10</li>\n<li>chrome</li>\n<li>opera 15或以上</li>\n</ul>\n<p><strong>多线程浏览器：</strong></p>\n<ul>\n<li>IE 6</li>\n<li>oprea 12或以上</li>\n<li>Firefox</li>\n</ul>\n<p>可在windows任务管理器中查看：</p>\n<p><img src=\"/uploads/post/20160617/process.jpg\" alt=\"浏览器是多进程还是多线程\"></p>\n<h3 id=\"三-多进程和多线程的比较\"><a href=\"#三-多进程和多线程的比较\" class=\"headerlink\" title=\"三. 多进程和多线程的比较\"></a>三. 多进程和多线程的比较</h3><p><strong>采用多进程的优点：</strong></p>\n<ul>\n<li>安全：现代系统都有进程的安全机制，单个进程有自己独立的内存空间</li>\n<li>稳定：不会因为一个线程的崩溃导致整个应用的崩溃</li>\n<li>性能</li>\n</ul>\n<p><strong>采用多进程的缺点：</strong></p>\n<ul>\n<li>内存占用大</li>\n<li>进程间通讯的成本大</li>\n<li>进程启动的开销大</li>\n</ul>\n<font color=\"red\">现代浏览器为啥会更多地采用多进程？</font>\n\n<blockquote>\n<p>现在的页面越来越复杂,H5, Webapp,或者Hybrid App等等，它们执行的任务越来越重，不再像以前都是文档类型的页面，现在的页面更像是一个应用。</p>\n<p>们对系统资源的需求变大，同时不稳定的机率也增大。如果同时开启多个页面，就会引入更长的操作延迟，严重影响用户体验。</p>\n<p>它页面浏览中核心的功能是页面的渲染(从DOM Tree到Render Tree)，JS的执行, 它是一个需要集中运算的功能，相对独立于系统资源的使用。而系统资源的使用又可以集中起来共享使用，也有利于将不安全的页面与系统资源隔离开来（沙箱机制的需求）。</p>\n</blockquote>\n","excerpt":"","more":"<h3 id=\"一-进程和线程的区别\"><a href=\"#一-进程和线程的区别\" class=\"headerlink\" title=\"一. 进程和线程的区别\"></a>一. 进程和线程的区别</h3><p>下面是在网上看到的一个科普贴：</p>\n<blockquote>\n<ul>\n<li>单进程单线程：一个人在一个桌子上吃菜。</li>\n<li>单进程多线程：多个人在同一个桌子上一起吃菜。</li>\n<li>多进程单线程：多个人每个人在自己的桌子上吃菜。</li>\n</ul>\n<p><strong>多线程</strong>的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说<strong>资源共享就会发生冲突争抢</strong>。</p>\n<p>对于 Windows 系统来说，【开桌子】的开销很大(创建进程的时间开销很大)，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。</p>\n<p>对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。</p>\n</blockquote>\n<p><strong>什么是进程？</strong></p>\n<p>进程是一个应用程序在处理机上的一次执行过程，可以申请和拥有系统资源，是一个动态的概念。</p>\n<p><strong>什么是线程？</strong></p>\n<p>线程是进程中的一部分，进程包含多个线程在运行。</p>\n<p>通常把<strong>进程</strong>作为<strong>分配资源的基本单位</strong>，而把<strong>线程</strong>作为<strong>独立运行和独立调度的基本单位</strong></p>\n<h3 id=\"二-浏览器的标签页是用多线程还是多进程实现\"><a href=\"#二-浏览器的标签页是用多线程还是多进程实现\" class=\"headerlink\" title=\"二. 浏览器的标签页是用多线程还是多进程实现\"></a>二. 浏览器的标签页是用多线程还是多进程实现</h3><p>不同浏览器采用的实现方法是不一样的。</p>\n<p><strong>多进程浏览器：</strong></p>\n<ul>\n<li>IE 10</li>\n<li>chrome</li>\n<li>opera 15或以上</li>\n</ul>\n<p><strong>多线程浏览器：</strong></p>\n<ul>\n<li>IE 6</li>\n<li>oprea 12或以上</li>\n<li>Firefox</li>\n</ul>\n<p>可在windows任务管理器中查看：</p>\n<p><img src=\"/uploads/post/20160617/process.jpg\" alt=\"浏览器是多进程还是多线程\"></p>\n<h3 id=\"三-多进程和多线程的比较\"><a href=\"#三-多进程和多线程的比较\" class=\"headerlink\" title=\"三. 多进程和多线程的比较\"></a>三. 多进程和多线程的比较</h3><p><strong>采用多进程的优点：</strong></p>\n<ul>\n<li>安全：现代系统都有进程的安全机制，单个进程有自己独立的内存空间</li>\n<li>稳定：不会因为一个线程的崩溃导致整个应用的崩溃</li>\n<li>性能</li>\n</ul>\n<p><strong>采用多进程的缺点：</strong></p>\n<ul>\n<li>内存占用大</li>\n<li>进程间通讯的成本大</li>\n<li>进程启动的开销大</li>\n</ul>\n<font color=\"red\">现代浏览器为啥会更多地采用多进程？</font>\n\n<blockquote>\n<p>现在的页面越来越复杂,H5, Webapp,或者Hybrid App等等，它们执行的任务越来越重，不再像以前都是文档类型的页面，现在的页面更像是一个应用。</p>\n<p>们对系统资源的需求变大，同时不稳定的机率也增大。如果同时开启多个页面，就会引入更长的操作延迟，严重影响用户体验。</p>\n<p>它页面浏览中核心的功能是页面的渲染(从DOM Tree到Render Tree)，JS的执行, 它是一个需要集中运算的功能，相对独立于系统资源的使用。而系统资源的使用又可以集中起来共享使用，也有利于将不安全的页面与系统资源隔离开来（沙箱机制的需求）。</p>\n</blockquote>\n"},{"layout":"post","title":"session和cookie的区别和联系","date":"2016-06-15T16:00:00.000Z","description":null,"_content":"\n### 一. 理解session和cookie\n\nHTTP协议本身是无状态的（每一次请求之间是独立的）\n\ncookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。\n\nsession机制则是又一种在客户端与服务器之间保持状态的解决方案。\n\n> 让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： \n\n> 1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 \n\n> 2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 \n\n> 3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。\n\n> 由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 \n\n### 二. 理解cookie机制\n\ncookies是服务器用来标识web用户的一小块数据。\n\ncookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。\n\n- cookie如何分发\n- cookie的内容\n- 客户端如何使用cookie\n\n#### 1. cookie如何分发\n\n**a. 服务器在返回的响应报文中，通过Set-Cookie头部来设置cookie**\n\n```\nHTTP/1.1 200 OK\nContent-type: text/html\nSet-Cookie: name=value; domain=\"www.baidu.com\";\n```\n**b. 客户端将set-cookie首部中的内容保存下来，在下次发送请求时携带**\n\n```\nGET /index.html HTTP/1.1\nCookie: name=value;\n```\ncookie的数据始终在同源的http请求中携带，并且会来回传递。\n\n#### 2. cookie的内容\n\n- 名称name: cookie的名称\n- 值value: cookie中存放的内容\n- 过期时间end: 表示cookie何时会被删除\n- 域domain: cookie对于哪个域是有效的\n- 路径path: 指定域中的某个路径\n- 安全标志secure\n\n只有名称和值会被浏览器传回服务器端，其它内容都是服务器给浏览器的指示，不会做为浏览器发送到服务器cookie的一部分\n\n根据**过期时间**不同，将cookie分为**会话cookie**和**持久cookie**。\n\n<font color=\"red\">会话cookie和持久cookie的区别：</font>\n\n**过期时间：**\n\t\n\t会话cookie：没有设定过期时间的cookie都会被当成会话cookie\n\n\t持久cookie：设置了过期时间的cookie是\n\n**存储地点：**\n\n    cookie都是存在客户端的。但是不同类型的cookie存在客户端的位置不一样。\n\n    会话cookie：存储在内存里\n\n    持久cookie：存储在硬盘上\n\n**消失时间：**\n\n    会话cookie：由于会话cookie是存在内存中的，内存又是相对于进程分配的，因此进程关闭，会话cookie就会消失。\n\n\t\t\t   对于多进程浏览器（chrome、IE 10），浏览器的一个标签页就是一个进程，在浏览器窗口(标签页)关闭之后就会消失；\n\n\t\t\t   对于多线程浏览器（firefox），浏览器的一个标签页是一个线程，只有当浏览器窗口关闭才会消失（所有浏览器窗口都是一个进程）。\n\n    持久cookie：是在过期时间之后消失。\n\n**是否被浏览器不同页面共享：**\n\n\t会话cookie：不同浏览器的处理方式不同。\n\n\t\t\t   对于多进程浏览器（chrome、IE 10），是不能被浏览器的不同标签页共享\n\t\t\t\t\n\t\t\t   对于多线程浏览器（firefox）,是可以被浏览器的不同标签页共享\n\n\t\t\t   一般来说是用javascript的window.open()打开的窗口会与原窗口共享内存cookie。\n\n\t持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n\n**补充一点点：**\n\n不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。\n\n### 三. 理解session机制\n\n- session指的是会话，会话：指一个浏览器窗口打开到关闭的这个期间。\n \n- session机制：是指的一种服务器端的机制。用来在客户端与服务器之间保持状态的解决方案。\n \n**session的作用：**session是服务器用来识别不同用户的。\n\nsession是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现。\n\n**session**是保存在**服务器端**的；每个session会有一个唯一的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串。\n\n**session id**是被保存在**客户端**的,可以在cookie中保存这个session id。\n\nsession（服务器端） <===============> session id（客户端）\n  \n> 当程序需要为某个客户端的请求创建一个session的时候，\n\n> 服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），\n\n> 如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个）\n\n> 如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，这个session id将被在本次响应中返回给客户端保存。 \n\n关闭浏览器不会导致session被删除，服务器会为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。\n\n### 四. session和cookie的区别\n\n- cookie数据存放在客户的浏览器上，session数据放在服务器上。\n- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗（例如：如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的  cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。）；考虑到安全应当使用session。\n- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能；考虑到减轻服务器性能方面，应当使用cookie。\n- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n- 所以个人建议：将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。\n\n","source":"_posts/2016-06-16-session和cookie的区别.md","raw":"---\nlayout: post\ntitle: session和cookie的区别和联系\ndate: 2016-06-16\ncategories: http协议\ntags: [http]\ndescription: \n---\n\n### 一. 理解session和cookie\n\nHTTP协议本身是无状态的（每一次请求之间是独立的）\n\ncookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。\n\nsession机制则是又一种在客户端与服务器之间保持状态的解决方案。\n\n> 让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： \n\n> 1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 \n\n> 2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 \n\n> 3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。\n\n> 由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 \n\n### 二. 理解cookie机制\n\ncookies是服务器用来标识web用户的一小块数据。\n\ncookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。\n\n- cookie如何分发\n- cookie的内容\n- 客户端如何使用cookie\n\n#### 1. cookie如何分发\n\n**a. 服务器在返回的响应报文中，通过Set-Cookie头部来设置cookie**\n\n```\nHTTP/1.1 200 OK\nContent-type: text/html\nSet-Cookie: name=value; domain=\"www.baidu.com\";\n```\n**b. 客户端将set-cookie首部中的内容保存下来，在下次发送请求时携带**\n\n```\nGET /index.html HTTP/1.1\nCookie: name=value;\n```\ncookie的数据始终在同源的http请求中携带，并且会来回传递。\n\n#### 2. cookie的内容\n\n- 名称name: cookie的名称\n- 值value: cookie中存放的内容\n- 过期时间end: 表示cookie何时会被删除\n- 域domain: cookie对于哪个域是有效的\n- 路径path: 指定域中的某个路径\n- 安全标志secure\n\n只有名称和值会被浏览器传回服务器端，其它内容都是服务器给浏览器的指示，不会做为浏览器发送到服务器cookie的一部分\n\n根据**过期时间**不同，将cookie分为**会话cookie**和**持久cookie**。\n\n<font color=\"red\">会话cookie和持久cookie的区别：</font>\n\n**过期时间：**\n\t\n\t会话cookie：没有设定过期时间的cookie都会被当成会话cookie\n\n\t持久cookie：设置了过期时间的cookie是\n\n**存储地点：**\n\n    cookie都是存在客户端的。但是不同类型的cookie存在客户端的位置不一样。\n\n    会话cookie：存储在内存里\n\n    持久cookie：存储在硬盘上\n\n**消失时间：**\n\n    会话cookie：由于会话cookie是存在内存中的，内存又是相对于进程分配的，因此进程关闭，会话cookie就会消失。\n\n\t\t\t   对于多进程浏览器（chrome、IE 10），浏览器的一个标签页就是一个进程，在浏览器窗口(标签页)关闭之后就会消失；\n\n\t\t\t   对于多线程浏览器（firefox），浏览器的一个标签页是一个线程，只有当浏览器窗口关闭才会消失（所有浏览器窗口都是一个进程）。\n\n    持久cookie：是在过期时间之后消失。\n\n**是否被浏览器不同页面共享：**\n\n\t会话cookie：不同浏览器的处理方式不同。\n\n\t\t\t   对于多进程浏览器（chrome、IE 10），是不能被浏览器的不同标签页共享\n\t\t\t\t\n\t\t\t   对于多线程浏览器（firefox）,是可以被浏览器的不同标签页共享\n\n\t\t\t   一般来说是用javascript的window.open()打开的窗口会与原窗口共享内存cookie。\n\n\t持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n\n**补充一点点：**\n\n不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。\n\n### 三. 理解session机制\n\n- session指的是会话，会话：指一个浏览器窗口打开到关闭的这个期间。\n \n- session机制：是指的一种服务器端的机制。用来在客户端与服务器之间保持状态的解决方案。\n \n**session的作用：**session是服务器用来识别不同用户的。\n\nsession是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现。\n\n**session**是保存在**服务器端**的；每个session会有一个唯一的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串。\n\n**session id**是被保存在**客户端**的,可以在cookie中保存这个session id。\n\nsession（服务器端） <===============> session id（客户端）\n  \n> 当程序需要为某个客户端的请求创建一个session的时候，\n\n> 服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），\n\n> 如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个）\n\n> 如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，这个session id将被在本次响应中返回给客户端保存。 \n\n关闭浏览器不会导致session被删除，服务器会为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。\n\n### 四. session和cookie的区别\n\n- cookie数据存放在客户的浏览器上，session数据放在服务器上。\n- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗（例如：如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的  cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。）；考虑到安全应当使用session。\n- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能；考虑到减轻服务器性能方面，应当使用cookie。\n- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n- 所以个人建议：将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。\n\n","slug":"2016-06-16-session和cookie的区别","published":1,"updated":"2016-08-20T08:41:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocil009kd5u8o8drbxqu","content":"<h3 id=\"一-理解session和cookie\"><a href=\"#一-理解session和cookie\" class=\"headerlink\" title=\"一. 理解session和cookie\"></a>一. 理解session和cookie</h3><p>HTTP协议本身是无状态的（每一次请求之间是独立的）</p>\n<p>cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。</p>\n<p>session机制则是又一种在客户端与服务器之间保持状态的解决方案。</p>\n<blockquote>\n<p>让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： </p>\n<p>1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 </p>\n<p>2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 </p>\n<p>3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。</p>\n<p>由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 </p>\n</blockquote>\n<h3 id=\"二-理解cookie机制\"><a href=\"#二-理解cookie机制\" class=\"headerlink\" title=\"二. 理解cookie机制\"></a>二. 理解cookie机制</h3><p>cookies是服务器用来标识web用户的一小块数据。</p>\n<p>cookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。</p>\n<ul>\n<li>cookie如何分发</li>\n<li>cookie的内容</li>\n<li>客户端如何使用cookie</li>\n</ul>\n<h4 id=\"1-cookie如何分发\"><a href=\"#1-cookie如何分发\" class=\"headerlink\" title=\"1. cookie如何分发\"></a>1. cookie如何分发</h4><p><strong>a. 服务器在返回的响应报文中，通过Set-Cookie头部来设置cookie</strong></p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-type</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">Set-Cookie</span>: name=value; domain=\"www.baidu.com\";</span><br></pre></td></tr></table></figure>\n<p><strong>b. 客户端将set-cookie首部中的内容保存下来，在下次发送请求时携带</strong></p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Cookie</span>: name=value;</span><br></pre></td></tr></table></figure>\n<p>cookie的数据始终在同源的http请求中携带，并且会来回传递。</p>\n<h4 id=\"2-cookie的内容\"><a href=\"#2-cookie的内容\" class=\"headerlink\" title=\"2. cookie的内容\"></a>2. cookie的内容</h4><ul>\n<li>名称name: cookie的名称</li>\n<li>值value: cookie中存放的内容</li>\n<li>过期时间end: 表示cookie何时会被删除</li>\n<li>域domain: cookie对于哪个域是有效的</li>\n<li>路径path: 指定域中的某个路径</li>\n<li>安全标志secure</li>\n</ul>\n<p>只有名称和值会被浏览器传回服务器端，其它内容都是服务器给浏览器的指示，不会做为浏览器发送到服务器cookie的一部分</p>\n<p>根据<strong>过期时间</strong>不同，将cookie分为<strong>会话cookie</strong>和<strong>持久cookie</strong>。</p>\n<font color=\"red\">会话cookie和持久cookie的区别：</font>\n\n<p><strong>过期时间：</strong></p>\n<pre><code>会话cookie：没有设定过期时间的cookie都会被当成会话cookie\n\n持久cookie：设置了过期时间的cookie是\n</code></pre><p><strong>存储地点：</strong></p>\n<pre><code>cookie都是存在客户端的。但是不同类型的cookie存在客户端的位置不一样。\n\n会话cookie：存储在内存里\n\n持久cookie：存储在硬盘上\n</code></pre><p><strong>消失时间：</strong></p>\n<pre><code>会话cookie：由于会话cookie是存在内存中的，内存又是相对于进程分配的，因此进程关闭，会话cookie就会消失。\n\n           对于多进程浏览器（chrome、IE 10），浏览器的一个标签页就是一个进程，在浏览器窗口(标签页)关闭之后就会消失；\n\n           对于多线程浏览器（firefox），浏览器的一个标签页是一个线程，只有当浏览器窗口关闭才会消失（所有浏览器窗口都是一个进程）。\n\n持久cookie：是在过期时间之后消失。\n</code></pre><p><strong>是否被浏览器不同页面共享：</strong></p>\n<pre><code>会话cookie：不同浏览器的处理方式不同。\n\n           对于多进程浏览器（chrome、IE 10），是不能被浏览器的不同标签页共享\n\n           对于多线程浏览器（firefox）,是可以被浏览器的不同标签页共享\n\n           一般来说是用javascript的window.open()打开的窗口会与原窗口共享内存cookie。\n\n持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n</code></pre><p><strong>补充一点点：</strong></p>\n<p>不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。</p>\n<h3 id=\"三-理解session机制\"><a href=\"#三-理解session机制\" class=\"headerlink\" title=\"三. 理解session机制\"></a>三. 理解session机制</h3><ul>\n<li><p>session指的是会话，会话：指一个浏览器窗口打开到关闭的这个期间。</p>\n</li>\n<li><p>session机制：是指的一种服务器端的机制。用来在客户端与服务器之间保持状态的解决方案。</p>\n</li>\n</ul>\n<p><strong>session的作用：</strong>session是服务器用来识别不同用户的。</p>\n<p>session是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现。</p>\n<p><strong>session</strong>是保存在<strong>服务器端</strong>的；每个session会有一个唯一的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串。</p>\n<p><strong>session id</strong>是被保存在<strong>客户端</strong>的,可以在cookie中保存这个session id。</p>\n<p>session（服务器端） &lt;===============&gt; session id（客户端）</p>\n<blockquote>\n<p>当程序需要为某个客户端的请求创建一个session的时候，</p>\n<p>服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），</p>\n<p>如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个）</p>\n<p>如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，这个session id将被在本次响应中返回给客户端保存。 </p>\n</blockquote>\n<p>关闭浏览器不会导致session被删除，服务器会为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。</p>\n<h3 id=\"四-session和cookie的区别\"><a href=\"#四-session和cookie的区别\" class=\"headerlink\" title=\"四. session和cookie的区别\"></a>四. session和cookie的区别</h3><ul>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>\n<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗（例如：如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的  cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。）；考虑到安全应当使用session。</li>\n<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能；考虑到减轻服务器性能方面，应当使用cookie。</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>\n<li>所以个人建议：将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-理解session和cookie\"><a href=\"#一-理解session和cookie\" class=\"headerlink\" title=\"一. 理解session和cookie\"></a>一. 理解session和cookie</h3><p>HTTP协议本身是无状态的（每一次请求之间是独立的）</p>\n<p>cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。</p>\n<p>session机制则是又一种在客户端与服务器之间保持状态的解决方案。</p>\n<blockquote>\n<p>让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： </p>\n<p>1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 </p>\n<p>2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 </p>\n<p>3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。</p>\n<p>由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 </p>\n</blockquote>\n<h3 id=\"二-理解cookie机制\"><a href=\"#二-理解cookie机制\" class=\"headerlink\" title=\"二. 理解cookie机制\"></a>二. 理解cookie机制</h3><p>cookies是服务器用来标识web用户的一小块数据。</p>\n<p>cookies的基本思想就是让浏览器积累一组服务器特有的信息，并在客户端和服务器端来回传递。</p>\n<ul>\n<li>cookie如何分发</li>\n<li>cookie的内容</li>\n<li>客户端如何使用cookie</li>\n</ul>\n<h4 id=\"1-cookie如何分发\"><a href=\"#1-cookie如何分发\" class=\"headerlink\" title=\"1. cookie如何分发\"></a>1. cookie如何分发</h4><p><strong>a. 服务器在返回的响应报文中，通过Set-Cookie头部来设置cookie</strong></p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-type</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">Set-Cookie</span>: name=value; domain=\"www.baidu.com\";</span><br></pre></td></tr></table></figure>\n<p><strong>b. 客户端将set-cookie首部中的内容保存下来，在下次发送请求时携带</strong></p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Cookie</span>: name=value;</span><br></pre></td></tr></table></figure>\n<p>cookie的数据始终在同源的http请求中携带，并且会来回传递。</p>\n<h4 id=\"2-cookie的内容\"><a href=\"#2-cookie的内容\" class=\"headerlink\" title=\"2. cookie的内容\"></a>2. cookie的内容</h4><ul>\n<li>名称name: cookie的名称</li>\n<li>值value: cookie中存放的内容</li>\n<li>过期时间end: 表示cookie何时会被删除</li>\n<li>域domain: cookie对于哪个域是有效的</li>\n<li>路径path: 指定域中的某个路径</li>\n<li>安全标志secure</li>\n</ul>\n<p>只有名称和值会被浏览器传回服务器端，其它内容都是服务器给浏览器的指示，不会做为浏览器发送到服务器cookie的一部分</p>\n<p>根据<strong>过期时间</strong>不同，将cookie分为<strong>会话cookie</strong>和<strong>持久cookie</strong>。</p>\n<font color=\"red\">会话cookie和持久cookie的区别：</font>\n\n<p><strong>过期时间：</strong></p>\n<pre><code>会话cookie：没有设定过期时间的cookie都会被当成会话cookie\n\n持久cookie：设置了过期时间的cookie是\n</code></pre><p><strong>存储地点：</strong></p>\n<pre><code>cookie都是存在客户端的。但是不同类型的cookie存在客户端的位置不一样。\n\n会话cookie：存储在内存里\n\n持久cookie：存储在硬盘上\n</code></pre><p><strong>消失时间：</strong></p>\n<pre><code>会话cookie：由于会话cookie是存在内存中的，内存又是相对于进程分配的，因此进程关闭，会话cookie就会消失。\n\n           对于多进程浏览器（chrome、IE 10），浏览器的一个标签页就是一个进程，在浏览器窗口(标签页)关闭之后就会消失；\n\n           对于多线程浏览器（firefox），浏览器的一个标签页是一个线程，只有当浏览器窗口关闭才会消失（所有浏览器窗口都是一个进程）。\n\n持久cookie：是在过期时间之后消失。\n</code></pre><p><strong>是否被浏览器不同页面共享：</strong></p>\n<pre><code>会话cookie：不同浏览器的处理方式不同。\n\n           对于多进程浏览器（chrome、IE 10），是不能被浏览器的不同标签页共享\n\n           对于多线程浏览器（firefox）,是可以被浏览器的不同标签页共享\n\n           一般来说是用javascript的window.open()打开的窗口会与原窗口共享内存cookie。\n\n持久cookie：是存在电脑硬盘里，是可以被同一个浏览器的所有页面共享的（无论是多进程还是多线程浏览器）；\n</code></pre><p><strong>补充一点点：</strong></p>\n<p>不同浏览器之间不能共享cookie，因为每个浏览器存cookie路径不是一样的。</p>\n<h3 id=\"三-理解session机制\"><a href=\"#三-理解session机制\" class=\"headerlink\" title=\"三. 理解session机制\"></a>三. 理解session机制</h3><ul>\n<li><p>session指的是会话，会话：指一个浏览器窗口打开到关闭的这个期间。</p>\n</li>\n<li><p>session机制：是指的一种服务器端的机制。用来在客户端与服务器之间保持状态的解决方案。</p>\n</li>\n</ul>\n<p><strong>session的作用：</strong>session是服务器用来识别不同用户的。</p>\n<p>session是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现。</p>\n<p><strong>session</strong>是保存在<strong>服务器端</strong>的；每个session会有一个唯一的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串。</p>\n<p><strong>session id</strong>是被保存在<strong>客户端</strong>的,可以在cookie中保存这个session id。</p>\n<p>session（服务器端） &lt;===============&gt; session id（客户端）</p>\n<blockquote>\n<p>当程序需要为某个客户端的请求创建一个session的时候，</p>\n<p>服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），</p>\n<p>如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个）</p>\n<p>如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，这个session id将被在本次响应中返回给客户端保存。 </p>\n</blockquote>\n<p>关闭浏览器不会导致session被删除，服务器会为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。</p>\n<h3 id=\"四-session和cookie的区别\"><a href=\"#四-session和cookie的区别\" class=\"headerlink\" title=\"四. session和cookie的区别\"></a>四. session和cookie的区别</h3><ul>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>\n<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗（例如：如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的  cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。）；考虑到安全应当使用session。</li>\n<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能；考虑到减轻服务器性能方面，应当使用cookie。</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>\n<li>所以个人建议：将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</li>\n</ul>\n"},{"layout":"post","title":"浏览器跨标签页通信","date":"2016-06-16T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是浏览器跨标签页通信\n\n举个栗子：\n\n    同一个浏览器，使用一个标签页打开淘宝，并登陆上去；\n\t然后再打开另外一个标签页，也打开淘宝的网页，\n\t你会发现，在第二个页面上，你也是处于登陆的状态。\n\t当在第二个页面注销登陆时，在第一个页面再刷新页面或者进行下面的操作时，就会重定向到登陆页面。\n\n### 二. 实现浏览器的跨标签页通信\n\n#### 1. 使用localStorage\n\n不论在哪个浏览器的标签页里访问了`localStorage`，所有其它的标签页都能通过 `window` 对象监听到这个事件。\n\n```js\nwindow.addEventListener('storage', function (event) {\n  console.log(event.key, event.newValue);\n});\n```\n\n#### 2. 使用cookie\n\n一个浏览器的所有标签页都是可以共享持久cookie的，但是只有同源的标签页可以共享\n\n#### 3. 使用HTML5的window.postMessage方法跨域\n\n跨文档通信\n\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，允许跨窗口通信，无论这两个窗口是否同源\n\n#### 4. 使用window.name\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。\n\n无论这些页面是否同源，前一个网页设置了window.name，后一个网页就可以访问。\n\n\n","source":"_posts/2016-06-17-浏览器跨标签页通信.md","raw":"---\nlayout: post\ntitle: 浏览器跨标签页通信\ndate: 2016-06-17\ncategories: 浏览器\ntags: [浏览器]\ndescription: \n---\n\n### 一. 什么是浏览器跨标签页通信\n\n举个栗子：\n\n    同一个浏览器，使用一个标签页打开淘宝，并登陆上去；\n\t然后再打开另外一个标签页，也打开淘宝的网页，\n\t你会发现，在第二个页面上，你也是处于登陆的状态。\n\t当在第二个页面注销登陆时，在第一个页面再刷新页面或者进行下面的操作时，就会重定向到登陆页面。\n\n### 二. 实现浏览器的跨标签页通信\n\n#### 1. 使用localStorage\n\n不论在哪个浏览器的标签页里访问了`localStorage`，所有其它的标签页都能通过 `window` 对象监听到这个事件。\n\n```js\nwindow.addEventListener('storage', function (event) {\n  console.log(event.key, event.newValue);\n});\n```\n\n#### 2. 使用cookie\n\n一个浏览器的所有标签页都是可以共享持久cookie的，但是只有同源的标签页可以共享\n\n#### 3. 使用HTML5的window.postMessage方法跨域\n\n跨文档通信\n\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，允许跨窗口通信，无论这两个窗口是否同源\n\n#### 4. 使用window.name\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。\n\n无论这些页面是否同源，前一个网页设置了window.name，后一个网页就可以访问。\n\n\n","slug":"2016-06-17-浏览器跨标签页通信","published":1,"updated":"2016-09-20T11:24:16.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocin009od5u8owzr0o38","content":"<h3 id=\"一-什么是浏览器跨标签页通信\"><a href=\"#一-什么是浏览器跨标签页通信\" class=\"headerlink\" title=\"一. 什么是浏览器跨标签页通信\"></a>一. 什么是浏览器跨标签页通信</h3><p>举个栗子：</p>\n<pre><code>同一个浏览器，使用一个标签页打开淘宝，并登陆上去；\n然后再打开另外一个标签页，也打开淘宝的网页，\n你会发现，在第二个页面上，你也是处于登陆的状态。\n当在第二个页面注销登陆时，在第一个页面再刷新页面或者进行下面的操作时，就会重定向到登陆页面。\n</code></pre><h3 id=\"二-实现浏览器的跨标签页通信\"><a href=\"#二-实现浏览器的跨标签页通信\" class=\"headerlink\" title=\"二. 实现浏览器的跨标签页通信\"></a>二. 实现浏览器的跨标签页通信</h3><h4 id=\"1-使用localStorage\"><a href=\"#1-使用localStorage\" class=\"headerlink\" title=\"1. 使用localStorage\"></a>1. 使用localStorage</h4><p>不论在哪个浏览器的标签页里访问了<code>localStorage</code>，所有其它的标签页都能通过 <code>window</code> 对象监听到这个事件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'storage'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(event.key, event.newValue);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用cookie\"><a href=\"#2-使用cookie\" class=\"headerlink\" title=\"2. 使用cookie\"></a>2. 使用cookie</h4><p>一个浏览器的所有标签页都是可以共享持久cookie的，但是只有同源的标签页可以共享</p>\n<h4 id=\"3-使用HTML5的window-postMessage方法跨域\"><a href=\"#3-使用HTML5的window-postMessage方法跨域\" class=\"headerlink\" title=\"3. 使用HTML5的window.postMessage方法跨域\"></a>3. 使用HTML5的window.postMessage方法跨域</h4><p>跨文档通信</p>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，允许跨窗口通信，无论这两个窗口是否同源</p>\n<h4 id=\"4-使用window-name\"><a href=\"#4-使用window-name\" class=\"headerlink\" title=\"4. 使用window.name\"></a>4. 使用window.name</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p>\n<p>无论这些页面是否同源，前一个网页设置了window.name，后一个网页就可以访问。</p>\n","excerpt":"","more":"<h3 id=\"一-什么是浏览器跨标签页通信\"><a href=\"#一-什么是浏览器跨标签页通信\" class=\"headerlink\" title=\"一. 什么是浏览器跨标签页通信\"></a>一. 什么是浏览器跨标签页通信</h3><p>举个栗子：</p>\n<pre><code>同一个浏览器，使用一个标签页打开淘宝，并登陆上去；\n然后再打开另外一个标签页，也打开淘宝的网页，\n你会发现，在第二个页面上，你也是处于登陆的状态。\n当在第二个页面注销登陆时，在第一个页面再刷新页面或者进行下面的操作时，就会重定向到登陆页面。\n</code></pre><h3 id=\"二-实现浏览器的跨标签页通信\"><a href=\"#二-实现浏览器的跨标签页通信\" class=\"headerlink\" title=\"二. 实现浏览器的跨标签页通信\"></a>二. 实现浏览器的跨标签页通信</h3><h4 id=\"1-使用localStorage\"><a href=\"#1-使用localStorage\" class=\"headerlink\" title=\"1. 使用localStorage\"></a>1. 使用localStorage</h4><p>不论在哪个浏览器的标签页里访问了<code>localStorage</code>，所有其它的标签页都能通过 <code>window</code> 对象监听到这个事件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'storage'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(event.key, event.newValue);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用cookie\"><a href=\"#2-使用cookie\" class=\"headerlink\" title=\"2. 使用cookie\"></a>2. 使用cookie</h4><p>一个浏览器的所有标签页都是可以共享持久cookie的，但是只有同源的标签页可以共享</p>\n<h4 id=\"3-使用HTML5的window-postMessage方法跨域\"><a href=\"#3-使用HTML5的window-postMessage方法跨域\" class=\"headerlink\" title=\"3. 使用HTML5的window.postMessage方法跨域\"></a>3. 使用HTML5的window.postMessage方法跨域</h4><p>跨文档通信</p>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，允许跨窗口通信，无论这两个窗口是否同源</p>\n<h4 id=\"4-使用window-name\"><a href=\"#4-使用window-name\" class=\"headerlink\" title=\"4. 使用window.name\"></a>4. 使用window.name</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p>\n<p>无论这些页面是否同源，前一个网页设置了window.name，后一个网页就可以访问。</p>\n"},{"layout":"post","title":"编写高质量代码————HTML、CSS","date":"2016-06-17T16:00:00.000Z","description":null,"_content":"\nweb标准：结构（HTML）、样式（CSS）、行为（javascript）分离\n\n代码注释：要养成添加注释的好习惯，能增加代码的可读性。\n\n公共组件和私有组件的维护：提高代码的重用性。\n公共组件：接口保持弹性，且高度模块化。\n\n如何组织公有组件：\n\n两种方法：集中和分散。\n\n将所有的公共组件打包好，一次性载入：jQuery\n将公共组件划分成一个个小的模块，按需加载:YUI\n\n### 一. 高质量的HTML\n\n#### 1. 注意标签的语义性\n\n使用语义化的标签，在去掉网页的样式之后，网页依然有很好的结构和可读性。\n\n(1) 标题和内容\n\n    <h1></h1>\n\n(2) 表单`<form>`\n\n- 表单域用`<fieldset>`标签包起来，`<fieldset>`的`border`设为`none`\n- 用`<legend>`标签说明表单的用途，`<legend>`的`display`设为`none`\n- 每一个`<input>`的说明文字需要用`<label>`标签，`<label>`的`for`属性设置为`<input>的id值`\n\neg:\n\n```js\n<form>\n\t<fieldset border=\"none\">\n\t\t<legend display=\"none\">登录表单</legend>\n\n\t\t<p><label for=\"name\">姓名:</label><input type=\"text\" id=\"name\"></p>\n\n\t\t<p><label for=\"name\">密码：</label><input type=\"password\" id=\"name\"></p>\n\t</fieldset>\n</form>\n```\n\n(3) 表格`<table>`\n\n- `<table>`\n- `<thead>`\n- `<tbody>`\n- `<tfoot>`\n- `<tr>`\n- `<td>`\n- `<th>`\n\n- 表格标题用`<caption>`\n- 表头用`<thead>`，表头里面的单元格用`<th>`\n- 表格主题部分用`<tbody>`,每行用`<tr>`,每个单元格用`<td>`\n- 表格尾部用`<tfoot>`\n\neg:\n\n```js\n<table>\n\t<caption>几种实现页面的比较</caption>\n\t<thead>\n\t\t<th>实现方式</th>\n\t\t<th>代码量</th>\n\t\t<th>兼容性</th>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>tabel布局</th>\n\t\t\t<td>多</td>\n\t\t\t<td>一般</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th>CSS布局</th>\n\t\t\t<td>少</td>\n\t\t\t<td>好</td>\n\t\t</tr>\n\t</tbody>\n</table>\n```\n\n### 二. 高质量的CSS\n\ncss的使用分为两个层面：使用css的API、如何组织css\n\n#### 1. 组织css的方法\n\n将网页中的样式按照职能分为3大类：\n\n- base.css\n- common.css\n- page.css\n\n**base.css**会被所有页面引用，是页面样式所需要的最底层，与具体的UI无关。\n\n**common.css**里面放的是大量重复的模块，以组件的形式提取出来。\n\n**page.css**里面放的每个页面独有的样式，每个页面都会有自己的page.css（也可以将每个页面的page.css放在同一个css文件里，然后根据页面配上注释）\n\n举一个base.css的例子：\n\n```js\n/css reset/\nbody, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td{\n\tmargin: 0;\n\tpadding: 0\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\nfieldset, img {border: 0;}\naddress, caption, cite, code, dfn, em, strong, th, var {\n\tfont-style: normal;\n\tfont-weight: normal;\n}\nol, ul {list-style: none;}\ncaption, th {text-align: left;}\nh1, h2, h3, h4, h5, h6 {font-size: 100%; font-weight: normal;}\nq:before, q:after {content: \"\"}\nabbr, acronym {border: 0}\n\n/*文字排版*/\n.f12 {font-size: 12px;}\n.f13 {font-size: 13px;}\n.f14 {font-size: 14px;}\n.f15 {font-size: 15px;}\n\n/*定位*/\n.tl {text-align: left;}\n.tc {text-align: center;}\n\n/*宽度高度*/\n.w {width: 100%;}\n.w10 {width: 10px;}\n.w100 {width: 100px;}\n\n/*边距*/\n.m10 {margin: 10px;}\n.mt10 {margin-top: 10px;}\n.mb10 {margin-botton: 10px;}\n.ml10 {maegin-left: 10px;}\n.mr10 {margin-right: 10px;}\n.p10 {padding: 10px;}\n.pt10 {padding-top: 10px;}\n.pb10 {padding-bottom: 10px;}\n.pl10 {padding-left: 10px;}\n.pr10 {padding-right: 10px;}\n```\n\n上面的代码没有给出全部的来，详细的见\n\n\n其中，base.css包括两个部分：**css reset**和**通用原子类**。\n\n**css reset**部分是出自雅虎的前端框架YUI。用来覆盖掉浏览器的默认样式。\n\n**通用原子类**包括文字、定位、长宽、边距。通用性，原子性（不可再分）。\n\n#### 2. 模块化css\n\n借用面向对象的思想，将相同的组件的样式提取成一个模块。\n\n提取模块的思想：**多用组合，少用继承**。将一个复杂的类拆分成：容易产生变化的类和相对稳定的类。\n\n将模块中不稳定的类单独变成一个类，例如：margin-top值\n\n<font color=\"red\">注意：不要同时使用margin-top,margin-bottom;相邻模块的margin-top和margin-bottom可能会重合。</font>\n\n#### 3. css的命名\n\n为了方便区分单词，可使用的两种命名方式\n\n- 驼峰命名法 firstWord\n- 划线命名法 first-word\n\n虽然说命名并没有什么特殊的规定，但是好的命名会使代码的可读性更高。\n\n推荐一种命名方式：\n\n使用驼峰命名法区分不同的单词，使用划线表示从属关系。\n\n举个栗子：\n\n```js\n<ul class=\"timeList\">\n\t<li>1</li>\n\t<li>2</li>\n\t<li class=\"timeList-lastItem\">3</li>\n</ul>\n```\n\n若团队合作中两个人的css代码冲突了，可以使用加前缀的方式：\n\n```js\npan-timeList {...}\npan-timeList-lastItem {...}\n```\n\n#### 4. css选择器的权重\n\n- 行内样式style:**1000**\n- ID选择器：**100**\n- 类class/属性选择器/伪类(:hover/:focus等)：**10**\n- 元素(标签)/伪元素：**1**\n\n<font color=\"red\">注意：**伪类**指的是一种状态，例如hover，active；**伪元素**指的是文档的某个特定部分的表现。</font>\n\n    权重的计算：\n    \n    body #content .data img:hover\n    \n    权重为：1 + 100 + 10 + 1 + 10 = 122\n\n\t不同的权重，权重高的有效；\n\t相同的权重，后定义的有效。\n\n#### 5. CSS hack\n\n**(1)IE条件注释法**\n\n针对IE浏览器，下面这个css文件只会被IE浏览器下载。\n\n<!-- [if IE]>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"css.css\">\n<![end if]-->\n\n**(2)选择符前缀法**\n\n**(3)属性前缀法**\n\na标签的4个伪类的顺序：lovehate**(:link，visited，hover，active)**","source":"_posts/2016-06-18-编写高质量代码——HTML、CSS.md","raw":"---\nlayout: post\ntitle: 编写高质量代码————HTML、CSS\ndate: 2016-06-18\ncategories: 前端笔记\ntags: [读书笔记,HTML,css]\ndescription: \n---\n\nweb标准：结构（HTML）、样式（CSS）、行为（javascript）分离\n\n代码注释：要养成添加注释的好习惯，能增加代码的可读性。\n\n公共组件和私有组件的维护：提高代码的重用性。\n公共组件：接口保持弹性，且高度模块化。\n\n如何组织公有组件：\n\n两种方法：集中和分散。\n\n将所有的公共组件打包好，一次性载入：jQuery\n将公共组件划分成一个个小的模块，按需加载:YUI\n\n### 一. 高质量的HTML\n\n#### 1. 注意标签的语义性\n\n使用语义化的标签，在去掉网页的样式之后，网页依然有很好的结构和可读性。\n\n(1) 标题和内容\n\n    <h1></h1>\n\n(2) 表单`<form>`\n\n- 表单域用`<fieldset>`标签包起来，`<fieldset>`的`border`设为`none`\n- 用`<legend>`标签说明表单的用途，`<legend>`的`display`设为`none`\n- 每一个`<input>`的说明文字需要用`<label>`标签，`<label>`的`for`属性设置为`<input>的id值`\n\neg:\n\n```js\n<form>\n\t<fieldset border=\"none\">\n\t\t<legend display=\"none\">登录表单</legend>\n\n\t\t<p><label for=\"name\">姓名:</label><input type=\"text\" id=\"name\"></p>\n\n\t\t<p><label for=\"name\">密码：</label><input type=\"password\" id=\"name\"></p>\n\t</fieldset>\n</form>\n```\n\n(3) 表格`<table>`\n\n- `<table>`\n- `<thead>`\n- `<tbody>`\n- `<tfoot>`\n- `<tr>`\n- `<td>`\n- `<th>`\n\n- 表格标题用`<caption>`\n- 表头用`<thead>`，表头里面的单元格用`<th>`\n- 表格主题部分用`<tbody>`,每行用`<tr>`,每个单元格用`<td>`\n- 表格尾部用`<tfoot>`\n\neg:\n\n```js\n<table>\n\t<caption>几种实现页面的比较</caption>\n\t<thead>\n\t\t<th>实现方式</th>\n\t\t<th>代码量</th>\n\t\t<th>兼容性</th>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>tabel布局</th>\n\t\t\t<td>多</td>\n\t\t\t<td>一般</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th>CSS布局</th>\n\t\t\t<td>少</td>\n\t\t\t<td>好</td>\n\t\t</tr>\n\t</tbody>\n</table>\n```\n\n### 二. 高质量的CSS\n\ncss的使用分为两个层面：使用css的API、如何组织css\n\n#### 1. 组织css的方法\n\n将网页中的样式按照职能分为3大类：\n\n- base.css\n- common.css\n- page.css\n\n**base.css**会被所有页面引用，是页面样式所需要的最底层，与具体的UI无关。\n\n**common.css**里面放的是大量重复的模块，以组件的形式提取出来。\n\n**page.css**里面放的每个页面独有的样式，每个页面都会有自己的page.css（也可以将每个页面的page.css放在同一个css文件里，然后根据页面配上注释）\n\n举一个base.css的例子：\n\n```js\n/css reset/\nbody, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td{\n\tmargin: 0;\n\tpadding: 0\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\nfieldset, img {border: 0;}\naddress, caption, cite, code, dfn, em, strong, th, var {\n\tfont-style: normal;\n\tfont-weight: normal;\n}\nol, ul {list-style: none;}\ncaption, th {text-align: left;}\nh1, h2, h3, h4, h5, h6 {font-size: 100%; font-weight: normal;}\nq:before, q:after {content: \"\"}\nabbr, acronym {border: 0}\n\n/*文字排版*/\n.f12 {font-size: 12px;}\n.f13 {font-size: 13px;}\n.f14 {font-size: 14px;}\n.f15 {font-size: 15px;}\n\n/*定位*/\n.tl {text-align: left;}\n.tc {text-align: center;}\n\n/*宽度高度*/\n.w {width: 100%;}\n.w10 {width: 10px;}\n.w100 {width: 100px;}\n\n/*边距*/\n.m10 {margin: 10px;}\n.mt10 {margin-top: 10px;}\n.mb10 {margin-botton: 10px;}\n.ml10 {maegin-left: 10px;}\n.mr10 {margin-right: 10px;}\n.p10 {padding: 10px;}\n.pt10 {padding-top: 10px;}\n.pb10 {padding-bottom: 10px;}\n.pl10 {padding-left: 10px;}\n.pr10 {padding-right: 10px;}\n```\n\n上面的代码没有给出全部的来，详细的见\n\n\n其中，base.css包括两个部分：**css reset**和**通用原子类**。\n\n**css reset**部分是出自雅虎的前端框架YUI。用来覆盖掉浏览器的默认样式。\n\n**通用原子类**包括文字、定位、长宽、边距。通用性，原子性（不可再分）。\n\n#### 2. 模块化css\n\n借用面向对象的思想，将相同的组件的样式提取成一个模块。\n\n提取模块的思想：**多用组合，少用继承**。将一个复杂的类拆分成：容易产生变化的类和相对稳定的类。\n\n将模块中不稳定的类单独变成一个类，例如：margin-top值\n\n<font color=\"red\">注意：不要同时使用margin-top,margin-bottom;相邻模块的margin-top和margin-bottom可能会重合。</font>\n\n#### 3. css的命名\n\n为了方便区分单词，可使用的两种命名方式\n\n- 驼峰命名法 firstWord\n- 划线命名法 first-word\n\n虽然说命名并没有什么特殊的规定，但是好的命名会使代码的可读性更高。\n\n推荐一种命名方式：\n\n使用驼峰命名法区分不同的单词，使用划线表示从属关系。\n\n举个栗子：\n\n```js\n<ul class=\"timeList\">\n\t<li>1</li>\n\t<li>2</li>\n\t<li class=\"timeList-lastItem\">3</li>\n</ul>\n```\n\n若团队合作中两个人的css代码冲突了，可以使用加前缀的方式：\n\n```js\npan-timeList {...}\npan-timeList-lastItem {...}\n```\n\n#### 4. css选择器的权重\n\n- 行内样式style:**1000**\n- ID选择器：**100**\n- 类class/属性选择器/伪类(:hover/:focus等)：**10**\n- 元素(标签)/伪元素：**1**\n\n<font color=\"red\">注意：**伪类**指的是一种状态，例如hover，active；**伪元素**指的是文档的某个特定部分的表现。</font>\n\n    权重的计算：\n    \n    body #content .data img:hover\n    \n    权重为：1 + 100 + 10 + 1 + 10 = 122\n\n\t不同的权重，权重高的有效；\n\t相同的权重，后定义的有效。\n\n#### 5. CSS hack\n\n**(1)IE条件注释法**\n\n针对IE浏览器，下面这个css文件只会被IE浏览器下载。\n\n<!-- [if IE]>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"css.css\">\n<![end if]-->\n\n**(2)选择符前缀法**\n\n**(3)属性前缀法**\n\na标签的4个伪类的顺序：lovehate**(:link，visited，hover，active)**","slug":"2016-06-18-编写高质量代码——HTML、CSS","published":1,"updated":"2016-07-03T13:48:16.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocio009rd5u8bc6rmnh8","content":"<p>web标准：结构（HTML）、样式（CSS）、行为（javascript）分离</p>\n<p>代码注释：要养成添加注释的好习惯，能增加代码的可读性。</p>\n<p>公共组件和私有组件的维护：提高代码的重用性。<br>公共组件：接口保持弹性，且高度模块化。</p>\n<p>如何组织公有组件：</p>\n<p>两种方法：集中和分散。</p>\n<p>将所有的公共组件打包好，一次性载入：jQuery<br>将公共组件划分成一个个小的模块，按需加载:YUI</p>\n<h3 id=\"一-高质量的HTML\"><a href=\"#一-高质量的HTML\" class=\"headerlink\" title=\"一. 高质量的HTML\"></a>一. 高质量的HTML</h3><h4 id=\"1-注意标签的语义性\"><a href=\"#1-注意标签的语义性\" class=\"headerlink\" title=\"1. 注意标签的语义性\"></a>1. 注意标签的语义性</h4><p>使用语义化的标签，在去掉网页的样式之后，网页依然有很好的结构和可读性。</p>\n<p>(1) 标题和内容</p>\n<pre><code>&lt;h1&gt;&lt;/h1&gt;\n</code></pre><p>(2) 表单<code>&lt;form&gt;</code></p>\n<ul>\n<li>表单域用<code>&lt;fieldset&gt;</code>标签包起来，<code>&lt;fieldset&gt;</code>的<code>border</code>设为<code>none</code></li>\n<li>用<code>&lt;legend&gt;</code>标签说明表单的用途，<code>&lt;legend&gt;</code>的<code>display</code>设为<code>none</code></li>\n<li>每一个<code>&lt;input&gt;</code>的说明文字需要用<code>&lt;label&gt;</code>标签，<code>&lt;label&gt;</code>的<code>for</code>属性设置为<code>&lt;input&gt;的id值</code></li>\n</ul>\n<p>eg:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form&gt;</span><br><span class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">fieldset</span> <span class=\"attr\">border</span>=<span class=\"string\">\"none\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">legend</span> <span class=\"attr\">display</span>=<span class=\"string\">\"none\"</span>&gt;</span>登录表单<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>姓名:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>密码：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>(3) 表格<code>&lt;table&gt;</code></p>\n<ul>\n<li><code>&lt;table&gt;</code></li>\n<li><code>&lt;thead&gt;</code></li>\n<li><code>&lt;tbody&gt;</code></li>\n<li><code>&lt;tfoot&gt;</code></li>\n<li><code>&lt;tr&gt;</code></li>\n<li><code>&lt;td&gt;</code></li>\n<li><p><code>&lt;th&gt;</code></p>\n</li>\n<li><p>表格标题用<code>&lt;caption&gt;</code></p>\n</li>\n<li>表头用<code>&lt;thead&gt;</code>，表头里面的单元格用<code>&lt;th&gt;</code></li>\n<li>表格主题部分用<code>&lt;tbody&gt;</code>,每行用<code>&lt;tr&gt;</code>,每个单元格用<code>&lt;td&gt;</code></li>\n<li>表格尾部用<code>&lt;tfoot&gt;</code></li>\n</ul>\n<p>eg:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;caption&gt;几种实现页面的比较&lt;/caption&gt;</span><br><span class=\"line\">\t&lt;thead&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;实现方式&lt;/th&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;代码量&lt;/th&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;兼容性&lt;/th&gt;</span><br><span class=\"line\">\t&lt;/thead&gt;</span><br><span class=\"line\">\t&lt;tbody&gt;</span><br><span class=\"line\">\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t&lt;th&gt;tabel布局&lt;/th&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;多&lt;/td&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;一般&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t&lt;th&gt;CSS布局&lt;/th&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;少&lt;/td&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;好&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;/tbody&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-高质量的CSS\"><a href=\"#二-高质量的CSS\" class=\"headerlink\" title=\"二. 高质量的CSS\"></a>二. 高质量的CSS</h3><p>css的使用分为两个层面：使用css的API、如何组织css</p>\n<h4 id=\"1-组织css的方法\"><a href=\"#1-组织css的方法\" class=\"headerlink\" title=\"1. 组织css的方法\"></a>1. 组织css的方法</h4><p>将网页中的样式按照职能分为3大类：</p>\n<ul>\n<li>base.css</li>\n<li>common.css</li>\n<li>page.css</li>\n</ul>\n<p><strong>base.css</strong>会被所有页面引用，是页面样式所需要的最底层，与具体的UI无关。</p>\n<p><strong>common.css</strong>里面放的是大量重复的模块，以组件的形式提取出来。</p>\n<p><strong>page.css</strong>里面放的每个页面独有的样式，每个页面都会有自己的page.css（也可以将每个页面的page.css放在同一个css文件里，然后根据页面配上注释）</p>\n<p>举一个base.css的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/css reset/</span><br><span class=\"line\">body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td&#123;</span><br><span class=\"line\">\tmargin: <span class=\"number\">0</span>;</span><br><span class=\"line\">\tpadding: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">table &#123;</span><br><span class=\"line\">\tborder-collapse: collapse;</span><br><span class=\"line\">\tborder-spacing: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fieldset, img &#123;border: <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">address, caption, cite, code, dfn, em, strong, th, <span class=\"keyword\">var</span> &#123;</span><br><span class=\"line\">\tfont-style: normal;</span><br><span class=\"line\">\tfont-weight: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ol, ul &#123;list-style: none;&#125;</span><br><span class=\"line\">caption, th &#123;text-align: left;&#125;</span><br><span class=\"line\">h1, h2, h3, h4, h5, h6 &#123;font-size: <span class=\"number\">100</span>%; font-weight: normal;&#125;</span><br><span class=\"line\">q:before, q:after &#123;content: <span class=\"string\">\"\"</span>&#125;</span><br><span class=\"line\">abbr, acronym &#123;border: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*文字排版*/</span></span><br><span class=\"line\">.f12 &#123;font-size: <span class=\"number\">12</span>px;&#125;</span><br><span class=\"line\">.f13 &#123;font-size: <span class=\"number\">13</span>px;&#125;</span><br><span class=\"line\">.f14 &#123;font-size: <span class=\"number\">14</span>px;&#125;</span><br><span class=\"line\">.f15 &#123;font-size: <span class=\"number\">15</span>px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*定位*/</span></span><br><span class=\"line\">.tl &#123;text-align: left;&#125;</span><br><span class=\"line\">.tc &#123;text-align: center;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*宽度高度*/</span></span><br><span class=\"line\">.w &#123;width: <span class=\"number\">100</span>%;&#125;</span><br><span class=\"line\">.w10 &#123;width: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.w100 &#123;width: <span class=\"number\">100</span>px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*边距*/</span></span><br><span class=\"line\">.m10 &#123;margin: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.mt10 &#123;margin-top: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.mb10 &#123;margin-botton: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.ml10 &#123;maegin-left: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.mr10 &#123;margin-right: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.p10 &#123;padding: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pt10 &#123;padding-top: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pb10 &#123;padding-bottom: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pl10 &#123;padding-left: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pr10 &#123;padding-right: <span class=\"number\">10</span>px;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码没有给出全部的来，详细的见</p>\n<p>其中，base.css包括两个部分：<strong>css reset</strong>和<strong>通用原子类</strong>。</p>\n<p><strong>css reset</strong>部分是出自雅虎的前端框架YUI。用来覆盖掉浏览器的默认样式。</p>\n<p><strong>通用原子类</strong>包括文字、定位、长宽、边距。通用性，原子性（不可再分）。</p>\n<h4 id=\"2-模块化css\"><a href=\"#2-模块化css\" class=\"headerlink\" title=\"2. 模块化css\"></a>2. 模块化css</h4><p>借用面向对象的思想，将相同的组件的样式提取成一个模块。</p>\n<p>提取模块的思想：<strong>多用组合，少用继承</strong>。将一个复杂的类拆分成：容易产生变化的类和相对稳定的类。</p>\n<p>将模块中不稳定的类单独变成一个类，例如：margin-top值</p>\n<font color=\"red\">注意：不要同时使用margin-top,margin-bottom;相邻模块的margin-top和margin-bottom可能会重合。</font>\n\n<h4 id=\"3-css的命名\"><a href=\"#3-css的命名\" class=\"headerlink\" title=\"3. css的命名\"></a>3. css的命名</h4><p>为了方便区分单词，可使用的两种命名方式</p>\n<ul>\n<li>驼峰命名法 firstWord</li>\n<li>划线命名法 first-word</li>\n</ul>\n<p>虽然说命名并没有什么特殊的规定，但是好的命名会使代码的可读性更高。</p>\n<p>推荐一种命名方式：</p>\n<p>使用驼峰命名法区分不同的单词，使用划线表示从属关系。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul class=\"timeList\"&gt;</span><br><span class=\"line\">\t&lt;li&gt;1&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li&gt;2&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li class=\"timeList-lastItem\"&gt;3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>若团队合作中两个人的css代码冲突了，可以使用加前缀的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pan-timeList &#123;...&#125;</span><br><span class=\"line\">pan-timeList-lastItem &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-css选择器的权重\"><a href=\"#4-css选择器的权重\" class=\"headerlink\" title=\"4. css选择器的权重\"></a>4. css选择器的权重</h4><ul>\n<li>行内样式style:<strong>1000</strong></li>\n<li>ID选择器：<strong>100</strong></li>\n<li>类class/属性选择器/伪类(:hover/:focus等)：<strong>10</strong></li>\n<li>元素(标签)/伪元素：<strong>1</strong></li>\n</ul>\n<font color=\"red\">注意：<strong>伪类</strong>指的是一种状态，例如hover，active；<strong>伪元素</strong>指的是文档的某个特定部分的表现。</font>\n\n<pre><code>权重的计算：\n\nbody #content .data img:hover\n\n权重为：1 + 100 + 10 + 1 + 10 = 122\n\n不同的权重，权重高的有效；\n相同的权重，后定义的有效。\n</code></pre><h4 id=\"5-CSS-hack\"><a href=\"#5-CSS-hack\" class=\"headerlink\" title=\"5. CSS hack\"></a>5. CSS hack</h4><p><strong>(1)IE条件注释法</strong></p>\n<p>针对IE浏览器，下面这个css文件只会被IE浏览器下载。</p>\n<!-- [if IE]>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"css.css\">\n<![end if]-->\n<p><strong>(2)选择符前缀法</strong></p>\n<p><strong>(3)属性前缀法</strong></p>\n<p>a标签的4个伪类的顺序：lovehate<strong>(:link，visited，hover，active)</strong></p>\n","excerpt":"","more":"<p>web标准：结构（HTML）、样式（CSS）、行为（javascript）分离</p>\n<p>代码注释：要养成添加注释的好习惯，能增加代码的可读性。</p>\n<p>公共组件和私有组件的维护：提高代码的重用性。<br>公共组件：接口保持弹性，且高度模块化。</p>\n<p>如何组织公有组件：</p>\n<p>两种方法：集中和分散。</p>\n<p>将所有的公共组件打包好，一次性载入：jQuery<br>将公共组件划分成一个个小的模块，按需加载:YUI</p>\n<h3 id=\"一-高质量的HTML\"><a href=\"#一-高质量的HTML\" class=\"headerlink\" title=\"一. 高质量的HTML\"></a>一. 高质量的HTML</h3><h4 id=\"1-注意标签的语义性\"><a href=\"#1-注意标签的语义性\" class=\"headerlink\" title=\"1. 注意标签的语义性\"></a>1. 注意标签的语义性</h4><p>使用语义化的标签，在去掉网页的样式之后，网页依然有很好的结构和可读性。</p>\n<p>(1) 标题和内容</p>\n<pre><code>&lt;h1&gt;&lt;/h1&gt;\n</code></pre><p>(2) 表单<code>&lt;form&gt;</code></p>\n<ul>\n<li>表单域用<code>&lt;fieldset&gt;</code>标签包起来，<code>&lt;fieldset&gt;</code>的<code>border</code>设为<code>none</code></li>\n<li>用<code>&lt;legend&gt;</code>标签说明表单的用途，<code>&lt;legend&gt;</code>的<code>display</code>设为<code>none</code></li>\n<li>每一个<code>&lt;input&gt;</code>的说明文字需要用<code>&lt;label&gt;</code>标签，<code>&lt;label&gt;</code>的<code>for</code>属性设置为<code>&lt;input&gt;的id值</code></li>\n</ul>\n<p>eg:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form&gt;</span><br><span class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">fieldset</span> <span class=\"attr\">border</span>=<span class=\"string\">\"none\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">legend</span> <span class=\"attr\">display</span>=<span class=\"string\">\"none\"</span>&gt;</span>登录表单<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>姓名:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"name\"</span>&gt;</span>密码：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>(3) 表格<code>&lt;table&gt;</code></p>\n<ul>\n<li><code>&lt;table&gt;</code></li>\n<li><code>&lt;thead&gt;</code></li>\n<li><code>&lt;tbody&gt;</code></li>\n<li><code>&lt;tfoot&gt;</code></li>\n<li><code>&lt;tr&gt;</code></li>\n<li><code>&lt;td&gt;</code></li>\n<li><p><code>&lt;th&gt;</code></p>\n</li>\n<li><p>表格标题用<code>&lt;caption&gt;</code></p>\n</li>\n<li>表头用<code>&lt;thead&gt;</code>，表头里面的单元格用<code>&lt;th&gt;</code></li>\n<li>表格主题部分用<code>&lt;tbody&gt;</code>,每行用<code>&lt;tr&gt;</code>,每个单元格用<code>&lt;td&gt;</code></li>\n<li>表格尾部用<code>&lt;tfoot&gt;</code></li>\n</ul>\n<p>eg:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;caption&gt;几种实现页面的比较&lt;/caption&gt;</span><br><span class=\"line\">\t&lt;thead&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;实现方式&lt;/th&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;代码量&lt;/th&gt;</span><br><span class=\"line\">\t\t&lt;th&gt;兼容性&lt;/th&gt;</span><br><span class=\"line\">\t&lt;/thead&gt;</span><br><span class=\"line\">\t&lt;tbody&gt;</span><br><span class=\"line\">\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t&lt;th&gt;tabel布局&lt;/th&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;多&lt;/td&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;一般&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t&lt;th&gt;CSS布局&lt;/th&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;少&lt;/td&gt;</span><br><span class=\"line\">\t\t\t&lt;td&gt;好&lt;/td&gt;</span><br><span class=\"line\">\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t&lt;/tbody&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-高质量的CSS\"><a href=\"#二-高质量的CSS\" class=\"headerlink\" title=\"二. 高质量的CSS\"></a>二. 高质量的CSS</h3><p>css的使用分为两个层面：使用css的API、如何组织css</p>\n<h4 id=\"1-组织css的方法\"><a href=\"#1-组织css的方法\" class=\"headerlink\" title=\"1. 组织css的方法\"></a>1. 组织css的方法</h4><p>将网页中的样式按照职能分为3大类：</p>\n<ul>\n<li>base.css</li>\n<li>common.css</li>\n<li>page.css</li>\n</ul>\n<p><strong>base.css</strong>会被所有页面引用，是页面样式所需要的最底层，与具体的UI无关。</p>\n<p><strong>common.css</strong>里面放的是大量重复的模块，以组件的形式提取出来。</p>\n<p><strong>page.css</strong>里面放的每个页面独有的样式，每个页面都会有自己的page.css（也可以将每个页面的page.css放在同一个css文件里，然后根据页面配上注释）</p>\n<p>举一个base.css的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/css reset/</span><br><span class=\"line\">body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td&#123;</span><br><span class=\"line\">\tmargin: <span class=\"number\">0</span>;</span><br><span class=\"line\">\tpadding: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">table &#123;</span><br><span class=\"line\">\tborder-collapse: collapse;</span><br><span class=\"line\">\tborder-spacing: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fieldset, img &#123;border: <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">address, caption, cite, code, dfn, em, strong, th, <span class=\"keyword\">var</span> &#123;</span><br><span class=\"line\">\tfont-style: normal;</span><br><span class=\"line\">\tfont-weight: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ol, ul &#123;list-style: none;&#125;</span><br><span class=\"line\">caption, th &#123;text-align: left;&#125;</span><br><span class=\"line\">h1, h2, h3, h4, h5, h6 &#123;font-size: <span class=\"number\">100</span>%; font-weight: normal;&#125;</span><br><span class=\"line\">q:before, q:after &#123;content: <span class=\"string\">\"\"</span>&#125;</span><br><span class=\"line\">abbr, acronym &#123;border: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*文字排版*/</span></span><br><span class=\"line\">.f12 &#123;font-size: <span class=\"number\">12</span>px;&#125;</span><br><span class=\"line\">.f13 &#123;font-size: <span class=\"number\">13</span>px;&#125;</span><br><span class=\"line\">.f14 &#123;font-size: <span class=\"number\">14</span>px;&#125;</span><br><span class=\"line\">.f15 &#123;font-size: <span class=\"number\">15</span>px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*定位*/</span></span><br><span class=\"line\">.tl &#123;text-align: left;&#125;</span><br><span class=\"line\">.tc &#123;text-align: center;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*宽度高度*/</span></span><br><span class=\"line\">.w &#123;width: <span class=\"number\">100</span>%;&#125;</span><br><span class=\"line\">.w10 &#123;width: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.w100 &#123;width: <span class=\"number\">100</span>px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*边距*/</span></span><br><span class=\"line\">.m10 &#123;margin: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.mt10 &#123;margin-top: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.mb10 &#123;margin-botton: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.ml10 &#123;maegin-left: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.mr10 &#123;margin-right: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.p10 &#123;padding: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pt10 &#123;padding-top: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pb10 &#123;padding-bottom: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pl10 &#123;padding-left: <span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">.pr10 &#123;padding-right: <span class=\"number\">10</span>px;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码没有给出全部的来，详细的见</p>\n<p>其中，base.css包括两个部分：<strong>css reset</strong>和<strong>通用原子类</strong>。</p>\n<p><strong>css reset</strong>部分是出自雅虎的前端框架YUI。用来覆盖掉浏览器的默认样式。</p>\n<p><strong>通用原子类</strong>包括文字、定位、长宽、边距。通用性，原子性（不可再分）。</p>\n<h4 id=\"2-模块化css\"><a href=\"#2-模块化css\" class=\"headerlink\" title=\"2. 模块化css\"></a>2. 模块化css</h4><p>借用面向对象的思想，将相同的组件的样式提取成一个模块。</p>\n<p>提取模块的思想：<strong>多用组合，少用继承</strong>。将一个复杂的类拆分成：容易产生变化的类和相对稳定的类。</p>\n<p>将模块中不稳定的类单独变成一个类，例如：margin-top值</p>\n<font color=\"red\">注意：不要同时使用margin-top,margin-bottom;相邻模块的margin-top和margin-bottom可能会重合。</font>\n\n<h4 id=\"3-css的命名\"><a href=\"#3-css的命名\" class=\"headerlink\" title=\"3. css的命名\"></a>3. css的命名</h4><p>为了方便区分单词，可使用的两种命名方式</p>\n<ul>\n<li>驼峰命名法 firstWord</li>\n<li>划线命名法 first-word</li>\n</ul>\n<p>虽然说命名并没有什么特殊的规定，但是好的命名会使代码的可读性更高。</p>\n<p>推荐一种命名方式：</p>\n<p>使用驼峰命名法区分不同的单词，使用划线表示从属关系。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul class=\"timeList\"&gt;</span><br><span class=\"line\">\t&lt;li&gt;1&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li&gt;2&lt;/li&gt;</span><br><span class=\"line\">\t&lt;li class=\"timeList-lastItem\"&gt;3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>若团队合作中两个人的css代码冲突了，可以使用加前缀的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pan-timeList &#123;...&#125;</span><br><span class=\"line\">pan-timeList-lastItem &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-css选择器的权重\"><a href=\"#4-css选择器的权重\" class=\"headerlink\" title=\"4. css选择器的权重\"></a>4. css选择器的权重</h4><ul>\n<li>行内样式style:<strong>1000</strong></li>\n<li>ID选择器：<strong>100</strong></li>\n<li>类class/属性选择器/伪类(:hover/:focus等)：<strong>10</strong></li>\n<li>元素(标签)/伪元素：<strong>1</strong></li>\n</ul>\n<font color=\"red\">注意：<strong>伪类</strong>指的是一种状态，例如hover，active；<strong>伪元素</strong>指的是文档的某个特定部分的表现。</font>\n\n<pre><code>权重的计算：\n\nbody #content .data img:hover\n\n权重为：1 + 100 + 10 + 1 + 10 = 122\n\n不同的权重，权重高的有效；\n相同的权重，后定义的有效。\n</code></pre><h4 id=\"5-CSS-hack\"><a href=\"#5-CSS-hack\" class=\"headerlink\" title=\"5. CSS hack\"></a>5. CSS hack</h4><p><strong>(1)IE条件注释法</strong></p>\n<p>针对IE浏览器，下面这个css文件只会被IE浏览器下载。</p>\n<!-- [if IE]>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"css.css\">\n<![end if]-->\n<p><strong>(2)选择符前缀法</strong></p>\n<p><strong>(3)属性前缀法</strong></p>\n<p>a标签的4个伪类的顺序：lovehate<strong>(:link，visited，hover，active)</strong></p>\n"},{"layout":"post","title":"微型调查问卷平台组件——日历组件","date":"2016-06-19T16:00:00.000Z","description":null,"_content":"\n### 一. 日历选择组件任务要求：\n\n**日历组件一：**\n\n- 参考并实现一个日历选择组件\n- 组件默认一直呈显示状态 \n- 通过某种方式选择年、月，选择了年月后，日期列表做相应切换 \n- 通过单击某个具体的日期进行日期选择\n- 组件初始化时，可配置可选日期的上下限。可选日期和不可选日期需要有样式上的区别 \n- 提供设定日期的接口，指定具体日期，日历面板相应日期选中\n- 提供获取日期的接口，获取日历面板中当前选中的日期，返回一个日期对象（或其他形式，自定）\n\n**demo地址：**[http://panpanfish.com/myDemo/research/date1.html](http://panpanfish.com/myDemo/research/date1.html \"日历组件一\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html \"日历组件一\")\n\n**日历组件二：**\n\n- 日期选择面板默认隐藏，会显示一个日期显示框和一个按钮，点击这两个部分，会浮出日历面板。再点击则隐藏。\n- 点击选择具体日期后，面板隐藏，日期显示框中显示选取的日期\n- 增加一个接口，用于当用户选择日期后的回调处理\n\n**demo地址：**[http://panpanfish.com/myDemo/research/date2.html](http://panpanfish.com/myDemo/research/date2.html \"日历组件二\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html \"日历组件二\")\n\n**日历组件三：**\n\n- 增加一个参数及相应接口方法，来决定这个日历组件是选择具体某天日期，还是选择一个时间段\n- 当设置为选择时间段时，需要在日历面板上点击两个日期来完成一次选择，两个日期中，较早的为起始时间，较晚的为结束时间，选择的时间段用特殊样式标示\n- 增加参数及响应接口方法，允许设置时间段选择的最小或最大跨度，并提供当不满足跨度设置时的默认处理及回调函数接口\n- 在弹出的日期段选择面板中增加确认和取消按钮\n\n**demo地址：**[http://panpanfish.com/myDemo/research/date3.html](http://panpanfish.com/myDemo/research/date3.html \"日历组件三\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html \"日历组件三\")\n\n### 二. 实现过程中遇到的问题\n\n#### 1. 对象引用的问题\n\n由于在写对象方法时，作为函数调用的内部的this指的并不是当前对象，因此经常会使用闭包来获取当前对象：\n\n\tvar that = this;\n\n因此产生了一个对象引用的问题，就是我在函数里面改变了that的一些属性值，与之对应的this值也会改变吗？\n\n举个栗子：\n\n\tvar a = {\n\t\tname: \"xiaoming\",\n\t\tage: 2\n\t}//可以理解为：我们创建了一个对象，并将这个对象的内存地址赋给a，也就是a指向该内存A\n\t\n\tvar b = a;//这里是将对象的内存地址又赋给了b，也就是a和b指向同一个内存A\n\t\n\tb.age = 3;\n\tconsole.log(a.age);//a.age = 3;\n\t\n\tb = null;//切断了b与内存A的关系，但此时a仍然可以读写该内存A\n\ta = null;//也切断了a与内存A的关系，这时内存A就被垃圾回收了\n\n> 这就是对象引用。可以简单理解同一银行帐号你拿存折，我拿卡。不管谁取钱了帐号都会减少金额，同理存钱也会涨。\n\n#### 2. 用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\n\n#### 3. select框与div水平无法对齐，给select框添加样式：verticle-align:middle；\n\n#### 4. 用parseInt()将字符串变成数字时，只能将以数字开头的字符串变成数字：\n\n例如： \n\n    parseInt(\"23abc\");//23\n    parseInt(\"abc23\");//NAN\n\n#### 5. 文本框输入字符事件 textInput、文本框获取焦点事件 focusin\n\n    火狐不支持focusin事件，和textInput事件\n    IE支持focusin事件，不支持textInput事件\n    chrome对这两个事件都支持\n\n\t解决这个兼容性的方法：将focusin事件换成了focus事件\n\t由于一聚焦就触发了，因此textInput事件失效了也没关系\n\n#### 6. `<table>`标签里面的padding无效\n\n`<table>`里面如果要设置padding，只能用`<table>`标签的属性\n\n- cellpadding：单元格外面的一个距离\n- cellspacing：表格边框与单元格补白的距离\n\n#### 7. 用createElement生成的是dom对象\n\n\t不能通过字符串的方式拼接\n\t\n\t只能通过appendChild的方式\n\n### 三. 第一次修订\n\n在我学习了requireJS和sass之后，又用requireJS和sass修改了一下日历组件（三）。\n\n将之前css里面用的固定长宽都修改成了百分比的形式，方便扩展。\n\n\n\n\n\n\n","source":"_posts/2016-06-20-微型调查问卷平台组件——日历组件.md","raw":"---\nlayout: post\ntitle: 微型调查问卷平台组件——日历组件\ndate: 2016-06-20\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n### 一. 日历选择组件任务要求：\n\n**日历组件一：**\n\n- 参考并实现一个日历选择组件\n- 组件默认一直呈显示状态 \n- 通过某种方式选择年、月，选择了年月后，日期列表做相应切换 \n- 通过单击某个具体的日期进行日期选择\n- 组件初始化时，可配置可选日期的上下限。可选日期和不可选日期需要有样式上的区别 \n- 提供设定日期的接口，指定具体日期，日历面板相应日期选中\n- 提供获取日期的接口，获取日历面板中当前选中的日期，返回一个日期对象（或其他形式，自定）\n\n**demo地址：**[http://panpanfish.com/myDemo/research/date1.html](http://panpanfish.com/myDemo/research/date1.html \"日历组件一\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html \"日历组件一\")\n\n**日历组件二：**\n\n- 日期选择面板默认隐藏，会显示一个日期显示框和一个按钮，点击这两个部分，会浮出日历面板。再点击则隐藏。\n- 点击选择具体日期后，面板隐藏，日期显示框中显示选取的日期\n- 增加一个接口，用于当用户选择日期后的回调处理\n\n**demo地址：**[http://panpanfish.com/myDemo/research/date2.html](http://panpanfish.com/myDemo/research/date2.html \"日历组件二\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html \"日历组件二\")\n\n**日历组件三：**\n\n- 增加一个参数及相应接口方法，来决定这个日历组件是选择具体某天日期，还是选择一个时间段\n- 当设置为选择时间段时，需要在日历面板上点击两个日期来完成一次选择，两个日期中，较早的为起始时间，较晚的为结束时间，选择的时间段用特殊样式标示\n- 增加参数及响应接口方法，允许设置时间段选择的最小或最大跨度，并提供当不满足跨度设置时的默认处理及回调函数接口\n- 在弹出的日期段选择面板中增加确认和取消按钮\n\n**demo地址：**[http://panpanfish.com/myDemo/research/date3.html](http://panpanfish.com/myDemo/research/date3.html \"日历组件三\")\n\n**代码地址：**[https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html](https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html \"日历组件三\")\n\n### 二. 实现过程中遇到的问题\n\n#### 1. 对象引用的问题\n\n由于在写对象方法时，作为函数调用的内部的this指的并不是当前对象，因此经常会使用闭包来获取当前对象：\n\n\tvar that = this;\n\n因此产生了一个对象引用的问题，就是我在函数里面改变了that的一些属性值，与之对应的this值也会改变吗？\n\n举个栗子：\n\n\tvar a = {\n\t\tname: \"xiaoming\",\n\t\tage: 2\n\t}//可以理解为：我们创建了一个对象，并将这个对象的内存地址赋给a，也就是a指向该内存A\n\t\n\tvar b = a;//这里是将对象的内存地址又赋给了b，也就是a和b指向同一个内存A\n\t\n\tb.age = 3;\n\tconsole.log(a.age);//a.age = 3;\n\t\n\tb = null;//切断了b与内存A的关系，但此时a仍然可以读写该内存A\n\ta = null;//也切断了a与内存A的关系，这时内存A就被垃圾回收了\n\n> 这就是对象引用。可以简单理解同一银行帐号你拿存折，我拿卡。不管谁取钱了帐号都会减少金额，同理存钱也会涨。\n\n#### 2. 用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\n\n#### 3. select框与div水平无法对齐，给select框添加样式：verticle-align:middle；\n\n#### 4. 用parseInt()将字符串变成数字时，只能将以数字开头的字符串变成数字：\n\n例如： \n\n    parseInt(\"23abc\");//23\n    parseInt(\"abc23\");//NAN\n\n#### 5. 文本框输入字符事件 textInput、文本框获取焦点事件 focusin\n\n    火狐不支持focusin事件，和textInput事件\n    IE支持focusin事件，不支持textInput事件\n    chrome对这两个事件都支持\n\n\t解决这个兼容性的方法：将focusin事件换成了focus事件\n\t由于一聚焦就触发了，因此textInput事件失效了也没关系\n\n#### 6. `<table>`标签里面的padding无效\n\n`<table>`里面如果要设置padding，只能用`<table>`标签的属性\n\n- cellpadding：单元格外面的一个距离\n- cellspacing：表格边框与单元格补白的距离\n\n#### 7. 用createElement生成的是dom对象\n\n\t不能通过字符串的方式拼接\n\t\n\t只能通过appendChild的方式\n\n### 三. 第一次修订\n\n在我学习了requireJS和sass之后，又用requireJS和sass修改了一下日历组件（三）。\n\n将之前css里面用的固定长宽都修改成了百分比的形式，方便扩展。\n\n\n\n\n\n\n","slug":"2016-06-20-微型调查问卷平台组件——日历组件","published":1,"updated":"2016-07-14T09:15:22.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocir009vd5u8l4hrsjwy","content":"<h3 id=\"一-日历选择组件任务要求：\"><a href=\"#一-日历选择组件任务要求：\" class=\"headerlink\" title=\"一. 日历选择组件任务要求：\"></a>一. 日历选择组件任务要求：</h3><p><strong>日历组件一：</strong></p>\n<ul>\n<li>参考并实现一个日历选择组件</li>\n<li>组件默认一直呈显示状态 </li>\n<li>通过某种方式选择年、月，选择了年月后，日期列表做相应切换 </li>\n<li>通过单击某个具体的日期进行日期选择</li>\n<li>组件初始化时，可配置可选日期的上下限。可选日期和不可选日期需要有样式上的区别 </li>\n<li>提供设定日期的接口，指定具体日期，日历面板相应日期选中</li>\n<li>提供获取日期的接口，获取日历面板中当前选中的日期，返回一个日期对象（或其他形式，自定）</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/date1.html\" title=\"日历组件一\">http://panpanfish.com/myDemo/research/date1.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html\" title=\"日历组件一\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html</a></p>\n<p><strong>日历组件二：</strong></p>\n<ul>\n<li>日期选择面板默认隐藏，会显示一个日期显示框和一个按钮，点击这两个部分，会浮出日历面板。再点击则隐藏。</li>\n<li>点击选择具体日期后，面板隐藏，日期显示框中显示选取的日期</li>\n<li>增加一个接口，用于当用户选择日期后的回调处理</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/date2.html\" title=\"日历组件二\">http://panpanfish.com/myDemo/research/date2.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html\" title=\"日历组件二\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html</a></p>\n<p><strong>日历组件三：</strong></p>\n<ul>\n<li>增加一个参数及相应接口方法，来决定这个日历组件是选择具体某天日期，还是选择一个时间段</li>\n<li>当设置为选择时间段时，需要在日历面板上点击两个日期来完成一次选择，两个日期中，较早的为起始时间，较晚的为结束时间，选择的时间段用特殊样式标示</li>\n<li>增加参数及响应接口方法，允许设置时间段选择的最小或最大跨度，并提供当不满足跨度设置时的默认处理及回调函数接口</li>\n<li>在弹出的日期段选择面板中增加确认和取消按钮</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/date3.html\" title=\"日历组件三\">http://panpanfish.com/myDemo/research/date3.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html\" title=\"日历组件三\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html</a></p>\n<h3 id=\"二-实现过程中遇到的问题\"><a href=\"#二-实现过程中遇到的问题\" class=\"headerlink\" title=\"二. 实现过程中遇到的问题\"></a>二. 实现过程中遇到的问题</h3><h4 id=\"1-对象引用的问题\"><a href=\"#1-对象引用的问题\" class=\"headerlink\" title=\"1. 对象引用的问题\"></a>1. 对象引用的问题</h4><p>由于在写对象方法时，作为函数调用的内部的this指的并不是当前对象，因此经常会使用闭包来获取当前对象：</p>\n<pre><code>var that = this;\n</code></pre><p>因此产生了一个对象引用的问题，就是我在函数里面改变了that的一些属性值，与之对应的this值也会改变吗？</p>\n<p>举个栗子：</p>\n<pre><code>var a = {\n    name: &quot;xiaoming&quot;,\n    age: 2\n}//可以理解为：我们创建了一个对象，并将这个对象的内存地址赋给a，也就是a指向该内存A\n\nvar b = a;//这里是将对象的内存地址又赋给了b，也就是a和b指向同一个内存A\n\nb.age = 3;\nconsole.log(a.age);//a.age = 3;\n\nb = null;//切断了b与内存A的关系，但此时a仍然可以读写该内存A\na = null;//也切断了a与内存A的关系，这时内存A就被垃圾回收了\n</code></pre><blockquote>\n<p>这就是对象引用。可以简单理解同一银行帐号你拿存折，我拿卡。不管谁取钱了帐号都会减少金额，同理存钱也会涨。</p>\n</blockquote>\n<h4 id=\"2-用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\"><a href=\"#2-用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\" class=\"headerlink\" title=\"2. 用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\"></a>2. 用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。</h4><h4 id=\"3-select框与div水平无法对齐，给select框添加样式：verticle-align-middle；\"><a href=\"#3-select框与div水平无法对齐，给select框添加样式：verticle-align-middle；\" class=\"headerlink\" title=\"3. select框与div水平无法对齐，给select框添加样式：verticle-align:middle；\"></a>3. select框与div水平无法对齐，给select框添加样式：verticle-align:middle；</h4><h4 id=\"4-用parseInt-将字符串变成数字时，只能将以数字开头的字符串变成数字：\"><a href=\"#4-用parseInt-将字符串变成数字时，只能将以数字开头的字符串变成数字：\" class=\"headerlink\" title=\"4. 用parseInt()将字符串变成数字时，只能将以数字开头的字符串变成数字：\"></a>4. 用parseInt()将字符串变成数字时，只能将以数字开头的字符串变成数字：</h4><p>例如： </p>\n<pre><code>parseInt(&quot;23abc&quot;);//23\nparseInt(&quot;abc23&quot;);//NAN\n</code></pre><h4 id=\"5-文本框输入字符事件-textInput、文本框获取焦点事件-focusin\"><a href=\"#5-文本框输入字符事件-textInput、文本框获取焦点事件-focusin\" class=\"headerlink\" title=\"5. 文本框输入字符事件 textInput、文本框获取焦点事件 focusin\"></a>5. 文本框输入字符事件 textInput、文本框获取焦点事件 focusin</h4><pre><code>火狐不支持focusin事件，和textInput事件\nIE支持focusin事件，不支持textInput事件\nchrome对这两个事件都支持\n\n解决这个兼容性的方法：将focusin事件换成了focus事件\n由于一聚焦就触发了，因此textInput事件失效了也没关系\n</code></pre><h4 id=\"6-lt-table-gt-标签里面的padding无效\"><a href=\"#6-lt-table-gt-标签里面的padding无效\" class=\"headerlink\" title=\"6. &lt;table&gt;标签里面的padding无效\"></a>6. <code>&lt;table&gt;</code>标签里面的padding无效</h4><p><code>&lt;table&gt;</code>里面如果要设置padding，只能用<code>&lt;table&gt;</code>标签的属性</p>\n<ul>\n<li>cellpadding：单元格外面的一个距离</li>\n<li>cellspacing：表格边框与单元格补白的距离</li>\n</ul>\n<h4 id=\"7-用createElement生成的是dom对象\"><a href=\"#7-用createElement生成的是dom对象\" class=\"headerlink\" title=\"7. 用createElement生成的是dom对象\"></a>7. 用createElement生成的是dom对象</h4><pre><code>不能通过字符串的方式拼接\n\n只能通过appendChild的方式\n</code></pre><h3 id=\"三-第一次修订\"><a href=\"#三-第一次修订\" class=\"headerlink\" title=\"三. 第一次修订\"></a>三. 第一次修订</h3><p>在我学习了requireJS和sass之后，又用requireJS和sass修改了一下日历组件（三）。</p>\n<p>将之前css里面用的固定长宽都修改成了百分比的形式，方便扩展。</p>\n","excerpt":"","more":"<h3 id=\"一-日历选择组件任务要求：\"><a href=\"#一-日历选择组件任务要求：\" class=\"headerlink\" title=\"一. 日历选择组件任务要求：\"></a>一. 日历选择组件任务要求：</h3><p><strong>日历组件一：</strong></p>\n<ul>\n<li>参考并实现一个日历选择组件</li>\n<li>组件默认一直呈显示状态 </li>\n<li>通过某种方式选择年、月，选择了年月后，日期列表做相应切换 </li>\n<li>通过单击某个具体的日期进行日期选择</li>\n<li>组件初始化时，可配置可选日期的上下限。可选日期和不可选日期需要有样式上的区别 </li>\n<li>提供设定日期的接口，指定具体日期，日历面板相应日期选中</li>\n<li>提供获取日期的接口，获取日历面板中当前选中的日期，返回一个日期对象（或其他形式，自定）</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/date1.html\" title=\"日历组件一\">http://panpanfish.com/myDemo/research/date1.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html\" title=\"日历组件一\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/date1.html</a></p>\n<p><strong>日历组件二：</strong></p>\n<ul>\n<li>日期选择面板默认隐藏，会显示一个日期显示框和一个按钮，点击这两个部分，会浮出日历面板。再点击则隐藏。</li>\n<li>点击选择具体日期后，面板隐藏，日期显示框中显示选取的日期</li>\n<li>增加一个接口，用于当用户选择日期后的回调处理</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/date2.html\" title=\"日历组件二\">http://panpanfish.com/myDemo/research/date2.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html\" title=\"日历组件二\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/date2.html</a></p>\n<p><strong>日历组件三：</strong></p>\n<ul>\n<li>增加一个参数及相应接口方法，来决定这个日历组件是选择具体某天日期，还是选择一个时间段</li>\n<li>当设置为选择时间段时，需要在日历面板上点击两个日期来完成一次选择，两个日期中，较早的为起始时间，较晚的为结束时间，选择的时间段用特殊样式标示</li>\n<li>增加参数及响应接口方法，允许设置时间段选择的最小或最大跨度，并提供当不满足跨度设置时的默认处理及回调函数接口</li>\n<li>在弹出的日期段选择面板中增加确认和取消按钮</li>\n</ul>\n<p><strong>demo地址：</strong><a href=\"http://panpanfish.com/myDemo/research/date3.html\" title=\"日历组件三\">http://panpanfish.com/myDemo/research/date3.html</a></p>\n<p><strong>代码地址：</strong><a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html\" title=\"日历组件三\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/date3.html</a></p>\n<h3 id=\"二-实现过程中遇到的问题\"><a href=\"#二-实现过程中遇到的问题\" class=\"headerlink\" title=\"二. 实现过程中遇到的问题\"></a>二. 实现过程中遇到的问题</h3><h4 id=\"1-对象引用的问题\"><a href=\"#1-对象引用的问题\" class=\"headerlink\" title=\"1. 对象引用的问题\"></a>1. 对象引用的问题</h4><p>由于在写对象方法时，作为函数调用的内部的this指的并不是当前对象，因此经常会使用闭包来获取当前对象：</p>\n<pre><code>var that = this;\n</code></pre><p>因此产生了一个对象引用的问题，就是我在函数里面改变了that的一些属性值，与之对应的this值也会改变吗？</p>\n<p>举个栗子：</p>\n<pre><code>var a = {\n    name: &quot;xiaoming&quot;,\n    age: 2\n}//可以理解为：我们创建了一个对象，并将这个对象的内存地址赋给a，也就是a指向该内存A\n\nvar b = a;//这里是将对象的内存地址又赋给了b，也就是a和b指向同一个内存A\n\nb.age = 3;\nconsole.log(a.age);//a.age = 3;\n\nb = null;//切断了b与内存A的关系，但此时a仍然可以读写该内存A\na = null;//也切断了a与内存A的关系，这时内存A就被垃圾回收了\n</code></pre><blockquote>\n<p>这就是对象引用。可以简单理解同一银行帐号你拿存折，我拿卡。不管谁取钱了帐号都会减少金额，同理存钱也会涨。</p>\n</blockquote>\n<h4 id=\"2-用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\"><a href=\"#2-用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\" class=\"headerlink\" title=\"2. 用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。\"></a>2. 用字符串拼接的方式添加dom时，首先声明的变量应该赋值为一个空的字符串，否则会拼接进一个undefined。</h4><h4 id=\"3-select框与div水平无法对齐，给select框添加样式：verticle-align-middle；\"><a href=\"#3-select框与div水平无法对齐，给select框添加样式：verticle-align-middle；\" class=\"headerlink\" title=\"3. select框与div水平无法对齐，给select框添加样式：verticle-align:middle；\"></a>3. select框与div水平无法对齐，给select框添加样式：verticle-align:middle；</h4><h4 id=\"4-用parseInt-将字符串变成数字时，只能将以数字开头的字符串变成数字：\"><a href=\"#4-用parseInt-将字符串变成数字时，只能将以数字开头的字符串变成数字：\" class=\"headerlink\" title=\"4. 用parseInt()将字符串变成数字时，只能将以数字开头的字符串变成数字：\"></a>4. 用parseInt()将字符串变成数字时，只能将以数字开头的字符串变成数字：</h4><p>例如： </p>\n<pre><code>parseInt(&quot;23abc&quot;);//23\nparseInt(&quot;abc23&quot;);//NAN\n</code></pre><h4 id=\"5-文本框输入字符事件-textInput、文本框获取焦点事件-focusin\"><a href=\"#5-文本框输入字符事件-textInput、文本框获取焦点事件-focusin\" class=\"headerlink\" title=\"5. 文本框输入字符事件 textInput、文本框获取焦点事件 focusin\"></a>5. 文本框输入字符事件 textInput、文本框获取焦点事件 focusin</h4><pre><code>火狐不支持focusin事件，和textInput事件\nIE支持focusin事件，不支持textInput事件\nchrome对这两个事件都支持\n\n解决这个兼容性的方法：将focusin事件换成了focus事件\n由于一聚焦就触发了，因此textInput事件失效了也没关系\n</code></pre><h4 id=\"6-lt-table-gt-标签里面的padding无效\"><a href=\"#6-lt-table-gt-标签里面的padding无效\" class=\"headerlink\" title=\"6. &lt;table&gt;标签里面的padding无效\"></a>6. <code>&lt;table&gt;</code>标签里面的padding无效</h4><p><code>&lt;table&gt;</code>里面如果要设置padding，只能用<code>&lt;table&gt;</code>标签的属性</p>\n<ul>\n<li>cellpadding：单元格外面的一个距离</li>\n<li>cellspacing：表格边框与单元格补白的距离</li>\n</ul>\n<h4 id=\"7-用createElement生成的是dom对象\"><a href=\"#7-用createElement生成的是dom对象\" class=\"headerlink\" title=\"7. 用createElement生成的是dom对象\"></a>7. 用createElement生成的是dom对象</h4><pre><code>不能通过字符串的方式拼接\n\n只能通过appendChild的方式\n</code></pre><h3 id=\"三-第一次修订\"><a href=\"#三-第一次修订\" class=\"headerlink\" title=\"三. 第一次修订\"></a>三. 第一次修订</h3><p>在我学习了requireJS和sass之后，又用requireJS和sass修改了一下日历组件（三）。</p>\n<p>将之前css里面用的固定长宽都修改成了百分比的形式，方便扩展。</p>\n"},{"layout":"post","title":"编写高质量代码————javaScript","date":"2016-06-20T16:00:00.000Z","description":null,"_content":"\n### 一. 高质量的javaScript\n\n#### 1. 团队合作——如何避免JS冲突\n\n    工程师甲定义了一个全局变量a\n    \n    var a, b = \"hello\";\n    \n    工程师乙也定义了一个全局变量a\n    \n    var a = \"la\";\n\n这种情况下，就会团队合作就会产生冲突。\n\n<font color=\"red\">**解决办法：**</font>\n\n用匿名函数将脚本包起来，可以将变量的作用域控制在匿名函数之内,可有效控制全局变量。\n\n    工程师甲的代码：\n    (function(){\n    \tvar a, b = \"hello\";\n    });\n    \n    工程师乙的代码：\n    (function(){\n    \tvar a = \"la\";\n    });\n\n### 2. 团队合作——两个功能模块之间如何进行通信\n\n使用1中的匿名函数包裹法，让每个功能呢的变量都限定在自己的作用域内，那么如果工程师乙想要使用工程师甲代码里的变量，应该怎么办呢？\n\n<font color=\"red\">**解决办法：**</font>\n\n使用全局变量进行通信，声明一个全局变量var GLOBAL = {};并使用命名空间。\n\n\t<script>       \n        var GLOBAL = {};//声明一个全局的对象\n\n\t\tGLOBAL.namespace = function(str) {\n\t\t\tvar arr = str.split(\".\"), o = GLOBAL;\n\t\t\tfor(var i = (arr[0] == \"GLOBAL\") ? 1 : 0; i < arr.length; i++) {\n\t\t\t\to[arr[i]] = o[arr[i]] || {};\n\t\t\t\to = o[arr[i]];\n\t\t\t}\n\t\t}\n    </script> \n    \n\t//工程师甲的代码\n    <script> \n      (function() {\n        var a = \"hello\";\n        GLOBAL.A = {};//命名空间为A\n        GLOBAL.A.str = a;\n        console.log(GLOBAL);//{A:{str:\"hello\"}}\n      })();\n    </script> \n    \n\t//工程师乙的代码\n    <script>  \n      (function() {\n        var b = GLOBAL.A.str;//这样乙的功能模块里就使用了甲里面的变量\n        console.log(GLOBAL);//{A:{str:\"hello\"}}\n      })();\n    </script> \n\n#### 3. 给所有的功能提供一个统一的入口\n\n    js分为框架部分和应用部分。\n    \n    框架部分用来定义全局变量，命名空间，与具体的功能无关。\n    \n    应用部分全部放在一个`init()`函数里面，用`window.onload = init;`调用初始化函数。\n\n**注意：**当页面的图片、媒体文件较多时，使用window.onload可能并不好，因为我们一般只需要等DOM元素加载完毕之后即可。\n\n#### 4. CSS放在页头，js放在页尾\n\n#### 5. 压缩js\n\n**压缩js所做的功能：**去掉空格、去掉换行、将复杂的变量名变成简单的变量名。\n\n#### 6. js分层\n\n推荐的一种分层的方法：\n\n- base层\n- common层：提供可以复用的组件\n- page层：与某一页面的具体功能相关\n\n**(1)base层**\n\n封装不同浏览器之间的差异，提供统一的接口（如前5个例子）；扩展js底层的接口。\n\n分为三类：event相关，dom相关，language相关\n\n**例子一：**\n\n<font color=\"red\">封装一个取得下一个DOM节点的函数`getNextNode`</font>\n\n    由于js中的nextSibling属性获得的相邻的下一个节点并不一定是dom节点，可能是空的文本节点等。\n\n    function getNextNode(node) {\n\t    var nextNode = node.nextSibling;\n\t    if(!nextNode) {\n\t      return null;\n\t    }\n\t    \n\t    while(true) {\n\t      if(nextNode.nodeType == 1) {\n\t    \tbreak;\n\t      } else {\n\t\t    if(nextNode.nextSibling) {\n\t\t      nextNode = nextNode.nextSibling;\n\t\t    } else {\n\t\t      break;\n\t\t    }\n\t      }\n\t    \n\t      return nextNode;\n\t    }\n    }\n\n**例子二：**\n\n<font color=\"red\">IE和其他浏览器中的事件对象`event`，封装一个获取当前事件的派生对象的函数`getEventTarget`</font>\n\n    在IE中，event是作为window对象的属性存在的；在其他浏览器中，event是事件的参数。\n    \n    在IE中，派生事件的对象是由`event.srcElement`获得；在其他浏览器中，派生事件的对象是由`event.target`获得。\n    \n    function getEventTarget(event) {\n    \tvar eve = window.event || event;\n    \treturn eve.srcElement || eve.target;\n    }\n\n**例子三：**\n\n<font color=\"red\">取消事件冒泡</font>\n\n    在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n    \n    在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n    \n    function stopPropagation(event) {\n    \tvar eve = window.event || event;\n    \tif(eve.stopPropagation) {\n    \t\teve.stopPropagation();\n    \t} else {\n    \t\teve.cancelBubble = true;\n    \t}\n    }\n\n**例子四：**\n\n<font color=\"red\">取消事件的默认行为</font>\n\n    **事件的默认行为：**例如`<a>`的点击事件的默认行为就是跳转链接\n    \n    在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n    \n    在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n    \n    function preventDefault() {\n    \tvar eve = window.event || event;\n    \tif(eve.preventDefault){\n    \t\teve.preventDefault();\n    \t} else {\n    \t\teve.returnValue = false;\n    \t}\n    }\n\n**例子五：**\n\n<font color=\"red\">绑定事件和取消绑定事件</font>\n\n    IE(IE8及以下版本)中使用obj.attachEvent(\"on...\",fn)绑定事件；使用obj.detachEvent(\"on...\",fn)来解绑事件。\n    \n    其他浏览器中使用obj.addEventListener(\"type\",fn,false)来绑定事件；使用obj.removeEventListener(\"type\",fn,false)来解绑事件\n    \n    var EventUtil = {\n    \n    \taddHandler: function(element,type,fn) {\n    \t\tif(element.attachEvent) {\n    \t\t\telement.attachEvent(\"on\" + type,fn);\n    \t\t} else {\n    \t\t\telement.addEventListener(type,fn,false);//如果允许事件冒泡，第三个参数则为false\n    \t\t}\n    \t},\n    \n    \tremoveHandler: function(element,type,fn) {\n    \t\tif(element.detachEvent) {\n    \t\t\telement.detachEvent(\"on\" + type,fn);\n    \t\t} else {\n    \t\t\telement.removeEventListener(type,fn,false);\n    \t\t}\n    \t}\n    \n    }\n\n-----------------------------------------------------\n\n下面是扩展js的底层接口的例子。\n\n**例子六：**\n\n<font color=\"red\">判断类型的方法</font>\n\n    //基本类型\n    function isNumber(s) {\n    \treturn !isNaN(s);\n    }\n    \n    function isString(s) {\n    \treturn typeof s === \"string\";\n    }\n    \n    function isBoolean(s) {\n    \treturn typeof s === \"boolean\";\n    }\n    \n    function isNull(s) {\n    \treturn s === null;\n    }\n    \n    function isUndefined(s) {\n    \treturn typeof s === \"undefined\";\n    }\n    \n    //判断是否为空\n    function isEmpty(s) {\n    \treturn /^\\s*$/.test(s);//正则表达式.test(字符串)\n    }\n    \n    //引用类型判断\n    function isArray(s) {\n    \treturn s instanceof Array;\n    }\n    \n    function isFunction(s) {\n    \treturn typeof s === \"function\";\n    }\n\n**例子七：**\n\n<font color=\"red\">用$代替document.getElementById(\"\")</font>\n\n    由于document.getElementById(\"\")太长了，可以写一个函数，用一个简单的函数名来代替它。\n    \n    function $(node) {\n    \tnode = typeof node === \"string\" ? document.getElementById(node) : node;//传入的参数是id值或者节点本身\n    \treturn node;\n    }\n\n**例子八：**\n\n<font color=\"red\">使用className获取节点的getElementsByClassName()</font>\n\n**用id名获取节点：**一个页面的同一个id只能出现一次，因此不能通过id来获取一组相似功能的节点。\n\n**用tag名获取节点：**程序和HTML耦合得太紧。\n\t\n\t//通过className来获取一组dom节点\n\t//输入参数：str为class的名字，必须；\n\t//root为该dom的父元素，可选\n\t//tag为标签名，可选\n    function getElementByClassName(str,root,tag) {\n    \tif(root) {\n    \t\troot = typeof root === \"string\" ? document.getElementById(root):root;\n    \t} else {\n    \t\troot = document.body;\n    \t}\n    \n    \ttag = tag || \"*\";\n    \tvar els = root.getElementByTagName(tag), arr = [];\n    \tfor(var i = 0; i < els.length; i++) {\n\t\t\tvar  elsClassName = els[i].className.split(\" \");\n\t\t\tfor(var j = 0; j < elsClassName.length; j++) {\n\t\t\t\tif(elsClassName[j] == str) {\n\t    \t\t\tarr.push(els[i]);\n\t    \t\t\tbreak;\n    \t\t\t}\n\t\t\t}   \t\t\n    \t}\n    \treturn arr;\n    }\n\n**例子九：**\n\n<font color=\"red\">增加className和删除某一个className</font>\n\n使用dom.className = \"\"；来删除className，但是这种方法有一个缺陷，就是会将dom元素的所有className都删除。所以需要封装可以删除或者添加某一个特定的className的函数。\n\n    //添加class的函数，输入参数node为该节点，str为class的名称\n    function addClass(node,str) {\n    \tvar reg = new RegExp(\"(^|\\\\s+)\" + str);\n    \tif(!reg.test(node.className)) {\n    \t\tnode.className = node.className + \" \" + str;\n    \t}\n    }\n    \n    //删除class的函数，输入参数node为该节点，str为class的名称\n    function removeClass(node,str) {\n    \tvar reg = new RegExp(\"(^|\\\\s+)\" + str);\n    \tnode.className = node.className.replace(reg,\"\");\n    }\n\n**(2) common层**\n\ncommon层一来base层提供的接口，为page组件调用。\n\n**common层常见的组件有：**\n\n- 异步通信的Ajax\n- 用于拖拽的Drag\n- 拖拉元素的Resize\n- 动画的Animation\n- 标签切换的Tab\n- 树形目录的Tree\n- 模拟弹出窗口Msg\n- 用于拾色器的ColorPicker\n- 用于日历的Calendar\n- 用于富文本编辑器的RichTextEditor\n- ............\n\n这些很多我之前都做过，但是并没有封装成一个组件的形式，有时间应该好好整理一下。\n\n    一个优秀的组件需要满足以下几个条件：\n    \n    - 跨浏览器兼容\n    - 组件易用\n    - 组件可重用\n    - 组件可扩展\n    - 代码组织有序，高内聚低耦合\n\ncommon层没有base层那么通用，不是每一个页面都会使用到common层里面的所有组件，因此应该将common层的按组件的形式保存在不同的**.js文件**里，然后**按需加载**。\n\n例如： common_tab.js、common_calendar.js\n\n**(3) page层**\n\npage层与具体的页面有关。\n\n<font color=\"red\">很多js框架可以为我们提供强大的base层和common层。</font>\n\n#### 7. 编程小技巧\n\n- 弹性\n- 可复用性\n- 避免产生副作用\n- 通过传参实现定制\n- 控制this关键字的指向\n- 预留回调接口\n- 编程中不要将相同的代码编写多次\n- 用hash对象传参\n\n可复用性：如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。\n\n通过传参实现定制：将容易变化的因素通过参数传进来\n\n利用hash对象传参的优点：参数的位置和顺序不重要了。","source":"_posts/2016-06-21-编写高质量代码——javaScript.md","raw":"---\nlayout: post\ntitle: 编写高质量代码————javaScript\ndate: 2016-06-21\ncategories: 前端笔记\ntags: [读书笔记,javaScript]\ndescription: \n---\n\n### 一. 高质量的javaScript\n\n#### 1. 团队合作——如何避免JS冲突\n\n    工程师甲定义了一个全局变量a\n    \n    var a, b = \"hello\";\n    \n    工程师乙也定义了一个全局变量a\n    \n    var a = \"la\";\n\n这种情况下，就会团队合作就会产生冲突。\n\n<font color=\"red\">**解决办法：**</font>\n\n用匿名函数将脚本包起来，可以将变量的作用域控制在匿名函数之内,可有效控制全局变量。\n\n    工程师甲的代码：\n    (function(){\n    \tvar a, b = \"hello\";\n    });\n    \n    工程师乙的代码：\n    (function(){\n    \tvar a = \"la\";\n    });\n\n### 2. 团队合作——两个功能模块之间如何进行通信\n\n使用1中的匿名函数包裹法，让每个功能呢的变量都限定在自己的作用域内，那么如果工程师乙想要使用工程师甲代码里的变量，应该怎么办呢？\n\n<font color=\"red\">**解决办法：**</font>\n\n使用全局变量进行通信，声明一个全局变量var GLOBAL = {};并使用命名空间。\n\n\t<script>       \n        var GLOBAL = {};//声明一个全局的对象\n\n\t\tGLOBAL.namespace = function(str) {\n\t\t\tvar arr = str.split(\".\"), o = GLOBAL;\n\t\t\tfor(var i = (arr[0] == \"GLOBAL\") ? 1 : 0; i < arr.length; i++) {\n\t\t\t\to[arr[i]] = o[arr[i]] || {};\n\t\t\t\to = o[arr[i]];\n\t\t\t}\n\t\t}\n    </script> \n    \n\t//工程师甲的代码\n    <script> \n      (function() {\n        var a = \"hello\";\n        GLOBAL.A = {};//命名空间为A\n        GLOBAL.A.str = a;\n        console.log(GLOBAL);//{A:{str:\"hello\"}}\n      })();\n    </script> \n    \n\t//工程师乙的代码\n    <script>  \n      (function() {\n        var b = GLOBAL.A.str;//这样乙的功能模块里就使用了甲里面的变量\n        console.log(GLOBAL);//{A:{str:\"hello\"}}\n      })();\n    </script> \n\n#### 3. 给所有的功能提供一个统一的入口\n\n    js分为框架部分和应用部分。\n    \n    框架部分用来定义全局变量，命名空间，与具体的功能无关。\n    \n    应用部分全部放在一个`init()`函数里面，用`window.onload = init;`调用初始化函数。\n\n**注意：**当页面的图片、媒体文件较多时，使用window.onload可能并不好，因为我们一般只需要等DOM元素加载完毕之后即可。\n\n#### 4. CSS放在页头，js放在页尾\n\n#### 5. 压缩js\n\n**压缩js所做的功能：**去掉空格、去掉换行、将复杂的变量名变成简单的变量名。\n\n#### 6. js分层\n\n推荐的一种分层的方法：\n\n- base层\n- common层：提供可以复用的组件\n- page层：与某一页面的具体功能相关\n\n**(1)base层**\n\n封装不同浏览器之间的差异，提供统一的接口（如前5个例子）；扩展js底层的接口。\n\n分为三类：event相关，dom相关，language相关\n\n**例子一：**\n\n<font color=\"red\">封装一个取得下一个DOM节点的函数`getNextNode`</font>\n\n    由于js中的nextSibling属性获得的相邻的下一个节点并不一定是dom节点，可能是空的文本节点等。\n\n    function getNextNode(node) {\n\t    var nextNode = node.nextSibling;\n\t    if(!nextNode) {\n\t      return null;\n\t    }\n\t    \n\t    while(true) {\n\t      if(nextNode.nodeType == 1) {\n\t    \tbreak;\n\t      } else {\n\t\t    if(nextNode.nextSibling) {\n\t\t      nextNode = nextNode.nextSibling;\n\t\t    } else {\n\t\t      break;\n\t\t    }\n\t      }\n\t    \n\t      return nextNode;\n\t    }\n    }\n\n**例子二：**\n\n<font color=\"red\">IE和其他浏览器中的事件对象`event`，封装一个获取当前事件的派生对象的函数`getEventTarget`</font>\n\n    在IE中，event是作为window对象的属性存在的；在其他浏览器中，event是事件的参数。\n    \n    在IE中，派生事件的对象是由`event.srcElement`获得；在其他浏览器中，派生事件的对象是由`event.target`获得。\n    \n    function getEventTarget(event) {\n    \tvar eve = window.event || event;\n    \treturn eve.srcElement || eve.target;\n    }\n\n**例子三：**\n\n<font color=\"red\">取消事件冒泡</font>\n\n    在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n    \n    在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n    \n    function stopPropagation(event) {\n    \tvar eve = window.event || event;\n    \tif(eve.stopPropagation) {\n    \t\teve.stopPropagation();\n    \t} else {\n    \t\teve.cancelBubble = true;\n    \t}\n    }\n\n**例子四：**\n\n<font color=\"red\">取消事件的默认行为</font>\n\n    **事件的默认行为：**例如`<a>`的点击事件的默认行为就是跳转链接\n    \n    在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n    \n    在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n    \n    function preventDefault() {\n    \tvar eve = window.event || event;\n    \tif(eve.preventDefault){\n    \t\teve.preventDefault();\n    \t} else {\n    \t\teve.returnValue = false;\n    \t}\n    }\n\n**例子五：**\n\n<font color=\"red\">绑定事件和取消绑定事件</font>\n\n    IE(IE8及以下版本)中使用obj.attachEvent(\"on...\",fn)绑定事件；使用obj.detachEvent(\"on...\",fn)来解绑事件。\n    \n    其他浏览器中使用obj.addEventListener(\"type\",fn,false)来绑定事件；使用obj.removeEventListener(\"type\",fn,false)来解绑事件\n    \n    var EventUtil = {\n    \n    \taddHandler: function(element,type,fn) {\n    \t\tif(element.attachEvent) {\n    \t\t\telement.attachEvent(\"on\" + type,fn);\n    \t\t} else {\n    \t\t\telement.addEventListener(type,fn,false);//如果允许事件冒泡，第三个参数则为false\n    \t\t}\n    \t},\n    \n    \tremoveHandler: function(element,type,fn) {\n    \t\tif(element.detachEvent) {\n    \t\t\telement.detachEvent(\"on\" + type,fn);\n    \t\t} else {\n    \t\t\telement.removeEventListener(type,fn,false);\n    \t\t}\n    \t}\n    \n    }\n\n-----------------------------------------------------\n\n下面是扩展js的底层接口的例子。\n\n**例子六：**\n\n<font color=\"red\">判断类型的方法</font>\n\n    //基本类型\n    function isNumber(s) {\n    \treturn !isNaN(s);\n    }\n    \n    function isString(s) {\n    \treturn typeof s === \"string\";\n    }\n    \n    function isBoolean(s) {\n    \treturn typeof s === \"boolean\";\n    }\n    \n    function isNull(s) {\n    \treturn s === null;\n    }\n    \n    function isUndefined(s) {\n    \treturn typeof s === \"undefined\";\n    }\n    \n    //判断是否为空\n    function isEmpty(s) {\n    \treturn /^\\s*$/.test(s);//正则表达式.test(字符串)\n    }\n    \n    //引用类型判断\n    function isArray(s) {\n    \treturn s instanceof Array;\n    }\n    \n    function isFunction(s) {\n    \treturn typeof s === \"function\";\n    }\n\n**例子七：**\n\n<font color=\"red\">用$代替document.getElementById(\"\")</font>\n\n    由于document.getElementById(\"\")太长了，可以写一个函数，用一个简单的函数名来代替它。\n    \n    function $(node) {\n    \tnode = typeof node === \"string\" ? document.getElementById(node) : node;//传入的参数是id值或者节点本身\n    \treturn node;\n    }\n\n**例子八：**\n\n<font color=\"red\">使用className获取节点的getElementsByClassName()</font>\n\n**用id名获取节点：**一个页面的同一个id只能出现一次，因此不能通过id来获取一组相似功能的节点。\n\n**用tag名获取节点：**程序和HTML耦合得太紧。\n\t\n\t//通过className来获取一组dom节点\n\t//输入参数：str为class的名字，必须；\n\t//root为该dom的父元素，可选\n\t//tag为标签名，可选\n    function getElementByClassName(str,root,tag) {\n    \tif(root) {\n    \t\troot = typeof root === \"string\" ? document.getElementById(root):root;\n    \t} else {\n    \t\troot = document.body;\n    \t}\n    \n    \ttag = tag || \"*\";\n    \tvar els = root.getElementByTagName(tag), arr = [];\n    \tfor(var i = 0; i < els.length; i++) {\n\t\t\tvar  elsClassName = els[i].className.split(\" \");\n\t\t\tfor(var j = 0; j < elsClassName.length; j++) {\n\t\t\t\tif(elsClassName[j] == str) {\n\t    \t\t\tarr.push(els[i]);\n\t    \t\t\tbreak;\n    \t\t\t}\n\t\t\t}   \t\t\n    \t}\n    \treturn arr;\n    }\n\n**例子九：**\n\n<font color=\"red\">增加className和删除某一个className</font>\n\n使用dom.className = \"\"；来删除className，但是这种方法有一个缺陷，就是会将dom元素的所有className都删除。所以需要封装可以删除或者添加某一个特定的className的函数。\n\n    //添加class的函数，输入参数node为该节点，str为class的名称\n    function addClass(node,str) {\n    \tvar reg = new RegExp(\"(^|\\\\s+)\" + str);\n    \tif(!reg.test(node.className)) {\n    \t\tnode.className = node.className + \" \" + str;\n    \t}\n    }\n    \n    //删除class的函数，输入参数node为该节点，str为class的名称\n    function removeClass(node,str) {\n    \tvar reg = new RegExp(\"(^|\\\\s+)\" + str);\n    \tnode.className = node.className.replace(reg,\"\");\n    }\n\n**(2) common层**\n\ncommon层一来base层提供的接口，为page组件调用。\n\n**common层常见的组件有：**\n\n- 异步通信的Ajax\n- 用于拖拽的Drag\n- 拖拉元素的Resize\n- 动画的Animation\n- 标签切换的Tab\n- 树形目录的Tree\n- 模拟弹出窗口Msg\n- 用于拾色器的ColorPicker\n- 用于日历的Calendar\n- 用于富文本编辑器的RichTextEditor\n- ............\n\n这些很多我之前都做过，但是并没有封装成一个组件的形式，有时间应该好好整理一下。\n\n    一个优秀的组件需要满足以下几个条件：\n    \n    - 跨浏览器兼容\n    - 组件易用\n    - 组件可重用\n    - 组件可扩展\n    - 代码组织有序，高内聚低耦合\n\ncommon层没有base层那么通用，不是每一个页面都会使用到common层里面的所有组件，因此应该将common层的按组件的形式保存在不同的**.js文件**里，然后**按需加载**。\n\n例如： common_tab.js、common_calendar.js\n\n**(3) page层**\n\npage层与具体的页面有关。\n\n<font color=\"red\">很多js框架可以为我们提供强大的base层和common层。</font>\n\n#### 7. 编程小技巧\n\n- 弹性\n- 可复用性\n- 避免产生副作用\n- 通过传参实现定制\n- 控制this关键字的指向\n- 预留回调接口\n- 编程中不要将相同的代码编写多次\n- 用hash对象传参\n\n可复用性：如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。\n\n通过传参实现定制：将容易变化的因素通过参数传进来\n\n利用hash对象传参的优点：参数的位置和顺序不重要了。","slug":"2016-06-21-编写高质量代码——javaScript","published":1,"updated":"2016-06-29T01:41:46.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocis009yd5u8i5ek0xqp","content":"<h3 id=\"一-高质量的javaScript\"><a href=\"#一-高质量的javaScript\" class=\"headerlink\" title=\"一. 高质量的javaScript\"></a>一. 高质量的javaScript</h3><h4 id=\"1-团队合作——如何避免JS冲突\"><a href=\"#1-团队合作——如何避免JS冲突\" class=\"headerlink\" title=\"1. 团队合作——如何避免JS冲突\"></a>1. 团队合作——如何避免JS冲突</h4><pre><code>工程师甲定义了一个全局变量a\n\nvar a, b = &quot;hello&quot;;\n\n工程师乙也定义了一个全局变量a\n\nvar a = &quot;la&quot;;\n</code></pre><p>这种情况下，就会团队合作就会产生冲突。</p>\n<font color=\"red\"><strong>解决办法：</strong></font>\n\n<p>用匿名函数将脚本包起来，可以将变量的作用域控制在匿名函数之内,可有效控制全局变量。</p>\n<pre><code>工程师甲的代码：\n(function(){\n    var a, b = &quot;hello&quot;;\n});\n\n工程师乙的代码：\n(function(){\n    var a = &quot;la&quot;;\n});\n</code></pre><h3 id=\"2-团队合作——两个功能模块之间如何进行通信\"><a href=\"#2-团队合作——两个功能模块之间如何进行通信\" class=\"headerlink\" title=\"2. 团队合作——两个功能模块之间如何进行通信\"></a>2. 团队合作——两个功能模块之间如何进行通信</h3><p>使用1中的匿名函数包裹法，让每个功能呢的变量都限定在自己的作用域内，那么如果工程师乙想要使用工程师甲代码里的变量，应该怎么办呢？</p>\n<font color=\"red\"><strong>解决办法：</strong></font>\n\n<p>使用全局变量进行通信，声明一个全局变量var GLOBAL = {};并使用命名空间。</p>\n<pre><code>&lt;script&gt;       \n    var GLOBAL = {};//声明一个全局的对象\n\n    GLOBAL.namespace = function(str) {\n        var arr = str.split(&quot;.&quot;), o = GLOBAL;\n        for(var i = (arr[0] == &quot;GLOBAL&quot;) ? 1 : 0; i &lt; arr.length; i++) {\n            o[arr[i]] = o[arr[i]] || {};\n            o = o[arr[i]];\n        }\n    }\n&lt;/script&gt; \n\n//工程师甲的代码\n&lt;script&gt; \n  (function() {\n    var a = &quot;hello&quot;;\n    GLOBAL.A = {};//命名空间为A\n    GLOBAL.A.str = a;\n    console.log(GLOBAL);//{A:{str:&quot;hello&quot;}}\n  })();\n&lt;/script&gt; \n\n//工程师乙的代码\n&lt;script&gt;  \n  (function() {\n    var b = GLOBAL.A.str;//这样乙的功能模块里就使用了甲里面的变量\n    console.log(GLOBAL);//{A:{str:&quot;hello&quot;}}\n  })();\n&lt;/script&gt; \n</code></pre><h4 id=\"3-给所有的功能提供一个统一的入口\"><a href=\"#3-给所有的功能提供一个统一的入口\" class=\"headerlink\" title=\"3. 给所有的功能提供一个统一的入口\"></a>3. 给所有的功能提供一个统一的入口</h4><pre><code>js分为框架部分和应用部分。\n\n框架部分用来定义全局变量，命名空间，与具体的功能无关。\n\n应用部分全部放在一个`init()`函数里面，用`window.onload = init;`调用初始化函数。\n</code></pre><p><strong>注意：</strong>当页面的图片、媒体文件较多时，使用window.onload可能并不好，因为我们一般只需要等DOM元素加载完毕之后即可。</p>\n<h4 id=\"4-CSS放在页头，js放在页尾\"><a href=\"#4-CSS放在页头，js放在页尾\" class=\"headerlink\" title=\"4. CSS放在页头，js放在页尾\"></a>4. CSS放在页头，js放在页尾</h4><h4 id=\"5-压缩js\"><a href=\"#5-压缩js\" class=\"headerlink\" title=\"5. 压缩js\"></a>5. 压缩js</h4><p><strong>压缩js所做的功能：</strong>去掉空格、去掉换行、将复杂的变量名变成简单的变量名。</p>\n<h4 id=\"6-js分层\"><a href=\"#6-js分层\" class=\"headerlink\" title=\"6. js分层\"></a>6. js分层</h4><p>推荐的一种分层的方法：</p>\n<ul>\n<li>base层</li>\n<li>common层：提供可以复用的组件</li>\n<li>page层：与某一页面的具体功能相关</li>\n</ul>\n<p><strong>(1)base层</strong></p>\n<p>封装不同浏览器之间的差异，提供统一的接口（如前5个例子）；扩展js底层的接口。</p>\n<p>分为三类：event相关，dom相关，language相关</p>\n<p><strong>例子一：</strong></p>\n<font color=\"red\">封装一个取得下一个DOM节点的函数<code>getNextNode</code></font>\n\n<pre><code>由于js中的nextSibling属性获得的相邻的下一个节点并不一定是dom节点，可能是空的文本节点等。\n\nfunction getNextNode(node) {\n    var nextNode = node.nextSibling;\n    if(!nextNode) {\n      return null;\n    }\n\n    while(true) {\n      if(nextNode.nodeType == 1) {\n        break;\n      } else {\n        if(nextNode.nextSibling) {\n          nextNode = nextNode.nextSibling;\n        } else {\n          break;\n        }\n      }\n\n      return nextNode;\n    }\n}\n</code></pre><p><strong>例子二：</strong></p>\n<font color=\"red\">IE和其他浏览器中的事件对象<code>event</code>，封装一个获取当前事件的派生对象的函数<code>getEventTarget</code></font>\n\n<pre><code>在IE中，event是作为window对象的属性存在的；在其他浏览器中，event是事件的参数。\n\n在IE中，派生事件的对象是由`event.srcElement`获得；在其他浏览器中，派生事件的对象是由`event.target`获得。\n\nfunction getEventTarget(event) {\n    var eve = window.event || event;\n    return eve.srcElement || eve.target;\n}\n</code></pre><p><strong>例子三：</strong></p>\n<font color=\"red\">取消事件冒泡</font>\n\n<pre><code>在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n\n在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n\nfunction stopPropagation(event) {\n    var eve = window.event || event;\n    if(eve.stopPropagation) {\n        eve.stopPropagation();\n    } else {\n        eve.cancelBubble = true;\n    }\n}\n</code></pre><p><strong>例子四：</strong></p>\n<font color=\"red\">取消事件的默认行为</font>\n\n<pre><code>**事件的默认行为：**例如`&lt;a&gt;`的点击事件的默认行为就是跳转链接\n\n在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n\n在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n\nfunction preventDefault() {\n    var eve = window.event || event;\n    if(eve.preventDefault){\n        eve.preventDefault();\n    } else {\n        eve.returnValue = false;\n    }\n}\n</code></pre><p><strong>例子五：</strong></p>\n<font color=\"red\">绑定事件和取消绑定事件</font>\n\n<pre><code>IE(IE8及以下版本)中使用obj.attachEvent(&quot;on...&quot;,fn)绑定事件；使用obj.detachEvent(&quot;on...&quot;,fn)来解绑事件。\n\n其他浏览器中使用obj.addEventListener(&quot;type&quot;,fn,false)来绑定事件；使用obj.removeEventListener(&quot;type&quot;,fn,false)来解绑事件\n\nvar EventUtil = {\n\n    addHandler: function(element,type,fn) {\n        if(element.attachEvent) {\n            element.attachEvent(&quot;on&quot; + type,fn);\n        } else {\n            element.addEventListener(type,fn,false);//如果允许事件冒泡，第三个参数则为false\n        }\n    },\n\n    removeHandler: function(element,type,fn) {\n        if(element.detachEvent) {\n            element.detachEvent(&quot;on&quot; + type,fn);\n        } else {\n            element.removeEventListener(type,fn,false);\n        }\n    }\n\n}\n</code></pre><hr>\n<p>下面是扩展js的底层接口的例子。</p>\n<p><strong>例子六：</strong></p>\n<font color=\"red\">判断类型的方法</font>\n\n<pre><code>//基本类型\nfunction isNumber(s) {\n    return !isNaN(s);\n}\n\nfunction isString(s) {\n    return typeof s === &quot;string&quot;;\n}\n\nfunction isBoolean(s) {\n    return typeof s === &quot;boolean&quot;;\n}\n\nfunction isNull(s) {\n    return s === null;\n}\n\nfunction isUndefined(s) {\n    return typeof s === &quot;undefined&quot;;\n}\n\n//判断是否为空\nfunction isEmpty(s) {\n    return /^\\s*$/.test(s);//正则表达式.test(字符串)\n}\n\n//引用类型判断\nfunction isArray(s) {\n    return s instanceof Array;\n}\n\nfunction isFunction(s) {\n    return typeof s === &quot;function&quot;;\n}\n</code></pre><p><strong>例子七：</strong></p>\n<font color=\"red\">用$代替document.getElementById(“”)</font>\n\n<pre><code>由于document.getElementById(&quot;&quot;)太长了，可以写一个函数，用一个简单的函数名来代替它。\n\nfunction $(node) {\n    node = typeof node === &quot;string&quot; ? document.getElementById(node) : node;//传入的参数是id值或者节点本身\n    return node;\n}\n</code></pre><p><strong>例子八：</strong></p>\n<font color=\"red\">使用className获取节点的getElementsByClassName()</font>\n\n<p><strong>用id名获取节点：</strong>一个页面的同一个id只能出现一次，因此不能通过id来获取一组相似功能的节点。</p>\n<p><strong>用tag名获取节点：</strong>程序和HTML耦合得太紧。</p>\n<pre><code>//通过className来获取一组dom节点\n//输入参数：str为class的名字，必须；\n//root为该dom的父元素，可选\n//tag为标签名，可选\nfunction getElementByClassName(str,root,tag) {\n    if(root) {\n        root = typeof root === &quot;string&quot; ? document.getElementById(root):root;\n    } else {\n        root = document.body;\n    }\n\n    tag = tag || &quot;*&quot;;\n    var els = root.getElementByTagName(tag), arr = [];\n    for(var i = 0; i &lt; els.length; i++) {\n        var  elsClassName = els[i].className.split(&quot; &quot;);\n        for(var j = 0; j &lt; elsClassName.length; j++) {\n            if(elsClassName[j] == str) {\n                arr.push(els[i]);\n                break;\n            }\n        }           \n    }\n    return arr;\n}\n</code></pre><p><strong>例子九：</strong></p>\n<font color=\"red\">增加className和删除某一个className</font>\n\n<p>使用dom.className = “”；来删除className，但是这种方法有一个缺陷，就是会将dom元素的所有className都删除。所以需要封装可以删除或者添加某一个特定的className的函数。</p>\n<pre><code>//添加class的函数，输入参数node为该节点，str为class的名称\nfunction addClass(node,str) {\n    var reg = new RegExp(&quot;(^|\\\\s+)&quot; + str);\n    if(!reg.test(node.className)) {\n        node.className = node.className + &quot; &quot; + str;\n    }\n}\n\n//删除class的函数，输入参数node为该节点，str为class的名称\nfunction removeClass(node,str) {\n    var reg = new RegExp(&quot;(^|\\\\s+)&quot; + str);\n    node.className = node.className.replace(reg,&quot;&quot;);\n}\n</code></pre><p><strong>(2) common层</strong></p>\n<p>common层一来base层提供的接口，为page组件调用。</p>\n<p><strong>common层常见的组件有：</strong></p>\n<ul>\n<li>异步通信的Ajax</li>\n<li>用于拖拽的Drag</li>\n<li>拖拉元素的Resize</li>\n<li>动画的Animation</li>\n<li>标签切换的Tab</li>\n<li>树形目录的Tree</li>\n<li>模拟弹出窗口Msg</li>\n<li>用于拾色器的ColorPicker</li>\n<li>用于日历的Calendar</li>\n<li>用于富文本编辑器的RichTextEditor</li>\n<li>…………</li>\n</ul>\n<p>这些很多我之前都做过，但是并没有封装成一个组件的形式，有时间应该好好整理一下。</p>\n<pre><code>一个优秀的组件需要满足以下几个条件：\n\n- 跨浏览器兼容\n- 组件易用\n- 组件可重用\n- 组件可扩展\n- 代码组织有序，高内聚低耦合\n</code></pre><p>common层没有base层那么通用，不是每一个页面都会使用到common层里面的所有组件，因此应该将common层的按组件的形式保存在不同的<strong>.js文件</strong>里，然后<strong>按需加载</strong>。</p>\n<p>例如： common_tab.js、common_calendar.js</p>\n<p><strong>(3) page层</strong></p>\n<p>page层与具体的页面有关。</p>\n<font color=\"red\">很多js框架可以为我们提供强大的base层和common层。</font>\n\n<h4 id=\"7-编程小技巧\"><a href=\"#7-编程小技巧\" class=\"headerlink\" title=\"7. 编程小技巧\"></a>7. 编程小技巧</h4><ul>\n<li>弹性</li>\n<li>可复用性</li>\n<li>避免产生副作用</li>\n<li>通过传参实现定制</li>\n<li>控制this关键字的指向</li>\n<li>预留回调接口</li>\n<li>编程中不要将相同的代码编写多次</li>\n<li>用hash对象传参</li>\n</ul>\n<p>可复用性：如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。</p>\n<p>通过传参实现定制：将容易变化的因素通过参数传进来</p>\n<p>利用hash对象传参的优点：参数的位置和顺序不重要了。</p>\n","excerpt":"","more":"<h3 id=\"一-高质量的javaScript\"><a href=\"#一-高质量的javaScript\" class=\"headerlink\" title=\"一. 高质量的javaScript\"></a>一. 高质量的javaScript</h3><h4 id=\"1-团队合作——如何避免JS冲突\"><a href=\"#1-团队合作——如何避免JS冲突\" class=\"headerlink\" title=\"1. 团队合作——如何避免JS冲突\"></a>1. 团队合作——如何避免JS冲突</h4><pre><code>工程师甲定义了一个全局变量a\n\nvar a, b = &quot;hello&quot;;\n\n工程师乙也定义了一个全局变量a\n\nvar a = &quot;la&quot;;\n</code></pre><p>这种情况下，就会团队合作就会产生冲突。</p>\n<font color=\"red\"><strong>解决办法：</strong></font>\n\n<p>用匿名函数将脚本包起来，可以将变量的作用域控制在匿名函数之内,可有效控制全局变量。</p>\n<pre><code>工程师甲的代码：\n(function(){\n    var a, b = &quot;hello&quot;;\n});\n\n工程师乙的代码：\n(function(){\n    var a = &quot;la&quot;;\n});\n</code></pre><h3 id=\"2-团队合作——两个功能模块之间如何进行通信\"><a href=\"#2-团队合作——两个功能模块之间如何进行通信\" class=\"headerlink\" title=\"2. 团队合作——两个功能模块之间如何进行通信\"></a>2. 团队合作——两个功能模块之间如何进行通信</h3><p>使用1中的匿名函数包裹法，让每个功能呢的变量都限定在自己的作用域内，那么如果工程师乙想要使用工程师甲代码里的变量，应该怎么办呢？</p>\n<font color=\"red\"><strong>解决办法：</strong></font>\n\n<p>使用全局变量进行通信，声明一个全局变量var GLOBAL = {};并使用命名空间。</p>\n<pre><code>&lt;script&gt;       \n    var GLOBAL = {};//声明一个全局的对象\n\n    GLOBAL.namespace = function(str) {\n        var arr = str.split(&quot;.&quot;), o = GLOBAL;\n        for(var i = (arr[0] == &quot;GLOBAL&quot;) ? 1 : 0; i &lt; arr.length; i++) {\n            o[arr[i]] = o[arr[i]] || {};\n            o = o[arr[i]];\n        }\n    }\n&lt;/script&gt; \n\n//工程师甲的代码\n&lt;script&gt; \n  (function() {\n    var a = &quot;hello&quot;;\n    GLOBAL.A = {};//命名空间为A\n    GLOBAL.A.str = a;\n    console.log(GLOBAL);//{A:{str:&quot;hello&quot;}}\n  })();\n&lt;/script&gt; \n\n//工程师乙的代码\n&lt;script&gt;  \n  (function() {\n    var b = GLOBAL.A.str;//这样乙的功能模块里就使用了甲里面的变量\n    console.log(GLOBAL);//{A:{str:&quot;hello&quot;}}\n  })();\n&lt;/script&gt; \n</code></pre><h4 id=\"3-给所有的功能提供一个统一的入口\"><a href=\"#3-给所有的功能提供一个统一的入口\" class=\"headerlink\" title=\"3. 给所有的功能提供一个统一的入口\"></a>3. 给所有的功能提供一个统一的入口</h4><pre><code>js分为框架部分和应用部分。\n\n框架部分用来定义全局变量，命名空间，与具体的功能无关。\n\n应用部分全部放在一个`init()`函数里面，用`window.onload = init;`调用初始化函数。\n</code></pre><p><strong>注意：</strong>当页面的图片、媒体文件较多时，使用window.onload可能并不好，因为我们一般只需要等DOM元素加载完毕之后即可。</p>\n<h4 id=\"4-CSS放在页头，js放在页尾\"><a href=\"#4-CSS放在页头，js放在页尾\" class=\"headerlink\" title=\"4. CSS放在页头，js放在页尾\"></a>4. CSS放在页头，js放在页尾</h4><h4 id=\"5-压缩js\"><a href=\"#5-压缩js\" class=\"headerlink\" title=\"5. 压缩js\"></a>5. 压缩js</h4><p><strong>压缩js所做的功能：</strong>去掉空格、去掉换行、将复杂的变量名变成简单的变量名。</p>\n<h4 id=\"6-js分层\"><a href=\"#6-js分层\" class=\"headerlink\" title=\"6. js分层\"></a>6. js分层</h4><p>推荐的一种分层的方法：</p>\n<ul>\n<li>base层</li>\n<li>common层：提供可以复用的组件</li>\n<li>page层：与某一页面的具体功能相关</li>\n</ul>\n<p><strong>(1)base层</strong></p>\n<p>封装不同浏览器之间的差异，提供统一的接口（如前5个例子）；扩展js底层的接口。</p>\n<p>分为三类：event相关，dom相关，language相关</p>\n<p><strong>例子一：</strong></p>\n<font color=\"red\">封装一个取得下一个DOM节点的函数<code>getNextNode</code></font>\n\n<pre><code>由于js中的nextSibling属性获得的相邻的下一个节点并不一定是dom节点，可能是空的文本节点等。\n\nfunction getNextNode(node) {\n    var nextNode = node.nextSibling;\n    if(!nextNode) {\n      return null;\n    }\n\n    while(true) {\n      if(nextNode.nodeType == 1) {\n        break;\n      } else {\n        if(nextNode.nextSibling) {\n          nextNode = nextNode.nextSibling;\n        } else {\n          break;\n        }\n      }\n\n      return nextNode;\n    }\n}\n</code></pre><p><strong>例子二：</strong></p>\n<font color=\"red\">IE和其他浏览器中的事件对象<code>event</code>，封装一个获取当前事件的派生对象的函数<code>getEventTarget</code></font>\n\n<pre><code>在IE中，event是作为window对象的属性存在的；在其他浏览器中，event是事件的参数。\n\n在IE中，派生事件的对象是由`event.srcElement`获得；在其他浏览器中，派生事件的对象是由`event.target`获得。\n\nfunction getEventTarget(event) {\n    var eve = window.event || event;\n    return eve.srcElement || eve.target;\n}\n</code></pre><p><strong>例子三：</strong></p>\n<font color=\"red\">取消事件冒泡</font>\n\n<pre><code>在IE中，使用`event.cancelBubble = true`来取消事件冒泡。\n\n在其他浏览器中，使用`stopPropagation()`方法来取消事件冒泡。\n\nfunction stopPropagation(event) {\n    var eve = window.event || event;\n    if(eve.stopPropagation) {\n        eve.stopPropagation();\n    } else {\n        eve.cancelBubble = true;\n    }\n}\n</code></pre><p><strong>例子四：</strong></p>\n<font color=\"red\">取消事件的默认行为</font>\n\n<pre><code>**事件的默认行为：**例如`&lt;a&gt;`的点击事件的默认行为就是跳转链接\n\n在IE中，使用`event.returnValue = false`来取消事件的默认行为。\n\n在其他浏览器中，使用`preventDefault()`方法来取消事件的默认行为。\n\nfunction preventDefault() {\n    var eve = window.event || event;\n    if(eve.preventDefault){\n        eve.preventDefault();\n    } else {\n        eve.returnValue = false;\n    }\n}\n</code></pre><p><strong>例子五：</strong></p>\n<font color=\"red\">绑定事件和取消绑定事件</font>\n\n<pre><code>IE(IE8及以下版本)中使用obj.attachEvent(&quot;on...&quot;,fn)绑定事件；使用obj.detachEvent(&quot;on...&quot;,fn)来解绑事件。\n\n其他浏览器中使用obj.addEventListener(&quot;type&quot;,fn,false)来绑定事件；使用obj.removeEventListener(&quot;type&quot;,fn,false)来解绑事件\n\nvar EventUtil = {\n\n    addHandler: function(element,type,fn) {\n        if(element.attachEvent) {\n            element.attachEvent(&quot;on&quot; + type,fn);\n        } else {\n            element.addEventListener(type,fn,false);//如果允许事件冒泡，第三个参数则为false\n        }\n    },\n\n    removeHandler: function(element,type,fn) {\n        if(element.detachEvent) {\n            element.detachEvent(&quot;on&quot; + type,fn);\n        } else {\n            element.removeEventListener(type,fn,false);\n        }\n    }\n\n}\n</code></pre><hr>\n<p>下面是扩展js的底层接口的例子。</p>\n<p><strong>例子六：</strong></p>\n<font color=\"red\">判断类型的方法</font>\n\n<pre><code>//基本类型\nfunction isNumber(s) {\n    return !isNaN(s);\n}\n\nfunction isString(s) {\n    return typeof s === &quot;string&quot;;\n}\n\nfunction isBoolean(s) {\n    return typeof s === &quot;boolean&quot;;\n}\n\nfunction isNull(s) {\n    return s === null;\n}\n\nfunction isUndefined(s) {\n    return typeof s === &quot;undefined&quot;;\n}\n\n//判断是否为空\nfunction isEmpty(s) {\n    return /^\\s*$/.test(s);//正则表达式.test(字符串)\n}\n\n//引用类型判断\nfunction isArray(s) {\n    return s instanceof Array;\n}\n\nfunction isFunction(s) {\n    return typeof s === &quot;function&quot;;\n}\n</code></pre><p><strong>例子七：</strong></p>\n<font color=\"red\">用$代替document.getElementById(“”)</font>\n\n<pre><code>由于document.getElementById(&quot;&quot;)太长了，可以写一个函数，用一个简单的函数名来代替它。\n\nfunction $(node) {\n    node = typeof node === &quot;string&quot; ? document.getElementById(node) : node;//传入的参数是id值或者节点本身\n    return node;\n}\n</code></pre><p><strong>例子八：</strong></p>\n<font color=\"red\">使用className获取节点的getElementsByClassName()</font>\n\n<p><strong>用id名获取节点：</strong>一个页面的同一个id只能出现一次，因此不能通过id来获取一组相似功能的节点。</p>\n<p><strong>用tag名获取节点：</strong>程序和HTML耦合得太紧。</p>\n<pre><code>//通过className来获取一组dom节点\n//输入参数：str为class的名字，必须；\n//root为该dom的父元素，可选\n//tag为标签名，可选\nfunction getElementByClassName(str,root,tag) {\n    if(root) {\n        root = typeof root === &quot;string&quot; ? document.getElementById(root):root;\n    } else {\n        root = document.body;\n    }\n\n    tag = tag || &quot;*&quot;;\n    var els = root.getElementByTagName(tag), arr = [];\n    for(var i = 0; i &lt; els.length; i++) {\n        var  elsClassName = els[i].className.split(&quot; &quot;);\n        for(var j = 0; j &lt; elsClassName.length; j++) {\n            if(elsClassName[j] == str) {\n                arr.push(els[i]);\n                break;\n            }\n        }           \n    }\n    return arr;\n}\n</code></pre><p><strong>例子九：</strong></p>\n<font color=\"red\">增加className和删除某一个className</font>\n\n<p>使用dom.className = “”；来删除className，但是这种方法有一个缺陷，就是会将dom元素的所有className都删除。所以需要封装可以删除或者添加某一个特定的className的函数。</p>\n<pre><code>//添加class的函数，输入参数node为该节点，str为class的名称\nfunction addClass(node,str) {\n    var reg = new RegExp(&quot;(^|\\\\s+)&quot; + str);\n    if(!reg.test(node.className)) {\n        node.className = node.className + &quot; &quot; + str;\n    }\n}\n\n//删除class的函数，输入参数node为该节点，str为class的名称\nfunction removeClass(node,str) {\n    var reg = new RegExp(&quot;(^|\\\\s+)&quot; + str);\n    node.className = node.className.replace(reg,&quot;&quot;);\n}\n</code></pre><p><strong>(2) common层</strong></p>\n<p>common层一来base层提供的接口，为page组件调用。</p>\n<p><strong>common层常见的组件有：</strong></p>\n<ul>\n<li>异步通信的Ajax</li>\n<li>用于拖拽的Drag</li>\n<li>拖拉元素的Resize</li>\n<li>动画的Animation</li>\n<li>标签切换的Tab</li>\n<li>树形目录的Tree</li>\n<li>模拟弹出窗口Msg</li>\n<li>用于拾色器的ColorPicker</li>\n<li>用于日历的Calendar</li>\n<li>用于富文本编辑器的RichTextEditor</li>\n<li>…………</li>\n</ul>\n<p>这些很多我之前都做过，但是并没有封装成一个组件的形式，有时间应该好好整理一下。</p>\n<pre><code>一个优秀的组件需要满足以下几个条件：\n\n- 跨浏览器兼容\n- 组件易用\n- 组件可重用\n- 组件可扩展\n- 代码组织有序，高内聚低耦合\n</code></pre><p>common层没有base层那么通用，不是每一个页面都会使用到common层里面的所有组件，因此应该将common层的按组件的形式保存在不同的<strong>.js文件</strong>里，然后<strong>按需加载</strong>。</p>\n<p>例如： common_tab.js、common_calendar.js</p>\n<p><strong>(3) page层</strong></p>\n<p>page层与具体的页面有关。</p>\n<font color=\"red\">很多js框架可以为我们提供强大的base层和common层。</font>\n\n<h4 id=\"7-编程小技巧\"><a href=\"#7-编程小技巧\" class=\"headerlink\" title=\"7. 编程小技巧\"></a>7. 编程小技巧</h4><ul>\n<li>弹性</li>\n<li>可复用性</li>\n<li>避免产生副作用</li>\n<li>通过传参实现定制</li>\n<li>控制this关键字的指向</li>\n<li>预留回调接口</li>\n<li>编程中不要将相同的代码编写多次</li>\n<li>用hash对象传参</li>\n</ul>\n<p>可复用性：如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。</p>\n<p>通过传参实现定制：将容易变化的因素通过参数传进来</p>\n<p>利用hash对象传参的优点：参数的位置和顺序不重要了。</p>\n"},{"layout":"post","title":"研究登陆信息与登陆状态","date":"2016-06-16T16:00:00.000Z","description":null,"_content":"\n这几天看了一下session和cookie的内容，突然对登陆页面产生了兴趣，经过测试发现，无论在多进程还是多线程浏览器中，淘宝的登陆是满足：\n\n1. 在浏览器的a标签页面登陆自己的账号，同时打开该浏览器的另外一个标签页b，在b页面访问淘宝，发现b页面是显示的登陆状态。\n\n2. 若在b页面退出登陆，再打开a页面，在不执行任何操作的情况下，a页面显示的虽然是登陆状态，但其实已经退出登陆了，刷新页面或者点击一个链接，都会跳到让你登陆的页面。\n\n3. a页面处于登录状态，若关闭浏览器，再次打开浏览器，访问淘宝，则仍然需要输入账号密码来登录。\n\n基于上面3点，产生了下面的疑问：\n\n1. 登录的信息（账号、密码）存在哪里？\n\n2. 登录的状态是保存在哪里？\n\n3. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\n\n4. 当勾选了记住密码，用户名和密码是保存在哪里的？\n\n> Cookie来起登陆作用的呢，有兴趣的可以把浏览器的Cookie禁用掉，应该大部分的网站登陆不进去，为什么不是全部呢，是因为cookie确实不是唯一一种支持登陆的方式，如果你懂得这个原理，你就知道，可以通过URL添加登陆参数来每次验证或者可以采用把登陆相关信息放到隐藏的表单里面，如果你采用以上方法的时候一定要重视用户登录信息的安全性。\n \n### 一. 登陆信息存在哪里?\n\n由于session是存在服务器的，session比cookie安全一些，因此向用户名和密码这种比较重要的信息都是用session进行保存的。\n\n然后使用cookie来保存session id\n\n### 二. 登录的状态是保存在哪里？\n\n登陆状态和登陆信息的处理方法是一样的。\n\n### 三. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\n\n不同标签页之间是共享同一个session的，关闭浏览器之后，再登陆该网站，session id变了，之前的session也被删掉了，因此需要重新登陆。\n\n一般利用会话cookie来保存session id。\n\n### 四. 当勾选了记住密码，用户名和密码是保存在哪里的?\n\n勾选了记住密码，再点击登陆按钮的时候，如果登陆成功就把用户名和密码设置到cookies（持久cookie）中。\n\n下一次的打开这个登陆网页的时候  在onload中先查看cookies中有没有数据，有的话就将之前记住的用户名和密码显示出来；没有的话就显示页面  然后和前面一样，点登陆的时候再设置cookie。\n\n上面都是现在自己的理解，也不知道是不是全部对的~不断地查漏补缺吧~>_<","source":"_posts/2016-06-17-研究登陆信息和登陆状态.md","raw":"---\nlayout: post\ntitle: 研究登陆信息与登陆状态\ndate: 2016-06-17\ncategories: 浏览器\ntags: [浏览器]\ndescription: \n---\n\n这几天看了一下session和cookie的内容，突然对登陆页面产生了兴趣，经过测试发现，无论在多进程还是多线程浏览器中，淘宝的登陆是满足：\n\n1. 在浏览器的a标签页面登陆自己的账号，同时打开该浏览器的另外一个标签页b，在b页面访问淘宝，发现b页面是显示的登陆状态。\n\n2. 若在b页面退出登陆，再打开a页面，在不执行任何操作的情况下，a页面显示的虽然是登陆状态，但其实已经退出登陆了，刷新页面或者点击一个链接，都会跳到让你登陆的页面。\n\n3. a页面处于登录状态，若关闭浏览器，再次打开浏览器，访问淘宝，则仍然需要输入账号密码来登录。\n\n基于上面3点，产生了下面的疑问：\n\n1. 登录的信息（账号、密码）存在哪里？\n\n2. 登录的状态是保存在哪里？\n\n3. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\n\n4. 当勾选了记住密码，用户名和密码是保存在哪里的？\n\n> Cookie来起登陆作用的呢，有兴趣的可以把浏览器的Cookie禁用掉，应该大部分的网站登陆不进去，为什么不是全部呢，是因为cookie确实不是唯一一种支持登陆的方式，如果你懂得这个原理，你就知道，可以通过URL添加登陆参数来每次验证或者可以采用把登陆相关信息放到隐藏的表单里面，如果你采用以上方法的时候一定要重视用户登录信息的安全性。\n \n### 一. 登陆信息存在哪里?\n\n由于session是存在服务器的，session比cookie安全一些，因此向用户名和密码这种比较重要的信息都是用session进行保存的。\n\n然后使用cookie来保存session id\n\n### 二. 登录的状态是保存在哪里？\n\n登陆状态和登陆信息的处理方法是一样的。\n\n### 三. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\n\n不同标签页之间是共享同一个session的，关闭浏览器之后，再登陆该网站，session id变了，之前的session也被删掉了，因此需要重新登陆。\n\n一般利用会话cookie来保存session id。\n\n### 四. 当勾选了记住密码，用户名和密码是保存在哪里的?\n\n勾选了记住密码，再点击登陆按钮的时候，如果登陆成功就把用户名和密码设置到cookies（持久cookie）中。\n\n下一次的打开这个登陆网页的时候  在onload中先查看cookies中有没有数据，有的话就将之前记住的用户名和密码显示出来；没有的话就显示页面  然后和前面一样，点登陆的时候再设置cookie。\n\n上面都是现在自己的理解，也不知道是不是全部对的~不断地查漏补缺吧~>_<","slug":"2016-06-17-研究登陆信息和登陆状态","published":1,"updated":"2016-06-17T07:05:54.000Z","comments":1,"photos":[],"link":"","_id":"cj035ociu00a2d5u81avh7x97","content":"<p>这几天看了一下session和cookie的内容，突然对登陆页面产生了兴趣，经过测试发现，无论在多进程还是多线程浏览器中，淘宝的登陆是满足：</p>\n<ol>\n<li><p>在浏览器的a标签页面登陆自己的账号，同时打开该浏览器的另外一个标签页b，在b页面访问淘宝，发现b页面是显示的登陆状态。</p>\n</li>\n<li><p>若在b页面退出登陆，再打开a页面，在不执行任何操作的情况下，a页面显示的虽然是登陆状态，但其实已经退出登陆了，刷新页面或者点击一个链接，都会跳到让你登陆的页面。</p>\n</li>\n<li><p>a页面处于登录状态，若关闭浏览器，再次打开浏览器，访问淘宝，则仍然需要输入账号密码来登录。</p>\n</li>\n</ol>\n<p>基于上面3点，产生了下面的疑问：</p>\n<ol>\n<li><p>登录的信息（账号、密码）存在哪里？</p>\n</li>\n<li><p>登录的状态是保存在哪里？</p>\n</li>\n<li><p>如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？</p>\n</li>\n<li><p>当勾选了记住密码，用户名和密码是保存在哪里的？</p>\n</li>\n</ol>\n<blockquote>\n<p>Cookie来起登陆作用的呢，有兴趣的可以把浏览器的Cookie禁用掉，应该大部分的网站登陆不进去，为什么不是全部呢，是因为cookie确实不是唯一一种支持登陆的方式，如果你懂得这个原理，你就知道，可以通过URL添加登陆参数来每次验证或者可以采用把登陆相关信息放到隐藏的表单里面，如果你采用以上方法的时候一定要重视用户登录信息的安全性。</p>\n</blockquote>\n<h3 id=\"一-登陆信息存在哪里\"><a href=\"#一-登陆信息存在哪里\" class=\"headerlink\" title=\"一. 登陆信息存在哪里?\"></a>一. 登陆信息存在哪里?</h3><p>由于session是存在服务器的，session比cookie安全一些，因此向用户名和密码这种比较重要的信息都是用session进行保存的。</p>\n<p>然后使用cookie来保存session id</p>\n<h3 id=\"二-登录的状态是保存在哪里？\"><a href=\"#二-登录的状态是保存在哪里？\" class=\"headerlink\" title=\"二. 登录的状态是保存在哪里？\"></a>二. 登录的状态是保存在哪里？</h3><p>登陆状态和登陆信息的处理方法是一样的。</p>\n<h3 id=\"三-如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\"><a href=\"#三-如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\" class=\"headerlink\" title=\"三. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\"></a>三. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？</h3><p>不同标签页之间是共享同一个session的，关闭浏览器之后，再登陆该网站，session id变了，之前的session也被删掉了，因此需要重新登陆。</p>\n<p>一般利用会话cookie来保存session id。</p>\n<h3 id=\"四-当勾选了记住密码，用户名和密码是保存在哪里的\"><a href=\"#四-当勾选了记住密码，用户名和密码是保存在哪里的\" class=\"headerlink\" title=\"四. 当勾选了记住密码，用户名和密码是保存在哪里的?\"></a>四. 当勾选了记住密码，用户名和密码是保存在哪里的?</h3><p>勾选了记住密码，再点击登陆按钮的时候，如果登陆成功就把用户名和密码设置到cookies（持久cookie）中。</p>\n<p>下一次的打开这个登陆网页的时候  在onload中先查看cookies中有没有数据，有的话就将之前记住的用户名和密码显示出来；没有的话就显示页面  然后和前面一样，点登陆的时候再设置cookie。</p>\n<p>上面都是现在自己的理解，也不知道是不是全部对的~不断地查漏补缺吧~&gt;_&lt;</p>\n","excerpt":"","more":"<p>这几天看了一下session和cookie的内容，突然对登陆页面产生了兴趣，经过测试发现，无论在多进程还是多线程浏览器中，淘宝的登陆是满足：</p>\n<ol>\n<li><p>在浏览器的a标签页面登陆自己的账号，同时打开该浏览器的另外一个标签页b，在b页面访问淘宝，发现b页面是显示的登陆状态。</p>\n</li>\n<li><p>若在b页面退出登陆，再打开a页面，在不执行任何操作的情况下，a页面显示的虽然是登陆状态，但其实已经退出登陆了，刷新页面或者点击一个链接，都会跳到让你登陆的页面。</p>\n</li>\n<li><p>a页面处于登录状态，若关闭浏览器，再次打开浏览器，访问淘宝，则仍然需要输入账号密码来登录。</p>\n</li>\n</ol>\n<p>基于上面3点，产生了下面的疑问：</p>\n<ol>\n<li><p>登录的信息（账号、密码）存在哪里？</p>\n</li>\n<li><p>登录的状态是保存在哪里？</p>\n</li>\n<li><p>如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？</p>\n</li>\n<li><p>当勾选了记住密码，用户名和密码是保存在哪里的？</p>\n</li>\n</ol>\n<blockquote>\n<p>Cookie来起登陆作用的呢，有兴趣的可以把浏览器的Cookie禁用掉，应该大部分的网站登陆不进去，为什么不是全部呢，是因为cookie确实不是唯一一种支持登陆的方式，如果你懂得这个原理，你就知道，可以通过URL添加登陆参数来每次验证或者可以采用把登陆相关信息放到隐藏的表单里面，如果你采用以上方法的时候一定要重视用户登录信息的安全性。</p>\n</blockquote>\n<h3 id=\"一-登陆信息存在哪里\"><a href=\"#一-登陆信息存在哪里\" class=\"headerlink\" title=\"一. 登陆信息存在哪里?\"></a>一. 登陆信息存在哪里?</h3><p>由于session是存在服务器的，session比cookie安全一些，因此向用户名和密码这种比较重要的信息都是用session进行保存的。</p>\n<p>然后使用cookie来保存session id</p>\n<h3 id=\"二-登录的状态是保存在哪里？\"><a href=\"#二-登录的状态是保存在哪里？\" class=\"headerlink\" title=\"二. 登录的状态是保存在哪里？\"></a>二. 登录的状态是保存在哪里？</h3><p>登陆状态和登陆信息的处理方法是一样的。</p>\n<h3 id=\"三-如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\"><a href=\"#三-如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\" class=\"headerlink\" title=\"三. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？\"></a>三. 如何做到不同标签页共享同一个登录状态，在关闭浏览器之后，该登录状态又失效？</h3><p>不同标签页之间是共享同一个session的，关闭浏览器之后，再登陆该网站，session id变了，之前的session也被删掉了，因此需要重新登陆。</p>\n<p>一般利用会话cookie来保存session id。</p>\n<h3 id=\"四-当勾选了记住密码，用户名和密码是保存在哪里的\"><a href=\"#四-当勾选了记住密码，用户名和密码是保存在哪里的\" class=\"headerlink\" title=\"四. 当勾选了记住密码，用户名和密码是保存在哪里的?\"></a>四. 当勾选了记住密码，用户名和密码是保存在哪里的?</h3><p>勾选了记住密码，再点击登陆按钮的时候，如果登陆成功就把用户名和密码设置到cookies（持久cookie）中。</p>\n<p>下一次的打开这个登陆网页的时候  在onload中先查看cookies中有没有数据，有的话就将之前记住的用户名和密码显示出来；没有的话就显示页面  然后和前面一样，点登陆的时候再设置cookie。</p>\n<p>上面都是现在自己的理解，也不知道是不是全部对的~不断地查漏补缺吧~&gt;_&lt;</p>\n"},{"layout":"post","title":"DOM扩展","date":"2016-06-23T16:00:00.000Z","description":null,"_content":"\n### 一. 为什么要扩展DOM\n\n在原来的dom操作中，从页面中获取dom的方式只有两种：\n\n- document.getElementById(\"id\")\n- document.getElementByTagName(\"input\")\n\n但是只用这两种方式获取dom节点有的时候会很不方便。\n\n于是出现了一些扩展的方法。\n\n扩展分为**标准扩展**和**专有扩展**。\n\n标准扩展又分为**选择符API**和**HTML5**。\n\n#### 1. 选择符API\n\n**（1）根据CSS选择器来获取dom元素**\n\n<font color=\"red\">支持的浏览器：IE8+、Firefox3.5+、Safari3.1+、Chrome、Opera10+</font>\n\n- querySelector(\"css选择器\")：返回**第一个**匹配这个选择器的元素，没有则为null\n- querySelectorAll(\"css选择器\")：返回**所有**匹配这个选择器的NodeList对象。\n- matchesSelector(\"dom节点\",\"css选择器\")：判断dom节点的选择符是否和某一选择符匹配，返回的是bool值\n\n**（2）获取元素节点**\n\n增加了5个属性，这5个属性都是针对为DOM的子节点\n\nchildElementCount：子元素的个数（length的dom版）\nfirstElementChild：第一个子元素（firstChild的dom版）\nlastElementChild：最后一个子元素（lastChild的dom版）\npreviousElementSibling：前一个兄弟元素（previousSibling的dom版）\nnextElementSibling：下一个兄弟元素（nextSibling的dom版）\n\n#### 2. HTML5中的扩展\n\n**（1）通过类名获取dom节点**\n\n<font color=\"red\">支持的浏览器有：IE9+、Firefox3+、Safari3.1+、Chrome、Opera9.5+</font>\n\n    getElementsByClassName(\"css\")\n\n**（2）获取某一个元素的类名数组div.classList**\n\n<font color=\"red\">支持的浏览器有：Firefox3.6+、Chrome</font>\n\ndiv.classList有4个方法：\n\n- add(value)\n- contains(add)：返回bool值\n- remove(value)\n- toggle(value)：触发器——如果类名列表中有这个值，删除它；没有给定值，则添加它。","source":"_posts/2016-06-24-DOM扩展.md","raw":"---\nlayout: post\ntitle: DOM扩展\ndate: 2016-06-24\ncategories: javaScript\ntags: [读书笔记,javaScript]\ndescription: \n---\n\n### 一. 为什么要扩展DOM\n\n在原来的dom操作中，从页面中获取dom的方式只有两种：\n\n- document.getElementById(\"id\")\n- document.getElementByTagName(\"input\")\n\n但是只用这两种方式获取dom节点有的时候会很不方便。\n\n于是出现了一些扩展的方法。\n\n扩展分为**标准扩展**和**专有扩展**。\n\n标准扩展又分为**选择符API**和**HTML5**。\n\n#### 1. 选择符API\n\n**（1）根据CSS选择器来获取dom元素**\n\n<font color=\"red\">支持的浏览器：IE8+、Firefox3.5+、Safari3.1+、Chrome、Opera10+</font>\n\n- querySelector(\"css选择器\")：返回**第一个**匹配这个选择器的元素，没有则为null\n- querySelectorAll(\"css选择器\")：返回**所有**匹配这个选择器的NodeList对象。\n- matchesSelector(\"dom节点\",\"css选择器\")：判断dom节点的选择符是否和某一选择符匹配，返回的是bool值\n\n**（2）获取元素节点**\n\n增加了5个属性，这5个属性都是针对为DOM的子节点\n\nchildElementCount：子元素的个数（length的dom版）\nfirstElementChild：第一个子元素（firstChild的dom版）\nlastElementChild：最后一个子元素（lastChild的dom版）\npreviousElementSibling：前一个兄弟元素（previousSibling的dom版）\nnextElementSibling：下一个兄弟元素（nextSibling的dom版）\n\n#### 2. HTML5中的扩展\n\n**（1）通过类名获取dom节点**\n\n<font color=\"red\">支持的浏览器有：IE9+、Firefox3+、Safari3.1+、Chrome、Opera9.5+</font>\n\n    getElementsByClassName(\"css\")\n\n**（2）获取某一个元素的类名数组div.classList**\n\n<font color=\"red\">支持的浏览器有：Firefox3.6+、Chrome</font>\n\ndiv.classList有4个方法：\n\n- add(value)\n- contains(add)：返回bool值\n- remove(value)\n- toggle(value)：触发器——如果类名列表中有这个值，删除它；没有给定值，则添加它。","slug":"2016-06-24-DOM扩展","published":1,"updated":"2016-06-28T02:06:16.000Z","comments":1,"photos":[],"link":"","_id":"cj035ociv00a5d5u84qfm9e13","content":"<h3 id=\"一-为什么要扩展DOM\"><a href=\"#一-为什么要扩展DOM\" class=\"headerlink\" title=\"一. 为什么要扩展DOM\"></a>一. 为什么要扩展DOM</h3><p>在原来的dom操作中，从页面中获取dom的方式只有两种：</p>\n<ul>\n<li>document.getElementById(“id”)</li>\n<li>document.getElementByTagName(“input”)</li>\n</ul>\n<p>但是只用这两种方式获取dom节点有的时候会很不方便。</p>\n<p>于是出现了一些扩展的方法。</p>\n<p>扩展分为<strong>标准扩展</strong>和<strong>专有扩展</strong>。</p>\n<p>标准扩展又分为<strong>选择符API</strong>和<strong>HTML5</strong>。</p>\n<h4 id=\"1-选择符API\"><a href=\"#1-选择符API\" class=\"headerlink\" title=\"1. 选择符API\"></a>1. 选择符API</h4><p><strong>（1）根据CSS选择器来获取dom元素</strong></p>\n<font color=\"red\">支持的浏览器：IE8+、Firefox3.5+、Safari3.1+、Chrome、Opera10+</font>\n\n<ul>\n<li>querySelector(“css选择器”)：返回<strong>第一个</strong>匹配这个选择器的元素，没有则为null</li>\n<li>querySelectorAll(“css选择器”)：返回<strong>所有</strong>匹配这个选择器的NodeList对象。</li>\n<li>matchesSelector(“dom节点”,”css选择器”)：判断dom节点的选择符是否和某一选择符匹配，返回的是bool值</li>\n</ul>\n<p><strong>（2）获取元素节点</strong></p>\n<p>增加了5个属性，这5个属性都是针对为DOM的子节点</p>\n<p>childElementCount：子元素的个数（length的dom版）<br>firstElementChild：第一个子元素（firstChild的dom版）<br>lastElementChild：最后一个子元素（lastChild的dom版）<br>previousElementSibling：前一个兄弟元素（previousSibling的dom版）<br>nextElementSibling：下一个兄弟元素（nextSibling的dom版）</p>\n<h4 id=\"2-HTML5中的扩展\"><a href=\"#2-HTML5中的扩展\" class=\"headerlink\" title=\"2. HTML5中的扩展\"></a>2. HTML5中的扩展</h4><p><strong>（1）通过类名获取dom节点</strong></p>\n<font color=\"red\">支持的浏览器有：IE9+、Firefox3+、Safari3.1+、Chrome、Opera9.5+</font>\n\n<pre><code>getElementsByClassName(&quot;css&quot;)\n</code></pre><p><strong>（2）获取某一个元素的类名数组div.classList</strong></p>\n<font color=\"red\">支持的浏览器有：Firefox3.6+、Chrome</font>\n\n<p>div.classList有4个方法：</p>\n<ul>\n<li>add(value)</li>\n<li>contains(add)：返回bool值</li>\n<li>remove(value)</li>\n<li>toggle(value)：触发器——如果类名列表中有这个值，删除它；没有给定值，则添加它。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-为什么要扩展DOM\"><a href=\"#一-为什么要扩展DOM\" class=\"headerlink\" title=\"一. 为什么要扩展DOM\"></a>一. 为什么要扩展DOM</h3><p>在原来的dom操作中，从页面中获取dom的方式只有两种：</p>\n<ul>\n<li>document.getElementById(“id”)</li>\n<li>document.getElementByTagName(“input”)</li>\n</ul>\n<p>但是只用这两种方式获取dom节点有的时候会很不方便。</p>\n<p>于是出现了一些扩展的方法。</p>\n<p>扩展分为<strong>标准扩展</strong>和<strong>专有扩展</strong>。</p>\n<p>标准扩展又分为<strong>选择符API</strong>和<strong>HTML5</strong>。</p>\n<h4 id=\"1-选择符API\"><a href=\"#1-选择符API\" class=\"headerlink\" title=\"1. 选择符API\"></a>1. 选择符API</h4><p><strong>（1）根据CSS选择器来获取dom元素</strong></p>\n<font color=\"red\">支持的浏览器：IE8+、Firefox3.5+、Safari3.1+、Chrome、Opera10+</font>\n\n<ul>\n<li>querySelector(“css选择器”)：返回<strong>第一个</strong>匹配这个选择器的元素，没有则为null</li>\n<li>querySelectorAll(“css选择器”)：返回<strong>所有</strong>匹配这个选择器的NodeList对象。</li>\n<li>matchesSelector(“dom节点”,”css选择器”)：判断dom节点的选择符是否和某一选择符匹配，返回的是bool值</li>\n</ul>\n<p><strong>（2）获取元素节点</strong></p>\n<p>增加了5个属性，这5个属性都是针对为DOM的子节点</p>\n<p>childElementCount：子元素的个数（length的dom版）<br>firstElementChild：第一个子元素（firstChild的dom版）<br>lastElementChild：最后一个子元素（lastChild的dom版）<br>previousElementSibling：前一个兄弟元素（previousSibling的dom版）<br>nextElementSibling：下一个兄弟元素（nextSibling的dom版）</p>\n<h4 id=\"2-HTML5中的扩展\"><a href=\"#2-HTML5中的扩展\" class=\"headerlink\" title=\"2. HTML5中的扩展\"></a>2. HTML5中的扩展</h4><p><strong>（1）通过类名获取dom节点</strong></p>\n<font color=\"red\">支持的浏览器有：IE9+、Firefox3+、Safari3.1+、Chrome、Opera9.5+</font>\n\n<pre><code>getElementsByClassName(&quot;css&quot;)\n</code></pre><p><strong>（2）获取某一个元素的类名数组div.classList</strong></p>\n<font color=\"red\">支持的浏览器有：Firefox3.6+、Chrome</font>\n\n<p>div.classList有4个方法：</p>\n<ul>\n<li>add(value)</li>\n<li>contains(add)：返回bool值</li>\n<li>remove(value)</li>\n<li>toggle(value)：触发器——如果类名列表中有这个值，删除它；没有给定值，则添加它。</li>\n</ul>\n"},{"layout":"post","title":"编写高质量代码实践——用js实现tab页切换","date":"2016-06-26T16:00:00.000Z","description":null,"_content":"\n实现tab不是什么很难的功能，之前我也写过《用纯css实现tab页》（[http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/](http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/)），这个demo主要是在我看了**《编写高质量代码》**这本书之后的一个小实践，虽然这本书并不是很新，有的东西或许慢慢地也用不着了，但是看了之后觉得受益匪浅，感觉自己之前写demo，写组件就是自己在那“硬实现功能”，也没有考虑设计模式，代码的质量等问题。\n\n所以想重构一下这个实现tab页的组件的代码，希望能够学以致用吧~~\n\n### 一. tab页切换\n\ndemo地址：[http://panpanfish.com/myDemo/tab.html](http://panpanfish.com/myDemo/tab.html)\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js](https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js)\n\n### 二. 实现思路\n\n#### 1. html部分\n\n**通过id来获取dom存在一定的局限性：**由于相同id只能出现一次，因此如果页面中需要出现多次tab组件，那么就会出现问题。\n\n**通过标签名获取dom：**虽然可以同时获取一部分dom，但是跟html结构耦合太紧，一旦html标签名发生变化，就得修改代码。\n\n于是，在tab组件的html部分，是通过定义className，然后在js里面通过className来获取dom。\n\n与js有关的className统一采用`J_className`命名的形式，这样方便以后查找。\n\n**className的命名采用以下原则：**使用驼峰命名法区分不同的单词，使用划线表示从属关系。\n\n#### 2. css部分\n\n- base.css：一些css样式重置\n- common_tab.css：具体到tab组件的样式\n\ncss按照base/common/page来分层\n\n但由于这里是写一个组件，所以没有page.css\n\n#### 3. js部分\n\n- base.js\n- common_tab.js\n\n**(1)base.js**\n\n`base.js`里面定义了一个全局对象`GLOBAL`，并创建了2个命名空间`Dom`和`Eve`。\n\n- `Dom`里面封装有关dom操作扩展的函数\n- `Eve`里面封装跟事件有关的操作\n\n**`Dom`里面的函数：**\n\n- $——根据id名获取dom\n- getElementsByClassName——根据className获取dom\n- addClass——给dom添加一个类\n- removeClass——删除dom的一个类\n\n**`Eve`里面的函数：**\n\n- addEvent——监听事件\n- removeEvent——移除事件\n\n**(2)common_tab.js**\n\n**通过hash对象传参**\n\n    利用hash对象传参的优点：参数的位置和顺序不重要了。\n    eg：\n    function setTab(config) {\n\t\t//函数的实现\n\t}\n\t\n\tsetTab({\n\t\troot: tab, \n\t\tcurrentClass: \"tab-curMenu\",\n\t\ttrigger: \"click\",\n\t\thandler: function(index) {\n\t\t\talert(\"您点击的是第\" + (index + 1) + \"个标签\");\n\t\t}\n\t});\n\t\n\n**可复用性**\n\n\t如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。\n\n\t可以通过一个for循环来实现多处复用\n\n\teg:\n\t//点击相应的标签，出现该处对应的tab页\n\tfor(var i = 0; i < this._tabMenus.length; i++) {\n\t\t(function(_i) {\n\t\t\tGLOBAL.Eve.addEvent(that._tabMenus[_i],\"click\",function() {\n\t\t\t\tthat.showItem(_i);\n\t\t\t});\n\t\t})(i);\n\t}\n\n**组件独立性**\n\n\t组件需要一个根节点，以保持每个组件之间的独立性。eg: config.root属性\n\n**通过参数实组件定制功能**\n\n\t将函数内不稳定的某个因素分离出来，以参数的形式传入，从而将不稳定的因素和函数解耦。\n\teg: \n\t被点击的标签的样式——config.currentClass\n\t触发标签页选中的方式——config.trigger\n\t是否需要自动播放功能——config.autoPlay\n\n**预留回调接口**\n\n\tconfig.handler\n\n\n\n","source":"_posts/2016-06-27-编写高质量代码实践——用js实现tab页切换.md","raw":"---\nlayout: post\ntitle: 编写高质量代码实践——用js实现tab页切换\ndate: 2016-06-27\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n实现tab不是什么很难的功能，之前我也写过《用纯css实现tab页》（[http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/](http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/)），这个demo主要是在我看了**《编写高质量代码》**这本书之后的一个小实践，虽然这本书并不是很新，有的东西或许慢慢地也用不着了，但是看了之后觉得受益匪浅，感觉自己之前写demo，写组件就是自己在那“硬实现功能”，也没有考虑设计模式，代码的质量等问题。\n\n所以想重构一下这个实现tab页的组件的代码，希望能够学以致用吧~~\n\n### 一. tab页切换\n\ndemo地址：[http://panpanfish.com/myDemo/tab.html](http://panpanfish.com/myDemo/tab.html)\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js](https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js)\n\n### 二. 实现思路\n\n#### 1. html部分\n\n**通过id来获取dom存在一定的局限性：**由于相同id只能出现一次，因此如果页面中需要出现多次tab组件，那么就会出现问题。\n\n**通过标签名获取dom：**虽然可以同时获取一部分dom，但是跟html结构耦合太紧，一旦html标签名发生变化，就得修改代码。\n\n于是，在tab组件的html部分，是通过定义className，然后在js里面通过className来获取dom。\n\n与js有关的className统一采用`J_className`命名的形式，这样方便以后查找。\n\n**className的命名采用以下原则：**使用驼峰命名法区分不同的单词，使用划线表示从属关系。\n\n#### 2. css部分\n\n- base.css：一些css样式重置\n- common_tab.css：具体到tab组件的样式\n\ncss按照base/common/page来分层\n\n但由于这里是写一个组件，所以没有page.css\n\n#### 3. js部分\n\n- base.js\n- common_tab.js\n\n**(1)base.js**\n\n`base.js`里面定义了一个全局对象`GLOBAL`，并创建了2个命名空间`Dom`和`Eve`。\n\n- `Dom`里面封装有关dom操作扩展的函数\n- `Eve`里面封装跟事件有关的操作\n\n**`Dom`里面的函数：**\n\n- $——根据id名获取dom\n- getElementsByClassName——根据className获取dom\n- addClass——给dom添加一个类\n- removeClass——删除dom的一个类\n\n**`Eve`里面的函数：**\n\n- addEvent——监听事件\n- removeEvent——移除事件\n\n**(2)common_tab.js**\n\n**通过hash对象传参**\n\n    利用hash对象传参的优点：参数的位置和顺序不重要了。\n    eg：\n    function setTab(config) {\n\t\t//函数的实现\n\t}\n\t\n\tsetTab({\n\t\troot: tab, \n\t\tcurrentClass: \"tab-curMenu\",\n\t\ttrigger: \"click\",\n\t\thandler: function(index) {\n\t\t\talert(\"您点击的是第\" + (index + 1) + \"个标签\");\n\t\t}\n\t});\n\t\n\n**可复用性**\n\n\t如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。\n\n\t可以通过一个for循环来实现多处复用\n\n\teg:\n\t//点击相应的标签，出现该处对应的tab页\n\tfor(var i = 0; i < this._tabMenus.length; i++) {\n\t\t(function(_i) {\n\t\t\tGLOBAL.Eve.addEvent(that._tabMenus[_i],\"click\",function() {\n\t\t\t\tthat.showItem(_i);\n\t\t\t});\n\t\t})(i);\n\t}\n\n**组件独立性**\n\n\t组件需要一个根节点，以保持每个组件之间的独立性。eg: config.root属性\n\n**通过参数实组件定制功能**\n\n\t将函数内不稳定的某个因素分离出来，以参数的形式传入，从而将不稳定的因素和函数解耦。\n\teg: \n\t被点击的标签的样式——config.currentClass\n\t触发标签页选中的方式——config.trigger\n\t是否需要自动播放功能——config.autoPlay\n\n**预留回调接口**\n\n\tconfig.handler\n\n\n\n","slug":"2016-06-27-编写高质量代码实践——用js实现tab页切换","published":1,"updated":"2016-07-05T14:16:26.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocix00a9d5u8k9nujbni","content":"<p>实现tab不是什么很难的功能，之前我也写过《用纯css实现tab页》（<a href=\"http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/\">http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/</a>），这个demo主要是在我看了<strong>《编写高质量代码》</strong>这本书之后的一个小实践，虽然这本书并不是很新，有的东西或许慢慢地也用不着了，但是看了之后觉得受益匪浅，感觉自己之前写demo，写组件就是自己在那“硬实现功能”，也没有考虑设计模式，代码的质量等问题。</p>\n<p>所以想重构一下这个实现tab页的组件的代码，希望能够学以致用吧~~</p>\n<h3 id=\"一-tab页切换\"><a href=\"#一-tab页切换\" class=\"headerlink\" title=\"一. tab页切换\"></a>一. tab页切换</h3><p>demo地址：<a href=\"http://panpanfish.com/myDemo/tab.html\">http://panpanfish.com/myDemo/tab.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js</a></p>\n<h3 id=\"二-实现思路\"><a href=\"#二-实现思路\" class=\"headerlink\" title=\"二. 实现思路\"></a>二. 实现思路</h3><h4 id=\"1-html部分\"><a href=\"#1-html部分\" class=\"headerlink\" title=\"1. html部分\"></a>1. html部分</h4><p><strong>通过id来获取dom存在一定的局限性：</strong>由于相同id只能出现一次，因此如果页面中需要出现多次tab组件，那么就会出现问题。</p>\n<p><strong>通过标签名获取dom：</strong>虽然可以同时获取一部分dom，但是跟html结构耦合太紧，一旦html标签名发生变化，就得修改代码。</p>\n<p>于是，在tab组件的html部分，是通过定义className，然后在js里面通过className来获取dom。</p>\n<p>与js有关的className统一采用<code>J_className</code>命名的形式，这样方便以后查找。</p>\n<p><strong>className的命名采用以下原则：</strong>使用驼峰命名法区分不同的单词，使用划线表示从属关系。</p>\n<h4 id=\"2-css部分\"><a href=\"#2-css部分\" class=\"headerlink\" title=\"2. css部分\"></a>2. css部分</h4><ul>\n<li>base.css：一些css样式重置</li>\n<li>common_tab.css：具体到tab组件的样式</li>\n</ul>\n<p>css按照base/common/page来分层</p>\n<p>但由于这里是写一个组件，所以没有page.css</p>\n<h4 id=\"3-js部分\"><a href=\"#3-js部分\" class=\"headerlink\" title=\"3. js部分\"></a>3. js部分</h4><ul>\n<li>base.js</li>\n<li>common_tab.js</li>\n</ul>\n<p><strong>(1)base.js</strong></p>\n<p><code>base.js</code>里面定义了一个全局对象<code>GLOBAL</code>，并创建了2个命名空间<code>Dom</code>和<code>Eve</code>。</p>\n<ul>\n<li><code>Dom</code>里面封装有关dom操作扩展的函数</li>\n<li><code>Eve</code>里面封装跟事件有关的操作</li>\n</ul>\n<p><strong><code>Dom</code>里面的函数：</strong></p>\n<ul>\n<li>$——根据id名获取dom</li>\n<li>getElementsByClassName——根据className获取dom</li>\n<li>addClass——给dom添加一个类</li>\n<li>removeClass——删除dom的一个类</li>\n</ul>\n<p><strong><code>Eve</code>里面的函数：</strong></p>\n<ul>\n<li>addEvent——监听事件</li>\n<li>removeEvent——移除事件</li>\n</ul>\n<p><strong>(2)common_tab.js</strong></p>\n<p><strong>通过hash对象传参</strong></p>\n<pre><code>利用hash对象传参的优点：参数的位置和顺序不重要了。\neg：\nfunction setTab(config) {\n    //函数的实现\n}\n\nsetTab({\n    root: tab, \n    currentClass: &quot;tab-curMenu&quot;,\n    trigger: &quot;click&quot;,\n    handler: function(index) {\n        alert(&quot;您点击的是第&quot; + (index + 1) + &quot;个标签&quot;);\n    }\n});\n</code></pre><p><strong>可复用性</strong></p>\n<pre><code>如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。\n\n可以通过一个for循环来实现多处复用\n\neg:\n//点击相应的标签，出现该处对应的tab页\nfor(var i = 0; i &lt; this._tabMenus.length; i++) {\n    (function(_i) {\n        GLOBAL.Eve.addEvent(that._tabMenus[_i],&quot;click&quot;,function() {\n            that.showItem(_i);\n        });\n    })(i);\n}\n</code></pre><p><strong>组件独立性</strong></p>\n<pre><code>组件需要一个根节点，以保持每个组件之间的独立性。eg: config.root属性\n</code></pre><p><strong>通过参数实组件定制功能</strong></p>\n<pre><code>将函数内不稳定的某个因素分离出来，以参数的形式传入，从而将不稳定的因素和函数解耦。\neg: \n被点击的标签的样式——config.currentClass\n触发标签页选中的方式——config.trigger\n是否需要自动播放功能——config.autoPlay\n</code></pre><p><strong>预留回调接口</strong></p>\n<pre><code>config.handler\n</code></pre>","excerpt":"","more":"<p>实现tab不是什么很难的功能，之前我也写过《用纯css实现tab页》（<a href=\"http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/\">http://panpanfish.com/2016/04/04/2016-04-04-%E7%94%A8CSS%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E7%9A%84%E5%88%87%E6%8D%A2/</a>），这个demo主要是在我看了<strong>《编写高质量代码》</strong>这本书之后的一个小实践，虽然这本书并不是很新，有的东西或许慢慢地也用不着了，但是看了之后觉得受益匪浅，感觉自己之前写demo，写组件就是自己在那“硬实现功能”，也没有考虑设计模式，代码的质量等问题。</p>\n<p>所以想重构一下这个实现tab页的组件的代码，希望能够学以致用吧~~</p>\n<h3 id=\"一-tab页切换\"><a href=\"#一-tab页切换\" class=\"headerlink\" title=\"一. tab页切换\"></a>一. tab页切换</h3><p>demo地址：<a href=\"http://panpanfish.com/myDemo/tab.html\">http://panpanfish.com/myDemo/tab.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js\">https://github.com/panpan040828/myDemo/blob/gh-pages/js/common/common_tab.js</a></p>\n<h3 id=\"二-实现思路\"><a href=\"#二-实现思路\" class=\"headerlink\" title=\"二. 实现思路\"></a>二. 实现思路</h3><h4 id=\"1-html部分\"><a href=\"#1-html部分\" class=\"headerlink\" title=\"1. html部分\"></a>1. html部分</h4><p><strong>通过id来获取dom存在一定的局限性：</strong>由于相同id只能出现一次，因此如果页面中需要出现多次tab组件，那么就会出现问题。</p>\n<p><strong>通过标签名获取dom：</strong>虽然可以同时获取一部分dom，但是跟html结构耦合太紧，一旦html标签名发生变化，就得修改代码。</p>\n<p>于是，在tab组件的html部分，是通过定义className，然后在js里面通过className来获取dom。</p>\n<p>与js有关的className统一采用<code>J_className</code>命名的形式，这样方便以后查找。</p>\n<p><strong>className的命名采用以下原则：</strong>使用驼峰命名法区分不同的单词，使用划线表示从属关系。</p>\n<h4 id=\"2-css部分\"><a href=\"#2-css部分\" class=\"headerlink\" title=\"2. css部分\"></a>2. css部分</h4><ul>\n<li>base.css：一些css样式重置</li>\n<li>common_tab.css：具体到tab组件的样式</li>\n</ul>\n<p>css按照base/common/page来分层</p>\n<p>但由于这里是写一个组件，所以没有page.css</p>\n<h4 id=\"3-js部分\"><a href=\"#3-js部分\" class=\"headerlink\" title=\"3. js部分\"></a>3. js部分</h4><ul>\n<li>base.js</li>\n<li>common_tab.js</li>\n</ul>\n<p><strong>(1)base.js</strong></p>\n<p><code>base.js</code>里面定义了一个全局对象<code>GLOBAL</code>，并创建了2个命名空间<code>Dom</code>和<code>Eve</code>。</p>\n<ul>\n<li><code>Dom</code>里面封装有关dom操作扩展的函数</li>\n<li><code>Eve</code>里面封装跟事件有关的操作</li>\n</ul>\n<p><strong><code>Dom</code>里面的函数：</strong></p>\n<ul>\n<li>$——根据id名获取dom</li>\n<li>getElementsByClassName——根据className获取dom</li>\n<li>addClass——给dom添加一个类</li>\n<li>removeClass——删除dom的一个类</li>\n</ul>\n<p><strong><code>Eve</code>里面的函数：</strong></p>\n<ul>\n<li>addEvent——监听事件</li>\n<li>removeEvent——移除事件</li>\n</ul>\n<p><strong>(2)common_tab.js</strong></p>\n<p><strong>通过hash对象传参</strong></p>\n<pre><code>利用hash对象传参的优点：参数的位置和顺序不重要了。\neg：\nfunction setTab(config) {\n    //函数的实现\n}\n\nsetTab({\n    root: tab, \n    currentClass: &quot;tab-curMenu&quot;,\n    trigger: &quot;click&quot;,\n    handler: function(index) {\n        alert(&quot;您点击的是第&quot; + (index + 1) + &quot;个标签&quot;);\n    }\n});\n</code></pre><p><strong>可复用性</strong></p>\n<pre><code>如果程序需要被同一个页面的多处复用，就不能用id来获取dom节点。\n\n可以通过一个for循环来实现多处复用\n\neg:\n//点击相应的标签，出现该处对应的tab页\nfor(var i = 0; i &lt; this._tabMenus.length; i++) {\n    (function(_i) {\n        GLOBAL.Eve.addEvent(that._tabMenus[_i],&quot;click&quot;,function() {\n            that.showItem(_i);\n        });\n    })(i);\n}\n</code></pre><p><strong>组件独立性</strong></p>\n<pre><code>组件需要一个根节点，以保持每个组件之间的独立性。eg: config.root属性\n</code></pre><p><strong>通过参数实组件定制功能</strong></p>\n<pre><code>将函数内不稳定的某个因素分离出来，以参数的形式传入，从而将不稳定的因素和函数解耦。\neg: \n被点击的标签的样式——config.currentClass\n触发标签页选中的方式——config.trigger\n是否需要自动播放功能——config.autoPlay\n</code></pre><p><strong>预留回调接口</strong></p>\n<pre><code>config.handler\n</code></pre>"},{"layout":"post","title":"CSS的预处理器","date":"2016-06-28T16:00:00.000Z","description":null,"_content":"###  一. 什么是CSS预处理器\n\n**CSS的优点**\n\n- 使结构和表现分离\n- 一个文件可以在多处引用\n\n**CSS的缺点**\n\n- 嵌套\n- 复用代码段\n- 模块化开发的不灵活\n- 不具备逻辑能力和抽象能力\n\n由于css是一门纯静态的语言，并且有上述这些缺点，因此出现了css预处理器。\n\n#### 1. 什么是css预处理器\n\n> css预处理器可以看成是css的一门方言，用更精简的语法表达更多。\n> \n> css预处理器并不是css的替代品，它只是让css变得更加高效、可维护。\n> \n> 使用css预处理器编写代码之后也会生成css代码，部署到线上的是生成的css文件，而不是预处理器文件（Sass/Less/stylus）。\n> \n> 因此，使用css预处理器主要是为了提高**开发效率**。\n\n<font color=\"red\">注意：永远不要去修改生成后的css</font>\n\n\n#### 2. 使用css预处理器的优点\n\n- 提高开发效率\n- 易维护，更方便的定制\n- 让css看起来更像是一门编程语言\n\n### 二. 几种css预处理器（Sass/Less/stylus）\n\nSass：2006年提出\nLess：2009年提出\nstylus：2010年\n\n### 三. 安装Sass\n\nSass的官网（中文）：[http://www.sasschina.com/](http://www.sasschina.com/)\n\n<font color=\"red\">第一步，安装ruby</font>\n\n由于之前我的博客是基于jekyll的，jekyll时基于ruby，所以我已经安装过ruby了。\n\n<font color=\"red\">第二步，安装Sass</font>\n\n    打开cmd\n    输入gem install sass\n\n发现提示了一个错误：\n\n![模拟文件报表排版](/uploads/post/20160629/sass-install.jpg)\n\n然后我就在网上找原因，后来发现了其他的安装方法\n\n[http://www.w3cplus.com/sassguide/install.html](http://www.w3cplus.com/sassguide/install.html \"安装sass\")\n\n我采用的是**第三种**安装方法\n\n    首先，在RubyGems.org上下载sass，然后保存在自己的电脑里\n    [https://rubygems.org/gems/sass](https://rubygems.org/gems/sass)\n    \n    然后，在cmd中输入`gem install 保存sass的路径`\n    \n    最后，输入`sass -v`来验证是否安装成功\n\n### 四. Sass的语法\n\n#### 1. Sass的两种后缀名文件\n\n- sass：语法严格，不使用大括号和分号。\n- scss：使用大括号和分号，**建议使用scss为后缀名**。\n\n#### 2. 导入sass文件\n\n在一个sass文件中可以通过`@import`导入另外一个写好的文件\n\n**@import可以导入的文件类型**\n\n    .css文件：不能忽略后缀名\n    .sass/.scss文件：可以忽略后缀名、前缀_\n\n#### 3. 注释\n\n    标准的css注释：/*.......*/\n    sass的静默注释：//........\n\n静默注释在生成的css文件中不会出现。\n\n#### 4. 变量\n\n**(1)普通变量**\n\n    使用$val：attr;来进行声明\n    在全局的范围内使用\n\n\teg:\n\t$highlight-color: #eee;\n\n**(2)默认变量!default**\n\t\n\t$highlight-color: #eee ！default;\n    sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可\n\n**(3)特殊变量**\n\n一般情况下，我们定义的变量都为属性值；如果变量作为属性，需要用一种特殊的方式使用`#{$variables}`。\n\n\teg:\n\t//定义\n\t$borderDirection: top; \n\t\n\t//使用\n\t.border-#{$borderDirection}{\n  \t\tborder-#{$borderDirection}:1px solid #ccc;\n\t}\n\n**(4)多值变量**\n\n    多值变量分为list类型和map类型\n    list类型有点像js中的数组，但是下标从1开始\n    map类型有点像js中的对象，但是是用()包裹起来\n\n**list类型**\n\n\t定义: \n\t$px: 5px 10px 15px 20px;//一维数组\n    $px: (5px 10px) (15px 20px);//二维数组\n\n\t取值： nth($px,2);//取到的是10px\n\n**map类型**\n\n\t定义：\n\t$heading: (h1: 2em, h2: 1.5em, h3: 1.2em);\n\n\t取值：map-get($heading, $h1);//取到的是2em\n\n**(5)变量的作用域**\n\n\t和一般编程语言一样，sass中声明的变量也有作用域\n\t在规则块以外声明的变量，相当于全局变量，可以在任意地方使用；\n\t在css规则块里面声明的变量，相当于局部变量，只能在{...}里面使用。\n\n\teg:\n\t$nav-color: red;//相当于全局变量\n\tnav {\n\t\t$width: 20px;\n\t\twidth: $width;//可以使用，不会有错误\n\t\tcolor: $nav-color;//可以使用\n\t}\n\n\tdiv {\n\t\twidth: $width;//不能使用，会有错误\n\t}\n\t\n**(6)变量的赋值**\n\n    可以给一个变量赋值\n    $nav-color: red;\n    \n    也可以用另外一个变量赋值给一个变量\n    $color: red;\n    $nav-color: color;\n\n#### 5. 嵌套css\n\n像俄罗斯套娃一样，在一个规则块里面嵌套规则块。\n\n**(1)选择器的嵌套**\n\n    eg:\n    //css\n    #content aside {background: #eee;}\n    #content article h1 {color: red;}\n    #content article p {color: black;}\n    \n    //sass,用嵌套的规则来写    \n    #content {\n    \tarticle {\n    \t\th1 {color: red;}\n    \t\tp {color: black;}\n    \t}\n    \t\n    \taside {background: #eee;}\n    }\n\n**在使用选择器的嵌套时，会用到以下两个属性：**\n\n**父选择器&**\n\n\t在使用嵌套规则时，`&`代表的是上一层的选择器。\n\n\teg:\n\n\t#content {\n    \tarticle {\n    \t\th1 {color: red;}\n    \t\t& p {color: black;}//这里的&代表article\n    \t}\n    \t\n    \taside {background: #eee;}\n    }\n\n\t由于sass是将嵌套规则的选择器用空格拼接起来，所以当遇到伪类时，使用嵌套规则就会有错误，这时就要使用父选择器&\n\tarticle a {\n\t\tcolor: red;\n\t\t&:hover: black;\n\t}\n\n**跳出上一层选择器**\n\n    @at-root：跳出上一层选择器\n    @at-root (without: all)：跳出所有的选择器\n    @at-root (without: rule)：跳出常规的css选择器\n    @at-root (without: media)：跳出@media\n\n**(2)属性的嵌套**\n\n    eg:\n    //css\n    nav {\n      border-style: solid;\n      border-width: 1px;\n      border-color: #ccc;\n    }\n    \n    //sass 属性嵌套\n    nav {\n      border: {\n      style: solid;\n      width: 1px;\n      color: #ccc;\n      }\n    }\n\n#### 6. 混合器\n\n实现大段样式的重用\n\n**@mixin：**定义混合器\n**@include：**引用混合器\n\n**@mixin里面可以是css的属性，也可以是css规则**\n\n    @mixin no-bullets {\n      list-style: none;\n      li {\n\t    list-style-image: none;\n\t    list-style-type: none;\n\t    margin-left: 0px;\n      }\n    }\n\n**给混合器传参，参数是变量`$val`**\n\n    //定义混合器\n    @mixin link-colors($normal, $hover, $visited) {\n      color: $normal;\n      &:hover { color: $hover; }\n      &:visited { color: $visited; }\n    }\n    \n    //引用混合器\n    a {\n      @include link-colors(blue, red, green);\n    }\n\n#### 7. 继承\n\n**选择器继承@extend：**让选择器继承另一个选择器的所有样式，并联合声明\n\n    //sass\n    h1 {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      @extend h1;\n      border-width: 2px;\n    }\n    \n    //css\n    h1,.speaker {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      border-width: 2px;\n    }\n\n**占位选择器%：**不继承的话，css里面不会出现，所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。\n\n\t//sass\n    %h1 {\n      border: 4px solid #ff9aa9;\n    }\n\t%h2 {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      @extend h1;\n      border-width: 2px;\n    }\n    \n    //css\n    h1,.speaker {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      border-width: 2px;\n    }\n\n#### 8. 函数\n\n自定义函数@function\n\n#### 9. 运算\n\n可以对数值型，如：数字、颜色、变量等，进行加减乘除四则运算，\n<font color=\"red\">注意:运算符前后留一个空格。</font>\n\n#### 11. 条件判断及循环\n\n    @if\n    @else\n    if(条件，条件为真，条件为假)\n    @for循环\n    @each循环\n\n### 五. Sass转化为css\n\n    打开cmd\n    进入到保存sass或者scss文件的文件夹中\n    在cmd中输入`sass --watch 文件名.scss:文件名.css`\n\n\n","source":"_posts/2016-06-29-CSS预处理器.md","raw":"---\nlayout: post\ntitle: CSS的预处理器\ndate: 2016-06-29\ncategories: CSS\ntags: [css,Sass]\ndescription: \n---\n###  一. 什么是CSS预处理器\n\n**CSS的优点**\n\n- 使结构和表现分离\n- 一个文件可以在多处引用\n\n**CSS的缺点**\n\n- 嵌套\n- 复用代码段\n- 模块化开发的不灵活\n- 不具备逻辑能力和抽象能力\n\n由于css是一门纯静态的语言，并且有上述这些缺点，因此出现了css预处理器。\n\n#### 1. 什么是css预处理器\n\n> css预处理器可以看成是css的一门方言，用更精简的语法表达更多。\n> \n> css预处理器并不是css的替代品，它只是让css变得更加高效、可维护。\n> \n> 使用css预处理器编写代码之后也会生成css代码，部署到线上的是生成的css文件，而不是预处理器文件（Sass/Less/stylus）。\n> \n> 因此，使用css预处理器主要是为了提高**开发效率**。\n\n<font color=\"red\">注意：永远不要去修改生成后的css</font>\n\n\n#### 2. 使用css预处理器的优点\n\n- 提高开发效率\n- 易维护，更方便的定制\n- 让css看起来更像是一门编程语言\n\n### 二. 几种css预处理器（Sass/Less/stylus）\n\nSass：2006年提出\nLess：2009年提出\nstylus：2010年\n\n### 三. 安装Sass\n\nSass的官网（中文）：[http://www.sasschina.com/](http://www.sasschina.com/)\n\n<font color=\"red\">第一步，安装ruby</font>\n\n由于之前我的博客是基于jekyll的，jekyll时基于ruby，所以我已经安装过ruby了。\n\n<font color=\"red\">第二步，安装Sass</font>\n\n    打开cmd\n    输入gem install sass\n\n发现提示了一个错误：\n\n![模拟文件报表排版](/uploads/post/20160629/sass-install.jpg)\n\n然后我就在网上找原因，后来发现了其他的安装方法\n\n[http://www.w3cplus.com/sassguide/install.html](http://www.w3cplus.com/sassguide/install.html \"安装sass\")\n\n我采用的是**第三种**安装方法\n\n    首先，在RubyGems.org上下载sass，然后保存在自己的电脑里\n    [https://rubygems.org/gems/sass](https://rubygems.org/gems/sass)\n    \n    然后，在cmd中输入`gem install 保存sass的路径`\n    \n    最后，输入`sass -v`来验证是否安装成功\n\n### 四. Sass的语法\n\n#### 1. Sass的两种后缀名文件\n\n- sass：语法严格，不使用大括号和分号。\n- scss：使用大括号和分号，**建议使用scss为后缀名**。\n\n#### 2. 导入sass文件\n\n在一个sass文件中可以通过`@import`导入另外一个写好的文件\n\n**@import可以导入的文件类型**\n\n    .css文件：不能忽略后缀名\n    .sass/.scss文件：可以忽略后缀名、前缀_\n\n#### 3. 注释\n\n    标准的css注释：/*.......*/\n    sass的静默注释：//........\n\n静默注释在生成的css文件中不会出现。\n\n#### 4. 变量\n\n**(1)普通变量**\n\n    使用$val：attr;来进行声明\n    在全局的范围内使用\n\n\teg:\n\t$highlight-color: #eee;\n\n**(2)默认变量!default**\n\t\n\t$highlight-color: #eee ！default;\n    sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可\n\n**(3)特殊变量**\n\n一般情况下，我们定义的变量都为属性值；如果变量作为属性，需要用一种特殊的方式使用`#{$variables}`。\n\n\teg:\n\t//定义\n\t$borderDirection: top; \n\t\n\t//使用\n\t.border-#{$borderDirection}{\n  \t\tborder-#{$borderDirection}:1px solid #ccc;\n\t}\n\n**(4)多值变量**\n\n    多值变量分为list类型和map类型\n    list类型有点像js中的数组，但是下标从1开始\n    map类型有点像js中的对象，但是是用()包裹起来\n\n**list类型**\n\n\t定义: \n\t$px: 5px 10px 15px 20px;//一维数组\n    $px: (5px 10px) (15px 20px);//二维数组\n\n\t取值： nth($px,2);//取到的是10px\n\n**map类型**\n\n\t定义：\n\t$heading: (h1: 2em, h2: 1.5em, h3: 1.2em);\n\n\t取值：map-get($heading, $h1);//取到的是2em\n\n**(5)变量的作用域**\n\n\t和一般编程语言一样，sass中声明的变量也有作用域\n\t在规则块以外声明的变量，相当于全局变量，可以在任意地方使用；\n\t在css规则块里面声明的变量，相当于局部变量，只能在{...}里面使用。\n\n\teg:\n\t$nav-color: red;//相当于全局变量\n\tnav {\n\t\t$width: 20px;\n\t\twidth: $width;//可以使用，不会有错误\n\t\tcolor: $nav-color;//可以使用\n\t}\n\n\tdiv {\n\t\twidth: $width;//不能使用，会有错误\n\t}\n\t\n**(6)变量的赋值**\n\n    可以给一个变量赋值\n    $nav-color: red;\n    \n    也可以用另外一个变量赋值给一个变量\n    $color: red;\n    $nav-color: color;\n\n#### 5. 嵌套css\n\n像俄罗斯套娃一样，在一个规则块里面嵌套规则块。\n\n**(1)选择器的嵌套**\n\n    eg:\n    //css\n    #content aside {background: #eee;}\n    #content article h1 {color: red;}\n    #content article p {color: black;}\n    \n    //sass,用嵌套的规则来写    \n    #content {\n    \tarticle {\n    \t\th1 {color: red;}\n    \t\tp {color: black;}\n    \t}\n    \t\n    \taside {background: #eee;}\n    }\n\n**在使用选择器的嵌套时，会用到以下两个属性：**\n\n**父选择器&**\n\n\t在使用嵌套规则时，`&`代表的是上一层的选择器。\n\n\teg:\n\n\t#content {\n    \tarticle {\n    \t\th1 {color: red;}\n    \t\t& p {color: black;}//这里的&代表article\n    \t}\n    \t\n    \taside {background: #eee;}\n    }\n\n\t由于sass是将嵌套规则的选择器用空格拼接起来，所以当遇到伪类时，使用嵌套规则就会有错误，这时就要使用父选择器&\n\tarticle a {\n\t\tcolor: red;\n\t\t&:hover: black;\n\t}\n\n**跳出上一层选择器**\n\n    @at-root：跳出上一层选择器\n    @at-root (without: all)：跳出所有的选择器\n    @at-root (without: rule)：跳出常规的css选择器\n    @at-root (without: media)：跳出@media\n\n**(2)属性的嵌套**\n\n    eg:\n    //css\n    nav {\n      border-style: solid;\n      border-width: 1px;\n      border-color: #ccc;\n    }\n    \n    //sass 属性嵌套\n    nav {\n      border: {\n      style: solid;\n      width: 1px;\n      color: #ccc;\n      }\n    }\n\n#### 6. 混合器\n\n实现大段样式的重用\n\n**@mixin：**定义混合器\n**@include：**引用混合器\n\n**@mixin里面可以是css的属性，也可以是css规则**\n\n    @mixin no-bullets {\n      list-style: none;\n      li {\n\t    list-style-image: none;\n\t    list-style-type: none;\n\t    margin-left: 0px;\n      }\n    }\n\n**给混合器传参，参数是变量`$val`**\n\n    //定义混合器\n    @mixin link-colors($normal, $hover, $visited) {\n      color: $normal;\n      &:hover { color: $hover; }\n      &:visited { color: $visited; }\n    }\n    \n    //引用混合器\n    a {\n      @include link-colors(blue, red, green);\n    }\n\n#### 7. 继承\n\n**选择器继承@extend：**让选择器继承另一个选择器的所有样式，并联合声明\n\n    //sass\n    h1 {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      @extend h1;\n      border-width: 2px;\n    }\n    \n    //css\n    h1,.speaker {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      border-width: 2px;\n    }\n\n**占位选择器%：**不继承的话，css里面不会出现，所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。\n\n\t//sass\n    %h1 {\n      border: 4px solid #ff9aa9;\n    }\n\t%h2 {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      @extend h1;\n      border-width: 2px;\n    }\n    \n    //css\n    h1,.speaker {\n      border: 4px solid #ff9aa9;\n    }\n    .speaker {\n      border-width: 2px;\n    }\n\n#### 8. 函数\n\n自定义函数@function\n\n#### 9. 运算\n\n可以对数值型，如：数字、颜色、变量等，进行加减乘除四则运算，\n<font color=\"red\">注意:运算符前后留一个空格。</font>\n\n#### 11. 条件判断及循环\n\n    @if\n    @else\n    if(条件，条件为真，条件为假)\n    @for循环\n    @each循环\n\n### 五. Sass转化为css\n\n    打开cmd\n    进入到保存sass或者scss文件的文件夹中\n    在cmd中输入`sass --watch 文件名.scss:文件名.css`\n\n\n","slug":"2016-06-29-CSS预处理器","published":1,"updated":"2016-07-02T03:29:22.000Z","comments":1,"photos":[],"link":"","_id":"cj035ociz00acd5u8ohs2gmrq","content":"<h3 id=\"一-什么是CSS预处理器\"><a href=\"#一-什么是CSS预处理器\" class=\"headerlink\" title=\"一. 什么是CSS预处理器\"></a>一. 什么是CSS预处理器</h3><p><strong>CSS的优点</strong></p>\n<ul>\n<li>使结构和表现分离</li>\n<li>一个文件可以在多处引用</li>\n</ul>\n<p><strong>CSS的缺点</strong></p>\n<ul>\n<li>嵌套</li>\n<li>复用代码段</li>\n<li>模块化开发的不灵活</li>\n<li>不具备逻辑能力和抽象能力</li>\n</ul>\n<p>由于css是一门纯静态的语言，并且有上述这些缺点，因此出现了css预处理器。</p>\n<h4 id=\"1-什么是css预处理器\"><a href=\"#1-什么是css预处理器\" class=\"headerlink\" title=\"1. 什么是css预处理器\"></a>1. 什么是css预处理器</h4><blockquote>\n<p>css预处理器可以看成是css的一门方言，用更精简的语法表达更多。</p>\n<p>css预处理器并不是css的替代品，它只是让css变得更加高效、可维护。</p>\n<p>使用css预处理器编写代码之后也会生成css代码，部署到线上的是生成的css文件，而不是预处理器文件（Sass/Less/stylus）。</p>\n<p>因此，使用css预处理器主要是为了提高<strong>开发效率</strong>。</p>\n</blockquote>\n<font color=\"red\">注意：永远不要去修改生成后的css</font>\n\n\n<h4 id=\"2-使用css预处理器的优点\"><a href=\"#2-使用css预处理器的优点\" class=\"headerlink\" title=\"2. 使用css预处理器的优点\"></a>2. 使用css预处理器的优点</h4><ul>\n<li>提高开发效率</li>\n<li>易维护，更方便的定制</li>\n<li>让css看起来更像是一门编程语言</li>\n</ul>\n<h3 id=\"二-几种css预处理器（Sass-Less-stylus）\"><a href=\"#二-几种css预处理器（Sass-Less-stylus）\" class=\"headerlink\" title=\"二. 几种css预处理器（Sass/Less/stylus）\"></a>二. 几种css预处理器（Sass/Less/stylus）</h3><p>Sass：2006年提出<br>Less：2009年提出<br>stylus：2010年</p>\n<h3 id=\"三-安装Sass\"><a href=\"#三-安装Sass\" class=\"headerlink\" title=\"三. 安装Sass\"></a>三. 安装Sass</h3><p>Sass的官网（中文）：<a href=\"http://www.sasschina.com/\" target=\"_blank\" rel=\"external\">http://www.sasschina.com/</a></p>\n<font color=\"red\">第一步，安装ruby</font>\n\n<p>由于之前我的博客是基于jekyll的，jekyll时基于ruby，所以我已经安装过ruby了。</p>\n<font color=\"red\">第二步，安装Sass</font>\n\n<pre><code>打开cmd\n输入gem install sass\n</code></pre><p>发现提示了一个错误：</p>\n<p><img src=\"/uploads/post/20160629/sass-install.jpg\" alt=\"模拟文件报表排版\"></p>\n<p>然后我就在网上找原因，后来发现了其他的安装方法</p>\n<p><a href=\"http://www.w3cplus.com/sassguide/install.html\" title=\"安装sass\" target=\"_blank\" rel=\"external\">http://www.w3cplus.com/sassguide/install.html</a></p>\n<p>我采用的是<strong>第三种</strong>安装方法</p>\n<pre><code>首先，在RubyGems.org上下载sass，然后保存在自己的电脑里\n[https://rubygems.org/gems/sass](https://rubygems.org/gems/sass)\n\n然后，在cmd中输入`gem install 保存sass的路径`\n\n最后，输入`sass -v`来验证是否安装成功\n</code></pre><h3 id=\"四-Sass的语法\"><a href=\"#四-Sass的语法\" class=\"headerlink\" title=\"四. Sass的语法\"></a>四. Sass的语法</h3><h4 id=\"1-Sass的两种后缀名文件\"><a href=\"#1-Sass的两种后缀名文件\" class=\"headerlink\" title=\"1. Sass的两种后缀名文件\"></a>1. Sass的两种后缀名文件</h4><ul>\n<li>sass：语法严格，不使用大括号和分号。</li>\n<li>scss：使用大括号和分号，<strong>建议使用scss为后缀名</strong>。</li>\n</ul>\n<h4 id=\"2-导入sass文件\"><a href=\"#2-导入sass文件\" class=\"headerlink\" title=\"2. 导入sass文件\"></a>2. 导入sass文件</h4><p>在一个sass文件中可以通过<code>@import</code>导入另外一个写好的文件</p>\n<p><strong>@import可以导入的文件类型</strong></p>\n<pre><code>.css文件：不能忽略后缀名\n.sass/.scss文件：可以忽略后缀名、前缀_\n</code></pre><h4 id=\"3-注释\"><a href=\"#3-注释\" class=\"headerlink\" title=\"3. 注释\"></a>3. 注释</h4><pre><code>标准的css注释：/*.......*/\nsass的静默注释：//........\n</code></pre><p>静默注释在生成的css文件中不会出现。</p>\n<h4 id=\"4-变量\"><a href=\"#4-变量\" class=\"headerlink\" title=\"4. 变量\"></a>4. 变量</h4><p><strong>(1)普通变量</strong></p>\n<pre><code>使用$val：attr;来进行声明\n在全局的范围内使用\n\neg:\n$highlight-color: #eee;\n</code></pre><p><strong>(2)默认变量!default</strong></p>\n<pre><code>$highlight-color: #eee ！default;\nsass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可\n</code></pre><p><strong>(3)特殊变量</strong></p>\n<p>一般情况下，我们定义的变量都为属性值；如果变量作为属性，需要用一种特殊的方式使用<code>#{$variables}</code>。</p>\n<pre><code>eg:\n//定义\n$borderDirection: top; \n\n//使用\n.border-#{$borderDirection}{\n      border-#{$borderDirection}:1px solid #ccc;\n}\n</code></pre><p><strong>(4)多值变量</strong></p>\n<pre><code>多值变量分为list类型和map类型\nlist类型有点像js中的数组，但是下标从1开始\nmap类型有点像js中的对象，但是是用()包裹起来\n</code></pre><p><strong>list类型</strong></p>\n<pre><code>定义: \n$px: 5px 10px 15px 20px;//一维数组\n$px: (5px 10px) (15px 20px);//二维数组\n\n取值： nth($px,2);//取到的是10px\n</code></pre><p><strong>map类型</strong></p>\n<pre><code>定义：\n$heading: (h1: 2em, h2: 1.5em, h3: 1.2em);\n\n取值：map-get($heading, $h1);//取到的是2em\n</code></pre><p><strong>(5)变量的作用域</strong></p>\n<pre><code>和一般编程语言一样，sass中声明的变量也有作用域\n在规则块以外声明的变量，相当于全局变量，可以在任意地方使用；\n在css规则块里面声明的变量，相当于局部变量，只能在{...}里面使用。\n\neg:\n$nav-color: red;//相当于全局变量\nnav {\n    $width: 20px;\n    width: $width;//可以使用，不会有错误\n    color: $nav-color;//可以使用\n}\n\ndiv {\n    width: $width;//不能使用，会有错误\n}\n</code></pre><p><strong>(6)变量的赋值</strong></p>\n<pre><code>可以给一个变量赋值\n$nav-color: red;\n\n也可以用另外一个变量赋值给一个变量\n$color: red;\n$nav-color: color;\n</code></pre><h4 id=\"5-嵌套css\"><a href=\"#5-嵌套css\" class=\"headerlink\" title=\"5. 嵌套css\"></a>5. 嵌套css</h4><p>像俄罗斯套娃一样，在一个规则块里面嵌套规则块。</p>\n<p><strong>(1)选择器的嵌套</strong></p>\n<pre><code>eg:\n//css\n#content aside {background: #eee;}\n#content article h1 {color: red;}\n#content article p {color: black;}\n\n//sass,用嵌套的规则来写    \n#content {\n    article {\n        h1 {color: red;}\n        p {color: black;}\n    }\n\n    aside {background: #eee;}\n}\n</code></pre><p><strong>在使用选择器的嵌套时，会用到以下两个属性：</strong></p>\n<p><strong>父选择器&amp;</strong></p>\n<pre><code>在使用嵌套规则时，`&amp;`代表的是上一层的选择器。\n\neg:\n\n#content {\n    article {\n        h1 {color: red;}\n        &amp; p {color: black;}//这里的&amp;代表article\n    }\n\n    aside {background: #eee;}\n}\n\n由于sass是将嵌套规则的选择器用空格拼接起来，所以当遇到伪类时，使用嵌套规则就会有错误，这时就要使用父选择器&amp;\narticle a {\n    color: red;\n    &amp;:hover: black;\n}\n</code></pre><p><strong>跳出上一层选择器</strong></p>\n<pre><code>@at-root：跳出上一层选择器\n@at-root (without: all)：跳出所有的选择器\n@at-root (without: rule)：跳出常规的css选择器\n@at-root (without: media)：跳出@media\n</code></pre><p><strong>(2)属性的嵌套</strong></p>\n<pre><code>eg:\n//css\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n\n//sass 属性嵌套\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n</code></pre><h4 id=\"6-混合器\"><a href=\"#6-混合器\" class=\"headerlink\" title=\"6. 混合器\"></a>6. 混合器</h4><p>实现大段样式的重用</p>\n<p><strong>@mixin：</strong>定义混合器<br><strong>@include：</strong>引用混合器</p>\n<p><strong>@mixin里面可以是css的属性，也可以是css规则</strong></p>\n<pre><code>@mixin no-bullets {\n  list-style: none;\n  li {\n    list-style-image: none;\n    list-style-type: none;\n    margin-left: 0px;\n  }\n}\n</code></pre><p><strong>给混合器传参，参数是变量<code>$val</code></strong></p>\n<pre><code>//定义混合器\n@mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &amp;:hover { color: $hover; }\n  &amp;:visited { color: $visited; }\n}\n\n//引用混合器\na {\n  @include link-colors(blue, red, green);\n}\n</code></pre><h4 id=\"7-继承\"><a href=\"#7-继承\" class=\"headerlink\" title=\"7. 继承\"></a>7. 继承</h4><p><strong>选择器继承@extend：</strong>让选择器继承另一个选择器的所有样式，并联合声明</p>\n<pre><code>//sass\nh1 {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  @extend h1;\n  border-width: 2px;\n}\n\n//css\nh1,.speaker {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  border-width: 2px;\n}\n</code></pre><p><strong>占位选择器%：</strong>不继承的话，css里面不会出现，所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。</p>\n<pre><code>//sass\n%h1 {\n  border: 4px solid #ff9aa9;\n}\n%h2 {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  @extend h1;\n  border-width: 2px;\n}\n\n//css\nh1,.speaker {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  border-width: 2px;\n}\n</code></pre><h4 id=\"8-函数\"><a href=\"#8-函数\" class=\"headerlink\" title=\"8. 函数\"></a>8. 函数</h4><p>自定义函数@function</p>\n<h4 id=\"9-运算\"><a href=\"#9-运算\" class=\"headerlink\" title=\"9. 运算\"></a>9. 运算</h4><p>可以对数值型，如：数字、颜色、变量等，进行加减乘除四则运算，</p>\n<font color=\"red\">注意:运算符前后留一个空格。</font>\n\n<h4 id=\"11-条件判断及循环\"><a href=\"#11-条件判断及循环\" class=\"headerlink\" title=\"11. 条件判断及循环\"></a>11. 条件判断及循环</h4><pre><code>@if\n@else\nif(条件，条件为真，条件为假)\n@for循环\n@each循环\n</code></pre><h3 id=\"五-Sass转化为css\"><a href=\"#五-Sass转化为css\" class=\"headerlink\" title=\"五. Sass转化为css\"></a>五. Sass转化为css</h3><pre><code>打开cmd\n进入到保存sass或者scss文件的文件夹中\n在cmd中输入`sass --watch 文件名.scss:文件名.css`\n</code></pre>","excerpt":"","more":"<h3 id=\"一-什么是CSS预处理器\"><a href=\"#一-什么是CSS预处理器\" class=\"headerlink\" title=\"一. 什么是CSS预处理器\"></a>一. 什么是CSS预处理器</h3><p><strong>CSS的优点</strong></p>\n<ul>\n<li>使结构和表现分离</li>\n<li>一个文件可以在多处引用</li>\n</ul>\n<p><strong>CSS的缺点</strong></p>\n<ul>\n<li>嵌套</li>\n<li>复用代码段</li>\n<li>模块化开发的不灵活</li>\n<li>不具备逻辑能力和抽象能力</li>\n</ul>\n<p>由于css是一门纯静态的语言，并且有上述这些缺点，因此出现了css预处理器。</p>\n<h4 id=\"1-什么是css预处理器\"><a href=\"#1-什么是css预处理器\" class=\"headerlink\" title=\"1. 什么是css预处理器\"></a>1. 什么是css预处理器</h4><blockquote>\n<p>css预处理器可以看成是css的一门方言，用更精简的语法表达更多。</p>\n<p>css预处理器并不是css的替代品，它只是让css变得更加高效、可维护。</p>\n<p>使用css预处理器编写代码之后也会生成css代码，部署到线上的是生成的css文件，而不是预处理器文件（Sass/Less/stylus）。</p>\n<p>因此，使用css预处理器主要是为了提高<strong>开发效率</strong>。</p>\n</blockquote>\n<font color=\"red\">注意：永远不要去修改生成后的css</font>\n\n\n<h4 id=\"2-使用css预处理器的优点\"><a href=\"#2-使用css预处理器的优点\" class=\"headerlink\" title=\"2. 使用css预处理器的优点\"></a>2. 使用css预处理器的优点</h4><ul>\n<li>提高开发效率</li>\n<li>易维护，更方便的定制</li>\n<li>让css看起来更像是一门编程语言</li>\n</ul>\n<h3 id=\"二-几种css预处理器（Sass-Less-stylus）\"><a href=\"#二-几种css预处理器（Sass-Less-stylus）\" class=\"headerlink\" title=\"二. 几种css预处理器（Sass/Less/stylus）\"></a>二. 几种css预处理器（Sass/Less/stylus）</h3><p>Sass：2006年提出<br>Less：2009年提出<br>stylus：2010年</p>\n<h3 id=\"三-安装Sass\"><a href=\"#三-安装Sass\" class=\"headerlink\" title=\"三. 安装Sass\"></a>三. 安装Sass</h3><p>Sass的官网（中文）：<a href=\"http://www.sasschina.com/\">http://www.sasschina.com/</a></p>\n<font color=\"red\">第一步，安装ruby</font>\n\n<p>由于之前我的博客是基于jekyll的，jekyll时基于ruby，所以我已经安装过ruby了。</p>\n<font color=\"red\">第二步，安装Sass</font>\n\n<pre><code>打开cmd\n输入gem install sass\n</code></pre><p>发现提示了一个错误：</p>\n<p><img src=\"/uploads/post/20160629/sass-install.jpg\" alt=\"模拟文件报表排版\"></p>\n<p>然后我就在网上找原因，后来发现了其他的安装方法</p>\n<p><a href=\"http://www.w3cplus.com/sassguide/install.html\" title=\"安装sass\">http://www.w3cplus.com/sassguide/install.html</a></p>\n<p>我采用的是<strong>第三种</strong>安装方法</p>\n<pre><code>首先，在RubyGems.org上下载sass，然后保存在自己的电脑里\n[https://rubygems.org/gems/sass](https://rubygems.org/gems/sass)\n\n然后，在cmd中输入`gem install 保存sass的路径`\n\n最后，输入`sass -v`来验证是否安装成功\n</code></pre><h3 id=\"四-Sass的语法\"><a href=\"#四-Sass的语法\" class=\"headerlink\" title=\"四. Sass的语法\"></a>四. Sass的语法</h3><h4 id=\"1-Sass的两种后缀名文件\"><a href=\"#1-Sass的两种后缀名文件\" class=\"headerlink\" title=\"1. Sass的两种后缀名文件\"></a>1. Sass的两种后缀名文件</h4><ul>\n<li>sass：语法严格，不使用大括号和分号。</li>\n<li>scss：使用大括号和分号，<strong>建议使用scss为后缀名</strong>。</li>\n</ul>\n<h4 id=\"2-导入sass文件\"><a href=\"#2-导入sass文件\" class=\"headerlink\" title=\"2. 导入sass文件\"></a>2. 导入sass文件</h4><p>在一个sass文件中可以通过<code>@import</code>导入另外一个写好的文件</p>\n<p><strong>@import可以导入的文件类型</strong></p>\n<pre><code>.css文件：不能忽略后缀名\n.sass/.scss文件：可以忽略后缀名、前缀_\n</code></pre><h4 id=\"3-注释\"><a href=\"#3-注释\" class=\"headerlink\" title=\"3. 注释\"></a>3. 注释</h4><pre><code>标准的css注释：/*.......*/\nsass的静默注释：//........\n</code></pre><p>静默注释在生成的css文件中不会出现。</p>\n<h4 id=\"4-变量\"><a href=\"#4-变量\" class=\"headerlink\" title=\"4. 变量\"></a>4. 变量</h4><p><strong>(1)普通变量</strong></p>\n<pre><code>使用$val：attr;来进行声明\n在全局的范围内使用\n\neg:\n$highlight-color: #eee;\n</code></pre><p><strong>(2)默认变量!default</strong></p>\n<pre><code>$highlight-color: #eee ！default;\nsass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可\n</code></pre><p><strong>(3)特殊变量</strong></p>\n<p>一般情况下，我们定义的变量都为属性值；如果变量作为属性，需要用一种特殊的方式使用<code>#{$variables}</code>。</p>\n<pre><code>eg:\n//定义\n$borderDirection: top; \n\n//使用\n.border-#{$borderDirection}{\n      border-#{$borderDirection}:1px solid #ccc;\n}\n</code></pre><p><strong>(4)多值变量</strong></p>\n<pre><code>多值变量分为list类型和map类型\nlist类型有点像js中的数组，但是下标从1开始\nmap类型有点像js中的对象，但是是用()包裹起来\n</code></pre><p><strong>list类型</strong></p>\n<pre><code>定义: \n$px: 5px 10px 15px 20px;//一维数组\n$px: (5px 10px) (15px 20px);//二维数组\n\n取值： nth($px,2);//取到的是10px\n</code></pre><p><strong>map类型</strong></p>\n<pre><code>定义：\n$heading: (h1: 2em, h2: 1.5em, h3: 1.2em);\n\n取值：map-get($heading, $h1);//取到的是2em\n</code></pre><p><strong>(5)变量的作用域</strong></p>\n<pre><code>和一般编程语言一样，sass中声明的变量也有作用域\n在规则块以外声明的变量，相当于全局变量，可以在任意地方使用；\n在css规则块里面声明的变量，相当于局部变量，只能在{...}里面使用。\n\neg:\n$nav-color: red;//相当于全局变量\nnav {\n    $width: 20px;\n    width: $width;//可以使用，不会有错误\n    color: $nav-color;//可以使用\n}\n\ndiv {\n    width: $width;//不能使用，会有错误\n}\n</code></pre><p><strong>(6)变量的赋值</strong></p>\n<pre><code>可以给一个变量赋值\n$nav-color: red;\n\n也可以用另外一个变量赋值给一个变量\n$color: red;\n$nav-color: color;\n</code></pre><h4 id=\"5-嵌套css\"><a href=\"#5-嵌套css\" class=\"headerlink\" title=\"5. 嵌套css\"></a>5. 嵌套css</h4><p>像俄罗斯套娃一样，在一个规则块里面嵌套规则块。</p>\n<p><strong>(1)选择器的嵌套</strong></p>\n<pre><code>eg:\n//css\n#content aside {background: #eee;}\n#content article h1 {color: red;}\n#content article p {color: black;}\n\n//sass,用嵌套的规则来写    \n#content {\n    article {\n        h1 {color: red;}\n        p {color: black;}\n    }\n\n    aside {background: #eee;}\n}\n</code></pre><p><strong>在使用选择器的嵌套时，会用到以下两个属性：</strong></p>\n<p><strong>父选择器&amp;</strong></p>\n<pre><code>在使用嵌套规则时，`&amp;`代表的是上一层的选择器。\n\neg:\n\n#content {\n    article {\n        h1 {color: red;}\n        &amp; p {color: black;}//这里的&amp;代表article\n    }\n\n    aside {background: #eee;}\n}\n\n由于sass是将嵌套规则的选择器用空格拼接起来，所以当遇到伪类时，使用嵌套规则就会有错误，这时就要使用父选择器&amp;\narticle a {\n    color: red;\n    &amp;:hover: black;\n}\n</code></pre><p><strong>跳出上一层选择器</strong></p>\n<pre><code>@at-root：跳出上一层选择器\n@at-root (without: all)：跳出所有的选择器\n@at-root (without: rule)：跳出常规的css选择器\n@at-root (without: media)：跳出@media\n</code></pre><p><strong>(2)属性的嵌套</strong></p>\n<pre><code>eg:\n//css\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n\n//sass 属性嵌套\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n</code></pre><h4 id=\"6-混合器\"><a href=\"#6-混合器\" class=\"headerlink\" title=\"6. 混合器\"></a>6. 混合器</h4><p>实现大段样式的重用</p>\n<p><strong>@mixin：</strong>定义混合器<br><strong>@include：</strong>引用混合器</p>\n<p><strong>@mixin里面可以是css的属性，也可以是css规则</strong></p>\n<pre><code>@mixin no-bullets {\n  list-style: none;\n  li {\n    list-style-image: none;\n    list-style-type: none;\n    margin-left: 0px;\n  }\n}\n</code></pre><p><strong>给混合器传参，参数是变量<code>$val</code></strong></p>\n<pre><code>//定义混合器\n@mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &amp;:hover { color: $hover; }\n  &amp;:visited { color: $visited; }\n}\n\n//引用混合器\na {\n  @include link-colors(blue, red, green);\n}\n</code></pre><h4 id=\"7-继承\"><a href=\"#7-继承\" class=\"headerlink\" title=\"7. 继承\"></a>7. 继承</h4><p><strong>选择器继承@extend：</strong>让选择器继承另一个选择器的所有样式，并联合声明</p>\n<pre><code>//sass\nh1 {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  @extend h1;\n  border-width: 2px;\n}\n\n//css\nh1,.speaker {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  border-width: 2px;\n}\n</code></pre><p><strong>占位选择器%：</strong>不继承的话，css里面不会出现，所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。</p>\n<pre><code>//sass\n%h1 {\n  border: 4px solid #ff9aa9;\n}\n%h2 {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  @extend h1;\n  border-width: 2px;\n}\n\n//css\nh1,.speaker {\n  border: 4px solid #ff9aa9;\n}\n.speaker {\n  border-width: 2px;\n}\n</code></pre><h4 id=\"8-函数\"><a href=\"#8-函数\" class=\"headerlink\" title=\"8. 函数\"></a>8. 函数</h4><p>自定义函数@function</p>\n<h4 id=\"9-运算\"><a href=\"#9-运算\" class=\"headerlink\" title=\"9. 运算\"></a>9. 运算</h4><p>可以对数值型，如：数字、颜色、变量等，进行加减乘除四则运算，</p>\n<font color=\"red\">注意:运算符前后留一个空格。</font>\n\n<h4 id=\"11-条件判断及循环\"><a href=\"#11-条件判断及循环\" class=\"headerlink\" title=\"11. 条件判断及循环\"></a>11. 条件判断及循环</h4><pre><code>@if\n@else\nif(条件，条件为真，条件为假)\n@for循环\n@each循环\n</code></pre><h3 id=\"五-Sass转化为css\"><a href=\"#五-Sass转化为css\" class=\"headerlink\" title=\"五. Sass转化为css\"></a>五. Sass转化为css</h3><pre><code>打开cmd\n进入到保存sass或者scss文件的文件夹中\n在cmd中输入`sass --watch 文件名.scss:文件名.css`\n</code></pre>"},{"layout":"post","title":"面向过程or面向对象编程","date":"2016-06-27T16:00:00.000Z","description":null,"_content":"\n这是两种编程方式。\n\n### 一. 面向过程编程\n\n> 面向过程编程的思维方式是计算机的思维方式——给处理器输入数据，处理器处理，然后输出数据。\n\n将程序分成**数据**和**处理函数**两个部分。\n\n数据和处理函数之间并没有关联起来，共同属于某个物件。\n\n> **整个编程的思维就是：**定义数据，定义处理函数，然后将数据传给处理函数进行处理；处理函数之间也可以相互调用；数据和处理函数之间耦合紧密。\n\n### 二. 面向对象编程\n\n> 面向对象编程的思维方式是使用生活中的思维进行编程，描述一个个物件，这些物件有自己的**属性**和**行为**。\n\n> **面向对象编程的思维就是：**定义一个个对象，对象有自己的属性和行为，因为属性和行为都是从属于对象的，于是有了对象内和对象外的概念，整个程序可以由一堆对象组成，对象与对象之间可能会有通信，为了实现这种通信，对象会将自己的部分属性设计成公有，暴露出来成为通信的接口。\n\n面向对象的特点：继承，封装，多态。\n\n#### 1. js中的面向对象编程\n\n与C++这种正统的面向对象语言相比，js中的面向对象有以下几点不同：\n\n- 没有Class来定义类，js中定义类是利用函数（构造函数）来充当类的。\n- 没有public、protect、private这些关键字来声明属性和行为的可访问性，js是利用作用域来实现公有还是私有的问题。**用`this.attr`来定义的属性是公有的，在`构造函数中用var定义`的属性是私有的**。\n\n```js\n    eg：\n    //定义Animal类\n    var Animal = function(name) {\n    \t//公有属性\n    \tthis.name = name || \"XXX\";\n    \tthis.type = \"animal\";\n    \n    \t//私有属性\n    \tvar age = 20;\n    \n    \t//私有方法\n    \tvar move = function() {\n    \t\talert(\"I'm moving now!\");\n    \t};\n    }\n    \n    //Animal的原型\n    Animal.prototype = {\n    \t//公有方法\n    \tsay: function() {\n    \t\talert(\"I'm a\" + this.type + \", my name is\" + this.name);\n    \t}\n    }\n    \n    //实例化Animal类\n    var myDog = new Animal(\"dudu\");\n    console.log(myDog.name);//可以访问公有属性\n    console.log(myDog.age);//会报错，不能访问私有属性\n    myDog.move();//会报错，不能访问私有方法\n```\n\n#### 2. js中如何定义私有属性和行为\n\n**方法一：在构造函数中定义**\n\n1中所讲的方法可以真正地实现属性和行为私有化，但是放在构造函数里会消耗更多地内存，因为原型中的属性和行为可以被所有实例共享，而构造函数里的属性和行为，是每个实例都会复制一份。\n\n**方法二：使用命名来约定其私有性（并不能真正实现私有）**\n\n    仍然用this._attr来定义，但是命名前加下划线。\n\n### 三. 电话本程序（分别用两种思想来写）\n\n#### 1. 用面向过程编程思想\n\n```js\n//电话本1\nvar phoneBook1 = [\n\t{name: \"a\", tel: \"111111\"},\n\t{name: \"b\", tel: \"222222\"},\n\t{name: \"c\", tel: \"333333\"},\n];\n\n//电话本2\nvar phoneBook2 = [\n\t{name: \"d\", tel: \"444444\"},\n\t{name: \"e\", tel: \"555555\"},\n\t{name: \"f\", tel: \"666666\"},\n];\n\n//查询电话\nfunction getTel(phoneBook,name) {\n\tvar tel = \"\";\n\tfor(var i = 0; i < phoneBook.length; i++) {\n\t\tif(name == phoneBook[i].name) {\n\t\t\ttel = phoneBook[i].tel;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n//添加记录\nfunction addItem(phoneBook,name,tel) {\n\tphoneBook.push({name: name, tel: tel});\n}\n\n//删除记录\nfunction removeItem(phoneBook,name) {\n\tvar n;\n\tfor(var i = 0; i < phoneBook.length; i++) {\n\t\tif(phoneBook[i].name == name) {\n\t\t\tn = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(n != undefined) {\n\t\tphoneBook.splice(n,1);\n\t}\n}\n```\n\n#### 2. 用面向对象编程思想\n\n```js\nvar PhoneBookManager = function(o) {\n\t//电话本为私有属性\n\tthis._phoneBook = o;\n}\n\nPhoneBookManager.prototype = {\n\tconstructor: PhoneBookManager,\n\n\t//查询电话\n\tgetTel: function(name) {\n\t\tvar tel = \"\";\n\t\tfor(var i = 0; i < phoneBook.length; i++) {\n\t\t\tif(name == this._phoneBook[i].name) {\n\t\t\t\ttel = this._phoneBook[i].tel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\n\t//添加记录\n\taddItem: function(name,tel) {\n\t\tthis._phoneBook.push({name: name, tel: tel});\n\t}\n\n\t//删除记录\n\tremoveItem: function(name) {\n\t\tvar n;\n\t\tfor(var i = 0; i < this._phoneBook.length; i++) {\n\t\t\tif(this._phoneBook[i].name == name) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n != undefined) {\n\t\t\tthis._phoneBook.splice(n,1);\n\t\t}\n\t}\n}\n\n//实例化一个电话本管理系统\nvar my = new PhoneBookManager([\n\t{name: \"a\", tel: \"111111\"},\n\t{name: \"b\", tel: \"222222\"},\n\t{name: \"c\", tel: \"333333\"},\n]);\n```","source":"_posts/2016-06-28-面向过程or面向对象编程.md","raw":"---\nlayout: post\ntitle: 面向过程or面向对象编程\ndate: 2016-06-28\ncategories: javaScript\ntags: [读书笔记,javaScript]\ndescription: \n---\n\n这是两种编程方式。\n\n### 一. 面向过程编程\n\n> 面向过程编程的思维方式是计算机的思维方式——给处理器输入数据，处理器处理，然后输出数据。\n\n将程序分成**数据**和**处理函数**两个部分。\n\n数据和处理函数之间并没有关联起来，共同属于某个物件。\n\n> **整个编程的思维就是：**定义数据，定义处理函数，然后将数据传给处理函数进行处理；处理函数之间也可以相互调用；数据和处理函数之间耦合紧密。\n\n### 二. 面向对象编程\n\n> 面向对象编程的思维方式是使用生活中的思维进行编程，描述一个个物件，这些物件有自己的**属性**和**行为**。\n\n> **面向对象编程的思维就是：**定义一个个对象，对象有自己的属性和行为，因为属性和行为都是从属于对象的，于是有了对象内和对象外的概念，整个程序可以由一堆对象组成，对象与对象之间可能会有通信，为了实现这种通信，对象会将自己的部分属性设计成公有，暴露出来成为通信的接口。\n\n面向对象的特点：继承，封装，多态。\n\n#### 1. js中的面向对象编程\n\n与C++这种正统的面向对象语言相比，js中的面向对象有以下几点不同：\n\n- 没有Class来定义类，js中定义类是利用函数（构造函数）来充当类的。\n- 没有public、protect、private这些关键字来声明属性和行为的可访问性，js是利用作用域来实现公有还是私有的问题。**用`this.attr`来定义的属性是公有的，在`构造函数中用var定义`的属性是私有的**。\n\n```js\n    eg：\n    //定义Animal类\n    var Animal = function(name) {\n    \t//公有属性\n    \tthis.name = name || \"XXX\";\n    \tthis.type = \"animal\";\n    \n    \t//私有属性\n    \tvar age = 20;\n    \n    \t//私有方法\n    \tvar move = function() {\n    \t\talert(\"I'm moving now!\");\n    \t};\n    }\n    \n    //Animal的原型\n    Animal.prototype = {\n    \t//公有方法\n    \tsay: function() {\n    \t\talert(\"I'm a\" + this.type + \", my name is\" + this.name);\n    \t}\n    }\n    \n    //实例化Animal类\n    var myDog = new Animal(\"dudu\");\n    console.log(myDog.name);//可以访问公有属性\n    console.log(myDog.age);//会报错，不能访问私有属性\n    myDog.move();//会报错，不能访问私有方法\n```\n\n#### 2. js中如何定义私有属性和行为\n\n**方法一：在构造函数中定义**\n\n1中所讲的方法可以真正地实现属性和行为私有化，但是放在构造函数里会消耗更多地内存，因为原型中的属性和行为可以被所有实例共享，而构造函数里的属性和行为，是每个实例都会复制一份。\n\n**方法二：使用命名来约定其私有性（并不能真正实现私有）**\n\n    仍然用this._attr来定义，但是命名前加下划线。\n\n### 三. 电话本程序（分别用两种思想来写）\n\n#### 1. 用面向过程编程思想\n\n```js\n//电话本1\nvar phoneBook1 = [\n\t{name: \"a\", tel: \"111111\"},\n\t{name: \"b\", tel: \"222222\"},\n\t{name: \"c\", tel: \"333333\"},\n];\n\n//电话本2\nvar phoneBook2 = [\n\t{name: \"d\", tel: \"444444\"},\n\t{name: \"e\", tel: \"555555\"},\n\t{name: \"f\", tel: \"666666\"},\n];\n\n//查询电话\nfunction getTel(phoneBook,name) {\n\tvar tel = \"\";\n\tfor(var i = 0; i < phoneBook.length; i++) {\n\t\tif(name == phoneBook[i].name) {\n\t\t\ttel = phoneBook[i].tel;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n//添加记录\nfunction addItem(phoneBook,name,tel) {\n\tphoneBook.push({name: name, tel: tel});\n}\n\n//删除记录\nfunction removeItem(phoneBook,name) {\n\tvar n;\n\tfor(var i = 0; i < phoneBook.length; i++) {\n\t\tif(phoneBook[i].name == name) {\n\t\t\tn = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(n != undefined) {\n\t\tphoneBook.splice(n,1);\n\t}\n}\n```\n\n#### 2. 用面向对象编程思想\n\n```js\nvar PhoneBookManager = function(o) {\n\t//电话本为私有属性\n\tthis._phoneBook = o;\n}\n\nPhoneBookManager.prototype = {\n\tconstructor: PhoneBookManager,\n\n\t//查询电话\n\tgetTel: function(name) {\n\t\tvar tel = \"\";\n\t\tfor(var i = 0; i < phoneBook.length; i++) {\n\t\t\tif(name == this._phoneBook[i].name) {\n\t\t\t\ttel = this._phoneBook[i].tel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\n\t//添加记录\n\taddItem: function(name,tel) {\n\t\tthis._phoneBook.push({name: name, tel: tel});\n\t}\n\n\t//删除记录\n\tremoveItem: function(name) {\n\t\tvar n;\n\t\tfor(var i = 0; i < this._phoneBook.length; i++) {\n\t\t\tif(this._phoneBook[i].name == name) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n != undefined) {\n\t\t\tthis._phoneBook.splice(n,1);\n\t\t}\n\t}\n}\n\n//实例化一个电话本管理系统\nvar my = new PhoneBookManager([\n\t{name: \"a\", tel: \"111111\"},\n\t{name: \"b\", tel: \"222222\"},\n\t{name: \"c\", tel: \"333333\"},\n]);\n```","slug":"2016-06-28-面向过程or面向对象编程","published":1,"updated":"2016-06-28T09:21:00.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocj100agd5u83c3w8knw","content":"<p>这是两种编程方式。</p>\n<h3 id=\"一-面向过程编程\"><a href=\"#一-面向过程编程\" class=\"headerlink\" title=\"一. 面向过程编程\"></a>一. 面向过程编程</h3><blockquote>\n<p>面向过程编程的思维方式是计算机的思维方式——给处理器输入数据，处理器处理，然后输出数据。</p>\n</blockquote>\n<p>将程序分成<strong>数据</strong>和<strong>处理函数</strong>两个部分。</p>\n<p>数据和处理函数之间并没有关联起来，共同属于某个物件。</p>\n<blockquote>\n<p><strong>整个编程的思维就是：</strong>定义数据，定义处理函数，然后将数据传给处理函数进行处理；处理函数之间也可以相互调用；数据和处理函数之间耦合紧密。</p>\n</blockquote>\n<h3 id=\"二-面向对象编程\"><a href=\"#二-面向对象编程\" class=\"headerlink\" title=\"二. 面向对象编程\"></a>二. 面向对象编程</h3><blockquote>\n<p>面向对象编程的思维方式是使用生活中的思维进行编程，描述一个个物件，这些物件有自己的<strong>属性</strong>和<strong>行为</strong>。</p>\n<p><strong>面向对象编程的思维就是：</strong>定义一个个对象，对象有自己的属性和行为，因为属性和行为都是从属于对象的，于是有了对象内和对象外的概念，整个程序可以由一堆对象组成，对象与对象之间可能会有通信，为了实现这种通信，对象会将自己的部分属性设计成公有，暴露出来成为通信的接口。</p>\n</blockquote>\n<p>面向对象的特点：继承，封装，多态。</p>\n<h4 id=\"1-js中的面向对象编程\"><a href=\"#1-js中的面向对象编程\" class=\"headerlink\" title=\"1. js中的面向对象编程\"></a>1. js中的面向对象编程</h4><p>与C++这种正统的面向对象语言相比，js中的面向对象有以下几点不同：</p>\n<ul>\n<li>没有Class来定义类，js中定义类是利用函数（构造函数）来充当类的。</li>\n<li>没有public、protect、private这些关键字来声明属性和行为的可访问性，js是利用作用域来实现公有还是私有的问题。<strong>用<code>this.attr</code>来定义的属性是公有的，在<code>构造函数中用var定义</code>的属性是私有的</strong>。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：</span><br><span class=\"line\"><span class=\"comment\">//定义Animal类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Animal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//公有属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"XXX\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.type = <span class=\"string\">\"animal\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//私有属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//私有方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> move = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"I'm moving now!\"</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Animal的原型</span></span><br><span class=\"line\">Animal.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//公有方法</span></span><br><span class=\"line\">\tsay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"I'm a\"</span> + <span class=\"keyword\">this</span>.type + <span class=\"string\">\", my name is\"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化Animal类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myDog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"dudu\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myDog.name);<span class=\"comment\">//可以访问公有属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myDog.age);<span class=\"comment\">//会报错，不能访问私有属性</span></span><br><span class=\"line\">myDog.move();<span class=\"comment\">//会报错，不能访问私有方法</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-js中如何定义私有属性和行为\"><a href=\"#2-js中如何定义私有属性和行为\" class=\"headerlink\" title=\"2. js中如何定义私有属性和行为\"></a>2. js中如何定义私有属性和行为</h4><p><strong>方法一：在构造函数中定义</strong></p>\n<p>1中所讲的方法可以真正地实现属性和行为私有化，但是放在构造函数里会消耗更多地内存，因为原型中的属性和行为可以被所有实例共享，而构造函数里的属性和行为，是每个实例都会复制一份。</p>\n<p><strong>方法二：使用命名来约定其私有性（并不能真正实现私有）</strong></p>\n<pre><code>仍然用this._attr来定义，但是命名前加下划线。\n</code></pre><h3 id=\"三-电话本程序（分别用两种思想来写）\"><a href=\"#三-电话本程序（分别用两种思想来写）\" class=\"headerlink\" title=\"三. 电话本程序（分别用两种思想来写）\"></a>三. 电话本程序（分别用两种思想来写）</h3><h4 id=\"1-用面向过程编程思想\"><a href=\"#1-用面向过程编程思想\" class=\"headerlink\" title=\"1. 用面向过程编程思想\"></a>1. 用面向过程编程思想</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//电话本1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> phoneBook1 = [</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"a\"</span>, tel: <span class=\"string\">\"111111\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"b\"</span>, tel: <span class=\"string\">\"222222\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"c\"</span>, tel: <span class=\"string\">\"333333\"</span>&#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//电话本2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> phoneBook2 = [</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"d\"</span>, tel: <span class=\"string\">\"444444\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"e\"</span>, tel: <span class=\"string\">\"555555\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"f\"</span>, tel: <span class=\"string\">\"666666\"</span>&#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询电话</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTel</span>(<span class=\"params\">phoneBook,name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> tel = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name == phoneBook[i].name) &#123;</span><br><span class=\"line\">\t\t\ttel = phoneBook[i].tel;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加记录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">phoneBook,name,tel</span>) </span>&#123;</span><br><span class=\"line\">\tphoneBook.push(&#123;name: name, tel: tel&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除记录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeItem</span>(<span class=\"params\">phoneBook,name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(phoneBook[i].name == name) &#123;</span><br><span class=\"line\">\t\t\tn = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n != <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">\t\tphoneBook.splice(n,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-用面向对象编程思想\"><a href=\"#2-用面向对象编程思想\" class=\"headerlink\" title=\"2. 用面向对象编程思想\"></a>2. 用面向对象编程思想</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PhoneBookManager = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//电话本为私有属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>._phoneBook = o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PhoneBookManager.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: PhoneBookManager,</span><br><span class=\"line\"></span><br><span class=\"line\">\t//查询电话</span><br><span class=\"line\">\tgetTel: function(name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> tel = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(name == <span class=\"keyword\">this</span>._phoneBook[i].name) &#123;</span><br><span class=\"line\">\t\t\t\ttel = <span class=\"keyword\">this</span>._phoneBook[i].tel;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//添加记录</span></span><br><span class=\"line\">\taddItem: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,tel</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._phoneBook.push(&#123;name: name, tel: tel&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//删除记录</span></span><br><span class=\"line\">\tremoveItem: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>._phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>._phoneBook[i].name == name) &#123;</span><br><span class=\"line\">\t\t\t\tn = i;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(n != <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>._phoneBook.splice(n,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化一个电话本管理系统</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> my = <span class=\"keyword\">new</span> PhoneBookManager([</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"a\"</span>, tel: <span class=\"string\">\"111111\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"b\"</span>, tel: <span class=\"string\">\"222222\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"c\"</span>, tel: <span class=\"string\">\"333333\"</span>&#125;,</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>这是两种编程方式。</p>\n<h3 id=\"一-面向过程编程\"><a href=\"#一-面向过程编程\" class=\"headerlink\" title=\"一. 面向过程编程\"></a>一. 面向过程编程</h3><blockquote>\n<p>面向过程编程的思维方式是计算机的思维方式——给处理器输入数据，处理器处理，然后输出数据。</p>\n</blockquote>\n<p>将程序分成<strong>数据</strong>和<strong>处理函数</strong>两个部分。</p>\n<p>数据和处理函数之间并没有关联起来，共同属于某个物件。</p>\n<blockquote>\n<p><strong>整个编程的思维就是：</strong>定义数据，定义处理函数，然后将数据传给处理函数进行处理；处理函数之间也可以相互调用；数据和处理函数之间耦合紧密。</p>\n</blockquote>\n<h3 id=\"二-面向对象编程\"><a href=\"#二-面向对象编程\" class=\"headerlink\" title=\"二. 面向对象编程\"></a>二. 面向对象编程</h3><blockquote>\n<p>面向对象编程的思维方式是使用生活中的思维进行编程，描述一个个物件，这些物件有自己的<strong>属性</strong>和<strong>行为</strong>。</p>\n<p><strong>面向对象编程的思维就是：</strong>定义一个个对象，对象有自己的属性和行为，因为属性和行为都是从属于对象的，于是有了对象内和对象外的概念，整个程序可以由一堆对象组成，对象与对象之间可能会有通信，为了实现这种通信，对象会将自己的部分属性设计成公有，暴露出来成为通信的接口。</p>\n</blockquote>\n<p>面向对象的特点：继承，封装，多态。</p>\n<h4 id=\"1-js中的面向对象编程\"><a href=\"#1-js中的面向对象编程\" class=\"headerlink\" title=\"1. js中的面向对象编程\"></a>1. js中的面向对象编程</h4><p>与C++这种正统的面向对象语言相比，js中的面向对象有以下几点不同：</p>\n<ul>\n<li>没有Class来定义类，js中定义类是利用函数（构造函数）来充当类的。</li>\n<li>没有public、protect、private这些关键字来声明属性和行为的可访问性，js是利用作用域来实现公有还是私有的问题。<strong>用<code>this.attr</code>来定义的属性是公有的，在<code>构造函数中用var定义</code>的属性是私有的</strong>。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：</span><br><span class=\"line\"><span class=\"comment\">//定义Animal类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Animal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//公有属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"XXX\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.type = <span class=\"string\">\"animal\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//私有属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//私有方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> move = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"I'm moving now!\"</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Animal的原型</span></span><br><span class=\"line\">Animal.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//公有方法</span></span><br><span class=\"line\">\tsay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"I'm a\"</span> + <span class=\"keyword\">this</span>.type + <span class=\"string\">\", my name is\"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化Animal类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myDog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"dudu\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myDog.name);<span class=\"comment\">//可以访问公有属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myDog.age);<span class=\"comment\">//会报错，不能访问私有属性</span></span><br><span class=\"line\">myDog.move();<span class=\"comment\">//会报错，不能访问私有方法</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-js中如何定义私有属性和行为\"><a href=\"#2-js中如何定义私有属性和行为\" class=\"headerlink\" title=\"2. js中如何定义私有属性和行为\"></a>2. js中如何定义私有属性和行为</h4><p><strong>方法一：在构造函数中定义</strong></p>\n<p>1中所讲的方法可以真正地实现属性和行为私有化，但是放在构造函数里会消耗更多地内存，因为原型中的属性和行为可以被所有实例共享，而构造函数里的属性和行为，是每个实例都会复制一份。</p>\n<p><strong>方法二：使用命名来约定其私有性（并不能真正实现私有）</strong></p>\n<pre><code>仍然用this._attr来定义，但是命名前加下划线。\n</code></pre><h3 id=\"三-电话本程序（分别用两种思想来写）\"><a href=\"#三-电话本程序（分别用两种思想来写）\" class=\"headerlink\" title=\"三. 电话本程序（分别用两种思想来写）\"></a>三. 电话本程序（分别用两种思想来写）</h3><h4 id=\"1-用面向过程编程思想\"><a href=\"#1-用面向过程编程思想\" class=\"headerlink\" title=\"1. 用面向过程编程思想\"></a>1. 用面向过程编程思想</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//电话本1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> phoneBook1 = [</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"a\"</span>, tel: <span class=\"string\">\"111111\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"b\"</span>, tel: <span class=\"string\">\"222222\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"c\"</span>, tel: <span class=\"string\">\"333333\"</span>&#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//电话本2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> phoneBook2 = [</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"d\"</span>, tel: <span class=\"string\">\"444444\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"e\"</span>, tel: <span class=\"string\">\"555555\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"f\"</span>, tel: <span class=\"string\">\"666666\"</span>&#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询电话</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTel</span>(<span class=\"params\">phoneBook,name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> tel = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name == phoneBook[i].name) &#123;</span><br><span class=\"line\">\t\t\ttel = phoneBook[i].tel;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加记录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">phoneBook,name,tel</span>) </span>&#123;</span><br><span class=\"line\">\tphoneBook.push(&#123;name: name, tel: tel&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除记录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeItem</span>(<span class=\"params\">phoneBook,name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(phoneBook[i].name == name) &#123;</span><br><span class=\"line\">\t\t\tn = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n != <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">\t\tphoneBook.splice(n,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-用面向对象编程思想\"><a href=\"#2-用面向对象编程思想\" class=\"headerlink\" title=\"2. 用面向对象编程思想\"></a>2. 用面向对象编程思想</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PhoneBookManager = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//电话本为私有属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>._phoneBook = o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PhoneBookManager.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: PhoneBookManager,</span><br><span class=\"line\"></span><br><span class=\"line\">\t//查询电话</span><br><span class=\"line\">\tgetTel: function(name) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> tel = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(name == <span class=\"keyword\">this</span>._phoneBook[i].name) &#123;</span><br><span class=\"line\">\t\t\t\ttel = <span class=\"keyword\">this</span>._phoneBook[i].tel;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//添加记录</span></span><br><span class=\"line\">\taddItem: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,tel</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._phoneBook.push(&#123;name: name, tel: tel&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//删除记录</span></span><br><span class=\"line\">\tremoveItem: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>._phoneBook.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>._phoneBook[i].name == name) &#123;</span><br><span class=\"line\">\t\t\t\tn = i;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(n != <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>._phoneBook.splice(n,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化一个电话本管理系统</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> my = <span class=\"keyword\">new</span> PhoneBookManager([</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"a\"</span>, tel: <span class=\"string\">\"111111\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"b\"</span>, tel: <span class=\"string\">\"222222\"</span>&#125;,</span><br><span class=\"line\">\t&#123;name: <span class=\"string\">\"c\"</span>, tel: <span class=\"string\">\"333333\"</span>&#125;,</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"使用sublime配置react环境","date":"2016-06-29T16:00:00.000Z","description":null,"_content":"\n由于很多的react不支持sublime text2，只支持sublime text3，于是又重新下载了sublime text3，并安装了相关的插件。\n\n### 一. 安装并破解sublime text3\n\n直接在网上下载的sublime text3需要注册码\n\n**破解方法：**\n\nhelp ——> Enter License\n\n然后输入从网上找来的破解码\n\n```\nMichael Barnes\nSingle User License\nEA7E-821385\n8A353C41 872A0D5C DF9B2950 AFF6F667\nC458EA6D 8EA3C286 98D1D650 131A97AB\nAA919AEC EF20E143 B361B1E7 4C8B7F04\nB085E65E 2F5F5360 8489D422 FB8FC1AA\n93F6323C FD7F7544 3F39C318 D95E6480\nFCCC7561 8A4A1741 68FA4223 ADCEDE07\n200C25BE DBBC4855 C4CFB774 C5EC138C\n0FEC1CEF D9DCECEC D3A5DAD1 01316C36\n```\n\n### 二. sublime安装插件\n\n**Sublime安装插件有两种方式:**\n\n- 直接下载安装包解压缩到Packages目录\n- 通过Package Control组件来安装组件(更方便)\n\n一般使用第二种方法安装插件，方便快捷~~\n\n#### 1. 安装package control\n\n**（1）打开控制台**\n\nview ——> show console\n\n**（2）在控制台中输入**\n\n```\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\n#### 2. 使用package control安装插件的一般方法\n\n同时按下：ctrl+shift+P\n\n然后选择：package:install\n\n在出来的输入框中输入需要安装的插件，例如：`emmet`\n\n### 三. 使用sublime安装react相关插件\n\n#### 1. babel\n\n**功能：**支持jsx语法高亮\n\n**安装：**在package control中查找babel\n\n**将某一种的文件扩展名添加为使用ES6语法：**\n\n- 打开`.js`或者`.jsx`文件\n- 选择`view ——> syntax ——> Open all with current extension as... ——> Babel ——> JavaScript (Babel)`\n\n\n#### 2. sublime-react\n\n**功能：**自动补全代码的react插件\n\n**安装：**在package control中查找ReactJS\n\n**使用：**输入简写的命令，按下`tab`键即可自动补全\n\n\n```\n   cdm→  componentDidMount: fn() { ... }\n   cdup→  componentDidUpdate: fn(pp, ps) { ... }\n   cs→  var cx = React.addons.classSet;\n   cwm→  componentWillMount: fn() { ... }\n   cwr→  componentWillReceiveProps: fn(np) { ... }\n   cwu→  componentWillUpdate: fn(np, ns) { ... }\n   cwun→  componentWillUnmount: fn() { ... }\n   cx→  cx({ ... })\n   fdn→  React.findDOMNode(...)\n   fup→  forceUpdate(...)\n   gdp→  getDefaultProps: fn() { return {...} } \n   gis→  getInitialState: fn() { return {...} } \n   ism→  isMounted()\n   props→  this.props.\n   pt→  propTypes { ... }\n   rcc→  component skeleton\n   refs→  this.refs.\n   ren→  render: fn() { return ... }\n   scu→  shouldComponentUpdate: fn(np, ns) { ... }\n   sst→  this.setState({ ... })\n   state→  this.state.\n```\n个人觉得使用这种代码自动补全的插件，虽然让我们开发变得更简便了，但是也有一些不好的方面。\n\n#### 3. Sass代码高亮sass\n\n**功能：**使sass代码也有高亮显示\n\n**安装：**在package control中查找sass\n\n\n#### 4. 将Sass编译成css —— sass build\n\n**功能：**将Sass编译成css代码\n\n**安装：**在package control中查找sass build\n\n**使用：**ctrl + B进行编译\n\n\n### 二. sublime插件之Sass自动编译成`.css`\n\nsublime的插件安装方法大同小异，都是将下载好的安装包放在`.../Data/Packages`文件夹里。\n\nsass自动编译插件下载地址：\n\n[https://github.com/jaumefontal/SASS-Build-SublimeText2](https://github.com/jaumefontal/SASS-Build-SublimeText2)\n\n**插件使用方法：**\n\n首先，将编译系统调成SASS\n\n\t点击 工具(T) ——> 编译系统(U) ——> SASS\n\n然后在.scss文件页面，使用`ctrl + B`\n\n### 三. sublime插件之`sublimeLinter`自动检测js语法错误\n\njs自动检测语法错误插件的下载地址：\n\n[https://github.com/SublimeLinter/SublimeLinter-for-ST2](https://github.com/SublimeLinter/SublimeLinter-for-ST2)\n\n**修改插件配置：**\n\n点击 首选项(N) ——> 插件设置 ——> sublimeLinter ——> setting-User 打开配置文件\n\n<font color=\"red\">参数配置中的各个参数的意思：</font>\n\n**运行模式**\n\n    \"sublimelinter\": \"save-only\"\n    \n    SublimeLinter 的运行模式，总共有四种，含义分别如下：    \n    - true 在用户输入时在后台进行即时校验；\n    - false 只有在初始化的时候才进行校验；\n    - \"load-save\" 当文件加载和保存的时候进行校验；\n    - \"save-only\" 当文件被保存的时候进行校验；\n    \n    推荐设置为 “save-only”，这样只在编写完代码，保存的时候才校验，Sublime Text 运行会更加流畅。\n\n\nsublime text3破解码\n\n\n\n安装package control\n\n打开控制台view ——> show console\n\n输入\n\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n\n\n\n\nbabel\n\n[https://github.com/babel/babel-sublime](https://github.com/babel/babel-sublime)\n\nsublime-React","source":"_posts/2016-06-30-折腾sublime插件.md","raw":"---\nlayout: post\ntitle: 使用sublime配置react环境\ndate: 2016-06-30\ncategories: 工具\ntags: [css,Sass]\ndescription: \n---\n\n由于很多的react不支持sublime text2，只支持sublime text3，于是又重新下载了sublime text3，并安装了相关的插件。\n\n### 一. 安装并破解sublime text3\n\n直接在网上下载的sublime text3需要注册码\n\n**破解方法：**\n\nhelp ——> Enter License\n\n然后输入从网上找来的破解码\n\n```\nMichael Barnes\nSingle User License\nEA7E-821385\n8A353C41 872A0D5C DF9B2950 AFF6F667\nC458EA6D 8EA3C286 98D1D650 131A97AB\nAA919AEC EF20E143 B361B1E7 4C8B7F04\nB085E65E 2F5F5360 8489D422 FB8FC1AA\n93F6323C FD7F7544 3F39C318 D95E6480\nFCCC7561 8A4A1741 68FA4223 ADCEDE07\n200C25BE DBBC4855 C4CFB774 C5EC138C\n0FEC1CEF D9DCECEC D3A5DAD1 01316C36\n```\n\n### 二. sublime安装插件\n\n**Sublime安装插件有两种方式:**\n\n- 直接下载安装包解压缩到Packages目录\n- 通过Package Control组件来安装组件(更方便)\n\n一般使用第二种方法安装插件，方便快捷~~\n\n#### 1. 安装package control\n\n**（1）打开控制台**\n\nview ——> show console\n\n**（2）在控制台中输入**\n\n```\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\n#### 2. 使用package control安装插件的一般方法\n\n同时按下：ctrl+shift+P\n\n然后选择：package:install\n\n在出来的输入框中输入需要安装的插件，例如：`emmet`\n\n### 三. 使用sublime安装react相关插件\n\n#### 1. babel\n\n**功能：**支持jsx语法高亮\n\n**安装：**在package control中查找babel\n\n**将某一种的文件扩展名添加为使用ES6语法：**\n\n- 打开`.js`或者`.jsx`文件\n- 选择`view ——> syntax ——> Open all with current extension as... ——> Babel ——> JavaScript (Babel)`\n\n\n#### 2. sublime-react\n\n**功能：**自动补全代码的react插件\n\n**安装：**在package control中查找ReactJS\n\n**使用：**输入简写的命令，按下`tab`键即可自动补全\n\n\n```\n   cdm→  componentDidMount: fn() { ... }\n   cdup→  componentDidUpdate: fn(pp, ps) { ... }\n   cs→  var cx = React.addons.classSet;\n   cwm→  componentWillMount: fn() { ... }\n   cwr→  componentWillReceiveProps: fn(np) { ... }\n   cwu→  componentWillUpdate: fn(np, ns) { ... }\n   cwun→  componentWillUnmount: fn() { ... }\n   cx→  cx({ ... })\n   fdn→  React.findDOMNode(...)\n   fup→  forceUpdate(...)\n   gdp→  getDefaultProps: fn() { return {...} } \n   gis→  getInitialState: fn() { return {...} } \n   ism→  isMounted()\n   props→  this.props.\n   pt→  propTypes { ... }\n   rcc→  component skeleton\n   refs→  this.refs.\n   ren→  render: fn() { return ... }\n   scu→  shouldComponentUpdate: fn(np, ns) { ... }\n   sst→  this.setState({ ... })\n   state→  this.state.\n```\n个人觉得使用这种代码自动补全的插件，虽然让我们开发变得更简便了，但是也有一些不好的方面。\n\n#### 3. Sass代码高亮sass\n\n**功能：**使sass代码也有高亮显示\n\n**安装：**在package control中查找sass\n\n\n#### 4. 将Sass编译成css —— sass build\n\n**功能：**将Sass编译成css代码\n\n**安装：**在package control中查找sass build\n\n**使用：**ctrl + B进行编译\n\n\n### 二. sublime插件之Sass自动编译成`.css`\n\nsublime的插件安装方法大同小异，都是将下载好的安装包放在`.../Data/Packages`文件夹里。\n\nsass自动编译插件下载地址：\n\n[https://github.com/jaumefontal/SASS-Build-SublimeText2](https://github.com/jaumefontal/SASS-Build-SublimeText2)\n\n**插件使用方法：**\n\n首先，将编译系统调成SASS\n\n\t点击 工具(T) ——> 编译系统(U) ——> SASS\n\n然后在.scss文件页面，使用`ctrl + B`\n\n### 三. sublime插件之`sublimeLinter`自动检测js语法错误\n\njs自动检测语法错误插件的下载地址：\n\n[https://github.com/SublimeLinter/SublimeLinter-for-ST2](https://github.com/SublimeLinter/SublimeLinter-for-ST2)\n\n**修改插件配置：**\n\n点击 首选项(N) ——> 插件设置 ——> sublimeLinter ——> setting-User 打开配置文件\n\n<font color=\"red\">参数配置中的各个参数的意思：</font>\n\n**运行模式**\n\n    \"sublimelinter\": \"save-only\"\n    \n    SublimeLinter 的运行模式，总共有四种，含义分别如下：    \n    - true 在用户输入时在后台进行即时校验；\n    - false 只有在初始化的时候才进行校验；\n    - \"load-save\" 当文件加载和保存的时候进行校验；\n    - \"save-only\" 当文件被保存的时候进行校验；\n    \n    推荐设置为 “save-only”，这样只在编写完代码，保存的时候才校验，Sublime Text 运行会更加流畅。\n\n\nsublime text3破解码\n\n\n\n安装package control\n\n打开控制台view ——> show console\n\n输入\n\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n\n\n\n\nbabel\n\n[https://github.com/babel/babel-sublime](https://github.com/babel/babel-sublime)\n\nsublime-React","slug":"2016-06-30-折腾sublime插件","published":1,"updated":"2016-09-05T08:27:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocj300ajd5u8n9f9l0sx","content":"<p>由于很多的react不支持sublime text2，只支持sublime text3，于是又重新下载了sublime text3，并安装了相关的插件。</p>\n<h3 id=\"一-安装并破解sublime-text3\"><a href=\"#一-安装并破解sublime-text3\" class=\"headerlink\" title=\"一. 安装并破解sublime text3\"></a>一. 安装并破解sublime text3</h3><p>直接在网上下载的sublime text3需要注册码</p>\n<p><strong>破解方法：</strong></p>\n<p>help ——&gt; Enter License</p>\n<p>然后输入从网上找来的破解码</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Michael Barnes</span><br><span class=\"line\">Single User License</span><br><span class=\"line\">EA7E-<span class=\"number\">821385</span></span><br><span class=\"line\"><span class=\"number\">8A353C41</span> <span class=\"number\">872</span>A0D5C DF9B2950 AFF6F667</span><br><span class=\"line\">C458EA6D <span class=\"number\">8</span>EA3C286 <span class=\"number\">98D1D650</span> <span class=\"number\">131</span>A97AB</span><br><span class=\"line\">AA919AEC EF20E143 B<span class=\"number\">361B1E7</span> <span class=\"number\">4C8B7F04</span></span><br><span class=\"line\">B085E65E <span class=\"number\">2F5F5360</span> <span class=\"number\">8489D422</span> FB8FC1AA</span><br><span class=\"line\"><span class=\"number\">93</span>F6323C FD7F7544 <span class=\"number\">3F39C318</span> D95E6480</span><br><span class=\"line\">FCCC7561 <span class=\"number\">8A4A1741</span> <span class=\"number\">68</span>FA4223 ADCEDE07</span><br><span class=\"line\"><span class=\"number\">200</span>C25BE DBBC4855 C4CFB774 C5EC138C</span><br><span class=\"line\"><span class=\"number\">0</span>FEC1CEF D9DCECEC D3A5DAD<span class=\"number\">1 01316C36</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-sublime安装插件\"><a href=\"#二-sublime安装插件\" class=\"headerlink\" title=\"二. sublime安装插件\"></a>二. sublime安装插件</h3><p><strong>Sublime安装插件有两种方式:</strong></p>\n<ul>\n<li>直接下载安装包解压缩到Packages目录</li>\n<li>通过Package Control组件来安装组件(更方便)</li>\n</ul>\n<p>一般使用第二种方法安装插件，方便快捷~~</p>\n<h4 id=\"1-安装package-control\"><a href=\"#1-安装package-control\" class=\"headerlink\" title=\"1. 安装package control\"></a>1. 安装package control</h4><p><strong>（1）打开控制台</strong></p>\n<p>view ——&gt; show console</p>\n<p><strong>（2）在控制台中输入</strong></p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = <span class=\"string\">'2915d1851351e5ee549c20394736b442'</span> + <span class=\"string\">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class=\"string\">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); <span class=\"keyword\">by</span> = urllib.request.urlopen( <span class=\"string\">'http://packagecontrol.io/'</span> + pf.<span class=\"built_in\">replace</span>(<span class=\"string\">' '</span>, <span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>(); dh = hashlib.sha256(<span class=\"keyword\">by</span>).hexdigest(); print(<span class=\"string\">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class=\"keyword\">if</span> dh != h <span class=\"keyword\">else</span> <span class=\"built_in\">open</span>(os.path.join( ipp, pf), <span class=\"string\">'wb'</span> ).<span class=\"built_in\">write</span>(<span class=\"keyword\">by</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用package-control安装插件的一般方法\"><a href=\"#2-使用package-control安装插件的一般方法\" class=\"headerlink\" title=\"2. 使用package control安装插件的一般方法\"></a>2. 使用package control安装插件的一般方法</h4><p>同时按下：ctrl+shift+P</p>\n<p>然后选择：package:install</p>\n<p>在出来的输入框中输入需要安装的插件，例如：<code>emmet</code></p>\n<h3 id=\"三-使用sublime安装react相关插件\"><a href=\"#三-使用sublime安装react相关插件\" class=\"headerlink\" title=\"三. 使用sublime安装react相关插件\"></a>三. 使用sublime安装react相关插件</h3><h4 id=\"1-babel\"><a href=\"#1-babel\" class=\"headerlink\" title=\"1. babel\"></a>1. babel</h4><p><strong>功能：</strong>支持jsx语法高亮</p>\n<p><strong>安装：</strong>在package control中查找babel</p>\n<p><strong>将某一种的文件扩展名添加为使用ES6语法：</strong></p>\n<ul>\n<li>打开<code>.js</code>或者<code>.jsx</code>文件</li>\n<li>选择<code>view ——&gt; syntax ——&gt; Open all with current extension as... ——&gt; Babel ——&gt; JavaScript (Babel)</code></li>\n</ul>\n<h4 id=\"2-sublime-react\"><a href=\"#2-sublime-react\" class=\"headerlink\" title=\"2. sublime-react\"></a>2. sublime-react</h4><p><strong>功能：</strong>自动补全代码的react插件</p>\n<p><strong>安装：</strong>在package control中查找ReactJS</p>\n<p><strong>使用：</strong>输入简写的命令，按下<code>tab</code>键即可自动补全</p>\n<figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cdm→  componentDidMount: fn() &#123; ... &#125;</span><br><span class=\"line\">cdup→  componentDidUpdate: fn(pp, ps) &#123; ... &#125;</span><br><span class=\"line\">cs→  <span class=\"keyword\">var</span> cx = <span class=\"type\">React</span>.addons.classSet;</span><br><span class=\"line\">cwm→  componentWillMount: fn() &#123; ... &#125;</span><br><span class=\"line\">cwr→  componentWillReceiveProps: fn(np) &#123; ... &#125;</span><br><span class=\"line\">cwu→  componentWillUpdate: fn(np, ns) &#123; ... &#125;</span><br><span class=\"line\">cwun→  componentWillUnmount: fn() &#123; ... &#125;</span><br><span class=\"line\">cx→  cx(&#123; ... &#125;)</span><br><span class=\"line\">fdn→  <span class=\"type\">React</span>.findDOMNode(...)</span><br><span class=\"line\">fup→  forceUpdate(...)</span><br><span class=\"line\">gdp→  getDefaultProps: fn() &#123; <span class=\"keyword\">return</span> <span class=\"meta\">&#123;...&#125;</span> &#125; </span><br><span class=\"line\">gis→  getInitialState: fn() &#123; <span class=\"keyword\">return</span> <span class=\"meta\">&#123;...&#125;</span> &#125; </span><br><span class=\"line\">ism→  isMounted()</span><br><span class=\"line\">props→  this.props.</span><br><span class=\"line\">pt→  propTypes &#123; ... &#125;</span><br><span class=\"line\">rcc→  component skeleton</span><br><span class=\"line\">refs→  this.refs.</span><br><span class=\"line\">ren→  render: fn() &#123; <span class=\"keyword\">return</span> ... &#125;</span><br><span class=\"line\">scu→  shouldComponentUpdate: fn(np, ns) &#123; ... &#125;</span><br><span class=\"line\">sst→  this.setState(&#123; ... &#125;)</span><br><span class=\"line\">state→  this.state.</span><br></pre></td></tr></table></figure>\n<p>个人觉得使用这种代码自动补全的插件，虽然让我们开发变得更简便了，但是也有一些不好的方面。</p>\n<h4 id=\"3-Sass代码高亮sass\"><a href=\"#3-Sass代码高亮sass\" class=\"headerlink\" title=\"3. Sass代码高亮sass\"></a>3. Sass代码高亮sass</h4><p><strong>功能：</strong>使sass代码也有高亮显示</p>\n<p><strong>安装：</strong>在package control中查找sass</p>\n<h4 id=\"4-将Sass编译成css-——-sass-build\"><a href=\"#4-将Sass编译成css-——-sass-build\" class=\"headerlink\" title=\"4. 将Sass编译成css —— sass build\"></a>4. 将Sass编译成css —— sass build</h4><p><strong>功能：</strong>将Sass编译成css代码</p>\n<p><strong>安装：</strong>在package control中查找sass build</p>\n<p><strong>使用：</strong>ctrl + B进行编译</p>\n<h3 id=\"二-sublime插件之Sass自动编译成-css\"><a href=\"#二-sublime插件之Sass自动编译成-css\" class=\"headerlink\" title=\"二. sublime插件之Sass自动编译成.css\"></a>二. sublime插件之Sass自动编译成<code>.css</code></h3><p>sublime的插件安装方法大同小异，都是将下载好的安装包放在<code>.../Data/Packages</code>文件夹里。</p>\n<p>sass自动编译插件下载地址：</p>\n<p><a href=\"https://github.com/jaumefontal/SASS-Build-SublimeText2\" target=\"_blank\" rel=\"external\">https://github.com/jaumefontal/SASS-Build-SublimeText2</a></p>\n<p><strong>插件使用方法：</strong></p>\n<p>首先，将编译系统调成SASS</p>\n<pre><code>点击 工具(T) ——&gt; 编译系统(U) ——&gt; SASS\n</code></pre><p>然后在.scss文件页面，使用<code>ctrl + B</code></p>\n<h3 id=\"三-sublime插件之sublimeLinter自动检测js语法错误\"><a href=\"#三-sublime插件之sublimeLinter自动检测js语法错误\" class=\"headerlink\" title=\"三. sublime插件之sublimeLinter自动检测js语法错误\"></a>三. sublime插件之<code>sublimeLinter</code>自动检测js语法错误</h3><p>js自动检测语法错误插件的下载地址：</p>\n<p><a href=\"https://github.com/SublimeLinter/SublimeLinter-for-ST2\" target=\"_blank\" rel=\"external\">https://github.com/SublimeLinter/SublimeLinter-for-ST2</a></p>\n<p><strong>修改插件配置：</strong></p>\n<p>点击 首选项(N) ——&gt; 插件设置 ——&gt; sublimeLinter ——&gt; setting-User 打开配置文件</p>\n<font color=\"red\">参数配置中的各个参数的意思：</font>\n\n<p><strong>运行模式</strong></p>\n<pre><code>&quot;sublimelinter&quot;: &quot;save-only&quot;\n\nSublimeLinter 的运行模式，总共有四种，含义分别如下：    \n- true 在用户输入时在后台进行即时校验；\n- false 只有在初始化的时候才进行校验；\n- &quot;load-save&quot; 当文件加载和保存的时候进行校验；\n- &quot;save-only&quot; 当文件被保存的时候进行校验；\n\n推荐设置为 “save-only”，这样只在编写完代码，保存的时候才校验，Sublime Text 运行会更加流畅。\n</code></pre><p>sublime text3破解码</p>\n<p>安装package control</p>\n<p>打开控制台view ——&gt; show console</p>\n<p>输入</p>\n<p>import urllib.request,os,hashlib; h = ‘2915d1851351e5ee549c20394736b442’ + ‘8bc59f460fa1548d1514676163dafc88’; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( ‘<a href=\"http://packagecontrol.io/\" target=\"_blank\" rel=\"external\">http://packagecontrol.io/</a>‘ + pf.replace(‘ ‘, ‘%20’)).read(); dh = hashlib.sha256(by).hexdigest(); print(‘Error validating download (got %s instead of %s), please try manual install’ % (dh, h)) if dh != h else open(os.path.join( ipp, pf), ‘wb’ ).write(by)</p>\n<p>babel</p>\n<p><a href=\"https://github.com/babel/babel-sublime\" target=\"_blank\" rel=\"external\">https://github.com/babel/babel-sublime</a></p>\n<p>sublime-React</p>\n","excerpt":"","more":"<p>由于很多的react不支持sublime text2，只支持sublime text3，于是又重新下载了sublime text3，并安装了相关的插件。</p>\n<h3 id=\"一-安装并破解sublime-text3\"><a href=\"#一-安装并破解sublime-text3\" class=\"headerlink\" title=\"一. 安装并破解sublime text3\"></a>一. 安装并破解sublime text3</h3><p>直接在网上下载的sublime text3需要注册码</p>\n<p><strong>破解方法：</strong></p>\n<p>help ——&gt; Enter License</p>\n<p>然后输入从网上找来的破解码</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Michael Barnes</span><br><span class=\"line\">Single User License</span><br><span class=\"line\">EA7E-<span class=\"number\">821385</span></span><br><span class=\"line\"><span class=\"number\">8A353C41</span> <span class=\"number\">872</span>A0D5C DF9B2950 AFF6F667</span><br><span class=\"line\">C458EA6D <span class=\"number\">8</span>EA3C286 <span class=\"number\">98D1D650</span> <span class=\"number\">131</span>A97AB</span><br><span class=\"line\">AA919AEC EF20E143 B<span class=\"number\">361B1E7</span> <span class=\"number\">4C8B7F04</span></span><br><span class=\"line\">B085E65E <span class=\"number\">2F5F5360</span> <span class=\"number\">8489D422</span> FB8FC1AA</span><br><span class=\"line\"><span class=\"number\">93</span>F6323C FD7F7544 <span class=\"number\">3F39C318</span> D95E6480</span><br><span class=\"line\">FCCC7561 <span class=\"number\">8A4A1741</span> <span class=\"number\">68</span>FA4223 ADCEDE07</span><br><span class=\"line\"><span class=\"number\">200</span>C25BE DBBC4855 C4CFB774 C5EC138C</span><br><span class=\"line\"><span class=\"number\">0</span>FEC1CEF D9DCECEC D3A5DAD<span class=\"number\">1 01316C36</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-sublime安装插件\"><a href=\"#二-sublime安装插件\" class=\"headerlink\" title=\"二. sublime安装插件\"></a>二. sublime安装插件</h3><p><strong>Sublime安装插件有两种方式:</strong></p>\n<ul>\n<li>直接下载安装包解压缩到Packages目录</li>\n<li>通过Package Control组件来安装组件(更方便)</li>\n</ul>\n<p>一般使用第二种方法安装插件，方便快捷~~</p>\n<h4 id=\"1-安装package-control\"><a href=\"#1-安装package-control\" class=\"headerlink\" title=\"1. 安装package control\"></a>1. 安装package control</h4><p><strong>（1）打开控制台</strong></p>\n<p>view ——&gt; show console</p>\n<p><strong>（2）在控制台中输入</strong></p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = <span class=\"string\">'2915d1851351e5ee549c20394736b442'</span> + <span class=\"string\">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class=\"string\">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); <span class=\"keyword\">by</span> = urllib.request.urlopen( <span class=\"string\">'http://packagecontrol.io/'</span> + pf.<span class=\"built_in\">replace</span>(<span class=\"string\">' '</span>, <span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>(); dh = hashlib.sha256(<span class=\"keyword\">by</span>).hexdigest(); print(<span class=\"string\">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class=\"keyword\">if</span> dh != h <span class=\"keyword\">else</span> <span class=\"built_in\">open</span>(os.path.join( ipp, pf), <span class=\"string\">'wb'</span> ).<span class=\"built_in\">write</span>(<span class=\"keyword\">by</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用package-control安装插件的一般方法\"><a href=\"#2-使用package-control安装插件的一般方法\" class=\"headerlink\" title=\"2. 使用package control安装插件的一般方法\"></a>2. 使用package control安装插件的一般方法</h4><p>同时按下：ctrl+shift+P</p>\n<p>然后选择：package:install</p>\n<p>在出来的输入框中输入需要安装的插件，例如：<code>emmet</code></p>\n<h3 id=\"三-使用sublime安装react相关插件\"><a href=\"#三-使用sublime安装react相关插件\" class=\"headerlink\" title=\"三. 使用sublime安装react相关插件\"></a>三. 使用sublime安装react相关插件</h3><h4 id=\"1-babel\"><a href=\"#1-babel\" class=\"headerlink\" title=\"1. babel\"></a>1. babel</h4><p><strong>功能：</strong>支持jsx语法高亮</p>\n<p><strong>安装：</strong>在package control中查找babel</p>\n<p><strong>将某一种的文件扩展名添加为使用ES6语法：</strong></p>\n<ul>\n<li>打开<code>.js</code>或者<code>.jsx</code>文件</li>\n<li>选择<code>view ——&gt; syntax ——&gt; Open all with current extension as... ——&gt; Babel ——&gt; JavaScript (Babel)</code></li>\n</ul>\n<h4 id=\"2-sublime-react\"><a href=\"#2-sublime-react\" class=\"headerlink\" title=\"2. sublime-react\"></a>2. sublime-react</h4><p><strong>功能：</strong>自动补全代码的react插件</p>\n<p><strong>安装：</strong>在package control中查找ReactJS</p>\n<p><strong>使用：</strong>输入简写的命令，按下<code>tab</code>键即可自动补全</p>\n<figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cdm→  componentDidMount: fn() &#123; ... &#125;</span><br><span class=\"line\">cdup→  componentDidUpdate: fn(pp, ps) &#123; ... &#125;</span><br><span class=\"line\">cs→  <span class=\"keyword\">var</span> cx = <span class=\"type\">React</span>.addons.classSet;</span><br><span class=\"line\">cwm→  componentWillMount: fn() &#123; ... &#125;</span><br><span class=\"line\">cwr→  componentWillReceiveProps: fn(np) &#123; ... &#125;</span><br><span class=\"line\">cwu→  componentWillUpdate: fn(np, ns) &#123; ... &#125;</span><br><span class=\"line\">cwun→  componentWillUnmount: fn() &#123; ... &#125;</span><br><span class=\"line\">cx→  cx(&#123; ... &#125;)</span><br><span class=\"line\">fdn→  <span class=\"type\">React</span>.findDOMNode(...)</span><br><span class=\"line\">fup→  forceUpdate(...)</span><br><span class=\"line\">gdp→  getDefaultProps: fn() &#123; <span class=\"keyword\">return</span> <span class=\"meta\">&#123;...&#125;</span> &#125; </span><br><span class=\"line\">gis→  getInitialState: fn() &#123; <span class=\"keyword\">return</span> <span class=\"meta\">&#123;...&#125;</span> &#125; </span><br><span class=\"line\">ism→  isMounted()</span><br><span class=\"line\">props→  this.props.</span><br><span class=\"line\">pt→  propTypes &#123; ... &#125;</span><br><span class=\"line\">rcc→  component skeleton</span><br><span class=\"line\">refs→  this.refs.</span><br><span class=\"line\">ren→  render: fn() &#123; <span class=\"keyword\">return</span> ... &#125;</span><br><span class=\"line\">scu→  shouldComponentUpdate: fn(np, ns) &#123; ... &#125;</span><br><span class=\"line\">sst→  this.setState(&#123; ... &#125;)</span><br><span class=\"line\">state→  this.state.</span><br></pre></td></tr></table></figure>\n<p>个人觉得使用这种代码自动补全的插件，虽然让我们开发变得更简便了，但是也有一些不好的方面。</p>\n<h4 id=\"3-Sass代码高亮sass\"><a href=\"#3-Sass代码高亮sass\" class=\"headerlink\" title=\"3. Sass代码高亮sass\"></a>3. Sass代码高亮sass</h4><p><strong>功能：</strong>使sass代码也有高亮显示</p>\n<p><strong>安装：</strong>在package control中查找sass</p>\n<h4 id=\"4-将Sass编译成css-——-sass-build\"><a href=\"#4-将Sass编译成css-——-sass-build\" class=\"headerlink\" title=\"4. 将Sass编译成css —— sass build\"></a>4. 将Sass编译成css —— sass build</h4><p><strong>功能：</strong>将Sass编译成css代码</p>\n<p><strong>安装：</strong>在package control中查找sass build</p>\n<p><strong>使用：</strong>ctrl + B进行编译</p>\n<h3 id=\"二-sublime插件之Sass自动编译成-css\"><a href=\"#二-sublime插件之Sass自动编译成-css\" class=\"headerlink\" title=\"二. sublime插件之Sass自动编译成.css\"></a>二. sublime插件之Sass自动编译成<code>.css</code></h3><p>sublime的插件安装方法大同小异，都是将下载好的安装包放在<code>.../Data/Packages</code>文件夹里。</p>\n<p>sass自动编译插件下载地址：</p>\n<p><a href=\"https://github.com/jaumefontal/SASS-Build-SublimeText2\">https://github.com/jaumefontal/SASS-Build-SublimeText2</a></p>\n<p><strong>插件使用方法：</strong></p>\n<p>首先，将编译系统调成SASS</p>\n<pre><code>点击 工具(T) ——&gt; 编译系统(U) ——&gt; SASS\n</code></pre><p>然后在.scss文件页面，使用<code>ctrl + B</code></p>\n<h3 id=\"三-sublime插件之sublimeLinter自动检测js语法错误\"><a href=\"#三-sublime插件之sublimeLinter自动检测js语法错误\" class=\"headerlink\" title=\"三. sublime插件之sublimeLinter自动检测js语法错误\"></a>三. sublime插件之<code>sublimeLinter</code>自动检测js语法错误</h3><p>js自动检测语法错误插件的下载地址：</p>\n<p><a href=\"https://github.com/SublimeLinter/SublimeLinter-for-ST2\">https://github.com/SublimeLinter/SublimeLinter-for-ST2</a></p>\n<p><strong>修改插件配置：</strong></p>\n<p>点击 首选项(N) ——&gt; 插件设置 ——&gt; sublimeLinter ——&gt; setting-User 打开配置文件</p>\n<font color=\"red\">参数配置中的各个参数的意思：</font>\n\n<p><strong>运行模式</strong></p>\n<pre><code>&quot;sublimelinter&quot;: &quot;save-only&quot;\n\nSublimeLinter 的运行模式，总共有四种，含义分别如下：    \n- true 在用户输入时在后台进行即时校验；\n- false 只有在初始化的时候才进行校验；\n- &quot;load-save&quot; 当文件加载和保存的时候进行校验；\n- &quot;save-only&quot; 当文件被保存的时候进行校验；\n\n推荐设置为 “save-only”，这样只在编写完代码，保存的时候才校验，Sublime Text 运行会更加流畅。\n</code></pre><p>sublime text3破解码</p>\n<p>安装package control</p>\n<p>打开控制台view ——&gt; show console</p>\n<p>输入</p>\n<p>import urllib.request,os,hashlib; h = ‘2915d1851351e5ee549c20394736b442’ + ‘8bc59f460fa1548d1514676163dafc88’; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( ‘<a href=\"http://packagecontrol.io/\">http://packagecontrol.io/</a>‘ + pf.replace(‘ ‘, ‘%20’)).read(); dh = hashlib.sha256(by).hexdigest(); print(‘Error validating download (got %s instead of %s), please try manual install’ % (dh, h)) if dh != h else open(os.path.join( ipp, pf), ‘wb’ ).write(by)</p>\n<p>babel</p>\n<p><a href=\"https://github.com/babel/babel-sublime\">https://github.com/babel/babel-sublime</a></p>\n<p>sublime-React</p>\n"},{"layout":"post","title":"实现工具栏——学习使用Sass和requireJS","date":"2016-07-02T16:00:00.000Z","description":null,"_content":"\n之前看过一些sass和模块化编程的知识，现在想通过这个小功能来运用一下。\n\n### 一. 工具栏\n\n工具栏demo地址：\n\n[http://panpanfish.com/myDemo/toolbar/toolbar2.html](http://panpanfish.com/myDemo/toolbar/toolbar2.html)\n\n工具栏代码地址：\n\n[https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar](https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar)\n\n\n### 二. HTML和css部分\n\n实现常见的工具栏有两种方式：\n\n- 使用背景图片，然后再使用css sprite技术进行定位\n- 使用图标字体\n\n#### 1. 两种方法的优缺点\n\n<font color=\"red\">使用背景图片 + css sprite的方式</font>\n\n**优点：**\n\n- HTML结构简单\n- 兼容性良好\n\n**缺点：**\n- 使用了大量的图片，对性能有一定的影响\n- 有一个最大的缺点就是，当你需要修改一些样式时，需要对图片进行修改，这样就会非常麻烦\n\ncss sprite主要是利用`background-image`，`background-position`\n\n<font color=\"red\">使用图标字体的方式</font>\n\n**优点：**\n\n避免了图片的使用，节约了性能，并且修改方便\n\n**缺点：**\n\nHTML结构复杂了一些\n不兼容IE6和IE7\n\n综上所述，还是使用图标字体的方式更好。\n\n#### 2. 获取免费的图标的方式\n\n下列网站上提供了很多免费的图标\n\n[https://icomoon.io/app/#/select](https://icomoon.io/app/#/select)\n\n(1) 选中自己需要的图标，点击右下角的`Generate Font`\n\n(2) 然后将生成的图标下载下来（点击右下角的`Download`）\n\n(3) 下载好的文件夹解压，解压后有用的文件只有\n\n- fonts文件夹\n- style.css文件\n\n将上述文件放在项目的`css文件夹`里，然后将`style.css`里的代码放在自己的`css文件`里，并在`html`页面的图标标签里引用相应的样式即可。\n\n#### 3. 使用sass来写css\n\n第一次使用sass来写css，感觉确实很方便。\n\n这里使用了sass的变量，混合器，嵌套，导入其他scss文件这几个功能。\n\n**写scss时需要注意：**\n\n- 运算符两边需要空格\n- 在导入其他的scss文件时，可以不写命名前的下划线和后缀\n\n#### 4. 这里的很多动画效果是利用才css3里面的属性完成的\n\n**(1) transition属性**\n\n修改图标的top值来改变显示，同时使用transition来平滑过渡\n\n**(2) transform属性**\n\n使用transform：scale()来改变图片的大小，同时使用transition来平滑过渡\n\n改变转换的基准点可以使用属性`transform-origin`\n\n这里需要注意不同浏览器之间的兼容性，这里利用了sass里面的@mixin。\n\n### 三. js部分\n\n这个工具栏需要用js来实现的功能就只有，第四个图标的返回顶部的功能。\n\n虽然这只是一个很小的插件，但是为了学习使用requireJS，这里还是用了requireJS。\n\n#### 1. requireJS的使用\n\n(1) 首先需要在requireJS的官网上下载require.js放入js文件夹中\n\nrequireJS中文官网：[http://www.requirejs.cn/](http://www.requirejs.cn/)\n\n(2) 然后再html里面引入reuqire.js，并指明入口文件\n\n    <script src=\"js/require.js\" data-main=\"js/toolbar.js\"></script>\n\n(3) toolbar.js里面的内容\n\n```js\n\trequirejs([\"base\",\"common_backTop\"], function(GLOBAL, backTop) {\n\t\tvar topDiv = GLOBAL.Dom.$(\"backTop\");\n\t\tconsole.log(topDiv);\n\t\tvar top = new backTop.BackTop(topDiv, {\n\t\t\tmode: \"move\",\n\t\t\tdes: 0,\n\t\t\tmoveTime: 100\n\t\t});\n\t});\n```\n\n表明引入了两个模块，一个是js的基础模块`base.js`；另外一个是实现回到顶部功能的`common_backTop.js`。\n\n(4) common_backTop.js模块的定义\n\n```js\ndefine([\"base\"], function(GLOBAL){\n\tvar BackTop = function(ele, config) {\n\t\tthis.ele = ele;\n\t\tthis.config = config;\n\t\tvar that = this;\n\t\tif(this.config.mode == \"move\") {\n\t\t\tGLOBAL.Eve.addEvent(this.ele, \"click\", function() {\n\t\t\t\tthat.move();\n\t\t\t});\n\t\t} else {\n\t\t\tGLOBAL.Eve.addEvent(this.ele, \"click\", function() {\n\t\t\t\tthat.go();\n\t\t\t});\n\t\t}\t\t\n\t\tthis.checkPos();\n\t}\n\n\tBackTop.prototype = {\n\t\tconstructor: BackTop,\n\n\t\tmove: function() {\t\n\t\t\tvar that = this.config;\t\n\t\t\tfunction scroll(){\n\t\t\t\tvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t\tif(scrollTop > that.des) {\n\t\t\t\t\tscrollTop -= 100;\n\t\t\t\t\tif(document.documentElement.scrollTop) {\n\t\t\t\t\t\tdocument.documentElement.scrollTop = scrollTop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdocument.body.scrollTop = scrollTop;\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(scroll, that.moveTime);\n\t\t\t\t} else if(scrollTop < that.des) {\n\t\t\t\t\tscrollTop += 100;\n\t\t\t\t\tif(document.documentElement.scrollTop) {\n\t\t\t\t\t\tdocument.documentElement.scrollTop = scrollTop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdocument.body.scrollTop = scrollTop;\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(scroll, that.moveTime);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tscroll();\n\t\t},\n\n\t\tgo: function() {\n\t\t\tif(document.documentElement.scrollTop) {\n\t\t\t\tdocument.documentElement.scrollTop = this.config.des;\n\t\t\t} else {\n\t\t\t\tconsole.log(this.config);\n\t\t\t\tdocument.body.scrollTop = this.config.des;\t\t\t\n\t\t\t}\n\t\t},\n\n\t\tcheckPos: function() {\n\t\t\tvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\tif(scrollTop < document.body.clientHeight) {\n\t\t\t\tthis.ele.style.display = \"block\";\n\t\t\t} else {\n\t\t\t\tthis.ele.style.display = \"none\";\n\t\t\t}\n\t\t},\n\t}\n\n\treturn {\n\t\tBackTop: BackTop\n\t}\n});\n```","source":"_posts/2016-07-01-实现侧边栏——学习使用sass和requireJS.md","raw":"---\nlayout: post\ntitle: 实现工具栏——学习使用Sass和requireJS\ndate: 2016-07-03\ncategories: Demo\ntags: [模块化,Sass]\ndescription: \n---\n\n之前看过一些sass和模块化编程的知识，现在想通过这个小功能来运用一下。\n\n### 一. 工具栏\n\n工具栏demo地址：\n\n[http://panpanfish.com/myDemo/toolbar/toolbar2.html](http://panpanfish.com/myDemo/toolbar/toolbar2.html)\n\n工具栏代码地址：\n\n[https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar](https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar)\n\n\n### 二. HTML和css部分\n\n实现常见的工具栏有两种方式：\n\n- 使用背景图片，然后再使用css sprite技术进行定位\n- 使用图标字体\n\n#### 1. 两种方法的优缺点\n\n<font color=\"red\">使用背景图片 + css sprite的方式</font>\n\n**优点：**\n\n- HTML结构简单\n- 兼容性良好\n\n**缺点：**\n- 使用了大量的图片，对性能有一定的影响\n- 有一个最大的缺点就是，当你需要修改一些样式时，需要对图片进行修改，这样就会非常麻烦\n\ncss sprite主要是利用`background-image`，`background-position`\n\n<font color=\"red\">使用图标字体的方式</font>\n\n**优点：**\n\n避免了图片的使用，节约了性能，并且修改方便\n\n**缺点：**\n\nHTML结构复杂了一些\n不兼容IE6和IE7\n\n综上所述，还是使用图标字体的方式更好。\n\n#### 2. 获取免费的图标的方式\n\n下列网站上提供了很多免费的图标\n\n[https://icomoon.io/app/#/select](https://icomoon.io/app/#/select)\n\n(1) 选中自己需要的图标，点击右下角的`Generate Font`\n\n(2) 然后将生成的图标下载下来（点击右下角的`Download`）\n\n(3) 下载好的文件夹解压，解压后有用的文件只有\n\n- fonts文件夹\n- style.css文件\n\n将上述文件放在项目的`css文件夹`里，然后将`style.css`里的代码放在自己的`css文件`里，并在`html`页面的图标标签里引用相应的样式即可。\n\n#### 3. 使用sass来写css\n\n第一次使用sass来写css，感觉确实很方便。\n\n这里使用了sass的变量，混合器，嵌套，导入其他scss文件这几个功能。\n\n**写scss时需要注意：**\n\n- 运算符两边需要空格\n- 在导入其他的scss文件时，可以不写命名前的下划线和后缀\n\n#### 4. 这里的很多动画效果是利用才css3里面的属性完成的\n\n**(1) transition属性**\n\n修改图标的top值来改变显示，同时使用transition来平滑过渡\n\n**(2) transform属性**\n\n使用transform：scale()来改变图片的大小，同时使用transition来平滑过渡\n\n改变转换的基准点可以使用属性`transform-origin`\n\n这里需要注意不同浏览器之间的兼容性，这里利用了sass里面的@mixin。\n\n### 三. js部分\n\n这个工具栏需要用js来实现的功能就只有，第四个图标的返回顶部的功能。\n\n虽然这只是一个很小的插件，但是为了学习使用requireJS，这里还是用了requireJS。\n\n#### 1. requireJS的使用\n\n(1) 首先需要在requireJS的官网上下载require.js放入js文件夹中\n\nrequireJS中文官网：[http://www.requirejs.cn/](http://www.requirejs.cn/)\n\n(2) 然后再html里面引入reuqire.js，并指明入口文件\n\n    <script src=\"js/require.js\" data-main=\"js/toolbar.js\"></script>\n\n(3) toolbar.js里面的内容\n\n```js\n\trequirejs([\"base\",\"common_backTop\"], function(GLOBAL, backTop) {\n\t\tvar topDiv = GLOBAL.Dom.$(\"backTop\");\n\t\tconsole.log(topDiv);\n\t\tvar top = new backTop.BackTop(topDiv, {\n\t\t\tmode: \"move\",\n\t\t\tdes: 0,\n\t\t\tmoveTime: 100\n\t\t});\n\t});\n```\n\n表明引入了两个模块，一个是js的基础模块`base.js`；另外一个是实现回到顶部功能的`common_backTop.js`。\n\n(4) common_backTop.js模块的定义\n\n```js\ndefine([\"base\"], function(GLOBAL){\n\tvar BackTop = function(ele, config) {\n\t\tthis.ele = ele;\n\t\tthis.config = config;\n\t\tvar that = this;\n\t\tif(this.config.mode == \"move\") {\n\t\t\tGLOBAL.Eve.addEvent(this.ele, \"click\", function() {\n\t\t\t\tthat.move();\n\t\t\t});\n\t\t} else {\n\t\t\tGLOBAL.Eve.addEvent(this.ele, \"click\", function() {\n\t\t\t\tthat.go();\n\t\t\t});\n\t\t}\t\t\n\t\tthis.checkPos();\n\t}\n\n\tBackTop.prototype = {\n\t\tconstructor: BackTop,\n\n\t\tmove: function() {\t\n\t\t\tvar that = this.config;\t\n\t\t\tfunction scroll(){\n\t\t\t\tvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t\tif(scrollTop > that.des) {\n\t\t\t\t\tscrollTop -= 100;\n\t\t\t\t\tif(document.documentElement.scrollTop) {\n\t\t\t\t\t\tdocument.documentElement.scrollTop = scrollTop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdocument.body.scrollTop = scrollTop;\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(scroll, that.moveTime);\n\t\t\t\t} else if(scrollTop < that.des) {\n\t\t\t\t\tscrollTop += 100;\n\t\t\t\t\tif(document.documentElement.scrollTop) {\n\t\t\t\t\t\tdocument.documentElement.scrollTop = scrollTop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdocument.body.scrollTop = scrollTop;\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(scroll, that.moveTime);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tscroll();\n\t\t},\n\n\t\tgo: function() {\n\t\t\tif(document.documentElement.scrollTop) {\n\t\t\t\tdocument.documentElement.scrollTop = this.config.des;\n\t\t\t} else {\n\t\t\t\tconsole.log(this.config);\n\t\t\t\tdocument.body.scrollTop = this.config.des;\t\t\t\n\t\t\t}\n\t\t},\n\n\t\tcheckPos: function() {\n\t\t\tvar scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\tif(scrollTop < document.body.clientHeight) {\n\t\t\t\tthis.ele.style.display = \"block\";\n\t\t\t} else {\n\t\t\t\tthis.ele.style.display = \"none\";\n\t\t\t}\n\t\t},\n\t}\n\n\treturn {\n\t\tBackTop: BackTop\n\t}\n});\n```","slug":"2016-07-01-实现侧边栏——学习使用sass和requireJS","published":1,"updated":"2016-07-03T13:43:50.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocj400and5u8rs0naohg","content":"<p>之前看过一些sass和模块化编程的知识，现在想通过这个小功能来运用一下。</p>\n<h3 id=\"一-工具栏\"><a href=\"#一-工具栏\" class=\"headerlink\" title=\"一. 工具栏\"></a>一. 工具栏</h3><p>工具栏demo地址：</p>\n<p><a href=\"http://panpanfish.com/myDemo/toolbar/toolbar2.html\">http://panpanfish.com/myDemo/toolbar/toolbar2.html</a></p>\n<p>工具栏代码地址：</p>\n<p><a href=\"https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar</a></p>\n<h3 id=\"二-HTML和css部分\"><a href=\"#二-HTML和css部分\" class=\"headerlink\" title=\"二. HTML和css部分\"></a>二. HTML和css部分</h3><p>实现常见的工具栏有两种方式：</p>\n<ul>\n<li>使用背景图片，然后再使用css sprite技术进行定位</li>\n<li>使用图标字体</li>\n</ul>\n<h4 id=\"1-两种方法的优缺点\"><a href=\"#1-两种方法的优缺点\" class=\"headerlink\" title=\"1. 两种方法的优缺点\"></a>1. 两种方法的优缺点</h4><font color=\"red\">使用背景图片 + css sprite的方式</font>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>HTML结构简单</li>\n<li>兼容性良好</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>使用了大量的图片，对性能有一定的影响</li>\n<li>有一个最大的缺点就是，当你需要修改一些样式时，需要对图片进行修改，这样就会非常麻烦</li>\n</ul>\n<p>css sprite主要是利用<code>background-image</code>，<code>background-position</code></p>\n<font color=\"red\">使用图标字体的方式</font>\n\n<p><strong>优点：</strong></p>\n<p>避免了图片的使用，节约了性能，并且修改方便</p>\n<p><strong>缺点：</strong></p>\n<p>HTML结构复杂了一些<br>不兼容IE6和IE7</p>\n<p>综上所述，还是使用图标字体的方式更好。</p>\n<h4 id=\"2-获取免费的图标的方式\"><a href=\"#2-获取免费的图标的方式\" class=\"headerlink\" title=\"2. 获取免费的图标的方式\"></a>2. 获取免费的图标的方式</h4><p>下列网站上提供了很多免费的图标</p>\n<p><a href=\"https://icomoon.io/app/#/select\" target=\"_blank\" rel=\"external\">https://icomoon.io/app/#/select</a></p>\n<p>(1) 选中自己需要的图标，点击右下角的<code>Generate Font</code></p>\n<p>(2) 然后将生成的图标下载下来（点击右下角的<code>Download</code>）</p>\n<p>(3) 下载好的文件夹解压，解压后有用的文件只有</p>\n<ul>\n<li>fonts文件夹</li>\n<li>style.css文件</li>\n</ul>\n<p>将上述文件放在项目的<code>css文件夹</code>里，然后将<code>style.css</code>里的代码放在自己的<code>css文件</code>里，并在<code>html</code>页面的图标标签里引用相应的样式即可。</p>\n<h4 id=\"3-使用sass来写css\"><a href=\"#3-使用sass来写css\" class=\"headerlink\" title=\"3. 使用sass来写css\"></a>3. 使用sass来写css</h4><p>第一次使用sass来写css，感觉确实很方便。</p>\n<p>这里使用了sass的变量，混合器，嵌套，导入其他scss文件这几个功能。</p>\n<p><strong>写scss时需要注意：</strong></p>\n<ul>\n<li>运算符两边需要空格</li>\n<li>在导入其他的scss文件时，可以不写命名前的下划线和后缀</li>\n</ul>\n<h4 id=\"4-这里的很多动画效果是利用才css3里面的属性完成的\"><a href=\"#4-这里的很多动画效果是利用才css3里面的属性完成的\" class=\"headerlink\" title=\"4. 这里的很多动画效果是利用才css3里面的属性完成的\"></a>4. 这里的很多动画效果是利用才css3里面的属性完成的</h4><p><strong>(1) transition属性</strong></p>\n<p>修改图标的top值来改变显示，同时使用transition来平滑过渡</p>\n<p><strong>(2) transform属性</strong></p>\n<p>使用transform：scale()来改变图片的大小，同时使用transition来平滑过渡</p>\n<p>改变转换的基准点可以使用属性<code>transform-origin</code></p>\n<p>这里需要注意不同浏览器之间的兼容性，这里利用了sass里面的@mixin。</p>\n<h3 id=\"三-js部分\"><a href=\"#三-js部分\" class=\"headerlink\" title=\"三. js部分\"></a>三. js部分</h3><p>这个工具栏需要用js来实现的功能就只有，第四个图标的返回顶部的功能。</p>\n<p>虽然这只是一个很小的插件，但是为了学习使用requireJS，这里还是用了requireJS。</p>\n<h4 id=\"1-requireJS的使用\"><a href=\"#1-requireJS的使用\" class=\"headerlink\" title=\"1. requireJS的使用\"></a>1. requireJS的使用</h4><p>(1) 首先需要在requireJS的官网上下载require.js放入js文件夹中</p>\n<p>requireJS中文官网：<a href=\"http://www.requirejs.cn/\" target=\"_blank\" rel=\"external\">http://www.requirejs.cn/</a></p>\n<p>(2) 然后再html里面引入reuqire.js，并指明入口文件</p>\n<pre><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/toolbar.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>(3) toolbar.js里面的内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requirejs([<span class=\"string\">\"base\"</span>,<span class=\"string\">\"common_backTop\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">GLOBAL, backTop</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> topDiv = GLOBAL.Dom.$(<span class=\"string\">\"backTop\"</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(topDiv);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> top = <span class=\"keyword\">new</span> backTop.BackTop(topDiv, &#123;</span><br><span class=\"line\">\t\tmode: <span class=\"string\">\"move\"</span>,</span><br><span class=\"line\">\t\tdes: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\tmoveTime: <span class=\"number\">100</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>表明引入了两个模块，一个是js的基础模块<code>base.js</code>；另外一个是实现回到顶部功能的<code>common_backTop.js</code>。</p>\n<p>(4) common_backTop.js模块的定义</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">\"base\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">GLOBAL</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> BackTop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, config</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.ele = ele;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.config.mode == <span class=\"string\">\"move\"</span>) &#123;</span><br><span class=\"line\">\t\t\tGLOBAL.Eve.addEvent(<span class=\"keyword\">this</span>.ele, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tthat.move();</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tGLOBAL.Eve.addEvent(<span class=\"keyword\">this</span>.ele, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tthat.go();</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.checkPos();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBackTop.prototype = &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">constructor</span>: BackTop,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmove: function() &#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>.config;\t</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scroll</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(scrollTop &gt; that.des) &#123;</span><br><span class=\"line\">\t\t\t\t\tscrollTop -= <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.scrollTop) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.body.scrollTop = scrollTop;\t\t\t</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tsetTimeout(scroll, that.moveTime);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(scrollTop &lt; that.des) &#123;</span><br><span class=\"line\">\t\t\t\t\tscrollTop += <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.scrollTop) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.body.scrollTop = scrollTop;\t\t\t</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tsetTimeout(scroll, that.moveTime);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tscroll();</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.scrollTop) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">document</span>.documentElement.scrollTop = <span class=\"keyword\">this</span>.config.des;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.config);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">document</span>.body.scrollTop = <span class=\"keyword\">this</span>.config.des;\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcheckPos: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(scrollTop &lt; <span class=\"built_in\">document</span>.body.clientHeight) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.ele.style.display = <span class=\"string\">\"block\"</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.ele.style.display = <span class=\"string\">\"none\"</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tBackTop: BackTop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>之前看过一些sass和模块化编程的知识，现在想通过这个小功能来运用一下。</p>\n<h3 id=\"一-工具栏\"><a href=\"#一-工具栏\" class=\"headerlink\" title=\"一. 工具栏\"></a>一. 工具栏</h3><p>工具栏demo地址：</p>\n<p><a href=\"http://panpanfish.com/myDemo/toolbar/toolbar2.html\">http://panpanfish.com/myDemo/toolbar/toolbar2.html</a></p>\n<p>工具栏代码地址：</p>\n<p><a href=\"https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar\">https://github.com/panpan040828/myDemo/tree/gh-pages/toolbar</a></p>\n<h3 id=\"二-HTML和css部分\"><a href=\"#二-HTML和css部分\" class=\"headerlink\" title=\"二. HTML和css部分\"></a>二. HTML和css部分</h3><p>实现常见的工具栏有两种方式：</p>\n<ul>\n<li>使用背景图片，然后再使用css sprite技术进行定位</li>\n<li>使用图标字体</li>\n</ul>\n<h4 id=\"1-两种方法的优缺点\"><a href=\"#1-两种方法的优缺点\" class=\"headerlink\" title=\"1. 两种方法的优缺点\"></a>1. 两种方法的优缺点</h4><font color=\"red\">使用背景图片 + css sprite的方式</font>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>HTML结构简单</li>\n<li>兼容性良好</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>使用了大量的图片，对性能有一定的影响</li>\n<li>有一个最大的缺点就是，当你需要修改一些样式时，需要对图片进行修改，这样就会非常麻烦</li>\n</ul>\n<p>css sprite主要是利用<code>background-image</code>，<code>background-position</code></p>\n<font color=\"red\">使用图标字体的方式</font>\n\n<p><strong>优点：</strong></p>\n<p>避免了图片的使用，节约了性能，并且修改方便</p>\n<p><strong>缺点：</strong></p>\n<p>HTML结构复杂了一些<br>不兼容IE6和IE7</p>\n<p>综上所述，还是使用图标字体的方式更好。</p>\n<h4 id=\"2-获取免费的图标的方式\"><a href=\"#2-获取免费的图标的方式\" class=\"headerlink\" title=\"2. 获取免费的图标的方式\"></a>2. 获取免费的图标的方式</h4><p>下列网站上提供了很多免费的图标</p>\n<p><a href=\"https://icomoon.io/app/#/select\">https://icomoon.io/app/#/select</a></p>\n<p>(1) 选中自己需要的图标，点击右下角的<code>Generate Font</code></p>\n<p>(2) 然后将生成的图标下载下来（点击右下角的<code>Download</code>）</p>\n<p>(3) 下载好的文件夹解压，解压后有用的文件只有</p>\n<ul>\n<li>fonts文件夹</li>\n<li>style.css文件</li>\n</ul>\n<p>将上述文件放在项目的<code>css文件夹</code>里，然后将<code>style.css</code>里的代码放在自己的<code>css文件</code>里，并在<code>html</code>页面的图标标签里引用相应的样式即可。</p>\n<h4 id=\"3-使用sass来写css\"><a href=\"#3-使用sass来写css\" class=\"headerlink\" title=\"3. 使用sass来写css\"></a>3. 使用sass来写css</h4><p>第一次使用sass来写css，感觉确实很方便。</p>\n<p>这里使用了sass的变量，混合器，嵌套，导入其他scss文件这几个功能。</p>\n<p><strong>写scss时需要注意：</strong></p>\n<ul>\n<li>运算符两边需要空格</li>\n<li>在导入其他的scss文件时，可以不写命名前的下划线和后缀</li>\n</ul>\n<h4 id=\"4-这里的很多动画效果是利用才css3里面的属性完成的\"><a href=\"#4-这里的很多动画效果是利用才css3里面的属性完成的\" class=\"headerlink\" title=\"4. 这里的很多动画效果是利用才css3里面的属性完成的\"></a>4. 这里的很多动画效果是利用才css3里面的属性完成的</h4><p><strong>(1) transition属性</strong></p>\n<p>修改图标的top值来改变显示，同时使用transition来平滑过渡</p>\n<p><strong>(2) transform属性</strong></p>\n<p>使用transform：scale()来改变图片的大小，同时使用transition来平滑过渡</p>\n<p>改变转换的基准点可以使用属性<code>transform-origin</code></p>\n<p>这里需要注意不同浏览器之间的兼容性，这里利用了sass里面的@mixin。</p>\n<h3 id=\"三-js部分\"><a href=\"#三-js部分\" class=\"headerlink\" title=\"三. js部分\"></a>三. js部分</h3><p>这个工具栏需要用js来实现的功能就只有，第四个图标的返回顶部的功能。</p>\n<p>虽然这只是一个很小的插件，但是为了学习使用requireJS，这里还是用了requireJS。</p>\n<h4 id=\"1-requireJS的使用\"><a href=\"#1-requireJS的使用\" class=\"headerlink\" title=\"1. requireJS的使用\"></a>1. requireJS的使用</h4><p>(1) 首先需要在requireJS的官网上下载require.js放入js文件夹中</p>\n<p>requireJS中文官网：<a href=\"http://www.requirejs.cn/\">http://www.requirejs.cn/</a></p>\n<p>(2) 然后再html里面引入reuqire.js，并指明入口文件</p>\n<pre><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/toolbar.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>(3) toolbar.js里面的内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requirejs([<span class=\"string\">\"base\"</span>,<span class=\"string\">\"common_backTop\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">GLOBAL, backTop</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> topDiv = GLOBAL.Dom.$(<span class=\"string\">\"backTop\"</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(topDiv);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> top = <span class=\"keyword\">new</span> backTop.BackTop(topDiv, &#123;</span><br><span class=\"line\">\t\tmode: <span class=\"string\">\"move\"</span>,</span><br><span class=\"line\">\t\tdes: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\tmoveTime: <span class=\"number\">100</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>表明引入了两个模块，一个是js的基础模块<code>base.js</code>；另外一个是实现回到顶部功能的<code>common_backTop.js</code>。</p>\n<p>(4) common_backTop.js模块的定义</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">\"base\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">GLOBAL</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> BackTop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, config</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.ele = ele;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.config.mode == <span class=\"string\">\"move\"</span>) &#123;</span><br><span class=\"line\">\t\t\tGLOBAL.Eve.addEvent(<span class=\"keyword\">this</span>.ele, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tthat.move();</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tGLOBAL.Eve.addEvent(<span class=\"keyword\">this</span>.ele, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tthat.go();</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.checkPos();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBackTop.prototype = &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">constructor</span>: BackTop,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmove: function() &#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>.config;\t</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scroll</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(scrollTop &gt; that.des) &#123;</span><br><span class=\"line\">\t\t\t\t\tscrollTop -= <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.scrollTop) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.body.scrollTop = scrollTop;\t\t\t</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tsetTimeout(scroll, that.moveTime);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(scrollTop &lt; that.des) &#123;</span><br><span class=\"line\">\t\t\t\t\tscrollTop += <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.scrollTop) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.body.scrollTop = scrollTop;\t\t\t</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tsetTimeout(scroll, that.moveTime);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tscroll();</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.scrollTop) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">document</span>.documentElement.scrollTop = <span class=\"keyword\">this</span>.config.des;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.config);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">document</span>.body.scrollTop = <span class=\"keyword\">this</span>.config.des;\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcheckPos: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(scrollTop &lt; <span class=\"built_in\">document</span>.body.clientHeight) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.ele.style.display = <span class=\"string\">\"block\"</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.ele.style.display = <span class=\"string\">\"none\"</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tBackTop: BackTop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"js中的错误处理与调试","date":"2016-07-05T16:00:00.000Z","description":null,"_content":"### 一. 错误类型\n\n- Error\n- EvalError\n- RangeError\n- ReferenceError\n- SyntaxError\n- TypeError\n- URIError\n\n#### 1. Error\n\n错误的基类型，所有错误继承自这个错误，编程中一般不会出现这个错误。\n\n#### 2. EvalError——使用eval()错误\n\n当没有把eval()当成函数调用时，会抛出这个错误。\n\n#### 3. RangeError——超出范围错误\n\n    eg：使用了数组不支持的项数。\n    var arr = new Array(-20);\n\n#### 4. ReferenceError——引用错误\n\n访问不存在的变量时会出现。\n\n#### 5. SyntaxError——语法错误\n\n当我们把有语法错误的字符串传到eval()函数里面时，会出现这个错误。\n\n#### 6. TypeError——类型错误\n\n当访问不存在的方法，或者传入函数的参数类型与预期不符合，会提示这个错误。\n\n#### 7. URLError——URL格式错误\n\n使用encodeURL()和decodeURL()，URL格式不正确时会出现这个错误。\n\n### 一. 错误处理机制\n\n#### 1. 捕获错误——try...catch\n\n**try...catch**\n\n```js\ntry {\n\t//可能会导致错误的代码\n} catch(error) {\n\t//发生错误时，应该怎么处理\n}\n```\n\n对于不同浏览器而言，这里的error对象包含不同的属性，但是**所有浏览器都有一个相同的属性**：\n\n\terror.message:浏览器给出的错误消息    \n\n**try...catch...finally**\n\n```js\ntry {\n\treturn 0;\t\n} catch(error) {\n\treturn 1;\n} finally {\n\treturn 2;\n}\n```\n\n<font color=\"red\">注意：**finally**语句块中的语句会覆盖**try**和**catch**里面的，所以代码会返回2。</font>\n\n#### 2. 抛出错误——throw\n\nthrow 用来创建自定义错误\n\nthrow new Error('something bad happened')\n","source":"_posts/2016-07-06-js中的错误处理与调试.md","raw":"---\nlayout: post\ntitle: js中的错误处理与调试\ndate: 2016-07-06\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n### 一. 错误类型\n\n- Error\n- EvalError\n- RangeError\n- ReferenceError\n- SyntaxError\n- TypeError\n- URIError\n\n#### 1. Error\n\n错误的基类型，所有错误继承自这个错误，编程中一般不会出现这个错误。\n\n#### 2. EvalError——使用eval()错误\n\n当没有把eval()当成函数调用时，会抛出这个错误。\n\n#### 3. RangeError——超出范围错误\n\n    eg：使用了数组不支持的项数。\n    var arr = new Array(-20);\n\n#### 4. ReferenceError——引用错误\n\n访问不存在的变量时会出现。\n\n#### 5. SyntaxError——语法错误\n\n当我们把有语法错误的字符串传到eval()函数里面时，会出现这个错误。\n\n#### 6. TypeError——类型错误\n\n当访问不存在的方法，或者传入函数的参数类型与预期不符合，会提示这个错误。\n\n#### 7. URLError——URL格式错误\n\n使用encodeURL()和decodeURL()，URL格式不正确时会出现这个错误。\n\n### 一. 错误处理机制\n\n#### 1. 捕获错误——try...catch\n\n**try...catch**\n\n```js\ntry {\n\t//可能会导致错误的代码\n} catch(error) {\n\t//发生错误时，应该怎么处理\n}\n```\n\n对于不同浏览器而言，这里的error对象包含不同的属性，但是**所有浏览器都有一个相同的属性**：\n\n\terror.message:浏览器给出的错误消息    \n\n**try...catch...finally**\n\n```js\ntry {\n\treturn 0;\t\n} catch(error) {\n\treturn 1;\n} finally {\n\treturn 2;\n}\n```\n\n<font color=\"red\">注意：**finally**语句块中的语句会覆盖**try**和**catch**里面的，所以代码会返回2。</font>\n\n#### 2. 抛出错误——throw\n\nthrow 用来创建自定义错误\n\nthrow new Error('something bad happened')\n","slug":"2016-07-06-js中的错误处理与调试","published":1,"updated":"2016-08-28T06:46:16.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocj600aqd5u83apyjkda","content":"<h3 id=\"一-错误类型\"><a href=\"#一-错误类型\" class=\"headerlink\" title=\"一. 错误类型\"></a>一. 错误类型</h3><ul>\n<li>Error</li>\n<li>EvalError</li>\n<li>RangeError</li>\n<li>ReferenceError</li>\n<li>SyntaxError</li>\n<li>TypeError</li>\n<li>URIError</li>\n</ul>\n<h4 id=\"1-Error\"><a href=\"#1-Error\" class=\"headerlink\" title=\"1. Error\"></a>1. Error</h4><p>错误的基类型，所有错误继承自这个错误，编程中一般不会出现这个错误。</p>\n<h4 id=\"2-EvalError——使用eval-错误\"><a href=\"#2-EvalError——使用eval-错误\" class=\"headerlink\" title=\"2. EvalError——使用eval()错误\"></a>2. EvalError——使用eval()错误</h4><p>当没有把eval()当成函数调用时，会抛出这个错误。</p>\n<h4 id=\"3-RangeError——超出范围错误\"><a href=\"#3-RangeError——超出范围错误\" class=\"headerlink\" title=\"3. RangeError——超出范围错误\"></a>3. RangeError——超出范围错误</h4><pre><code>eg：使用了数组不支持的项数。\nvar arr = new Array(-20);\n</code></pre><h4 id=\"4-ReferenceError——引用错误\"><a href=\"#4-ReferenceError——引用错误\" class=\"headerlink\" title=\"4. ReferenceError——引用错误\"></a>4. ReferenceError——引用错误</h4><p>访问不存在的变量时会出现。</p>\n<h4 id=\"5-SyntaxError——语法错误\"><a href=\"#5-SyntaxError——语法错误\" class=\"headerlink\" title=\"5. SyntaxError——语法错误\"></a>5. SyntaxError——语法错误</h4><p>当我们把有语法错误的字符串传到eval()函数里面时，会出现这个错误。</p>\n<h4 id=\"6-TypeError——类型错误\"><a href=\"#6-TypeError——类型错误\" class=\"headerlink\" title=\"6. TypeError——类型错误\"></a>6. TypeError——类型错误</h4><p>当访问不存在的方法，或者传入函数的参数类型与预期不符合，会提示这个错误。</p>\n<h4 id=\"7-URLError——URL格式错误\"><a href=\"#7-URLError——URL格式错误\" class=\"headerlink\" title=\"7. URLError——URL格式错误\"></a>7. URLError——URL格式错误</h4><p>使用encodeURL()和decodeURL()，URL格式不正确时会出现这个错误。</p>\n<h3 id=\"一-错误处理机制\"><a href=\"#一-错误处理机制\" class=\"headerlink\" title=\"一. 错误处理机制\"></a>一. 错误处理机制</h3><h4 id=\"1-捕获错误——try…catch\"><a href=\"#1-捕获错误——try…catch\" class=\"headerlink\" title=\"1. 捕获错误——try…catch\"></a>1. 捕获错误——try…catch</h4><p><strong>try…catch</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//可能会导致错误的代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//发生错误时，应该怎么处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同浏览器而言，这里的error对象包含不同的属性，但是<strong>所有浏览器都有一个相同的属性</strong>：</p>\n<pre><code>error.message:浏览器给出的错误消息    \n</code></pre><p><strong>try…catch…finally</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<font color=\"red\">注意：<strong>finally</strong>语句块中的语句会覆盖<strong>try</strong>和<strong>catch</strong>里面的，所以代码会返回2。</font>\n\n<h4 id=\"2-抛出错误——throw\"><a href=\"#2-抛出错误——throw\" class=\"headerlink\" title=\"2. 抛出错误——throw\"></a>2. 抛出错误——throw</h4><p>throw 用来创建自定义错误</p>\n<p>throw new Error(‘something bad happened’)</p>\n","excerpt":"","more":"<h3 id=\"一-错误类型\"><a href=\"#一-错误类型\" class=\"headerlink\" title=\"一. 错误类型\"></a>一. 错误类型</h3><ul>\n<li>Error</li>\n<li>EvalError</li>\n<li>RangeError</li>\n<li>ReferenceError</li>\n<li>SyntaxError</li>\n<li>TypeError</li>\n<li>URIError</li>\n</ul>\n<h4 id=\"1-Error\"><a href=\"#1-Error\" class=\"headerlink\" title=\"1. Error\"></a>1. Error</h4><p>错误的基类型，所有错误继承自这个错误，编程中一般不会出现这个错误。</p>\n<h4 id=\"2-EvalError——使用eval-错误\"><a href=\"#2-EvalError——使用eval-错误\" class=\"headerlink\" title=\"2. EvalError——使用eval()错误\"></a>2. EvalError——使用eval()错误</h4><p>当没有把eval()当成函数调用时，会抛出这个错误。</p>\n<h4 id=\"3-RangeError——超出范围错误\"><a href=\"#3-RangeError——超出范围错误\" class=\"headerlink\" title=\"3. RangeError——超出范围错误\"></a>3. RangeError——超出范围错误</h4><pre><code>eg：使用了数组不支持的项数。\nvar arr = new Array(-20);\n</code></pre><h4 id=\"4-ReferenceError——引用错误\"><a href=\"#4-ReferenceError——引用错误\" class=\"headerlink\" title=\"4. ReferenceError——引用错误\"></a>4. ReferenceError——引用错误</h4><p>访问不存在的变量时会出现。</p>\n<h4 id=\"5-SyntaxError——语法错误\"><a href=\"#5-SyntaxError——语法错误\" class=\"headerlink\" title=\"5. SyntaxError——语法错误\"></a>5. SyntaxError——语法错误</h4><p>当我们把有语法错误的字符串传到eval()函数里面时，会出现这个错误。</p>\n<h4 id=\"6-TypeError——类型错误\"><a href=\"#6-TypeError——类型错误\" class=\"headerlink\" title=\"6. TypeError——类型错误\"></a>6. TypeError——类型错误</h4><p>当访问不存在的方法，或者传入函数的参数类型与预期不符合，会提示这个错误。</p>\n<h4 id=\"7-URLError——URL格式错误\"><a href=\"#7-URLError——URL格式错误\" class=\"headerlink\" title=\"7. URLError——URL格式错误\"></a>7. URLError——URL格式错误</h4><p>使用encodeURL()和decodeURL()，URL格式不正确时会出现这个错误。</p>\n<h3 id=\"一-错误处理机制\"><a href=\"#一-错误处理机制\" class=\"headerlink\" title=\"一. 错误处理机制\"></a>一. 错误处理机制</h3><h4 id=\"1-捕获错误——try…catch\"><a href=\"#1-捕获错误——try…catch\" class=\"headerlink\" title=\"1. 捕获错误——try…catch\"></a>1. 捕获错误——try…catch</h4><p><strong>try…catch</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//可能会导致错误的代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//发生错误时，应该怎么处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同浏览器而言，这里的error对象包含不同的属性，但是<strong>所有浏览器都有一个相同的属性</strong>：</p>\n<pre><code>error.message:浏览器给出的错误消息    \n</code></pre><p><strong>try…catch…finally</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<font color=\"red\">注意：<strong>finally</strong>语句块中的语句会覆盖<strong>try</strong>和<strong>catch</strong>里面的，所以代码会返回2。</font>\n\n<h4 id=\"2-抛出错误——throw\"><a href=\"#2-抛出错误——throw\" class=\"headerlink\" title=\"2. 抛出错误——throw\"></a>2. 抛出错误——throw</h4><p>throw 用来创建自定义错误</p>\n<p>throw new Error(‘something bad happened’)</p>\n"},{"layout":"post","title":"js中运算符的优先级","date":"2016-07-05T16:00:00.000Z","description":null,"_content":"**运算符的优先级**用于计算表达式时不同运算符执行的顺序。\n\n下表是由运算符的优先级是由 **高 ————> 低**，相同优先级的运算符按从左至右的顺序求值。\n\n\n    运算符\t\t\t\t\t\t\t\t描述\n    . [] ()\t\t\t\t\t\t\t\t字段访问、数组下标、函数调用以及表达式分组\n    ++ -- - ~ ! delete new typeof void\t一元运算符、返回数据类型、对象创建、未定义值\n    * / %\t\t\t\t\t\t\t\t乘法、除法、取模\n    + - +\t\t\t\t\t\t\t\t加法、减法、字符串连接\n    << >> >>>\t\t\t\t\t\t\t移位\n    < <= > >= instanceof\t\t\t\t小于、小于等于、大于、大于等于、instanceof\n    == != === !==\t\t\t\t\t\t等于、不等于、严格相等、非严格相等\n    &\t\t\t\t\t\t\t\t\t按位与\n    ^\t\t\t\t\t\t\t\t\t按位异或\n    |\t\t\t\t\t\t\t\t\t按位或\n    &&\t\t\t\t\t\t\t\t\t逻辑与\n    ||\t\t\t\t\t\t\t\t\t逻辑或\n    ?:\t\t\t\t\t\t\t\t\t条件\n    = oP=\t\t\t\t\t\t\t\t赋值、运算赋值\n    ,\t\t\t\t\t\t\t\t\t多重求值\n\n    \n\n\n","source":"_posts/2016-07-06-js中运算符的优先级.md","raw":"---\nlayout: post\ntitle: js中运算符的优先级\ndate: 2016-07-06\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n**运算符的优先级**用于计算表达式时不同运算符执行的顺序。\n\n下表是由运算符的优先级是由 **高 ————> 低**，相同优先级的运算符按从左至右的顺序求值。\n\n\n    运算符\t\t\t\t\t\t\t\t描述\n    . [] ()\t\t\t\t\t\t\t\t字段访问、数组下标、函数调用以及表达式分组\n    ++ -- - ~ ! delete new typeof void\t一元运算符、返回数据类型、对象创建、未定义值\n    * / %\t\t\t\t\t\t\t\t乘法、除法、取模\n    + - +\t\t\t\t\t\t\t\t加法、减法、字符串连接\n    << >> >>>\t\t\t\t\t\t\t移位\n    < <= > >= instanceof\t\t\t\t小于、小于等于、大于、大于等于、instanceof\n    == != === !==\t\t\t\t\t\t等于、不等于、严格相等、非严格相等\n    &\t\t\t\t\t\t\t\t\t按位与\n    ^\t\t\t\t\t\t\t\t\t按位异或\n    |\t\t\t\t\t\t\t\t\t按位或\n    &&\t\t\t\t\t\t\t\t\t逻辑与\n    ||\t\t\t\t\t\t\t\t\t逻辑或\n    ?:\t\t\t\t\t\t\t\t\t条件\n    = oP=\t\t\t\t\t\t\t\t赋值、运算赋值\n    ,\t\t\t\t\t\t\t\t\t多重求值\n\n    \n\n\n","slug":"2016-07-06-js中运算符的优先级","published":1,"updated":"2016-07-06T02:45:46.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocj900aud5u82ukmitnt","content":"<p><strong>运算符的优先级</strong>用于计算表达式时不同运算符执行的顺序。</p>\n<p>下表是由运算符的优先级是由 <strong>高 ————&gt; 低</strong>，相同优先级的运算符按从左至右的顺序求值。</p>\n<pre><code>运算符                                描述\n. [] ()                                字段访问、数组下标、函数调用以及表达式分组\n++ -- - ~ ! delete new typeof void    一元运算符、返回数据类型、对象创建、未定义值\n* / %                                乘法、除法、取模\n+ - +                                加法、减法、字符串连接\n&lt;&lt; &gt;&gt; &gt;&gt;&gt;                            移位\n&lt; &lt;= &gt; &gt;= instanceof                小于、小于等于、大于、大于等于、instanceof\n== != === !==                        等于、不等于、严格相等、非严格相等\n&amp;                                    按位与\n^                                    按位异或\n|                                    按位或\n&amp;&amp;                                    逻辑与\n||                                    逻辑或\n?:                                    条件\n= oP=                                赋值、运算赋值\n,                                    多重求值\n</code></pre>","excerpt":"","more":"<p><strong>运算符的优先级</strong>用于计算表达式时不同运算符执行的顺序。</p>\n<p>下表是由运算符的优先级是由 <strong>高 ————&gt; 低</strong>，相同优先级的运算符按从左至右的顺序求值。</p>\n<pre><code>运算符                                描述\n. [] ()                                字段访问、数组下标、函数调用以及表达式分组\n++ -- - ~ ! delete new typeof void    一元运算符、返回数据类型、对象创建、未定义值\n* / %                                乘法、除法、取模\n+ - +                                加法、减法、字符串连接\n&lt;&lt; &gt;&gt; &gt;&gt;&gt;                            移位\n&lt; &lt;= &gt; &gt;= instanceof                小于、小于等于、大于、大于等于、instanceof\n== != === !==                        等于、不等于、严格相等、非严格相等\n&amp;                                    按位与\n^                                    按位异或\n|                                    按位或\n&amp;&amp;                                    逻辑与\n||                                    逻辑或\n?:                                    条件\n= oP=                                赋值、运算赋值\n,                                    多重求值\n</code></pre>"},{"layout":"post","title":"微型调查问卷平台","date":"2016-07-12T16:00:00.000Z","description":null,"_content":"### 一. 微型调查问卷平台\n\n**微型调查问卷平台需要实现的功能如下：**\n\n#### 1. 问卷管理列表\n\n- 有一个头部可以显示logo，不需要实现登录等操作\n- 问卷管理列表页面默认为首页\n- 有一个表格用于展示所有已创建的问卷\n- 列表中包括列有：问卷名称，问卷状态（未发布，发布中，已结束），和操作区域（编辑、删除、查看数据）\n- 问卷状态为未发布时，可以做的操作为编辑、删除、查看问卷\n- 问卷状态为发布中和已结束时，可以做的操作为查看数据、查看问卷\n- 表格最左侧有批量选择（多选）的checkbox，多选后，可以进行批量删除功能，checkbox样式用默认即可，不需要按照设计图的样式\n- 当一个问卷都没有的时候，表格不展现，页面显示大大的新建问卷按钮\n\n#### 2. 问卷新建及编辑\n\n- 点击问卷管理列表中的新建按钮后，进入到问卷新建页面\n- 点击问卷列表中某个问卷行的编辑按钮后，进入到问卷的编辑页面\n- 新建页面和编辑页面基本相同\n- 问卷有一个标题字段，点击后可以进入编辑状态\n- 可以针对问卷中的问题进行增删改操作，每个问卷最少一个问题，最多十个问题\n- 问题类型包括：单选题、多选题、单行文本题\n- 可以对所有问题进行位置改变（上移、下移），复用，删除的操作\n- 最上面的问题没有上移操作，最下面的问题没有下移操作\n- 点击复用时，在被复用的问题紧接着的下方新增一个和被复用完全一样的问题（包括选项）\n- 对于单选题和多选题，可以对问题的选项进行增、删、改、排序操作\n- 文本题可以设定是必填还是非必填的问题\n- 有一个问卷调查填写截止时间，使用一个日历组件来进行时间的选择，日期选择不能早于当前日期\n- 保存问卷可以进行问卷的保存\n- 发布问卷可以使得问卷状态变为发布中的状态\n- 当点击发布时，如果截止日期早于当前日期，则需要提示修改截止日期\n\nDemo地址：[http://panpanfish.com/myDemo/questionNaire/index.html](http://panpanfish.com/myDemo/questionNaire/index.html \"微型调查问卷平台\")\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/index.html](https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/ \"微型调查问卷平台\")\n\n#### 3. 删除问卷\n\n在问卷管理列表中点击某个问卷的删除按钮后，弹出一个弹出层，让用户二次确认是否删除该问卷，如果用户点击是，则删除掉该问卷\n\n#### 4. 查看问卷\n\n- 在问卷管理列表中点击查看问卷的按钮后，在新窗口中打开该问卷的页面，该页面是可供用户进行问卷填写的页面，在问卷未发布状态和已结束状态时，问卷提交是无效的。\n- 该页面在移动端需要进行良好的兼容支持\n\n#### 5.查看数据\n- 在问卷管理列表中点击查看数据按钮后，进入到一个数据报告页面，用图表形式呈现各个单选题和多选题的选择情况\n- 如设计稿中呈现，每一个问题在右侧用某种图表来呈现答题情况，自行选择合适的图表，设计稿中仅为示意，图表样式不需要和设计稿一致。推荐单选题使用饼状图，多选题使用条形图\n- 文本题用一个百分比图展现有效回答占比即可\n- 返回按钮点击后返回列表页面\n- 在项目中尝试模块化的方法及工具\n- 在项目中尝试CSS预处理工具\n- 在项目中尝试项目构建、打包工具\n\n### 二. 调查问卷平台的组成部分\n\n问卷列表\n浮出层\n\n### 三. 做的过程中遇到的问题\n\n### 1. 问卷列表页\n\n#### a. 两个模块之间如何通信\n\neg:\n\n问卷管理列表页点击删除按钮会出现弹出窗，点击弹出窗上的确定按钮，需要删除问卷列表模块的对应的列表。\n\n**这里用到了浮出层模块和问卷列表模块之间的通信，这里是使用回调函数来实现的。**\n\n```\n在问卷列表模块：\n\n//删除按钮绑定事件\nG.Eve.addEvent(button[1],\"click\",function(event) {\n\t\tvar e = window.event || event;\n\t\tvar target = e.target || e.srcElement;\n\t\tvar floatLayer = new FloatLayer({\t\t\n\t\t\t\troot: G.Dom.$(\"floatDiv\"),\n\t\t\t\tisMove: true,\n\t\t\t\tisZoom: true,\n\t\t\t\tfloatContent: {\n\t\t\t\t\ttitle: \"提示\",\n\t\t\t\t\tcontent: \"确定要删除第\" + (_i + 1) + \"份问卷吗？\"\n\t\t\t\t\t\t},\n\t\t\t\t\t_handler: function() {\n\t\t\t\t\tthat.deleteItem(target);\n\t\t\t\t}\t\t\t\t\t\n\t\t });\n\t\t//初始化，生成浮出层\t\t\t\t\n\t\tfloatLayer.show();\n});\n\n//传入浮出层模块的回调函数deleteItem()\ndeleteItem: function(target) {\n\tthis.listBody.removeChild(target.parentNode.parentNode);\n}\n\n//浮出层模块的确定按钮添加事件\nGLOBAL.Eve.addEvent(that._alertDiv.btnSure,\"click\",function() {\n\tthat.hide();\n\n\t//如果给浮出层模块设定了回调函数，即config._handler不为空，那么久执行传进来的回调函数\n\tif(that._handler) {\n\t\tthat._handler();\n\t}\n});\n```\t\t\t\n\n#### b. 复选框checkbox选中状态\n\n对于复选框被选中，在**HTML**中有三种方法：\n\n    <input id=\"btn\" type=\"checkbox\" checked=\"checked\" />\n    \n    <input id=\"btn\" type=\"checkbox\" checked=\"true\" />\n    \n    <input id=\"btn\" type=\"checkbox\" checked />\n\n但是在**js**中，只有一种方法是有效的：\n\n\tvar btn = document.getElementById(\"btn\");\n\t//无论在HTML中使用什么方式，让复选框被选中，在这里只会输出true而不是checked\n\tconsole.log(btn.checked);\n\n#### c. 解决IE下不兼容html5标签的方法\n\n在这里主要是IE不兼容<main>标签引起了排版的错乱。\n\n在css中加上\n\n```\nmain, article, aside, dialog, footer, header, section, footer, nav, figure, menu{ display:block }\n```","source":"_posts/2016-07-13-微型调查问卷平台.md","raw":"---\nlayout: post\ntitle: 微型调查问卷平台\ndate: 2016-07-13\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n### 一. 微型调查问卷平台\n\n**微型调查问卷平台需要实现的功能如下：**\n\n#### 1. 问卷管理列表\n\n- 有一个头部可以显示logo，不需要实现登录等操作\n- 问卷管理列表页面默认为首页\n- 有一个表格用于展示所有已创建的问卷\n- 列表中包括列有：问卷名称，问卷状态（未发布，发布中，已结束），和操作区域（编辑、删除、查看数据）\n- 问卷状态为未发布时，可以做的操作为编辑、删除、查看问卷\n- 问卷状态为发布中和已结束时，可以做的操作为查看数据、查看问卷\n- 表格最左侧有批量选择（多选）的checkbox，多选后，可以进行批量删除功能，checkbox样式用默认即可，不需要按照设计图的样式\n- 当一个问卷都没有的时候，表格不展现，页面显示大大的新建问卷按钮\n\n#### 2. 问卷新建及编辑\n\n- 点击问卷管理列表中的新建按钮后，进入到问卷新建页面\n- 点击问卷列表中某个问卷行的编辑按钮后，进入到问卷的编辑页面\n- 新建页面和编辑页面基本相同\n- 问卷有一个标题字段，点击后可以进入编辑状态\n- 可以针对问卷中的问题进行增删改操作，每个问卷最少一个问题，最多十个问题\n- 问题类型包括：单选题、多选题、单行文本题\n- 可以对所有问题进行位置改变（上移、下移），复用，删除的操作\n- 最上面的问题没有上移操作，最下面的问题没有下移操作\n- 点击复用时，在被复用的问题紧接着的下方新增一个和被复用完全一样的问题（包括选项）\n- 对于单选题和多选题，可以对问题的选项进行增、删、改、排序操作\n- 文本题可以设定是必填还是非必填的问题\n- 有一个问卷调查填写截止时间，使用一个日历组件来进行时间的选择，日期选择不能早于当前日期\n- 保存问卷可以进行问卷的保存\n- 发布问卷可以使得问卷状态变为发布中的状态\n- 当点击发布时，如果截止日期早于当前日期，则需要提示修改截止日期\n\nDemo地址：[http://panpanfish.com/myDemo/questionNaire/index.html](http://panpanfish.com/myDemo/questionNaire/index.html \"微型调查问卷平台\")\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/index.html](https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/ \"微型调查问卷平台\")\n\n#### 3. 删除问卷\n\n在问卷管理列表中点击某个问卷的删除按钮后，弹出一个弹出层，让用户二次确认是否删除该问卷，如果用户点击是，则删除掉该问卷\n\n#### 4. 查看问卷\n\n- 在问卷管理列表中点击查看问卷的按钮后，在新窗口中打开该问卷的页面，该页面是可供用户进行问卷填写的页面，在问卷未发布状态和已结束状态时，问卷提交是无效的。\n- 该页面在移动端需要进行良好的兼容支持\n\n#### 5.查看数据\n- 在问卷管理列表中点击查看数据按钮后，进入到一个数据报告页面，用图表形式呈现各个单选题和多选题的选择情况\n- 如设计稿中呈现，每一个问题在右侧用某种图表来呈现答题情况，自行选择合适的图表，设计稿中仅为示意，图表样式不需要和设计稿一致。推荐单选题使用饼状图，多选题使用条形图\n- 文本题用一个百分比图展现有效回答占比即可\n- 返回按钮点击后返回列表页面\n- 在项目中尝试模块化的方法及工具\n- 在项目中尝试CSS预处理工具\n- 在项目中尝试项目构建、打包工具\n\n### 二. 调查问卷平台的组成部分\n\n问卷列表\n浮出层\n\n### 三. 做的过程中遇到的问题\n\n### 1. 问卷列表页\n\n#### a. 两个模块之间如何通信\n\neg:\n\n问卷管理列表页点击删除按钮会出现弹出窗，点击弹出窗上的确定按钮，需要删除问卷列表模块的对应的列表。\n\n**这里用到了浮出层模块和问卷列表模块之间的通信，这里是使用回调函数来实现的。**\n\n```\n在问卷列表模块：\n\n//删除按钮绑定事件\nG.Eve.addEvent(button[1],\"click\",function(event) {\n\t\tvar e = window.event || event;\n\t\tvar target = e.target || e.srcElement;\n\t\tvar floatLayer = new FloatLayer({\t\t\n\t\t\t\troot: G.Dom.$(\"floatDiv\"),\n\t\t\t\tisMove: true,\n\t\t\t\tisZoom: true,\n\t\t\t\tfloatContent: {\n\t\t\t\t\ttitle: \"提示\",\n\t\t\t\t\tcontent: \"确定要删除第\" + (_i + 1) + \"份问卷吗？\"\n\t\t\t\t\t\t},\n\t\t\t\t\t_handler: function() {\n\t\t\t\t\tthat.deleteItem(target);\n\t\t\t\t}\t\t\t\t\t\n\t\t });\n\t\t//初始化，生成浮出层\t\t\t\t\n\t\tfloatLayer.show();\n});\n\n//传入浮出层模块的回调函数deleteItem()\ndeleteItem: function(target) {\n\tthis.listBody.removeChild(target.parentNode.parentNode);\n}\n\n//浮出层模块的确定按钮添加事件\nGLOBAL.Eve.addEvent(that._alertDiv.btnSure,\"click\",function() {\n\tthat.hide();\n\n\t//如果给浮出层模块设定了回调函数，即config._handler不为空，那么久执行传进来的回调函数\n\tif(that._handler) {\n\t\tthat._handler();\n\t}\n});\n```\t\t\t\n\n#### b. 复选框checkbox选中状态\n\n对于复选框被选中，在**HTML**中有三种方法：\n\n    <input id=\"btn\" type=\"checkbox\" checked=\"checked\" />\n    \n    <input id=\"btn\" type=\"checkbox\" checked=\"true\" />\n    \n    <input id=\"btn\" type=\"checkbox\" checked />\n\n但是在**js**中，只有一种方法是有效的：\n\n\tvar btn = document.getElementById(\"btn\");\n\t//无论在HTML中使用什么方式，让复选框被选中，在这里只会输出true而不是checked\n\tconsole.log(btn.checked);\n\n#### c. 解决IE下不兼容html5标签的方法\n\n在这里主要是IE不兼容<main>标签引起了排版的错乱。\n\n在css中加上\n\n```\nmain, article, aside, dialog, footer, header, section, footer, nav, figure, menu{ display:block }\n```","slug":"2016-07-13-微型调查问卷平台","published":1,"updated":"2016-08-23T03:34:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjc00axd5u8qgc1kzku","content":"<h3 id=\"一-微型调查问卷平台\"><a href=\"#一-微型调查问卷平台\" class=\"headerlink\" title=\"一. 微型调查问卷平台\"></a>一. 微型调查问卷平台</h3><p><strong>微型调查问卷平台需要实现的功能如下：</strong></p>\n<h4 id=\"1-问卷管理列表\"><a href=\"#1-问卷管理列表\" class=\"headerlink\" title=\"1. 问卷管理列表\"></a>1. 问卷管理列表</h4><ul>\n<li>有一个头部可以显示logo，不需要实现登录等操作</li>\n<li>问卷管理列表页面默认为首页</li>\n<li>有一个表格用于展示所有已创建的问卷</li>\n<li>列表中包括列有：问卷名称，问卷状态（未发布，发布中，已结束），和操作区域（编辑、删除、查看数据）</li>\n<li>问卷状态为未发布时，可以做的操作为编辑、删除、查看问卷</li>\n<li>问卷状态为发布中和已结束时，可以做的操作为查看数据、查看问卷</li>\n<li>表格最左侧有批量选择（多选）的checkbox，多选后，可以进行批量删除功能，checkbox样式用默认即可，不需要按照设计图的样式</li>\n<li>当一个问卷都没有的时候，表格不展现，页面显示大大的新建问卷按钮</li>\n</ul>\n<h4 id=\"2-问卷新建及编辑\"><a href=\"#2-问卷新建及编辑\" class=\"headerlink\" title=\"2. 问卷新建及编辑\"></a>2. 问卷新建及编辑</h4><ul>\n<li>点击问卷管理列表中的新建按钮后，进入到问卷新建页面</li>\n<li>点击问卷列表中某个问卷行的编辑按钮后，进入到问卷的编辑页面</li>\n<li>新建页面和编辑页面基本相同</li>\n<li>问卷有一个标题字段，点击后可以进入编辑状态</li>\n<li>可以针对问卷中的问题进行增删改操作，每个问卷最少一个问题，最多十个问题</li>\n<li>问题类型包括：单选题、多选题、单行文本题</li>\n<li>可以对所有问题进行位置改变（上移、下移），复用，删除的操作</li>\n<li>最上面的问题没有上移操作，最下面的问题没有下移操作</li>\n<li>点击复用时，在被复用的问题紧接着的下方新增一个和被复用完全一样的问题（包括选项）</li>\n<li>对于单选题和多选题，可以对问题的选项进行增、删、改、排序操作</li>\n<li>文本题可以设定是必填还是非必填的问题</li>\n<li>有一个问卷调查填写截止时间，使用一个日历组件来进行时间的选择，日期选择不能早于当前日期</li>\n<li>保存问卷可以进行问卷的保存</li>\n<li>发布问卷可以使得问卷状态变为发布中的状态</li>\n<li>当点击发布时，如果截止日期早于当前日期，则需要提示修改截止日期</li>\n</ul>\n<p>Demo地址：<a href=\"http://panpanfish.com/myDemo/questionNaire/index.html\" title=\"微型调查问卷平台\">http://panpanfish.com/myDemo/questionNaire/index.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/\" title=\"微型调查问卷平台\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/index.html</a></p>\n<h4 id=\"3-删除问卷\"><a href=\"#3-删除问卷\" class=\"headerlink\" title=\"3. 删除问卷\"></a>3. 删除问卷</h4><p>在问卷管理列表中点击某个问卷的删除按钮后，弹出一个弹出层，让用户二次确认是否删除该问卷，如果用户点击是，则删除掉该问卷</p>\n<h4 id=\"4-查看问卷\"><a href=\"#4-查看问卷\" class=\"headerlink\" title=\"4. 查看问卷\"></a>4. 查看问卷</h4><ul>\n<li>在问卷管理列表中点击查看问卷的按钮后，在新窗口中打开该问卷的页面，该页面是可供用户进行问卷填写的页面，在问卷未发布状态和已结束状态时，问卷提交是无效的。</li>\n<li>该页面在移动端需要进行良好的兼容支持</li>\n</ul>\n<h4 id=\"5-查看数据\"><a href=\"#5-查看数据\" class=\"headerlink\" title=\"5.查看数据\"></a>5.查看数据</h4><ul>\n<li>在问卷管理列表中点击查看数据按钮后，进入到一个数据报告页面，用图表形式呈现各个单选题和多选题的选择情况</li>\n<li>如设计稿中呈现，每一个问题在右侧用某种图表来呈现答题情况，自行选择合适的图表，设计稿中仅为示意，图表样式不需要和设计稿一致。推荐单选题使用饼状图，多选题使用条形图</li>\n<li>文本题用一个百分比图展现有效回答占比即可</li>\n<li>返回按钮点击后返回列表页面</li>\n<li>在项目中尝试模块化的方法及工具</li>\n<li>在项目中尝试CSS预处理工具</li>\n<li>在项目中尝试项目构建、打包工具</li>\n</ul>\n<h3 id=\"二-调查问卷平台的组成部分\"><a href=\"#二-调查问卷平台的组成部分\" class=\"headerlink\" title=\"二. 调查问卷平台的组成部分\"></a>二. 调查问卷平台的组成部分</h3><p>问卷列表<br>浮出层</p>\n<h3 id=\"三-做的过程中遇到的问题\"><a href=\"#三-做的过程中遇到的问题\" class=\"headerlink\" title=\"三. 做的过程中遇到的问题\"></a>三. 做的过程中遇到的问题</h3><h3 id=\"1-问卷列表页\"><a href=\"#1-问卷列表页\" class=\"headerlink\" title=\"1. 问卷列表页\"></a>1. 问卷列表页</h3><h4 id=\"a-两个模块之间如何通信\"><a href=\"#a-两个模块之间如何通信\" class=\"headerlink\" title=\"a. 两个模块之间如何通信\"></a>a. 两个模块之间如何通信</h4><p>eg:</p>\n<p>问卷管理列表页点击删除按钮会出现弹出窗，点击弹出窗上的确定按钮，需要删除问卷列表模块的对应的列表。</p>\n<p><strong>这里用到了浮出层模块和问卷列表模块之间的通信，这里是使用回调函数来实现的。</strong></p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在问卷列表模块：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除按钮绑定事件</span></span><br><span class=\"line\">G.Eve.addEvent(button[<span class=\"number\">1</span>],<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e = window.event || event;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> target = e.target || e.srcElement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> floatLayer = <span class=\"keyword\">new</span> FloatLayer(&#123;\t\t</span><br><span class=\"line\">\t\t\t\troot: G.Dom.$(<span class=\"string\">\"floatDiv\"</span>),</span><br><span class=\"line\">\t\t\t\tisMove: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t\tisZoom: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t\tfloatContent: &#123;</span><br><span class=\"line\">\t\t\t\t\ttitle: <span class=\"string\">\"提示\"</span>,</span><br><span class=\"line\">\t\t\t\t\tcontent: <span class=\"string\">\"确定要删除第\"</span> + (_i + <span class=\"number\">1</span>) + <span class=\"string\">\"份问卷吗？\"</span></span><br><span class=\"line\">\t\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t_handler: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.deleteItem(target);</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t\t\t</span><br><span class=\"line\">\t\t &#125;);</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化，生成浮出层\t\t\t\t</span></span><br><span class=\"line\">\t\tfloatLayer.show();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//传入浮出层模块的回调函数deleteItem()</span></span><br><span class=\"line\">deleteItem: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.listBody.removeChild(target.parentNode.parentNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//浮出层模块的确定按钮添加事件</span></span><br><span class=\"line\">GLOBAL.Eve.addEvent(that._alertDiv.btnSure,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tthat.hide();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果给浮出层模块设定了回调函数，即config._handler不为空，那么久执行传进来的回调函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(that._handler) &#123;</span><br><span class=\"line\">\t\tthat._handler();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">```\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#### b. 复选框checkbox选中状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">对于复选框被选中，在**HTML**中有三种方法：</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"checkbox\"</span> checked=<span class=\"string\">\"checked\"</span> /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"checkbox\"</span> checked=<span class=\"string\">\"true\"</span> /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"checkbox\"</span> checked /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">但是在**js**中，只有一种方法是有效的：</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> btn = document.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//无论在HTML中使用什么方式，让复选框被选中，在这里只会输出true而不是checked</span></span><br><span class=\"line\">\tconsole.log(btn.checked);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#### c. 解决IE下不兼容html5标签的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">在这里主要是IE不兼容&lt;main&gt;标签引起了排版的错乱。</span><br><span class=\"line\"></span><br><span class=\"line\">在css中加上</span><br></pre></td></tr></table></figure>\n<p>main, article, aside, dialog, footer, header, section, footer, nav, figure, menu{ display:block }<br>```</p>\n","excerpt":"","more":"<h3 id=\"一-微型调查问卷平台\"><a href=\"#一-微型调查问卷平台\" class=\"headerlink\" title=\"一. 微型调查问卷平台\"></a>一. 微型调查问卷平台</h3><p><strong>微型调查问卷平台需要实现的功能如下：</strong></p>\n<h4 id=\"1-问卷管理列表\"><a href=\"#1-问卷管理列表\" class=\"headerlink\" title=\"1. 问卷管理列表\"></a>1. 问卷管理列表</h4><ul>\n<li>有一个头部可以显示logo，不需要实现登录等操作</li>\n<li>问卷管理列表页面默认为首页</li>\n<li>有一个表格用于展示所有已创建的问卷</li>\n<li>列表中包括列有：问卷名称，问卷状态（未发布，发布中，已结束），和操作区域（编辑、删除、查看数据）</li>\n<li>问卷状态为未发布时，可以做的操作为编辑、删除、查看问卷</li>\n<li>问卷状态为发布中和已结束时，可以做的操作为查看数据、查看问卷</li>\n<li>表格最左侧有批量选择（多选）的checkbox，多选后，可以进行批量删除功能，checkbox样式用默认即可，不需要按照设计图的样式</li>\n<li>当一个问卷都没有的时候，表格不展现，页面显示大大的新建问卷按钮</li>\n</ul>\n<h4 id=\"2-问卷新建及编辑\"><a href=\"#2-问卷新建及编辑\" class=\"headerlink\" title=\"2. 问卷新建及编辑\"></a>2. 问卷新建及编辑</h4><ul>\n<li>点击问卷管理列表中的新建按钮后，进入到问卷新建页面</li>\n<li>点击问卷列表中某个问卷行的编辑按钮后，进入到问卷的编辑页面</li>\n<li>新建页面和编辑页面基本相同</li>\n<li>问卷有一个标题字段，点击后可以进入编辑状态</li>\n<li>可以针对问卷中的问题进行增删改操作，每个问卷最少一个问题，最多十个问题</li>\n<li>问题类型包括：单选题、多选题、单行文本题</li>\n<li>可以对所有问题进行位置改变（上移、下移），复用，删除的操作</li>\n<li>最上面的问题没有上移操作，最下面的问题没有下移操作</li>\n<li>点击复用时，在被复用的问题紧接着的下方新增一个和被复用完全一样的问题（包括选项）</li>\n<li>对于单选题和多选题，可以对问题的选项进行增、删、改、排序操作</li>\n<li>文本题可以设定是必填还是非必填的问题</li>\n<li>有一个问卷调查填写截止时间，使用一个日历组件来进行时间的选择，日期选择不能早于当前日期</li>\n<li>保存问卷可以进行问卷的保存</li>\n<li>发布问卷可以使得问卷状态变为发布中的状态</li>\n<li>当点击发布时，如果截止日期早于当前日期，则需要提示修改截止日期</li>\n</ul>\n<p>Demo地址：<a href=\"http://panpanfish.com/myDemo/questionNaire/index.html\" title=\"微型调查问卷平台\">http://panpanfish.com/myDemo/questionNaire/index.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/\" title=\"微型调查问卷平台\">https://github.com/panpan040828/myDemo/blob/gh-pages/questionNaire/index.html</a></p>\n<h4 id=\"3-删除问卷\"><a href=\"#3-删除问卷\" class=\"headerlink\" title=\"3. 删除问卷\"></a>3. 删除问卷</h4><p>在问卷管理列表中点击某个问卷的删除按钮后，弹出一个弹出层，让用户二次确认是否删除该问卷，如果用户点击是，则删除掉该问卷</p>\n<h4 id=\"4-查看问卷\"><a href=\"#4-查看问卷\" class=\"headerlink\" title=\"4. 查看问卷\"></a>4. 查看问卷</h4><ul>\n<li>在问卷管理列表中点击查看问卷的按钮后，在新窗口中打开该问卷的页面，该页面是可供用户进行问卷填写的页面，在问卷未发布状态和已结束状态时，问卷提交是无效的。</li>\n<li>该页面在移动端需要进行良好的兼容支持</li>\n</ul>\n<h4 id=\"5-查看数据\"><a href=\"#5-查看数据\" class=\"headerlink\" title=\"5.查看数据\"></a>5.查看数据</h4><ul>\n<li>在问卷管理列表中点击查看数据按钮后，进入到一个数据报告页面，用图表形式呈现各个单选题和多选题的选择情况</li>\n<li>如设计稿中呈现，每一个问题在右侧用某种图表来呈现答题情况，自行选择合适的图表，设计稿中仅为示意，图表样式不需要和设计稿一致。推荐单选题使用饼状图，多选题使用条形图</li>\n<li>文本题用一个百分比图展现有效回答占比即可</li>\n<li>返回按钮点击后返回列表页面</li>\n<li>在项目中尝试模块化的方法及工具</li>\n<li>在项目中尝试CSS预处理工具</li>\n<li>在项目中尝试项目构建、打包工具</li>\n</ul>\n<h3 id=\"二-调查问卷平台的组成部分\"><a href=\"#二-调查问卷平台的组成部分\" class=\"headerlink\" title=\"二. 调查问卷平台的组成部分\"></a>二. 调查问卷平台的组成部分</h3><p>问卷列表<br>浮出层</p>\n<h3 id=\"三-做的过程中遇到的问题\"><a href=\"#三-做的过程中遇到的问题\" class=\"headerlink\" title=\"三. 做的过程中遇到的问题\"></a>三. 做的过程中遇到的问题</h3><h3 id=\"1-问卷列表页\"><a href=\"#1-问卷列表页\" class=\"headerlink\" title=\"1. 问卷列表页\"></a>1. 问卷列表页</h3><h4 id=\"a-两个模块之间如何通信\"><a href=\"#a-两个模块之间如何通信\" class=\"headerlink\" title=\"a. 两个模块之间如何通信\"></a>a. 两个模块之间如何通信</h4><p>eg:</p>\n<p>问卷管理列表页点击删除按钮会出现弹出窗，点击弹出窗上的确定按钮，需要删除问卷列表模块的对应的列表。</p>\n<p><strong>这里用到了浮出层模块和问卷列表模块之间的通信，这里是使用回调函数来实现的。</strong></p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在问卷列表模块：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除按钮绑定事件</span></span><br><span class=\"line\">G.Eve.addEvent(button[<span class=\"number\">1</span>],<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(event)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e = window.event || event;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> target = e.target || e.srcElement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> floatLayer = <span class=\"keyword\">new</span> FloatLayer(&#123;\t\t</span><br><span class=\"line\">\t\t\t\troot: G.Dom.$(<span class=\"string\">\"floatDiv\"</span>),</span><br><span class=\"line\">\t\t\t\tisMove: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t\tisZoom: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t\tfloatContent: &#123;</span><br><span class=\"line\">\t\t\t\t\ttitle: <span class=\"string\">\"提示\"</span>,</span><br><span class=\"line\">\t\t\t\t\tcontent: <span class=\"string\">\"确定要删除第\"</span> + (_i + <span class=\"number\">1</span>) + <span class=\"string\">\"份问卷吗？\"</span></span><br><span class=\"line\">\t\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\t_handler: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.deleteItem(target);</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t\t\t</span><br><span class=\"line\">\t\t &#125;);</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化，生成浮出层\t\t\t\t</span></span><br><span class=\"line\">\t\tfloatLayer.show();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//传入浮出层模块的回调函数deleteItem()</span></span><br><span class=\"line\">deleteItem: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(target)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.listBody.removeChild(target.parentNode.parentNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//浮出层模块的确定按钮添加事件</span></span><br><span class=\"line\">GLOBAL.Eve.addEvent(that._alertDiv.btnSure,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tthat.hide();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果给浮出层模块设定了回调函数，即config._handler不为空，那么久执行传进来的回调函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(that._handler) &#123;</span><br><span class=\"line\">\t\tthat._handler();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">```\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#### b. 复选框checkbox选中状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">对于复选框被选中，在**HTML**中有三种方法：</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"checkbox\"</span> checked=<span class=\"string\">\"checked\"</span> /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"checkbox\"</span> checked=<span class=\"string\">\"true\"</span> /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"checkbox\"</span> checked /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">但是在**js**中，只有一种方法是有效的：</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> btn = document.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//无论在HTML中使用什么方式，让复选框被选中，在这里只会输出true而不是checked</span></span><br><span class=\"line\">\tconsole.log(btn.checked);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#### c. 解决IE下不兼容html5标签的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">在这里主要是IE不兼容&lt;main&gt;标签引起了排版的错乱。</span><br><span class=\"line\"></span><br><span class=\"line\">在css中加上</span><br></pre></td></tr></table></figure>\n<p>main, article, aside, dialog, footer, header, section, footer, nav, figure, menu{ display:block }<br>```</p>\n"},{"layout":"post","title":"js模块化编程之requireJS","date":"2016-06-30T16:00:00.000Z","description":null,"_content":"###  一. 什么是requireJS？\n\njs的模块化规范有3种：commonJs、AMD、CMD\n\n\n### 二. requireJS的作用\n\n- 实现js文件的异步加载\n- 管理不同js文件之间的依赖，便于代码的编写和维护\n- 防止命名冲突\n\n### 三. requireJS的使用\n\n**首先，在官网上下载requireJS后放在自己的项目的js文件夹里**\n\nrequireJS官网：[http://requirejs.org/](http://requirejs.org/)\n\n**requireJS常用的方法：**\n\n<font color=\"red\">main.js主模块内使用require()</font>\n   \n    require([需要引入的模块], 回调函数(参数代表刚刚引入的模块){})；\n\n    eg:\n\n    require([\"jquery\"], function($) {\n    \n    });\n\n<font color=\"red\">使用require.config进行配置</font>\n\nrequire.config()接受一个配置对象\n\n    eg:\n    \n    require.config ({\n    \n    \t//定义基目录\n    \tbaseUrl: 'js/lib',\n    \t\n        //定义别名\n    \tpaths: {\n    \t\tjquery: \"jquery-1.11.3.min\"\n    \t},\n    \t\n    \t//加载不是使用AMD标准定义的模块\n    \t//引入underscore和backbone这两个库\n    \t//shim属性用来配置不兼容的模块\n    \tshim: {\n    \t\t'underscore': {\n    \t\t\texports: '_'\n    \t\t},\n    \t\t\n    \t\t'backbone': {\n    \t\t\tdeps: ['underscore', 'jquery'],\n    \t\t\texports: 'Backbone'\n    \t\t}\n    \t}\n    });\n\n\n<font color=\"red\">define：定义模块</font>\n   \n    define([需要引入的模块], function())\n\n    eg:\n\n    define(\"myModule\", [\"jquery\"], function(参数代表刚刚引入的模块) {\n    \treturn {\n    \t\t\n    \t}\n    });\n    通过return返回的函数，外面才能调用。\n    \n    其中模块的名字可以省略，因为AMD中的模块加载器可以将js文件名当做模块的名称。\n\n使用data-main=\"js/main\"来引入入口文件，入口文件指的是当requirejs加载完毕之后立即调用的js——>main.js。\n\n<script type=\"text/javascript\" src=\"js/require.js\" data-main=\"js/main\"></script>\n\n### 四. requirejs的原理\n\nrequirejs可以看成一个模块加载器\n\n1.我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。\n\n 2.通过我们在main.js里面定义的requirejs方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。\n\n 3.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。\n\n 4.由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者requirejs方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。\n\n 5.当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。\n\n 6.以上就是一个简单的流程。\n","source":"_posts/2016-07-01-js模块化编程之requireJS.md","raw":"---\nlayout: post\ntitle: js模块化编程之requireJS\ndate: 2016-07-01\ncategories: javaScript\ntags: [javaScript,模块化]\ndescription: \n---\n###  一. 什么是requireJS？\n\njs的模块化规范有3种：commonJs、AMD、CMD\n\n\n### 二. requireJS的作用\n\n- 实现js文件的异步加载\n- 管理不同js文件之间的依赖，便于代码的编写和维护\n- 防止命名冲突\n\n### 三. requireJS的使用\n\n**首先，在官网上下载requireJS后放在自己的项目的js文件夹里**\n\nrequireJS官网：[http://requirejs.org/](http://requirejs.org/)\n\n**requireJS常用的方法：**\n\n<font color=\"red\">main.js主模块内使用require()</font>\n   \n    require([需要引入的模块], 回调函数(参数代表刚刚引入的模块){})；\n\n    eg:\n\n    require([\"jquery\"], function($) {\n    \n    });\n\n<font color=\"red\">使用require.config进行配置</font>\n\nrequire.config()接受一个配置对象\n\n    eg:\n    \n    require.config ({\n    \n    \t//定义基目录\n    \tbaseUrl: 'js/lib',\n    \t\n        //定义别名\n    \tpaths: {\n    \t\tjquery: \"jquery-1.11.3.min\"\n    \t},\n    \t\n    \t//加载不是使用AMD标准定义的模块\n    \t//引入underscore和backbone这两个库\n    \t//shim属性用来配置不兼容的模块\n    \tshim: {\n    \t\t'underscore': {\n    \t\t\texports: '_'\n    \t\t},\n    \t\t\n    \t\t'backbone': {\n    \t\t\tdeps: ['underscore', 'jquery'],\n    \t\t\texports: 'Backbone'\n    \t\t}\n    \t}\n    });\n\n\n<font color=\"red\">define：定义模块</font>\n   \n    define([需要引入的模块], function())\n\n    eg:\n\n    define(\"myModule\", [\"jquery\"], function(参数代表刚刚引入的模块) {\n    \treturn {\n    \t\t\n    \t}\n    });\n    通过return返回的函数，外面才能调用。\n    \n    其中模块的名字可以省略，因为AMD中的模块加载器可以将js文件名当做模块的名称。\n\n使用data-main=\"js/main\"来引入入口文件，入口文件指的是当requirejs加载完毕之后立即调用的js——>main.js。\n\n<script type=\"text/javascript\" src=\"js/require.js\" data-main=\"js/main\"></script>\n\n### 四. requirejs的原理\n\nrequirejs可以看成一个模块加载器\n\n1.我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。\n\n 2.通过我们在main.js里面定义的requirejs方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。\n\n 3.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。\n\n 4.由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者requirejs方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。\n\n 5.当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。\n\n 6.以上就是一个简单的流程。\n","slug":"2016-07-01-js模块化编程之requireJS","published":1,"updated":"2016-08-27T14:25:54.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocje00b1d5u8q9ju9fvd","content":"<h3 id=\"一-什么是requireJS？\"><a href=\"#一-什么是requireJS？\" class=\"headerlink\" title=\"一. 什么是requireJS？\"></a>一. 什么是requireJS？</h3><p>js的模块化规范有3种：commonJs、AMD、CMD</p>\n<h3 id=\"二-requireJS的作用\"><a href=\"#二-requireJS的作用\" class=\"headerlink\" title=\"二. requireJS的作用\"></a>二. requireJS的作用</h3><ul>\n<li>实现js文件的异步加载</li>\n<li>管理不同js文件之间的依赖，便于代码的编写和维护</li>\n<li>防止命名冲突</li>\n</ul>\n<h3 id=\"三-requireJS的使用\"><a href=\"#三-requireJS的使用\" class=\"headerlink\" title=\"三. requireJS的使用\"></a>三. requireJS的使用</h3><p><strong>首先，在官网上下载requireJS后放在自己的项目的js文件夹里</strong></p>\n<p>requireJS官网：<a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">http://requirejs.org/</a></p>\n<p><strong>requireJS常用的方法：</strong></p>\n<font color=\"red\">main.js主模块内使用require()</font>\n\n<pre><code>require([需要引入的模块], 回调函数(参数代表刚刚引入的模块){})；\n\neg:\n\nrequire([&quot;jquery&quot;], function($) {\n\n});\n</code></pre><font color=\"red\">使用require.config进行配置</font>\n\n<p>require.config()接受一个配置对象</p>\n<pre><code>eg:\n\nrequire.config ({\n\n    //定义基目录\n    baseUrl: &apos;js/lib&apos;,\n\n    //定义别名\n    paths: {\n        jquery: &quot;jquery-1.11.3.min&quot;\n    },\n\n    //加载不是使用AMD标准定义的模块\n    //引入underscore和backbone这两个库\n    //shim属性用来配置不兼容的模块\n    shim: {\n        &apos;underscore&apos;: {\n            exports: &apos;_&apos;\n        },\n\n        &apos;backbone&apos;: {\n            deps: [&apos;underscore&apos;, &apos;jquery&apos;],\n            exports: &apos;Backbone&apos;\n        }\n    }\n});\n</code></pre><font color=\"red\">define：定义模块</font>\n\n<pre><code>define([需要引入的模块], function())\n\neg:\n\ndefine(&quot;myModule&quot;, [&quot;jquery&quot;], function(参数代表刚刚引入的模块) {\n    return {\n\n    }\n});\n通过return返回的函数，外面才能调用。\n\n其中模块的名字可以省略，因为AMD中的模块加载器可以将js文件名当做模块的名称。\n</code></pre><p>使用data-main=”js/main”来引入入口文件，入口文件指的是当requirejs加载完毕之后立即调用的js——&gt;main.js。</p>\n<script type=\"text/javascript\" src=\"js/require.js\" data-main=\"js/main\"></script>\n\n<h3 id=\"四-requirejs的原理\"><a href=\"#四-requirejs的原理\" class=\"headerlink\" title=\"四. requirejs的原理\"></a>四. requirejs的原理</h3><p>requirejs可以看成一个模块加载器</p>\n<p>1.我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。</p>\n<p> 2.通过我们在main.js里面定义的requirejs方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。</p>\n<p> 3.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。</p>\n<p> 4.由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者requirejs方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。</p>\n<p> 5.当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。</p>\n<p> 6.以上就是一个简单的流程。</p>\n","excerpt":"","more":"<h3 id=\"一-什么是requireJS？\"><a href=\"#一-什么是requireJS？\" class=\"headerlink\" title=\"一. 什么是requireJS？\"></a>一. 什么是requireJS？</h3><p>js的模块化规范有3种：commonJs、AMD、CMD</p>\n<h3 id=\"二-requireJS的作用\"><a href=\"#二-requireJS的作用\" class=\"headerlink\" title=\"二. requireJS的作用\"></a>二. requireJS的作用</h3><ul>\n<li>实现js文件的异步加载</li>\n<li>管理不同js文件之间的依赖，便于代码的编写和维护</li>\n<li>防止命名冲突</li>\n</ul>\n<h3 id=\"三-requireJS的使用\"><a href=\"#三-requireJS的使用\" class=\"headerlink\" title=\"三. requireJS的使用\"></a>三. requireJS的使用</h3><p><strong>首先，在官网上下载requireJS后放在自己的项目的js文件夹里</strong></p>\n<p>requireJS官网：<a href=\"http://requirejs.org/\">http://requirejs.org/</a></p>\n<p><strong>requireJS常用的方法：</strong></p>\n<font color=\"red\">main.js主模块内使用require()</font>\n\n<pre><code>require([需要引入的模块], 回调函数(参数代表刚刚引入的模块){})；\n\neg:\n\nrequire([&quot;jquery&quot;], function($) {\n\n});\n</code></pre><font color=\"red\">使用require.config进行配置</font>\n\n<p>require.config()接受一个配置对象</p>\n<pre><code>eg:\n\nrequire.config ({\n\n    //定义基目录\n    baseUrl: &apos;js/lib&apos;,\n\n    //定义别名\n    paths: {\n        jquery: &quot;jquery-1.11.3.min&quot;\n    },\n\n    //加载不是使用AMD标准定义的模块\n    //引入underscore和backbone这两个库\n    //shim属性用来配置不兼容的模块\n    shim: {\n        &apos;underscore&apos;: {\n            exports: &apos;_&apos;\n        },\n\n        &apos;backbone&apos;: {\n            deps: [&apos;underscore&apos;, &apos;jquery&apos;],\n            exports: &apos;Backbone&apos;\n        }\n    }\n});\n</code></pre><font color=\"red\">define：定义模块</font>\n\n<pre><code>define([需要引入的模块], function())\n\neg:\n\ndefine(&quot;myModule&quot;, [&quot;jquery&quot;], function(参数代表刚刚引入的模块) {\n    return {\n\n    }\n});\n通过return返回的函数，外面才能调用。\n\n其中模块的名字可以省略，因为AMD中的模块加载器可以将js文件名当做模块的名称。\n</code></pre><p>使用data-main=”js/main”来引入入口文件，入口文件指的是当requirejs加载完毕之后立即调用的js——&gt;main.js。</p>\n<script type=\"text/javascript\" src=\"js/require.js\" data-main=\"js/main\"></script>\n\n<h3 id=\"四-requirejs的原理\"><a href=\"#四-requirejs的原理\" class=\"headerlink\" title=\"四. requirejs的原理\"></a>四. requirejs的原理</h3><p>requirejs可以看成一个模块加载器</p>\n<p>1.我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。</p>\n<p> 2.通过我们在main.js里面定义的requirejs方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。</p>\n<p> 3.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。</p>\n<p> 4.由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者requirejs方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。</p>\n<p> 5.当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。</p>\n<p> 6.以上就是一个简单的流程。</p>\n"},{"layout":"post","title":"动态改变div的高度","date":"2016-07-14T16:00:00.000Z","description":null,"_content":"\n**动态改变div的高度，分两种情况：**\n\n- 知道变化后的div的高度\n- 不知道变化后的div的高度\n\n### 一. 知道变化后的div的高度\n\n这种情况比较简单，有2种实现方式：\n\n- 使用css3里的transition\n- 使用js里的setTimeout\n\n#### 1. 使用css3里的transition\n\n```js\neg:\n\n<div class=\"myDiv\" id=\"myDiv\"></div>\n<input id=\"btn\" type=\"button\" value=\"click\" />\n\n<style>\n\t.myDiv {\n\t\tbackground-color: red;\n\t\theight: 20px;\n\t\t//使用css3里的transition进行过渡\n\t    transition: height 2s;\n\t}\n</style>\n\n<script>\n\tvar div = document.getElementById(\"myDiv\");\n\tvar btn = document.getElementById(\"btn\");\n\n\tbtn.onclick = function() {\n\t\tdiv.style.height = 100px;\n\t}\n</script>\n```\n\n#### 2. 使用setTimeout\n\n```js\neg:\n\n<div class=\"myDiv\" id=\"myDiv\"></div>\n<input id=\"btn\" type=\"button\" value=\"click\" />\n\n<style>\n\t.myDiv {\n\t\tbackground-color: red;\n\t\theight: 20px;\n\t}\n</style>\n\n<script>\n\tvar div = document.getElementById(\"myDiv\");\n\tvar btn = document.getElementById(\"btn\");\n\t\n\tvar changeSize = function() {\n\t\tvar height = parseFloat(div.style.height);\n\t\theight += 10;\n\t\tif(parseFloat(div.style.height) <= 100) {\n\t\t\tdiv.style.height = height + \"px\";\n\t\t\tsetTimeout(function() {\n\t\t\t\tchangeSize();\n\t\t\t}, 100);\n\t\t}\n\t}\n\tbtn.onclick = function() {\n\t\tchangeSize();\n\t}\n</script>\n```\n\n### 二. 不知道变化后的div的高度\n\n如果不知道变化之后的高度的具体值，用css3里面的transition属性，是不起作用的。\n\n基本思想是首先用一个变量`height`保存外层div的初始高度，然后将外层div的高度设为auto，让其根据内层div的高度变化，再用一个变量`targetHeight`保存此时外层div的高度,将外层div的高度设置为`height`（初始值），然后利用setTimeout函数，进外层div高度设置为`targetHeight`，并设置transition属性。\n\n注意：这里一定要使用setTimeout函数，这样div的高度才会有一个变化的过程，transition属性才会起作用。\n\n```js\n<div id=\"box\" class=\"box\"></div>\n<input type=\"button\" id=\"button\" value=\"点击我\">\n\n<style>\n\t\n</style>\n\n<script>\n\t(function() {\n\n\t\tvar box = document.getElementById(\"box\"), \n\t\t\tbutton = document.getElementById(\"button\");\n\t\tbutton.onclick = function() {\t\t\t        \n\t\t\t // 随机高度内容    \n\t\t\t\n\t\t\t box.innerHTML = '<div class=\"in\" style=\"height:'+ Math.round(400 * Math.random()) +'px;\"></div>';\n\n\t\t\t //用变量height保存最开始的高度值 \n\t\t\t var height = document.defaultView.getComputedStyle(box,null).height;\n\t\t\t //让div随着内部元素的高度而变化\n\t\t\t box.style.height = \"auto\";\n\t\t\t //计算div现在的高度值\n\t\t\t var targetHeight = window.getComputedStyle(box).height;\n\n\t\t\t box.style.height = height;\n\t\t\t //这里的延时是为了让高度有一个变化的过程，这样transition才能起作用\n\t\t\t setTimeout(function() {\n\t\t\t      box.style.transition = \"height \"+\"3s\";\n\t\t\t      box.style.height = targetHeight;\n\t\t\t }, 10);\n\t\t };\n\t\t\t\n\t\t//初始化高度\n\t\tbox.style.height = \"0px\";    \n\t\t \n\t})();\n</script>\n```","source":"_posts/2016-07-15-动态改变div的高度.md","raw":"---\nlayout: post\ntitle: 动态改变div的高度\ndate: 2016-07-15\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n**动态改变div的高度，分两种情况：**\n\n- 知道变化后的div的高度\n- 不知道变化后的div的高度\n\n### 一. 知道变化后的div的高度\n\n这种情况比较简单，有2种实现方式：\n\n- 使用css3里的transition\n- 使用js里的setTimeout\n\n#### 1. 使用css3里的transition\n\n```js\neg:\n\n<div class=\"myDiv\" id=\"myDiv\"></div>\n<input id=\"btn\" type=\"button\" value=\"click\" />\n\n<style>\n\t.myDiv {\n\t\tbackground-color: red;\n\t\theight: 20px;\n\t\t//使用css3里的transition进行过渡\n\t    transition: height 2s;\n\t}\n</style>\n\n<script>\n\tvar div = document.getElementById(\"myDiv\");\n\tvar btn = document.getElementById(\"btn\");\n\n\tbtn.onclick = function() {\n\t\tdiv.style.height = 100px;\n\t}\n</script>\n```\n\n#### 2. 使用setTimeout\n\n```js\neg:\n\n<div class=\"myDiv\" id=\"myDiv\"></div>\n<input id=\"btn\" type=\"button\" value=\"click\" />\n\n<style>\n\t.myDiv {\n\t\tbackground-color: red;\n\t\theight: 20px;\n\t}\n</style>\n\n<script>\n\tvar div = document.getElementById(\"myDiv\");\n\tvar btn = document.getElementById(\"btn\");\n\t\n\tvar changeSize = function() {\n\t\tvar height = parseFloat(div.style.height);\n\t\theight += 10;\n\t\tif(parseFloat(div.style.height) <= 100) {\n\t\t\tdiv.style.height = height + \"px\";\n\t\t\tsetTimeout(function() {\n\t\t\t\tchangeSize();\n\t\t\t}, 100);\n\t\t}\n\t}\n\tbtn.onclick = function() {\n\t\tchangeSize();\n\t}\n</script>\n```\n\n### 二. 不知道变化后的div的高度\n\n如果不知道变化之后的高度的具体值，用css3里面的transition属性，是不起作用的。\n\n基本思想是首先用一个变量`height`保存外层div的初始高度，然后将外层div的高度设为auto，让其根据内层div的高度变化，再用一个变量`targetHeight`保存此时外层div的高度,将外层div的高度设置为`height`（初始值），然后利用setTimeout函数，进外层div高度设置为`targetHeight`，并设置transition属性。\n\n注意：这里一定要使用setTimeout函数，这样div的高度才会有一个变化的过程，transition属性才会起作用。\n\n```js\n<div id=\"box\" class=\"box\"></div>\n<input type=\"button\" id=\"button\" value=\"点击我\">\n\n<style>\n\t\n</style>\n\n<script>\n\t(function() {\n\n\t\tvar box = document.getElementById(\"box\"), \n\t\t\tbutton = document.getElementById(\"button\");\n\t\tbutton.onclick = function() {\t\t\t        \n\t\t\t // 随机高度内容    \n\t\t\t\n\t\t\t box.innerHTML = '<div class=\"in\" style=\"height:'+ Math.round(400 * Math.random()) +'px;\"></div>';\n\n\t\t\t //用变量height保存最开始的高度值 \n\t\t\t var height = document.defaultView.getComputedStyle(box,null).height;\n\t\t\t //让div随着内部元素的高度而变化\n\t\t\t box.style.height = \"auto\";\n\t\t\t //计算div现在的高度值\n\t\t\t var targetHeight = window.getComputedStyle(box).height;\n\n\t\t\t box.style.height = height;\n\t\t\t //这里的延时是为了让高度有一个变化的过程，这样transition才能起作用\n\t\t\t setTimeout(function() {\n\t\t\t      box.style.transition = \"height \"+\"3s\";\n\t\t\t      box.style.height = targetHeight;\n\t\t\t }, 10);\n\t\t };\n\t\t\t\n\t\t//初始化高度\n\t\tbox.style.height = \"0px\";    \n\t\t \n\t})();\n</script>\n```","slug":"2016-07-15-动态改变div的高度","published":1,"updated":"2016-07-16T14:03:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjg00b4d5u8gk6s7u1n","content":"<p><strong>动态改变div的高度，分两种情况：</strong></p>\n<ul>\n<li>知道变化后的div的高度</li>\n<li>不知道变化后的div的高度</li>\n</ul>\n<h3 id=\"一-知道变化后的div的高度\"><a href=\"#一-知道变化后的div的高度\" class=\"headerlink\" title=\"一. 知道变化后的div的高度\"></a>一. 知道变化后的div的高度</h3><p>这种情况比较简单，有2种实现方式：</p>\n<ul>\n<li>使用css3里的transition</li>\n<li>使用js里的setTimeout</li>\n</ul>\n<h4 id=\"1-使用css3里的transition\"><a href=\"#1-使用css3里的transition\" class=\"headerlink\" title=\"1. 使用css3里的transition\"></a>1. 使用css3里的transition</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"myDiv\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"click\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">\t.myDiv &#123;</span><br><span class=\"line\">\t\tbackground-color: red;</span><br><span class=\"line\">\t\theight: 20px;</span><br><span class=\"line\">\t\t//使用css3里的transition进行过渡</span><br><span class=\"line\">\t    transition: height 2s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tbtn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\tdiv.style.height = <span class=\"number\">100</span>px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用setTimeout\"><a href=\"#2-使用setTimeout\" class=\"headerlink\" title=\"2. 使用setTimeout\"></a>2. 使用setTimeout</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"myDiv\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"click\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.myDiv</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> changeSize = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> height = <span class=\"built_in\">parseFloat</span>(div.style.height);</span><br><span class=\"line\">\t\theight += <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">parseFloat</span>(div.style.height) &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">\t\t\tdiv.style.height = height + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tchangeSize();</span><br><span class=\"line\">\t\t\t&#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbtn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\tchangeSize();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-不知道变化后的div的高度\"><a href=\"#二-不知道变化后的div的高度\" class=\"headerlink\" title=\"二. 不知道变化后的div的高度\"></a>二. 不知道变化后的div的高度</h3><p>如果不知道变化之后的高度的具体值，用css3里面的transition属性，是不起作用的。</p>\n<p>基本思想是首先用一个变量<code>height</code>保存外层div的初始高度，然后将外层div的高度设为auto，让其根据内层div的高度变化，再用一个变量<code>targetHeight</code>保存此时外层div的高度,将外层div的高度设置为<code>height</code>（初始值），然后利用setTimeout函数，进外层div高度设置为<code>targetHeight</code>，并设置transition属性。</p>\n<p>注意：这里一定要使用setTimeout函数，这样div的高度才会有一个变化的过程，transition属性才会起作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"box\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"box\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">\"button\"</span> id=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"点击我\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> box = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"box\"</span>), </span><br><span class=\"line\">\t\t\tbutton = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"button\"</span>);</span><br><span class=\"line\">\t\tbutton.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;\t\t\t        </span><br><span class=\"line\">\t\t\t <span class=\"comment\">// 随机高度内容    </span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t box.innerHTML = <span class=\"string\">'&lt;div class=\"in\" style=\"height:'</span>+ <span class=\"built_in\">Math</span>.round(<span class=\"number\">400</span> * <span class=\"built_in\">Math</span>.random()) +<span class=\"string\">'px;\"&gt;&lt;/div&gt;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t <span class=\"comment\">//用变量height保存最开始的高度值 </span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">var</span> height = <span class=\"built_in\">document</span>.defaultView.getComputedStyle(box,<span class=\"literal\">null</span>).height;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">//让div随着内部元素的高度而变化</span></span><br><span class=\"line\">\t\t\t box.style.height = <span class=\"string\">\"auto\"</span>;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">//计算div现在的高度值</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">var</span> targetHeight = <span class=\"built_in\">window</span>.getComputedStyle(box).height;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t box.style.height = height;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">//这里的延时是为了让高度有一个变化的过程，这样transition才能起作用</span></span><br><span class=\"line\">\t\t\t setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t      box.style.transition = <span class=\"string\">\"height \"</span>+<span class=\"string\">\"3s\"</span>;</span><br><span class=\"line\">\t\t\t      box.style.height = targetHeight;</span><br><span class=\"line\">\t\t\t &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t &#125;;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化高度</span></span><br><span class=\"line\">\t\tbox.style.height = <span class=\"string\">\"0px\"</span>;    </span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t&#125;)();</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p><strong>动态改变div的高度，分两种情况：</strong></p>\n<ul>\n<li>知道变化后的div的高度</li>\n<li>不知道变化后的div的高度</li>\n</ul>\n<h3 id=\"一-知道变化后的div的高度\"><a href=\"#一-知道变化后的div的高度\" class=\"headerlink\" title=\"一. 知道变化后的div的高度\"></a>一. 知道变化后的div的高度</h3><p>这种情况比较简单，有2种实现方式：</p>\n<ul>\n<li>使用css3里的transition</li>\n<li>使用js里的setTimeout</li>\n</ul>\n<h4 id=\"1-使用css3里的transition\"><a href=\"#1-使用css3里的transition\" class=\"headerlink\" title=\"1. 使用css3里的transition\"></a>1. 使用css3里的transition</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"myDiv\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"click\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">\t.myDiv &#123;</span><br><span class=\"line\">\t\tbackground-color: red;</span><br><span class=\"line\">\t\theight: 20px;</span><br><span class=\"line\">\t\t//使用css3里的transition进行过渡</span><br><span class=\"line\">\t    transition: height 2s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tbtn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\tdiv.style.height = <span class=\"number\">100</span>px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用setTimeout\"><a href=\"#2-使用setTimeout\" class=\"headerlink\" title=\"2. 使用setTimeout\"></a>2. 使用setTimeout</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"myDiv\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myDiv\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;input id=<span class=\"string\">\"btn\"</span> type=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"click\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span><br><span class=\"line\">\t<span class=\"selector-class\">.myDiv</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> changeSize = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> height = <span class=\"built_in\">parseFloat</span>(div.style.height);</span><br><span class=\"line\">\t\theight += <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">parseFloat</span>(div.style.height) &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">\t\t\tdiv.style.height = height + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tchangeSize();</span><br><span class=\"line\">\t\t\t&#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbtn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\tchangeSize();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-不知道变化后的div的高度\"><a href=\"#二-不知道变化后的div的高度\" class=\"headerlink\" title=\"二. 不知道变化后的div的高度\"></a>二. 不知道变化后的div的高度</h3><p>如果不知道变化之后的高度的具体值，用css3里面的transition属性，是不起作用的。</p>\n<p>基本思想是首先用一个变量<code>height</code>保存外层div的初始高度，然后将外层div的高度设为auto，让其根据内层div的高度变化，再用一个变量<code>targetHeight</code>保存此时外层div的高度,将外层div的高度设置为<code>height</code>（初始值），然后利用setTimeout函数，进外层div高度设置为<code>targetHeight</code>，并设置transition属性。</p>\n<p>注意：这里一定要使用setTimeout函数，这样div的高度才会有一个变化的过程，transition属性才会起作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"box\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"box\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">\"button\"</span> id=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"点击我\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> box = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"box\"</span>), </span><br><span class=\"line\">\t\t\tbutton = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"button\"</span>);</span><br><span class=\"line\">\t\tbutton.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;\t\t\t        </span><br><span class=\"line\">\t\t\t <span class=\"comment\">// 随机高度内容    </span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t box.innerHTML = <span class=\"string\">'&lt;div class=\"in\" style=\"height:'</span>+ <span class=\"built_in\">Math</span>.round(<span class=\"number\">400</span> * <span class=\"built_in\">Math</span>.random()) +<span class=\"string\">'px;\"&gt;&lt;/div&gt;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t <span class=\"comment\">//用变量height保存最开始的高度值 </span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">var</span> height = <span class=\"built_in\">document</span>.defaultView.getComputedStyle(box,<span class=\"literal\">null</span>).height;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">//让div随着内部元素的高度而变化</span></span><br><span class=\"line\">\t\t\t box.style.height = <span class=\"string\">\"auto\"</span>;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">//计算div现在的高度值</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">var</span> targetHeight = <span class=\"built_in\">window</span>.getComputedStyle(box).height;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t box.style.height = height;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">//这里的延时是为了让高度有一个变化的过程，这样transition才能起作用</span></span><br><span class=\"line\">\t\t\t setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t      box.style.transition = <span class=\"string\">\"height \"</span>+<span class=\"string\">\"3s\"</span>;</span><br><span class=\"line\">\t\t\t      box.style.height = targetHeight;</span><br><span class=\"line\">\t\t\t &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t &#125;;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化高度</span></span><br><span class=\"line\">\t\tbox.style.height = <span class=\"string\">\"0px\"</span>;    </span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t&#125;)();</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"微型调查问卷平台组件——弹出层","date":"2016-07-05T16:00:00.000Z","description":null,"_content":"\n### 一. 弹出层\n\nDemo地址：[http://panpanfish.com/myDemo/research/floatdiv.html](http://panpanfish.com/myDemo/research/floatdiv.html \"弹出层\")\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js](https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js \"弹出层地址\")\n\n**需要实现的功能有：**\n\n- 弹出层的中心默认在屏幕正中\n- 当弹出层显示时，屏幕滚动时，弹出层始终保持位置固定在屏幕正中，不随屏幕滚动而变化位置。或者禁止页面在有弹出层出现时滚动\n- 当弹出层显示时，点击弹出层以外的部分，默认为关闭弹出层。可以实现一个半透明的遮罩来挡住弹出层外的部分\n- 弹出层的样式、内容和逻辑尽量解耦\n- 提供使用JavaScript控制弹出层展现和关闭的接口\n- 弹出层的窗口大小可以是一个默认固定值，也可以是随内容变化而自适应变化，也可以是通过接口参数进行调整，自行根据自己能力进行选择\n- 有能力的同学可以实现弹出层的拖拽移动浮出窗口位置以及拖拽边缘来放大缩小浮出窗口的功能\n\n#### 1. 做弹出层遇到的问题\n\n弹出层包括两个部分：灰色遮罩层、弹出框\n\n**(1) this指代的问题**\n\n`setTimeout`,`setTimeout`里面的回调函数内的**this指的是全局对象**，因此需要用`var that = this;`，再利用闭包，在`setTimeOut`里面使用`that`。\n\n关于this指代对象的问题，可看相关博客\n[http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/](http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/ \"js中的this对象\")\n\n**(2)css3中的transform、transition**\n\n    transform:translate(x,y);//x轴，y轴平移\n    \n    transform:scale(x,y);//放大或者缩小\n    \n    transition：需要变化的属性的名称 变化持续的时间 变化函数曲线 执行变化延迟的时间;\n    \n    transition: transform 200ms linear 0ms;\n\n**(3)选取某一个标签下class为myclass的标签**\n\n```\neg: p.myclass{}//中间不能空格\n```\n\n**(4) 监听事件，兼容浏览器**\n\n```\nif(mydiv.addEventListener) {\n\tmydiv.addEventListener(\"click\",fn);//fn为一个函数\n} else if(mydiv.attachEvent){\n\tmydiv.attachEvent(\"onclick\",fn);\n} else {\n\tmydiv['on' + 'click'] = fn;\n}\n```\n\n#### 2. 弹出层扩展的功能————拖拽\n\n注意：这个拖拽功能和HTML5里面的原生拖放是不一样的两种功能。\n\n**拖拽功能的好处：**\n\n在输入一些信息的时候，常需要查看页面上的一些内容，有了拖拽功能，就可以把弹出框移到一边，以便可以看到挡在下面的信息。\n\n##### (1)拖拽实现的基本思想\n\n拖拽中涉及到的事件有三个：**onmousedown**、**onmousemove**、**onmouseup**\n\n**鼠标按下：**onmousedown事件触发时，获取当前弹出框（绝对定位）的left、top值；获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY。\n\n<font color=\"red\">注意：鼠标按下时，监听鼠标按下事件的div是我们需要移动的div（这个例子里是弹出框的头部）</font>\n\n**鼠标移动：**onmousemove事件触发时，获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY；并减去鼠标按下时的event.clientX、event.clientY，计算出鼠标在横轴和纵轴分别走了多远；并将弹出框的left和top值分别移动相应的值。\n\n<font color=\"red\">注意：\n\n按照实现原理来讲，鼠标移动时，监听鼠标移动事件的div也是我们需要移动的div（这个例子里是弹出框的头部）\n\n但是，由于mousemove事件并不是连续的，不是每次移动1px鼠标指针，就会触发mousemove事件，而是windows会周期性检查mouse的位置来触发mousemove事件。</font>\n\n**因此会出现一个问题：**\n\n在一个比较小的dom对象执行拖拽时，鼠标已经拖动走了，但是div还停留在原地，如果这个时候，还是给当前的div绑定的mousemove事件，就会出现问题（因为鼠标下次移动就不是在当前的div对象上了）\n\n**如何解决这个问题：**\n\n\t**在ie中：**可以使用setCapture()和releaseCapture()来解决这个问题。\n\t\n\t- setCapture():某一对象调用这个函数之后，之后的所有的mouse事件都发送给这个对象（相当于在这个对象上执行事件，调用这个对象绑定的事件监听函数）\n\t- relaeaseCapture():某一对象调用这个函数之后，将mouse事件还回去。\n\t\n\t**在其他浏览器中：**让document代替div监听这个事件\n\n其实可以在所有浏览器中，都可以使用document代替div监听这个事件。\n\n**鼠标松开：**onmouseup事件触发时，获取当前弹出框（绝对定位）的left、top值。\n\n<font color=\"red\">注意：这个事件是在鼠标移动之后发生，因此会出现与鼠标事件一样的问题，解决方法如上。</font>\n\n##### (2)实现拖拽中遇到的问题\n\n**获取html元素样式**\n\n具体见[http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/](http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/ \"使用js获取元素样式方法\")\n\n<font color=\"red\">注意：</font>使用getComputedStyle时，获取的是计算后的样式，在这里使用了百分比和translate(-50%, -50%);但使用ie中的currentStyle.attr只能获取到百分比，而不是px值。\n\n**当前鼠标的在可见区域里的位置**\n\n\t鼠标事件的两个属性：`event.clientX`、`event.clientY`\n\n**鼠标变成可移动的光标**\n\n\t设置css中的cursor属性：\n\t\n\tn-resize\t此光标指示矩形框的边缘可被向上（北）移动。\n\ts-resize\t此光标指示矩形框的边缘可被向下移动（南）。\n\tw-resize  \t此光标指示矩形框的边缘可被向左移动（西）。\n\te-resize \t此光标指示矩形框的边缘可被向右（东）移动。\n\t\n\t\n\tse-resize\t此光标指示矩形框的边缘可被向下及向右移动（南/东）。\n\tsw-resize\t此光标指示矩形框的边缘可被向下及向左移动（南/西）。\n\tne-resize\t此光标指示矩形框的边缘可被向上及向右移动（北/东）。\n\tnw-resize\t此光标指示矩形框的边缘可被向上及向左移动（北/西）。\n\n**offsetTop,offsetParent**\n\nobj.offsetTop 指 obj 距离上方或上层控件的位置\n\n**offsetTop**返回的并不一定是元素距离浏览器上方的位置，如果元素的上层元素有定位的话，返回的是元素距离上层元素的位置。\n\n**offsetParent：**返回一个元素离其最近的已经定位的元素，如果没有就返回body\n\n**获取元素位置的函数：**\n\n```js\nvar GetPosition= function(obj) {\n\tvar left = 0;\n\tvar top = 0;\n\twhile(obj.offsetParent) {//如果obj的有最近的父级定位元素就继续\n\t\tleft += obj.offsetLeft;//累加\n\t\ttop += obj.offsetTop;\n\t\tobj = obj.offsetParent;//更新obj,继续判断新的obj是否还有父级定位，然后继续累加\n\t}\n\treturn {\n\t\t\t\"left\":left,\n\t\t\t\"top\":top\n\t\t\t}//返回json格式\n}\n```\n\n#### 3. 弹出框扩展功能————拉动弹出框边缘，使之扩大缩小\n\n由于拖拽和放大缩小的实现原理类似，我将此功能和上一功能封装到一个`dynamic`函数里了。\n\n注意：在鼠标按下监听事件，在鼠标释放时应该清除事件绑定，要不然会出现同时拖拽和放大缩小的问题。\n\n<font color=\"red\">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font>\n\n在看了几天书之后，觉得自己之前写的弹出框复用性太差，结构有些混乱，于是又重构了一下代码。\n\n### 三. 利用requireJS和Sass来优化弹出框组件\n\n#### 1. css部分\n\n其实css部分改动不多，毕竟是个小组件，就是把**颜色**和**弹出框的宽、高**用变量表示，便于以后修改。\n\n#### 2. js部分\n\n(1)将一些扩展的API和兼容浏览器的写法都封装到了一个base.js模块中，便于以后复用\n\nbase.js里的方法根据命名空间的不同，分为2类：\n\n\tDom：与Dom操作有关的方法\n\t\t—— $(node)：根据id名获取节点\n\t\t—— insertAfter(targetNode,newNode)：[在一个节点之后插入一个节点]\n\t\t—— getElementsByClassName(attr,root,tag)：通过className获取节点\n\t\t—— addClass(node,attr)：增加一个类\n\t\t—— removeClass(node,attr)：删除一个类\n\t\t—— getPoint(node)：获取某元素以浏览器左上角为原点的坐标\n\t\t—— getCssAttr(node,attr)：获取计算后的DOM属性功能\n\t\t\n\tEve：与事件有关的方法\n\t\t—— addEvent(node,type,fn)：绑定事件，兼容ie\n\t\t—— removeEvent(node,type,fn)：移除事件，兼容ie\n\n(2)将弹出框的js代码进行整理\n\n首先，由于一个页面可能出现有多处按钮点击出现弹出框，因此就不能通过id名获取激发弹出框的`<input>`\n\n<font color=\"red\">html修改如下：</font>\n\n\t<input class=\"float-button J_floatBtn\" type=\"submit\" value=\"弹出浮出层\" />\n\t通过className: J_floatBtn来获取input框，注意这样获取的是一个数组\n\n然后，将js中的内容抽离成两个js：common_floatDiv.js和main.js\n\n    common_floatDiv.js里面就是封装好的弹出框的一些属性和方法\n    main.js里面是和页面有关的\n\t\n\t通过main.js里面输入的参数可以定制相应的弹出框\n\n\t弹出框属性的注释：\n\n\tconfig = {\n\t\tpopupBtn: 点击显示弹出框的按钮,\n\t\troot: 弹出框外层包裹的div,\n\t\tisMove: 是否允许弹出框移动,\n\t\tisZoom: 是否允许弹出框扩大缩小,\n\t\tfloatContent: [{//弹出框的内容，分为标题和正文内容\n\t\t\ttitle: \"这是一个浮出层\",\n\t\t\tcontent: \"这是浮出层的内容\"\n\t\t},{\n\t\t\ttitle: \"这是第二个浮出层\",\n\t\t\tcontent: \"这是浮出层的内容\"\n\t\t}],\n\t\t_handler: 回调函数,\t\t\n\t}\n\n\t弹出框方法的注释：\n\n\tinit()：初始化弹出框的HTML结构\n\tinitContent()：初始化弹出框的内容\n\tinitSize()：初始化弹出框的宽高，还有在页面中的位置\n\tshow()：显示弹出框\n\thide()：隐藏弹出框\n\tdragDiv()：拖拽弹出框\n\tresizeDiv()：扩大缩小弹出框\n\tdynamic()：实现拖拽和扩大缩小需要用到的一个函数\n\t\t\n这里使用了requireJS，使页面结构更加清晰了。\n\n使用原型+构造函数的方式创建对象\n\n```js\n//common_floatDiv.js\nvar FloatLayer = function(config) {\n\t\tthis.popupBtn = config.popupBtn;\n\t\tthis.root = config.root;\n\t\tthis.isMove = config.isMove || true;\n\t\tthis.isZoom = config.isZoom || true;\t\n\t\tthis._handler = config._handler;\n\t\tthis.floatContent = config.floatContent;\n\t\tthis._alertDiv = {};\n\t\tthis.params = {\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tcurrentX: 0,\n\t\t\tcurrentY: 0,\n\t\t\tflag: false\n\t\t};\n\t\t\n\t\t//初始化，生成浮出层\n\t\tthis.init();\n\n\t\t//给按钮绑定事件\n\t\tvar that = this;\n\t\tfor(var i = 0; i < this.popupBtn.length; i++) {\n\t\t\t(function(_i) {\n\t\t\t\tGLOBAL.Eve.addEvent(that.popupBtn[_i],\"click\",function() {\n\t\t\t\t\tthat.initContent(_i);\n\t\t\t\t\tthat.initSize();\n\t\t\t\t\tthat.show(_i);\n\t\t\t\t});\n\n\t\t\t\tGLOBAL.Eve.addEvent(that.root,\"click\",function() {\n\t\t\t\t\tthat.hide(_i);\n\t\t\t\t});\n\n\t\t\t\t//阻止弹出框上的点击事件冒泡到浮出层上\n\t\t\t\tGLOBAL.Eve.addEvent(that.root.children[0],\"click\",function(e) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t});\t\n\n\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnSure,\"click\",function() {\n\t\t\t\t\tthat.hide(_i);\n\t\t\t\t});\n\n\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnCancel,\"click\",function() {\n\t\t\t\t\tthat.hide(_i);\n\t\t\t\t});\n\n\t\t\t\tif(that.isMove[_i] == true) {\n\t\t\t\t\tconsole.log(\"1\");\n\t\t\t\t\tthat.dragDiv();\n\t\t\t\t};\n\n\t\t\t\tif(that.isZoom[_i] == true) {\n\t\t\t\t\tthat.resizeDiv();\n\t\t\t\t\tconsole.log(\"2\");\n\t\t\t\t}\t\t\t\n\t\t\t})(i);\n\t\t}\n}\n\nFloatLayer.prototype = {\n\tconstructor: FloatLayer,\n\t//初始化\n\tinit: function() {\t\n\t\tvar alertDiv = document.createElement(\"div\");\n\t\talertDiv.className = \"alert\";\n\t\talertDiv.id = \"alertDiv\";\n\t\talertDiv.style.visibility = \"hidden\";\n\n\t\talertDiv.innerHTML = \"<div id='alertHeader' class='alert-header'>\" \n\t\t\t\t\t\t\t+ \"</div>\"\n\t\t\t\t\t\t\t+ \"<div id='alertBody' class='alert-body'>\"\n\t\t\t\t\t\t\t+ \"</div>\"\n\t\t\t\t\t\t\t+ \"<div class='alert-footer'>\"\n\t\t\t\t\t\t\t+ \"<input id='btnSure' class='alert-button' type='submit' value='确认' />\"\n\t\t\t\t\t\t\t+ \"<input id='btnCancel' class='alert-button' type='submit' value='取消' />\"\n\t\t\t\t\t\t\t+ \"</div>\"\n\t\t\t\t\t\t\t+ \"<div id='resizeRig' class='resize-right'></div>\"\n\t\t\t\t\t\t\t+ \"<div id='resizeBot' class='resize-bottom'></div>\"\n\t\t\t\t\t\t\t+ \"<div id='resizeDiv' class='resize-div'></div>\";\n\t\t\tthis.root.appendChild(alertDiv);\n\n\t\t\tvar elehead = GLOBAL.Dom.$(\"alertHeader\");\n\t\t\tvar elebody = GLOBAL.Dom.$(\"alertBody\");\n\t\t\tvar resizeRig = GLOBAL.Dom.$(\"resizeRig\");\n\t\t\tvar resizeBot = GLOBAL.Dom.$(\"resizeBot\");\n\t\t\tvar resizeDiv = GLOBAL.Dom.$(\"resizeDiv\");\n\t\t\tvar btnSure = GLOBAL.Dom.$(\"btnSure\");\n\t\t\tvar btnCancel = GLOBAL.Dom.$(\"btnCancel\");\n\t\t\tthis._alertDiv = {\n\t\t\t\twrap: alertDiv,\n\t\t\t\thead: elehead,\n\t\t\t\tbody: elebody,\n\t\t\t\tresizeRig: resizeRig,\n\t\t\t\tresizeBot: resizeBot,\n\t\t\t\tresizeDiv: resizeDiv,\n\t\t\t\tbtnSure: btnSure,\n\t\t\t\tbtnCancel: btnCancel\n\t\t\t};\t\t\t\n\t\t},\n\n\t\t//初始化弹出框的内容\n\t\tinitContent: function(i) {\n\t\t\tvar alertDiv = this._alertDiv;\n\t\t\tvar title = this.floatContent[i].title;\n\t\t\tvar content = this.floatContent[i].content;\t\t\t\n\t\t\talertDiv.head.innerHTML = title;\n\t\t\talertDiv.body.innerHTML = content;\t\t\n\t\t},\n\n\t\t//初始化弹出框的位置和长宽\n\t\tinitSize: function() {\n\t\t\tvar alertWrap = this._alertDiv.wrap;\n\t\t\talertWrap.style.left = \"\";\n\t\t\talertWrap.style.top = \"\";\n\t\t\talertWrap.style.width = \"\";\n\t\t\talertWrap.style.height = \"\";\n\t\t},\n\n\t\t//弹出框出现\n\t\tshow: function(i) {\t\n\t\t\tvar that = this.root;\t\t\n\t\t\tvar alert = this._alertDiv.wrap;\n\t\t\tthat.style.visibility = \"visible\";\n\t\t\tsetTimeout(function(){\n\t\t\t\talert.style.visibility = \"visible\";\n\t\t\t\talert.style.transition = \"transform 200ms linear\";\n\t\t\t\talert.style.transform = 'translate(-50%, -50%) scale(1,1)';\n\t\t\t}, 200);\t\t\t\t\n\t\t},\n\n\t\t//弹出框隐藏\n\t\thide: function(i) {\t\n\t\t\tvar that = this.root;\n\t\t\tvar alert = this._alertDiv.wrap;\t\n\t\t\talert.style.transition = \"transform 200ms linear\";\n\t\t\talert.style.transform = 'translate(-50%, -50%) scale(0,0)';\n\t\t\talert.style.visibility = \"hidden\";\t\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\tthat.style.visibility = \"hidden\";\n\t\t\t}, 200);\t\n\t\t},\n\n\t\t//定义一个方法，实现拖拽功能\n\t\tdragDiv: function() {\n\t\t\tvar needParams = this.params;\n\t\t\tvar alert = this._alertDiv.wrap;\n\t\t\tvar eleHead = this._alertDiv.head;\t\t\t\n\t\t\tthis.dynamic(eleHead,alert,\"left\",needParams);\n\t\t\tthis.dynamic(eleHead,alert,\"top\",needParams);\n\t\t\t\t\n\t\t},\n\n\t\t//实现扩大缩小弹出框\n\t\tresizeDiv: function() {\n\t\t\tvar needParams = this.params;\n\t\t\tvar alert = this._alertDiv.wrap;\n\t\t\tvar eleRig = this._alertDiv.resizeRig;\n\t\t\tvar eleBot = this._alertDiv.resizeBot;\n\t\t\tvar eleDiv = this._alertDiv.resizeDiv;\n\t\t\tthis.dynamic(eleRig,alert,\"width\",needParams);\n\t\t\tthis.dynamic(eleBot,alert,\"height\",needParams);\n\t\t\tthis.dynamic(eleDiv,alert,\"width\",needParams);\n\t\t\tthis.dynamic(eleDiv,alert,\"height\",needParams);\n\t\t},\n\n\t\t//实现拖拽和放大缩小功能\n\t\tdynamic: function(bar,target,attr,par) {\n\t\t\t\t\tvar startDrag = function(event) {\n\t\t\t\t\t\tvar e = event ? event: window.event;\n\t\t\t\t\t\tif(par.flag) {\n\t\t\t\t\t\t\t//鼠标在移动时，鼠标同时是处于按下的状态\n\t\t\t\t\t\t\tvar now = new Array(2), dis = new Array(2);\n\t\t\t\t\t\t\tnow[0] = e.clientX;\n\t\t\t\t\t\t\tnow[1] = e.clientY;\n\t\t\t\t\t\t\tdis[0] = now[0] - par.currentX;\n\t\t\t\t\t\t\tdis[1] = now[1] - par.currentY;\n\n\t\t\t\t\t\t\tif(attr == \"left\" || attr == \"width\") {\n\t\t\t\t\t\t\t\ttarget.style[attr] = parseInt(par[attr]) + dis[0] + \"px\";\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\ttarget.style[attr] = parseInt(par[attr]) + dis[1] + \"px\";\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar stopDrag = function() {\n\t\t\t\t\t\tpar.flag = false;//鼠标释放\n\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);//获取此时的样式值\n\t\t\t\t\t\tif(bar.releaseCapture) {\n\t\t\t\t\t\t\tbar.onmousemove = null;\n\t\t\t\t\t\t\tbar.onmouseup = null;\n\t\t\t\t\t\t\tbar.releaseCapture();\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(document,\"mousemove\",startDrag);\n\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(document,\"mouseup\",stopDrag);\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tGLOBAL.Eve.addEvent(bar, \"mousedown\", function(event) {\n\n\t\t\t\t\t\t//首先获取当前的Div的left，right值存放起来\n\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);\n\t\t\t\t\t\n\t\t\t\t\t\tvar e = event ? event: window.event;\n\t\t\t\t\t\t//鼠标按下，记录当前鼠标所在的位置\n\t\t\t\t\t\tpar.flag = true;\n\t\t\t\t\t\tpar.currentX = e.clientX;\n\t\t\t\t\t\tpar.currentY = e.clientY;\n\t\t\t\t\t\t//ie中才有setCapture\n\t\t\t\t\t\tif(bar.setCapture) {\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, \"mousemove\", startDrag);\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, \"mouseup\", stopDrag);\n\t\t\t\t\t\t\tbar.setCapture();\n\t\t\t\t\t\t}else {\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(document, \"mousemove\", startDrag);\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(document, \"mouseup\", stopDrag);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\t\t\n\t\t}\n\t}\n```\n\n","source":"_posts/2016-07-06-微型调查问卷平台组件——弹出层.md","raw":"---\nlayout: post\ntitle: 微型调查问卷平台组件——弹出层\ndate: 2016-07-06\ncategories: Demo\ntags: [javaScript]\ndescription: \n---\n\n### 一. 弹出层\n\nDemo地址：[http://panpanfish.com/myDemo/research/floatdiv.html](http://panpanfish.com/myDemo/research/floatdiv.html \"弹出层\")\n\n代码地址：[https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js](https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js \"弹出层地址\")\n\n**需要实现的功能有：**\n\n- 弹出层的中心默认在屏幕正中\n- 当弹出层显示时，屏幕滚动时，弹出层始终保持位置固定在屏幕正中，不随屏幕滚动而变化位置。或者禁止页面在有弹出层出现时滚动\n- 当弹出层显示时，点击弹出层以外的部分，默认为关闭弹出层。可以实现一个半透明的遮罩来挡住弹出层外的部分\n- 弹出层的样式、内容和逻辑尽量解耦\n- 提供使用JavaScript控制弹出层展现和关闭的接口\n- 弹出层的窗口大小可以是一个默认固定值，也可以是随内容变化而自适应变化，也可以是通过接口参数进行调整，自行根据自己能力进行选择\n- 有能力的同学可以实现弹出层的拖拽移动浮出窗口位置以及拖拽边缘来放大缩小浮出窗口的功能\n\n#### 1. 做弹出层遇到的问题\n\n弹出层包括两个部分：灰色遮罩层、弹出框\n\n**(1) this指代的问题**\n\n`setTimeout`,`setTimeout`里面的回调函数内的**this指的是全局对象**，因此需要用`var that = this;`，再利用闭包，在`setTimeOut`里面使用`that`。\n\n关于this指代对象的问题，可看相关博客\n[http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/](http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/ \"js中的this对象\")\n\n**(2)css3中的transform、transition**\n\n    transform:translate(x,y);//x轴，y轴平移\n    \n    transform:scale(x,y);//放大或者缩小\n    \n    transition：需要变化的属性的名称 变化持续的时间 变化函数曲线 执行变化延迟的时间;\n    \n    transition: transform 200ms linear 0ms;\n\n**(3)选取某一个标签下class为myclass的标签**\n\n```\neg: p.myclass{}//中间不能空格\n```\n\n**(4) 监听事件，兼容浏览器**\n\n```\nif(mydiv.addEventListener) {\n\tmydiv.addEventListener(\"click\",fn);//fn为一个函数\n} else if(mydiv.attachEvent){\n\tmydiv.attachEvent(\"onclick\",fn);\n} else {\n\tmydiv['on' + 'click'] = fn;\n}\n```\n\n#### 2. 弹出层扩展的功能————拖拽\n\n注意：这个拖拽功能和HTML5里面的原生拖放是不一样的两种功能。\n\n**拖拽功能的好处：**\n\n在输入一些信息的时候，常需要查看页面上的一些内容，有了拖拽功能，就可以把弹出框移到一边，以便可以看到挡在下面的信息。\n\n##### (1)拖拽实现的基本思想\n\n拖拽中涉及到的事件有三个：**onmousedown**、**onmousemove**、**onmouseup**\n\n**鼠标按下：**onmousedown事件触发时，获取当前弹出框（绝对定位）的left、top值；获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY。\n\n<font color=\"red\">注意：鼠标按下时，监听鼠标按下事件的div是我们需要移动的div（这个例子里是弹出框的头部）</font>\n\n**鼠标移动：**onmousemove事件触发时，获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY；并减去鼠标按下时的event.clientX、event.clientY，计算出鼠标在横轴和纵轴分别走了多远；并将弹出框的left和top值分别移动相应的值。\n\n<font color=\"red\">注意：\n\n按照实现原理来讲，鼠标移动时，监听鼠标移动事件的div也是我们需要移动的div（这个例子里是弹出框的头部）\n\n但是，由于mousemove事件并不是连续的，不是每次移动1px鼠标指针，就会触发mousemove事件，而是windows会周期性检查mouse的位置来触发mousemove事件。</font>\n\n**因此会出现一个问题：**\n\n在一个比较小的dom对象执行拖拽时，鼠标已经拖动走了，但是div还停留在原地，如果这个时候，还是给当前的div绑定的mousemove事件，就会出现问题（因为鼠标下次移动就不是在当前的div对象上了）\n\n**如何解决这个问题：**\n\n\t**在ie中：**可以使用setCapture()和releaseCapture()来解决这个问题。\n\t\n\t- setCapture():某一对象调用这个函数之后，之后的所有的mouse事件都发送给这个对象（相当于在这个对象上执行事件，调用这个对象绑定的事件监听函数）\n\t- relaeaseCapture():某一对象调用这个函数之后，将mouse事件还回去。\n\t\n\t**在其他浏览器中：**让document代替div监听这个事件\n\n其实可以在所有浏览器中，都可以使用document代替div监听这个事件。\n\n**鼠标松开：**onmouseup事件触发时，获取当前弹出框（绝对定位）的left、top值。\n\n<font color=\"red\">注意：这个事件是在鼠标移动之后发生，因此会出现与鼠标事件一样的问题，解决方法如上。</font>\n\n##### (2)实现拖拽中遇到的问题\n\n**获取html元素样式**\n\n具体见[http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/](http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/ \"使用js获取元素样式方法\")\n\n<font color=\"red\">注意：</font>使用getComputedStyle时，获取的是计算后的样式，在这里使用了百分比和translate(-50%, -50%);但使用ie中的currentStyle.attr只能获取到百分比，而不是px值。\n\n**当前鼠标的在可见区域里的位置**\n\n\t鼠标事件的两个属性：`event.clientX`、`event.clientY`\n\n**鼠标变成可移动的光标**\n\n\t设置css中的cursor属性：\n\t\n\tn-resize\t此光标指示矩形框的边缘可被向上（北）移动。\n\ts-resize\t此光标指示矩形框的边缘可被向下移动（南）。\n\tw-resize  \t此光标指示矩形框的边缘可被向左移动（西）。\n\te-resize \t此光标指示矩形框的边缘可被向右（东）移动。\n\t\n\t\n\tse-resize\t此光标指示矩形框的边缘可被向下及向右移动（南/东）。\n\tsw-resize\t此光标指示矩形框的边缘可被向下及向左移动（南/西）。\n\tne-resize\t此光标指示矩形框的边缘可被向上及向右移动（北/东）。\n\tnw-resize\t此光标指示矩形框的边缘可被向上及向左移动（北/西）。\n\n**offsetTop,offsetParent**\n\nobj.offsetTop 指 obj 距离上方或上层控件的位置\n\n**offsetTop**返回的并不一定是元素距离浏览器上方的位置，如果元素的上层元素有定位的话，返回的是元素距离上层元素的位置。\n\n**offsetParent：**返回一个元素离其最近的已经定位的元素，如果没有就返回body\n\n**获取元素位置的函数：**\n\n```js\nvar GetPosition= function(obj) {\n\tvar left = 0;\n\tvar top = 0;\n\twhile(obj.offsetParent) {//如果obj的有最近的父级定位元素就继续\n\t\tleft += obj.offsetLeft;//累加\n\t\ttop += obj.offsetTop;\n\t\tobj = obj.offsetParent;//更新obj,继续判断新的obj是否还有父级定位，然后继续累加\n\t}\n\treturn {\n\t\t\t\"left\":left,\n\t\t\t\"top\":top\n\t\t\t}//返回json格式\n}\n```\n\n#### 3. 弹出框扩展功能————拉动弹出框边缘，使之扩大缩小\n\n由于拖拽和放大缩小的实现原理类似，我将此功能和上一功能封装到一个`dynamic`函数里了。\n\n注意：在鼠标按下监听事件，在鼠标释放时应该清除事件绑定，要不然会出现同时拖拽和放大缩小的问题。\n\n<font color=\"red\">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font>\n\n在看了几天书之后，觉得自己之前写的弹出框复用性太差，结构有些混乱，于是又重构了一下代码。\n\n### 三. 利用requireJS和Sass来优化弹出框组件\n\n#### 1. css部分\n\n其实css部分改动不多，毕竟是个小组件，就是把**颜色**和**弹出框的宽、高**用变量表示，便于以后修改。\n\n#### 2. js部分\n\n(1)将一些扩展的API和兼容浏览器的写法都封装到了一个base.js模块中，便于以后复用\n\nbase.js里的方法根据命名空间的不同，分为2类：\n\n\tDom：与Dom操作有关的方法\n\t\t—— $(node)：根据id名获取节点\n\t\t—— insertAfter(targetNode,newNode)：[在一个节点之后插入一个节点]\n\t\t—— getElementsByClassName(attr,root,tag)：通过className获取节点\n\t\t—— addClass(node,attr)：增加一个类\n\t\t—— removeClass(node,attr)：删除一个类\n\t\t—— getPoint(node)：获取某元素以浏览器左上角为原点的坐标\n\t\t—— getCssAttr(node,attr)：获取计算后的DOM属性功能\n\t\t\n\tEve：与事件有关的方法\n\t\t—— addEvent(node,type,fn)：绑定事件，兼容ie\n\t\t—— removeEvent(node,type,fn)：移除事件，兼容ie\n\n(2)将弹出框的js代码进行整理\n\n首先，由于一个页面可能出现有多处按钮点击出现弹出框，因此就不能通过id名获取激发弹出框的`<input>`\n\n<font color=\"red\">html修改如下：</font>\n\n\t<input class=\"float-button J_floatBtn\" type=\"submit\" value=\"弹出浮出层\" />\n\t通过className: J_floatBtn来获取input框，注意这样获取的是一个数组\n\n然后，将js中的内容抽离成两个js：common_floatDiv.js和main.js\n\n    common_floatDiv.js里面就是封装好的弹出框的一些属性和方法\n    main.js里面是和页面有关的\n\t\n\t通过main.js里面输入的参数可以定制相应的弹出框\n\n\t弹出框属性的注释：\n\n\tconfig = {\n\t\tpopupBtn: 点击显示弹出框的按钮,\n\t\troot: 弹出框外层包裹的div,\n\t\tisMove: 是否允许弹出框移动,\n\t\tisZoom: 是否允许弹出框扩大缩小,\n\t\tfloatContent: [{//弹出框的内容，分为标题和正文内容\n\t\t\ttitle: \"这是一个浮出层\",\n\t\t\tcontent: \"这是浮出层的内容\"\n\t\t},{\n\t\t\ttitle: \"这是第二个浮出层\",\n\t\t\tcontent: \"这是浮出层的内容\"\n\t\t}],\n\t\t_handler: 回调函数,\t\t\n\t}\n\n\t弹出框方法的注释：\n\n\tinit()：初始化弹出框的HTML结构\n\tinitContent()：初始化弹出框的内容\n\tinitSize()：初始化弹出框的宽高，还有在页面中的位置\n\tshow()：显示弹出框\n\thide()：隐藏弹出框\n\tdragDiv()：拖拽弹出框\n\tresizeDiv()：扩大缩小弹出框\n\tdynamic()：实现拖拽和扩大缩小需要用到的一个函数\n\t\t\n这里使用了requireJS，使页面结构更加清晰了。\n\n使用原型+构造函数的方式创建对象\n\n```js\n//common_floatDiv.js\nvar FloatLayer = function(config) {\n\t\tthis.popupBtn = config.popupBtn;\n\t\tthis.root = config.root;\n\t\tthis.isMove = config.isMove || true;\n\t\tthis.isZoom = config.isZoom || true;\t\n\t\tthis._handler = config._handler;\n\t\tthis.floatContent = config.floatContent;\n\t\tthis._alertDiv = {};\n\t\tthis.params = {\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tcurrentX: 0,\n\t\t\tcurrentY: 0,\n\t\t\tflag: false\n\t\t};\n\t\t\n\t\t//初始化，生成浮出层\n\t\tthis.init();\n\n\t\t//给按钮绑定事件\n\t\tvar that = this;\n\t\tfor(var i = 0; i < this.popupBtn.length; i++) {\n\t\t\t(function(_i) {\n\t\t\t\tGLOBAL.Eve.addEvent(that.popupBtn[_i],\"click\",function() {\n\t\t\t\t\tthat.initContent(_i);\n\t\t\t\t\tthat.initSize();\n\t\t\t\t\tthat.show(_i);\n\t\t\t\t});\n\n\t\t\t\tGLOBAL.Eve.addEvent(that.root,\"click\",function() {\n\t\t\t\t\tthat.hide(_i);\n\t\t\t\t});\n\n\t\t\t\t//阻止弹出框上的点击事件冒泡到浮出层上\n\t\t\t\tGLOBAL.Eve.addEvent(that.root.children[0],\"click\",function(e) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t});\t\n\n\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnSure,\"click\",function() {\n\t\t\t\t\tthat.hide(_i);\n\t\t\t\t});\n\n\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnCancel,\"click\",function() {\n\t\t\t\t\tthat.hide(_i);\n\t\t\t\t});\n\n\t\t\t\tif(that.isMove[_i] == true) {\n\t\t\t\t\tconsole.log(\"1\");\n\t\t\t\t\tthat.dragDiv();\n\t\t\t\t};\n\n\t\t\t\tif(that.isZoom[_i] == true) {\n\t\t\t\t\tthat.resizeDiv();\n\t\t\t\t\tconsole.log(\"2\");\n\t\t\t\t}\t\t\t\n\t\t\t})(i);\n\t\t}\n}\n\nFloatLayer.prototype = {\n\tconstructor: FloatLayer,\n\t//初始化\n\tinit: function() {\t\n\t\tvar alertDiv = document.createElement(\"div\");\n\t\talertDiv.className = \"alert\";\n\t\talertDiv.id = \"alertDiv\";\n\t\talertDiv.style.visibility = \"hidden\";\n\n\t\talertDiv.innerHTML = \"<div id='alertHeader' class='alert-header'>\" \n\t\t\t\t\t\t\t+ \"</div>\"\n\t\t\t\t\t\t\t+ \"<div id='alertBody' class='alert-body'>\"\n\t\t\t\t\t\t\t+ \"</div>\"\n\t\t\t\t\t\t\t+ \"<div class='alert-footer'>\"\n\t\t\t\t\t\t\t+ \"<input id='btnSure' class='alert-button' type='submit' value='确认' />\"\n\t\t\t\t\t\t\t+ \"<input id='btnCancel' class='alert-button' type='submit' value='取消' />\"\n\t\t\t\t\t\t\t+ \"</div>\"\n\t\t\t\t\t\t\t+ \"<div id='resizeRig' class='resize-right'></div>\"\n\t\t\t\t\t\t\t+ \"<div id='resizeBot' class='resize-bottom'></div>\"\n\t\t\t\t\t\t\t+ \"<div id='resizeDiv' class='resize-div'></div>\";\n\t\t\tthis.root.appendChild(alertDiv);\n\n\t\t\tvar elehead = GLOBAL.Dom.$(\"alertHeader\");\n\t\t\tvar elebody = GLOBAL.Dom.$(\"alertBody\");\n\t\t\tvar resizeRig = GLOBAL.Dom.$(\"resizeRig\");\n\t\t\tvar resizeBot = GLOBAL.Dom.$(\"resizeBot\");\n\t\t\tvar resizeDiv = GLOBAL.Dom.$(\"resizeDiv\");\n\t\t\tvar btnSure = GLOBAL.Dom.$(\"btnSure\");\n\t\t\tvar btnCancel = GLOBAL.Dom.$(\"btnCancel\");\n\t\t\tthis._alertDiv = {\n\t\t\t\twrap: alertDiv,\n\t\t\t\thead: elehead,\n\t\t\t\tbody: elebody,\n\t\t\t\tresizeRig: resizeRig,\n\t\t\t\tresizeBot: resizeBot,\n\t\t\t\tresizeDiv: resizeDiv,\n\t\t\t\tbtnSure: btnSure,\n\t\t\t\tbtnCancel: btnCancel\n\t\t\t};\t\t\t\n\t\t},\n\n\t\t//初始化弹出框的内容\n\t\tinitContent: function(i) {\n\t\t\tvar alertDiv = this._alertDiv;\n\t\t\tvar title = this.floatContent[i].title;\n\t\t\tvar content = this.floatContent[i].content;\t\t\t\n\t\t\talertDiv.head.innerHTML = title;\n\t\t\talertDiv.body.innerHTML = content;\t\t\n\t\t},\n\n\t\t//初始化弹出框的位置和长宽\n\t\tinitSize: function() {\n\t\t\tvar alertWrap = this._alertDiv.wrap;\n\t\t\talertWrap.style.left = \"\";\n\t\t\talertWrap.style.top = \"\";\n\t\t\talertWrap.style.width = \"\";\n\t\t\talertWrap.style.height = \"\";\n\t\t},\n\n\t\t//弹出框出现\n\t\tshow: function(i) {\t\n\t\t\tvar that = this.root;\t\t\n\t\t\tvar alert = this._alertDiv.wrap;\n\t\t\tthat.style.visibility = \"visible\";\n\t\t\tsetTimeout(function(){\n\t\t\t\talert.style.visibility = \"visible\";\n\t\t\t\talert.style.transition = \"transform 200ms linear\";\n\t\t\t\talert.style.transform = 'translate(-50%, -50%) scale(1,1)';\n\t\t\t}, 200);\t\t\t\t\n\t\t},\n\n\t\t//弹出框隐藏\n\t\thide: function(i) {\t\n\t\t\tvar that = this.root;\n\t\t\tvar alert = this._alertDiv.wrap;\t\n\t\t\talert.style.transition = \"transform 200ms linear\";\n\t\t\talert.style.transform = 'translate(-50%, -50%) scale(0,0)';\n\t\t\talert.style.visibility = \"hidden\";\t\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\tthat.style.visibility = \"hidden\";\n\t\t\t}, 200);\t\n\t\t},\n\n\t\t//定义一个方法，实现拖拽功能\n\t\tdragDiv: function() {\n\t\t\tvar needParams = this.params;\n\t\t\tvar alert = this._alertDiv.wrap;\n\t\t\tvar eleHead = this._alertDiv.head;\t\t\t\n\t\t\tthis.dynamic(eleHead,alert,\"left\",needParams);\n\t\t\tthis.dynamic(eleHead,alert,\"top\",needParams);\n\t\t\t\t\n\t\t},\n\n\t\t//实现扩大缩小弹出框\n\t\tresizeDiv: function() {\n\t\t\tvar needParams = this.params;\n\t\t\tvar alert = this._alertDiv.wrap;\n\t\t\tvar eleRig = this._alertDiv.resizeRig;\n\t\t\tvar eleBot = this._alertDiv.resizeBot;\n\t\t\tvar eleDiv = this._alertDiv.resizeDiv;\n\t\t\tthis.dynamic(eleRig,alert,\"width\",needParams);\n\t\t\tthis.dynamic(eleBot,alert,\"height\",needParams);\n\t\t\tthis.dynamic(eleDiv,alert,\"width\",needParams);\n\t\t\tthis.dynamic(eleDiv,alert,\"height\",needParams);\n\t\t},\n\n\t\t//实现拖拽和放大缩小功能\n\t\tdynamic: function(bar,target,attr,par) {\n\t\t\t\t\tvar startDrag = function(event) {\n\t\t\t\t\t\tvar e = event ? event: window.event;\n\t\t\t\t\t\tif(par.flag) {\n\t\t\t\t\t\t\t//鼠标在移动时，鼠标同时是处于按下的状态\n\t\t\t\t\t\t\tvar now = new Array(2), dis = new Array(2);\n\t\t\t\t\t\t\tnow[0] = e.clientX;\n\t\t\t\t\t\t\tnow[1] = e.clientY;\n\t\t\t\t\t\t\tdis[0] = now[0] - par.currentX;\n\t\t\t\t\t\t\tdis[1] = now[1] - par.currentY;\n\n\t\t\t\t\t\t\tif(attr == \"left\" || attr == \"width\") {\n\t\t\t\t\t\t\t\ttarget.style[attr] = parseInt(par[attr]) + dis[0] + \"px\";\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\ttarget.style[attr] = parseInt(par[attr]) + dis[1] + \"px\";\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar stopDrag = function() {\n\t\t\t\t\t\tpar.flag = false;//鼠标释放\n\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);//获取此时的样式值\n\t\t\t\t\t\tif(bar.releaseCapture) {\n\t\t\t\t\t\t\tbar.onmousemove = null;\n\t\t\t\t\t\t\tbar.onmouseup = null;\n\t\t\t\t\t\t\tbar.releaseCapture();\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(document,\"mousemove\",startDrag);\n\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(document,\"mouseup\",stopDrag);\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tGLOBAL.Eve.addEvent(bar, \"mousedown\", function(event) {\n\n\t\t\t\t\t\t//首先获取当前的Div的left，right值存放起来\n\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);\n\t\t\t\t\t\n\t\t\t\t\t\tvar e = event ? event: window.event;\n\t\t\t\t\t\t//鼠标按下，记录当前鼠标所在的位置\n\t\t\t\t\t\tpar.flag = true;\n\t\t\t\t\t\tpar.currentX = e.clientX;\n\t\t\t\t\t\tpar.currentY = e.clientY;\n\t\t\t\t\t\t//ie中才有setCapture\n\t\t\t\t\t\tif(bar.setCapture) {\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, \"mousemove\", startDrag);\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, \"mouseup\", stopDrag);\n\t\t\t\t\t\t\tbar.setCapture();\n\t\t\t\t\t\t}else {\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(document, \"mousemove\", startDrag);\n\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(document, \"mouseup\", stopDrag);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\t\t\n\t\t}\n\t}\n```\n\n","slug":"2016-07-06-微型调查问卷平台组件——弹出层","published":1,"updated":"2016-09-13T03:16:40.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjh00b7d5u8uh6l6xq4","content":"<h3 id=\"一-弹出层\"><a href=\"#一-弹出层\" class=\"headerlink\" title=\"一. 弹出层\"></a>一. 弹出层</h3><p>Demo地址：<a href=\"http://panpanfish.com/myDemo/research/floatdiv.html\" title=\"弹出层\">http://panpanfish.com/myDemo/research/floatdiv.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js\" title=\"弹出层地址\" target=\"_blank\" rel=\"external\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js</a></p>\n<p><strong>需要实现的功能有：</strong></p>\n<ul>\n<li>弹出层的中心默认在屏幕正中</li>\n<li>当弹出层显示时，屏幕滚动时，弹出层始终保持位置固定在屏幕正中，不随屏幕滚动而变化位置。或者禁止页面在有弹出层出现时滚动</li>\n<li>当弹出层显示时，点击弹出层以外的部分，默认为关闭弹出层。可以实现一个半透明的遮罩来挡住弹出层外的部分</li>\n<li>弹出层的样式、内容和逻辑尽量解耦</li>\n<li>提供使用JavaScript控制弹出层展现和关闭的接口</li>\n<li>弹出层的窗口大小可以是一个默认固定值，也可以是随内容变化而自适应变化，也可以是通过接口参数进行调整，自行根据自己能力进行选择</li>\n<li>有能力的同学可以实现弹出层的拖拽移动浮出窗口位置以及拖拽边缘来放大缩小浮出窗口的功能</li>\n</ul>\n<h4 id=\"1-做弹出层遇到的问题\"><a href=\"#1-做弹出层遇到的问题\" class=\"headerlink\" title=\"1. 做弹出层遇到的问题\"></a>1. 做弹出层遇到的问题</h4><p>弹出层包括两个部分：灰色遮罩层、弹出框</p>\n<p><strong>(1) this指代的问题</strong></p>\n<p><code>setTimeout</code>,<code>setTimeout</code>里面的回调函数内的<strong>this指的是全局对象</strong>，因此需要用<code>var that = this;</code>，再利用闭包，在<code>setTimeOut</code>里面使用<code>that</code>。</p>\n<p>关于this指代对象的问题，可看相关博客<br><a href=\"http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/\" title=\"js中的this对象\">http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/</a></p>\n<p><strong>(2)css3中的transform、transition</strong></p>\n<pre><code>transform:translate(x,y);//x轴，y轴平移\n\ntransform:scale(x,y);//放大或者缩小\n\ntransition：需要变化的属性的名称 变化持续的时间 变化函数曲线 执行变化延迟的时间;\n\ntransition: transform 200ms linear 0ms;\n</code></pre><p><strong>(3)选取某一个标签下class为myclass的标签</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: <span class=\"selector-tag\">p</span>.myclass&#123;&#125;<span class=\"comment\">//中间不能空格</span></span><br></pre></td></tr></table></figure>\n<p><strong>(4) 监听事件，兼容浏览器</strong></p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mydiv.addEventListener) &#123;</span><br><span class=\"line\">\tmydiv.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">fn</span>)</span>;<span class=\"comment\">//fn为一个函数</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mydiv.attachEvent)&#123;</span><br><span class=\"line\">\tmydiv.attachEvent(<span class=\"string\">\"onclick\"</span>,<span class=\"function\"><span class=\"keyword\">fn</span>)</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tmydiv['on' + 'click'] = <span class=\"function\"><span class=\"keyword\">fn</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-弹出层扩展的功能————拖拽\"><a href=\"#2-弹出层扩展的功能————拖拽\" class=\"headerlink\" title=\"2. 弹出层扩展的功能————拖拽\"></a>2. 弹出层扩展的功能————拖拽</h4><p>注意：这个拖拽功能和HTML5里面的原生拖放是不一样的两种功能。</p>\n<p><strong>拖拽功能的好处：</strong></p>\n<p>在输入一些信息的时候，常需要查看页面上的一些内容，有了拖拽功能，就可以把弹出框移到一边，以便可以看到挡在下面的信息。</p>\n<h5 id=\"1-拖拽实现的基本思想\"><a href=\"#1-拖拽实现的基本思想\" class=\"headerlink\" title=\"(1)拖拽实现的基本思想\"></a>(1)拖拽实现的基本思想</h5><p>拖拽中涉及到的事件有三个：<strong>onmousedown</strong>、<strong>onmousemove</strong>、<strong>onmouseup</strong></p>\n<p><strong>鼠标按下：</strong>onmousedown事件触发时，获取当前弹出框（绝对定位）的left、top值；获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY。</p>\n<font color=\"red\">注意：鼠标按下时，监听鼠标按下事件的div是我们需要移动的div（这个例子里是弹出框的头部）</font>\n\n<p><strong>鼠标移动：</strong>onmousemove事件触发时，获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY；并减去鼠标按下时的event.clientX、event.clientY，计算出鼠标在横轴和纵轴分别走了多远；并将弹出框的left和top值分别移动相应的值。</p>\n<font color=\"red\">注意：<br><br>按照实现原理来讲，鼠标移动时，监听鼠标移动事件的div也是我们需要移动的div（这个例子里是弹出框的头部）<br><br>但是，由于mousemove事件并不是连续的，不是每次移动1px鼠标指针，就会触发mousemove事件，而是windows会周期性检查mouse的位置来触发mousemove事件。</font>\n\n<p><strong>因此会出现一个问题：</strong></p>\n<p>在一个比较小的dom对象执行拖拽时，鼠标已经拖动走了，但是div还停留在原地，如果这个时候，还是给当前的div绑定的mousemove事件，就会出现问题（因为鼠标下次移动就不是在当前的div对象上了）</p>\n<p><strong>如何解决这个问题：</strong></p>\n<pre><code>**在ie中：**可以使用setCapture()和releaseCapture()来解决这个问题。\n\n- setCapture():某一对象调用这个函数之后，之后的所有的mouse事件都发送给这个对象（相当于在这个对象上执行事件，调用这个对象绑定的事件监听函数）\n- relaeaseCapture():某一对象调用这个函数之后，将mouse事件还回去。\n\n**在其他浏览器中：**让document代替div监听这个事件\n</code></pre><p>其实可以在所有浏览器中，都可以使用document代替div监听这个事件。</p>\n<p><strong>鼠标松开：</strong>onmouseup事件触发时，获取当前弹出框（绝对定位）的left、top值。</p>\n<font color=\"red\">注意：这个事件是在鼠标移动之后发生，因此会出现与鼠标事件一样的问题，解决方法如上。</font>\n\n<h5 id=\"2-实现拖拽中遇到的问题\"><a href=\"#2-实现拖拽中遇到的问题\" class=\"headerlink\" title=\"(2)实现拖拽中遇到的问题\"></a>(2)实现拖拽中遇到的问题</h5><p><strong>获取html元素样式</strong></p>\n<p>具体见<a href=\"http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/\" title=\"使用js获取元素样式方法\">http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/</a></p>\n<font color=\"red\">注意：</font>使用getComputedStyle时，获取的是计算后的样式，在这里使用了百分比和translate(-50%, -50%);但使用ie中的currentStyle.attr只能获取到百分比，而不是px值。<br><br><strong>当前鼠标的在可见区域里的位置</strong><br><br>    鼠标事件的两个属性：<code>event.clientX</code>、<code>event.clientY</code><br><br><strong>鼠标变成可移动的光标</strong><br><br>    设置css中的cursor属性：<br><br>    n-resize    此光标指示矩形框的边缘可被向上（北）移动。<br>    s-resize    此光标指示矩形框的边缘可被向下移动（南）。<br>    w-resize      此光标指示矩形框的边缘可被向左移动（西）。<br>    e-resize     此光标指示矩形框的边缘可被向右（东）移动。<br><br><br>    se-resize    此光标指示矩形框的边缘可被向下及向右移动（南/东）。<br>    sw-resize    此光标指示矩形框的边缘可被向下及向左移动（南/西）。<br>    ne-resize    此光标指示矩形框的边缘可被向上及向右移动（北/东）。<br>    nw-resize    此光标指示矩形框的边缘可被向上及向左移动（北/西）。<br><br><strong>offsetTop,offsetParent</strong><br><br>obj.offsetTop 指 obj 距离上方或上层控件的位置<br><br><strong>offsetTop</strong>返回的并不一定是元素距离浏览器上方的位置，如果元素的上层元素有定位的话，返回的是元素距离上层元素的位置。<br><br><strong>offsetParent：</strong>返回一个元素离其最近的已经定位的元素，如果没有就返回body<br><br><strong>获取元素位置的函数：</strong><br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GetPosition= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> top = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(obj.offsetParent) &#123;<span class=\"comment\">//如果obj的有最近的父级定位元素就继续</span></span><br><span class=\"line\">\t\tleft += obj.offsetLeft;<span class=\"comment\">//累加</span></span><br><span class=\"line\">\t\ttop += obj.offsetTop;</span><br><span class=\"line\">\t\tobj = obj.offsetParent;<span class=\"comment\">//更新obj,继续判断新的obj是否还有父级定位，然后继续累加</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"left\"</span>:left,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"top\"</span>:top</span><br><span class=\"line\">\t\t\t&#125;<span class=\"comment\">//返回json格式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 3. 弹出框扩展功能————拉动弹出框边缘，使之扩大缩小<br><br>由于拖拽和放大缩小的实现原理类似，我将此功能和上一功能封装到一个<code>dynamic</code>函数里了。<br><br>注意：在鼠标按下监听事件，在鼠标释放时应该清除事件绑定，要不然会出现同时拖拽和放大缩小的问题。<br><br><font color=\"red\">—————————————————————————————————————————————————————————-</font>\n\n<p>在看了几天书之后，觉得自己之前写的弹出框复用性太差，结构有些混乱，于是又重构了一下代码。</p>\n<h3 id=\"三-利用requireJS和Sass来优化弹出框组件\"><a href=\"#三-利用requireJS和Sass来优化弹出框组件\" class=\"headerlink\" title=\"三. 利用requireJS和Sass来优化弹出框组件\"></a>三. 利用requireJS和Sass来优化弹出框组件</h3><h4 id=\"1-css部分\"><a href=\"#1-css部分\" class=\"headerlink\" title=\"1. css部分\"></a>1. css部分</h4><p>其实css部分改动不多，毕竟是个小组件，就是把<strong>颜色</strong>和<strong>弹出框的宽、高</strong>用变量表示，便于以后修改。</p>\n<h4 id=\"2-js部分\"><a href=\"#2-js部分\" class=\"headerlink\" title=\"2. js部分\"></a>2. js部分</h4><p>(1)将一些扩展的API和兼容浏览器的写法都封装到了一个base.js模块中，便于以后复用</p>\n<p>base.js里的方法根据命名空间的不同，分为2类：</p>\n<pre><code>Dom：与Dom操作有关的方法\n    —— $(node)：根据id名获取节点\n    —— insertAfter(targetNode,newNode)：[在一个节点之后插入一个节点]\n    —— getElementsByClassName(attr,root,tag)：通过className获取节点\n    —— addClass(node,attr)：增加一个类\n    —— removeClass(node,attr)：删除一个类\n    —— getPoint(node)：获取某元素以浏览器左上角为原点的坐标\n    —— getCssAttr(node,attr)：获取计算后的DOM属性功能\n\nEve：与事件有关的方法\n    —— addEvent(node,type,fn)：绑定事件，兼容ie\n    —— removeEvent(node,type,fn)：移除事件，兼容ie\n</code></pre><p>(2)将弹出框的js代码进行整理</p>\n<p>首先，由于一个页面可能出现有多处按钮点击出现弹出框，因此就不能通过id名获取激发弹出框的<code>&lt;input&gt;</code></p>\n<font color=\"red\">html修改如下：</font>\n\n<pre><code>&lt;input class=&quot;float-button J_floatBtn&quot; type=&quot;submit&quot; value=&quot;弹出浮出层&quot; /&gt;\n通过className: J_floatBtn来获取input框，注意这样获取的是一个数组\n</code></pre><p>然后，将js中的内容抽离成两个js：common_floatDiv.js和main.js</p>\n<pre><code>common_floatDiv.js里面就是封装好的弹出框的一些属性和方法\nmain.js里面是和页面有关的\n\n通过main.js里面输入的参数可以定制相应的弹出框\n\n弹出框属性的注释：\n\nconfig = {\n    popupBtn: 点击显示弹出框的按钮,\n    root: 弹出框外层包裹的div,\n    isMove: 是否允许弹出框移动,\n    isZoom: 是否允许弹出框扩大缩小,\n    floatContent: [{//弹出框的内容，分为标题和正文内容\n        title: &quot;这是一个浮出层&quot;,\n        content: &quot;这是浮出层的内容&quot;\n    },{\n        title: &quot;这是第二个浮出层&quot;,\n        content: &quot;这是浮出层的内容&quot;\n    }],\n    _handler: 回调函数,        \n}\n\n弹出框方法的注释：\n\ninit()：初始化弹出框的HTML结构\ninitContent()：初始化弹出框的内容\ninitSize()：初始化弹出框的宽高，还有在页面中的位置\nshow()：显示弹出框\nhide()：隐藏弹出框\ndragDiv()：拖拽弹出框\nresizeDiv()：扩大缩小弹出框\ndynamic()：实现拖拽和扩大缩小需要用到的一个函数\n</code></pre><p>这里使用了requireJS，使页面结构更加清晰了。</p>\n<p>使用原型+构造函数的方式创建对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//common_floatDiv.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FloatLayer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.popupBtn = config.popupBtn;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.root = config.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.isMove = config.isMove || <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.isZoom = config.isZoom || <span class=\"literal\">true</span>;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._handler = config._handler;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.floatContent = config.floatContent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._alertDiv = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.params = &#123;</span><br><span class=\"line\">\t\t\tleft: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\ttop: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\twidth: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\theight: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\tcurrentX: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\tcurrentY: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\tflag: <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化，生成浮出层</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.init();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//给按钮绑定事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.popupBtn.length; i++) &#123;</span><br><span class=\"line\">\t\t\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_i</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that.popupBtn[_i],<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.initContent(_i);</span><br><span class=\"line\">\t\t\t\t\tthat.initSize();</span><br><span class=\"line\">\t\t\t\t\tthat.show(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that.root,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.hide(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//阻止弹出框上的点击事件冒泡到浮出层上</span></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that.root.children[<span class=\"number\">0</span>],<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\te.stopPropagation();</span><br><span class=\"line\">\t\t\t\t&#125;);\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnSure,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.hide(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnCancel,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.hide(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(that.isMove[_i] == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">\t\t\t\t\tthat.dragDiv();</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(that.isZoom[_i] == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tthat.resizeDiv();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t</span><br><span class=\"line\">\t\t\t&#125;)(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FloatLayer.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: FloatLayer,</span><br><span class=\"line\">\t//初始化</span><br><span class=\"line\">\tinit: function() &#123;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> alertDiv = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">\t\talertDiv.className = <span class=\"string\">\"alert\"</span>;</span><br><span class=\"line\">\t\talertDiv.id = <span class=\"string\">\"alertDiv\"</span>;</span><br><span class=\"line\">\t\talertDiv.style.visibility = <span class=\"string\">\"hidden\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\talertDiv.innerHTML = <span class=\"string\">\"&lt;div id='alertHeader' class='alert-header'&gt;\"</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='alertBody' class='alert-body'&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div class='alert-footer'&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;input id='btnSure' class='alert-button' type='submit' value='确认' /&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;input id='btnCancel' class='alert-button' type='submit' value='取消' /&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='resizeRig' class='resize-right'&gt;&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='resizeBot' class='resize-bottom'&gt;&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='resizeDiv' class='resize-div'&gt;&lt;/div&gt;\"</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.root.appendChild(alertDiv);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> elehead = GLOBAL.Dom.$(<span class=\"string\">\"alertHeader\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> elebody = GLOBAL.Dom.$(<span class=\"string\">\"alertBody\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> resizeRig = GLOBAL.Dom.$(<span class=\"string\">\"resizeRig\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> resizeBot = GLOBAL.Dom.$(<span class=\"string\">\"resizeBot\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> resizeDiv = GLOBAL.Dom.$(<span class=\"string\">\"resizeDiv\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> btnSure = GLOBAL.Dom.$(<span class=\"string\">\"btnSure\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> btnCancel = GLOBAL.Dom.$(<span class=\"string\">\"btnCancel\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>._alertDiv = &#123;</span><br><span class=\"line\">\t\t\t\twrap: alertDiv,</span><br><span class=\"line\">\t\t\t\thead: elehead,</span><br><span class=\"line\">\t\t\t\tbody: elebody,</span><br><span class=\"line\">\t\t\t\tresizeRig: resizeRig,</span><br><span class=\"line\">\t\t\t\tresizeBot: resizeBot,</span><br><span class=\"line\">\t\t\t\tresizeDiv: resizeDiv,</span><br><span class=\"line\">\t\t\t\tbtnSure: btnSure,</span><br><span class=\"line\">\t\t\t\tbtnCancel: btnCancel</span><br><span class=\"line\">\t\t\t&#125;;\t\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化弹出框的内容</span></span><br><span class=\"line\">\t\tinitContent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alertDiv = <span class=\"keyword\">this</span>._alertDiv;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> title = <span class=\"keyword\">this</span>.floatContent[i].title;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> content = <span class=\"keyword\">this</span>.floatContent[i].content;\t\t\t</span><br><span class=\"line\">\t\t\talertDiv.head.innerHTML = title;</span><br><span class=\"line\">\t\t\talertDiv.body.innerHTML = content;\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化弹出框的位置和长宽</span></span><br><span class=\"line\">\t\tinitSize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alertWrap = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\talertWrap.style.left = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t\talertWrap.style.top = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t\talertWrap.style.width = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t\talertWrap.style.height = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出框出现</span></span><br><span class=\"line\">\t\tshow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>.root;\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\tthat.style.visibility = <span class=\"string\">\"visible\"</span>;</span><br><span class=\"line\">\t\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\talert.style.visibility = <span class=\"string\">\"visible\"</span>;</span><br><span class=\"line\">\t\t\t\talert.style.transition = <span class=\"string\">\"transform 200ms linear\"</span>;</span><br><span class=\"line\">\t\t\t\talert.style.transform = <span class=\"string\">'translate(-50%, -50%) scale(1,1)'</span>;</span><br><span class=\"line\">\t\t\t&#125;, <span class=\"number\">200</span>);\t\t\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出框隐藏</span></span><br><span class=\"line\">\t\thide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;\t</span><br><span class=\"line\">\t\t\talert.style.transition = <span class=\"string\">\"transform 200ms linear\"</span>;</span><br><span class=\"line\">\t\t\talert.style.transform = <span class=\"string\">'translate(-50%, -50%) scale(0,0)'</span>;</span><br><span class=\"line\">\t\t\talert.style.visibility = <span class=\"string\">\"hidden\"</span>;\t\t\t\t</span><br><span class=\"line\">\t\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\tthat.style.visibility = <span class=\"string\">\"hidden\"</span>;</span><br><span class=\"line\">\t\t\t&#125;, <span class=\"number\">200</span>);\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//定义一个方法，实现拖拽功能</span></span><br><span class=\"line\">\t\tdragDiv: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> needParams = <span class=\"keyword\">this</span>.params;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleHead = <span class=\"keyword\">this</span>._alertDiv.head;\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleHead,alert,<span class=\"string\">\"left\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleHead,alert,<span class=\"string\">\"top\"</span>,needParams);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//实现扩大缩小弹出框</span></span><br><span class=\"line\">\t\tresizeDiv: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> needParams = <span class=\"keyword\">this</span>.params;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleRig = <span class=\"keyword\">this</span>._alertDiv.resizeRig;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleBot = <span class=\"keyword\">this</span>._alertDiv.resizeBot;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleDiv = <span class=\"keyword\">this</span>._alertDiv.resizeDiv;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleRig,alert,<span class=\"string\">\"width\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleBot,alert,<span class=\"string\">\"height\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleDiv,alert,<span class=\"string\">\"width\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleDiv,alert,<span class=\"string\">\"height\"</span>,needParams);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//实现拖拽和放大缩小功能</span></span><br><span class=\"line\">\t\tdynamic: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bar,target,attr,par</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> startDrag = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> e = event ? event: <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(par.flag) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//鼠标在移动时，鼠标同时是处于按下的状态</span></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>), dis = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\tnow[<span class=\"number\">0</span>] = e.clientX;</span><br><span class=\"line\">\t\t\t\t\t\t\tnow[<span class=\"number\">1</span>] = e.clientY;</span><br><span class=\"line\">\t\t\t\t\t\t\tdis[<span class=\"number\">0</span>] = now[<span class=\"number\">0</span>] - par.currentX;</span><br><span class=\"line\">\t\t\t\t\t\t\tdis[<span class=\"number\">1</span>] = now[<span class=\"number\">1</span>] - par.currentY;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(attr == <span class=\"string\">\"left\"</span> || attr == <span class=\"string\">\"width\"</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\ttarget.style[attr] = <span class=\"built_in\">parseInt</span>(par[attr]) + dis[<span class=\"number\">0</span>] + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\ttarget.style[attr] = <span class=\"built_in\">parseInt</span>(par[attr]) + dis[<span class=\"number\">1</span>] + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> stopDrag = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\tpar.flag = <span class=\"literal\">false</span>;<span class=\"comment\">//鼠标释放</span></span><br><span class=\"line\">\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);<span class=\"comment\">//获取此时的样式值</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(bar.releaseCapture) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.onmousemove = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.onmouseup = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.releaseCapture();</span><br><span class=\"line\">\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(<span class=\"built_in\">document</span>,<span class=\"string\">\"mousemove\"</span>,startDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(<span class=\"built_in\">document</span>,<span class=\"string\">\"mouseup\"</span>,stopDrag);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tGLOBAL.Eve.addEvent(bar, <span class=\"string\">\"mousedown\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//首先获取当前的Div的left，right值存放起来</span></span><br><span class=\"line\">\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> e = event ? event: <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//鼠标按下，记录当前鼠标所在的位置</span></span><br><span class=\"line\">\t\t\t\t\t\tpar.flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\tpar.currentX = e.clientX;</span><br><span class=\"line\">\t\t\t\t\t\tpar.currentY = e.clientY;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//ie中才有setCapture</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(bar.setCapture) &#123;\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, <span class=\"string\">\"mousemove\"</span>, startDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, <span class=\"string\">\"mouseup\"</span>, stopDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.setCapture();</span><br><span class=\"line\">\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(<span class=\"built_in\">document</span>, <span class=\"string\">\"mousemove\"</span>, startDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(<span class=\"built_in\">document</span>, <span class=\"string\">\"mouseup\"</span>, stopDrag);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;);\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-弹出层\"><a href=\"#一-弹出层\" class=\"headerlink\" title=\"一. 弹出层\"></a>一. 弹出层</h3><p>Demo地址：<a href=\"http://panpanfish.com/myDemo/research/floatdiv.html\" title=\"弹出层\">http://panpanfish.com/myDemo/research/floatdiv.html</a></p>\n<p>代码地址：<a href=\"https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js\" title=\"弹出层地址\">https://github.com/panpan040828/myDemo/blob/gh-pages/research/js/floatDiv/common_floatDiv.js</a></p>\n<p><strong>需要实现的功能有：</strong></p>\n<ul>\n<li>弹出层的中心默认在屏幕正中</li>\n<li>当弹出层显示时，屏幕滚动时，弹出层始终保持位置固定在屏幕正中，不随屏幕滚动而变化位置。或者禁止页面在有弹出层出现时滚动</li>\n<li>当弹出层显示时，点击弹出层以外的部分，默认为关闭弹出层。可以实现一个半透明的遮罩来挡住弹出层外的部分</li>\n<li>弹出层的样式、内容和逻辑尽量解耦</li>\n<li>提供使用JavaScript控制弹出层展现和关闭的接口</li>\n<li>弹出层的窗口大小可以是一个默认固定值，也可以是随内容变化而自适应变化，也可以是通过接口参数进行调整，自行根据自己能力进行选择</li>\n<li>有能力的同学可以实现弹出层的拖拽移动浮出窗口位置以及拖拽边缘来放大缩小浮出窗口的功能</li>\n</ul>\n<h4 id=\"1-做弹出层遇到的问题\"><a href=\"#1-做弹出层遇到的问题\" class=\"headerlink\" title=\"1. 做弹出层遇到的问题\"></a>1. 做弹出层遇到的问题</h4><p>弹出层包括两个部分：灰色遮罩层、弹出框</p>\n<p><strong>(1) this指代的问题</strong></p>\n<p><code>setTimeout</code>,<code>setTimeout</code>里面的回调函数内的<strong>this指的是全局对象</strong>，因此需要用<code>var that = this;</code>，再利用闭包，在<code>setTimeOut</code>里面使用<code>that</code>。</p>\n<p>关于this指代对象的问题，可看相关博客<br><a href=\"http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/\" title=\"js中的this对象\">http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/</a></p>\n<p><strong>(2)css3中的transform、transition</strong></p>\n<pre><code>transform:translate(x,y);//x轴，y轴平移\n\ntransform:scale(x,y);//放大或者缩小\n\ntransition：需要变化的属性的名称 变化持续的时间 变化函数曲线 执行变化延迟的时间;\n\ntransition: transform 200ms linear 0ms;\n</code></pre><p><strong>(3)选取某一个标签下class为myclass的标签</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: <span class=\"selector-tag\">p</span>.myclass&#123;&#125;<span class=\"comment\">//中间不能空格</span></span><br></pre></td></tr></table></figure>\n<p><strong>(4) 监听事件，兼容浏览器</strong></p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mydiv.addEventListener) &#123;</span><br><span class=\"line\">\tmydiv.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">fn</span>)</span>;<span class=\"comment\">//fn为一个函数</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mydiv.attachEvent)&#123;</span><br><span class=\"line\">\tmydiv.attachEvent(<span class=\"string\">\"onclick\"</span>,<span class=\"function\"><span class=\"keyword\">fn</span>)</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tmydiv['on' + 'click'] = <span class=\"function\"><span class=\"keyword\">fn</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-弹出层扩展的功能————拖拽\"><a href=\"#2-弹出层扩展的功能————拖拽\" class=\"headerlink\" title=\"2. 弹出层扩展的功能————拖拽\"></a>2. 弹出层扩展的功能————拖拽</h4><p>注意：这个拖拽功能和HTML5里面的原生拖放是不一样的两种功能。</p>\n<p><strong>拖拽功能的好处：</strong></p>\n<p>在输入一些信息的时候，常需要查看页面上的一些内容，有了拖拽功能，就可以把弹出框移到一边，以便可以看到挡在下面的信息。</p>\n<h5 id=\"1-拖拽实现的基本思想\"><a href=\"#1-拖拽实现的基本思想\" class=\"headerlink\" title=\"(1)拖拽实现的基本思想\"></a>(1)拖拽实现的基本思想</h5><p>拖拽中涉及到的事件有三个：<strong>onmousedown</strong>、<strong>onmousemove</strong>、<strong>onmouseup</strong></p>\n<p><strong>鼠标按下：</strong>onmousedown事件触发时，获取当前弹出框（绝对定位）的left、top值；获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY。</p>\n<font color=\"red\">注意：鼠标按下时，监听鼠标按下事件的div是我们需要移动的div（这个例子里是弹出框的头部）</font>\n\n<p><strong>鼠标移动：</strong>onmousemove事件触发时，获取鼠标的在可见区域内距离浏览器左边、上边的距离：event.clientX、event.clientY；并减去鼠标按下时的event.clientX、event.clientY，计算出鼠标在横轴和纵轴分别走了多远；并将弹出框的left和top值分别移动相应的值。</p>\n<font color=\"red\">注意：<br><br>按照实现原理来讲，鼠标移动时，监听鼠标移动事件的div也是我们需要移动的div（这个例子里是弹出框的头部）<br><br>但是，由于mousemove事件并不是连续的，不是每次移动1px鼠标指针，就会触发mousemove事件，而是windows会周期性检查mouse的位置来触发mousemove事件。</font>\n\n<p><strong>因此会出现一个问题：</strong></p>\n<p>在一个比较小的dom对象执行拖拽时，鼠标已经拖动走了，但是div还停留在原地，如果这个时候，还是给当前的div绑定的mousemove事件，就会出现问题（因为鼠标下次移动就不是在当前的div对象上了）</p>\n<p><strong>如何解决这个问题：</strong></p>\n<pre><code>**在ie中：**可以使用setCapture()和releaseCapture()来解决这个问题。\n\n- setCapture():某一对象调用这个函数之后，之后的所有的mouse事件都发送给这个对象（相当于在这个对象上执行事件，调用这个对象绑定的事件监听函数）\n- relaeaseCapture():某一对象调用这个函数之后，将mouse事件还回去。\n\n**在其他浏览器中：**让document代替div监听这个事件\n</code></pre><p>其实可以在所有浏览器中，都可以使用document代替div监听这个事件。</p>\n<p><strong>鼠标松开：</strong>onmouseup事件触发时，获取当前弹出框（绝对定位）的left、top值。</p>\n<font color=\"red\">注意：这个事件是在鼠标移动之后发生，因此会出现与鼠标事件一样的问题，解决方法如上。</font>\n\n<h5 id=\"2-实现拖拽中遇到的问题\"><a href=\"#2-实现拖拽中遇到的问题\" class=\"headerlink\" title=\"(2)实现拖拽中遇到的问题\"></a>(2)实现拖拽中遇到的问题</h5><p><strong>获取html元素样式</strong></p>\n<p>具体见<a href=\"http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/\" title=\"使用js获取元素样式方法\">http://panpanfish.com/2016/06/07/2016-06-07-js%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F/</a></p>\n<font color=\"red\">注意：</font>使用getComputedStyle时，获取的是计算后的样式，在这里使用了百分比和translate(-50%, -50%);但使用ie中的currentStyle.attr只能获取到百分比，而不是px值。<br><br><strong>当前鼠标的在可见区域里的位置</strong><br><br>    鼠标事件的两个属性：<code>event.clientX</code>、<code>event.clientY</code><br><br><strong>鼠标变成可移动的光标</strong><br><br>    设置css中的cursor属性：<br><br>    n-resize    此光标指示矩形框的边缘可被向上（北）移动。<br>    s-resize    此光标指示矩形框的边缘可被向下移动（南）。<br>    w-resize      此光标指示矩形框的边缘可被向左移动（西）。<br>    e-resize     此光标指示矩形框的边缘可被向右（东）移动。<br><br><br>    se-resize    此光标指示矩形框的边缘可被向下及向右移动（南/东）。<br>    sw-resize    此光标指示矩形框的边缘可被向下及向左移动（南/西）。<br>    ne-resize    此光标指示矩形框的边缘可被向上及向右移动（北/东）。<br>    nw-resize    此光标指示矩形框的边缘可被向上及向左移动（北/西）。<br><br><strong>offsetTop,offsetParent</strong><br><br>obj.offsetTop 指 obj 距离上方或上层控件的位置<br><br><strong>offsetTop</strong>返回的并不一定是元素距离浏览器上方的位置，如果元素的上层元素有定位的话，返回的是元素距离上层元素的位置。<br><br><strong>offsetParent：</strong>返回一个元素离其最近的已经定位的元素，如果没有就返回body<br><br><strong>获取元素位置的函数：</strong><br><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GetPosition= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> top = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(obj.offsetParent) &#123;<span class=\"comment\">//如果obj的有最近的父级定位元素就继续</span></span><br><span class=\"line\">\t\tleft += obj.offsetLeft;<span class=\"comment\">//累加</span></span><br><span class=\"line\">\t\ttop += obj.offsetTop;</span><br><span class=\"line\">\t\tobj = obj.offsetParent;<span class=\"comment\">//更新obj,继续判断新的obj是否还有父级定位，然后继续累加</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"left\"</span>:left,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"top\"</span>:top</span><br><span class=\"line\">\t\t\t&#125;<span class=\"comment\">//返回json格式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 3. 弹出框扩展功能————拉动弹出框边缘，使之扩大缩小<br><br>由于拖拽和放大缩小的实现原理类似，我将此功能和上一功能封装到一个<code>dynamic</code>函数里了。<br><br>注意：在鼠标按下监听事件，在鼠标释放时应该清除事件绑定，要不然会出现同时拖拽和放大缩小的问题。<br><br><font color=\"red\">—————————————————————————————————————————————————————————-</font>\n\n<p>在看了几天书之后，觉得自己之前写的弹出框复用性太差，结构有些混乱，于是又重构了一下代码。</p>\n<h3 id=\"三-利用requireJS和Sass来优化弹出框组件\"><a href=\"#三-利用requireJS和Sass来优化弹出框组件\" class=\"headerlink\" title=\"三. 利用requireJS和Sass来优化弹出框组件\"></a>三. 利用requireJS和Sass来优化弹出框组件</h3><h4 id=\"1-css部分\"><a href=\"#1-css部分\" class=\"headerlink\" title=\"1. css部分\"></a>1. css部分</h4><p>其实css部分改动不多，毕竟是个小组件，就是把<strong>颜色</strong>和<strong>弹出框的宽、高</strong>用变量表示，便于以后修改。</p>\n<h4 id=\"2-js部分\"><a href=\"#2-js部分\" class=\"headerlink\" title=\"2. js部分\"></a>2. js部分</h4><p>(1)将一些扩展的API和兼容浏览器的写法都封装到了一个base.js模块中，便于以后复用</p>\n<p>base.js里的方法根据命名空间的不同，分为2类：</p>\n<pre><code>Dom：与Dom操作有关的方法\n    —— $(node)：根据id名获取节点\n    —— insertAfter(targetNode,newNode)：[在一个节点之后插入一个节点]\n    —— getElementsByClassName(attr,root,tag)：通过className获取节点\n    —— addClass(node,attr)：增加一个类\n    —— removeClass(node,attr)：删除一个类\n    —— getPoint(node)：获取某元素以浏览器左上角为原点的坐标\n    —— getCssAttr(node,attr)：获取计算后的DOM属性功能\n\nEve：与事件有关的方法\n    —— addEvent(node,type,fn)：绑定事件，兼容ie\n    —— removeEvent(node,type,fn)：移除事件，兼容ie\n</code></pre><p>(2)将弹出框的js代码进行整理</p>\n<p>首先，由于一个页面可能出现有多处按钮点击出现弹出框，因此就不能通过id名获取激发弹出框的<code>&lt;input&gt;</code></p>\n<font color=\"red\">html修改如下：</font>\n\n<pre><code>&lt;input class=&quot;float-button J_floatBtn&quot; type=&quot;submit&quot; value=&quot;弹出浮出层&quot; /&gt;\n通过className: J_floatBtn来获取input框，注意这样获取的是一个数组\n</code></pre><p>然后，将js中的内容抽离成两个js：common_floatDiv.js和main.js</p>\n<pre><code>common_floatDiv.js里面就是封装好的弹出框的一些属性和方法\nmain.js里面是和页面有关的\n\n通过main.js里面输入的参数可以定制相应的弹出框\n\n弹出框属性的注释：\n\nconfig = {\n    popupBtn: 点击显示弹出框的按钮,\n    root: 弹出框外层包裹的div,\n    isMove: 是否允许弹出框移动,\n    isZoom: 是否允许弹出框扩大缩小,\n    floatContent: [{//弹出框的内容，分为标题和正文内容\n        title: &quot;这是一个浮出层&quot;,\n        content: &quot;这是浮出层的内容&quot;\n    },{\n        title: &quot;这是第二个浮出层&quot;,\n        content: &quot;这是浮出层的内容&quot;\n    }],\n    _handler: 回调函数,        \n}\n\n弹出框方法的注释：\n\ninit()：初始化弹出框的HTML结构\ninitContent()：初始化弹出框的内容\ninitSize()：初始化弹出框的宽高，还有在页面中的位置\nshow()：显示弹出框\nhide()：隐藏弹出框\ndragDiv()：拖拽弹出框\nresizeDiv()：扩大缩小弹出框\ndynamic()：实现拖拽和扩大缩小需要用到的一个函数\n</code></pre><p>这里使用了requireJS，使页面结构更加清晰了。</p>\n<p>使用原型+构造函数的方式创建对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//common_floatDiv.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> FloatLayer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.popupBtn = config.popupBtn;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.root = config.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.isMove = config.isMove || <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.isZoom = config.isZoom || <span class=\"literal\">true</span>;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._handler = config._handler;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.floatContent = config.floatContent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._alertDiv = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.params = &#123;</span><br><span class=\"line\">\t\t\tleft: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\ttop: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\twidth: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\theight: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\tcurrentX: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\tcurrentY: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\tflag: <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化，生成浮出层</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.init();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//给按钮绑定事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.popupBtn.length; i++) &#123;</span><br><span class=\"line\">\t\t\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_i</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that.popupBtn[_i],<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.initContent(_i);</span><br><span class=\"line\">\t\t\t\t\tthat.initSize();</span><br><span class=\"line\">\t\t\t\t\tthat.show(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that.root,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.hide(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//阻止弹出框上的点击事件冒泡到浮出层上</span></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that.root.children[<span class=\"number\">0</span>],<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\te.stopPropagation();</span><br><span class=\"line\">\t\t\t\t&#125;);\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnSure,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.hide(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tGLOBAL.Eve.addEvent(that._alertDiv.btnCancel,<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tthat.hide(_i);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(that.isMove[_i] == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">\t\t\t\t\tthat.dragDiv();</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(that.isZoom[_i] == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tthat.resizeDiv();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t</span><br><span class=\"line\">\t\t\t&#125;)(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FloatLayer.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: FloatLayer,</span><br><span class=\"line\">\t//初始化</span><br><span class=\"line\">\tinit: function() &#123;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> alertDiv = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">\t\talertDiv.className = <span class=\"string\">\"alert\"</span>;</span><br><span class=\"line\">\t\talertDiv.id = <span class=\"string\">\"alertDiv\"</span>;</span><br><span class=\"line\">\t\talertDiv.style.visibility = <span class=\"string\">\"hidden\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\talertDiv.innerHTML = <span class=\"string\">\"&lt;div id='alertHeader' class='alert-header'&gt;\"</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='alertBody' class='alert-body'&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div class='alert-footer'&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;input id='btnSure' class='alert-button' type='submit' value='确认' /&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;input id='btnCancel' class='alert-button' type='submit' value='取消' /&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='resizeRig' class='resize-right'&gt;&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='resizeBot' class='resize-bottom'&gt;&lt;/div&gt;\"</span></span><br><span class=\"line\">\t\t\t\t\t\t\t+ <span class=\"string\">\"&lt;div id='resizeDiv' class='resize-div'&gt;&lt;/div&gt;\"</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.root.appendChild(alertDiv);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> elehead = GLOBAL.Dom.$(<span class=\"string\">\"alertHeader\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> elebody = GLOBAL.Dom.$(<span class=\"string\">\"alertBody\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> resizeRig = GLOBAL.Dom.$(<span class=\"string\">\"resizeRig\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> resizeBot = GLOBAL.Dom.$(<span class=\"string\">\"resizeBot\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> resizeDiv = GLOBAL.Dom.$(<span class=\"string\">\"resizeDiv\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> btnSure = GLOBAL.Dom.$(<span class=\"string\">\"btnSure\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> btnCancel = GLOBAL.Dom.$(<span class=\"string\">\"btnCancel\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>._alertDiv = &#123;</span><br><span class=\"line\">\t\t\t\twrap: alertDiv,</span><br><span class=\"line\">\t\t\t\thead: elehead,</span><br><span class=\"line\">\t\t\t\tbody: elebody,</span><br><span class=\"line\">\t\t\t\tresizeRig: resizeRig,</span><br><span class=\"line\">\t\t\t\tresizeBot: resizeBot,</span><br><span class=\"line\">\t\t\t\tresizeDiv: resizeDiv,</span><br><span class=\"line\">\t\t\t\tbtnSure: btnSure,</span><br><span class=\"line\">\t\t\t\tbtnCancel: btnCancel</span><br><span class=\"line\">\t\t\t&#125;;\t\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化弹出框的内容</span></span><br><span class=\"line\">\t\tinitContent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alertDiv = <span class=\"keyword\">this</span>._alertDiv;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> title = <span class=\"keyword\">this</span>.floatContent[i].title;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> content = <span class=\"keyword\">this</span>.floatContent[i].content;\t\t\t</span><br><span class=\"line\">\t\t\talertDiv.head.innerHTML = title;</span><br><span class=\"line\">\t\t\talertDiv.body.innerHTML = content;\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化弹出框的位置和长宽</span></span><br><span class=\"line\">\t\tinitSize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alertWrap = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\talertWrap.style.left = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t\talertWrap.style.top = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t\talertWrap.style.width = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t\talertWrap.style.height = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出框出现</span></span><br><span class=\"line\">\t\tshow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>.root;\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\tthat.style.visibility = <span class=\"string\">\"visible\"</span>;</span><br><span class=\"line\">\t\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\talert.style.visibility = <span class=\"string\">\"visible\"</span>;</span><br><span class=\"line\">\t\t\t\talert.style.transition = <span class=\"string\">\"transform 200ms linear\"</span>;</span><br><span class=\"line\">\t\t\t\talert.style.transform = <span class=\"string\">'translate(-50%, -50%) scale(1,1)'</span>;</span><br><span class=\"line\">\t\t\t&#125;, <span class=\"number\">200</span>);\t\t\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出框隐藏</span></span><br><span class=\"line\">\t\thide: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;\t</span><br><span class=\"line\">\t\t\talert.style.transition = <span class=\"string\">\"transform 200ms linear\"</span>;</span><br><span class=\"line\">\t\t\talert.style.transform = <span class=\"string\">'translate(-50%, -50%) scale(0,0)'</span>;</span><br><span class=\"line\">\t\t\talert.style.visibility = <span class=\"string\">\"hidden\"</span>;\t\t\t\t</span><br><span class=\"line\">\t\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t\tthat.style.visibility = <span class=\"string\">\"hidden\"</span>;</span><br><span class=\"line\">\t\t\t&#125;, <span class=\"number\">200</span>);\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//定义一个方法，实现拖拽功能</span></span><br><span class=\"line\">\t\tdragDiv: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> needParams = <span class=\"keyword\">this</span>.params;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleHead = <span class=\"keyword\">this</span>._alertDiv.head;\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleHead,alert,<span class=\"string\">\"left\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleHead,alert,<span class=\"string\">\"top\"</span>,needParams);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//实现扩大缩小弹出框</span></span><br><span class=\"line\">\t\tresizeDiv: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> needParams = <span class=\"keyword\">this</span>.params;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> alert = <span class=\"keyword\">this</span>._alertDiv.wrap;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleRig = <span class=\"keyword\">this</span>._alertDiv.resizeRig;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleBot = <span class=\"keyword\">this</span>._alertDiv.resizeBot;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> eleDiv = <span class=\"keyword\">this</span>._alertDiv.resizeDiv;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleRig,alert,<span class=\"string\">\"width\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleBot,alert,<span class=\"string\">\"height\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleDiv,alert,<span class=\"string\">\"width\"</span>,needParams);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dynamic(eleDiv,alert,<span class=\"string\">\"height\"</span>,needParams);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//实现拖拽和放大缩小功能</span></span><br><span class=\"line\">\t\tdynamic: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bar,target,attr,par</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> startDrag = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> e = event ? event: <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(par.flag) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//鼠标在移动时，鼠标同时是处于按下的状态</span></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>), dis = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\tnow[<span class=\"number\">0</span>] = e.clientX;</span><br><span class=\"line\">\t\t\t\t\t\t\tnow[<span class=\"number\">1</span>] = e.clientY;</span><br><span class=\"line\">\t\t\t\t\t\t\tdis[<span class=\"number\">0</span>] = now[<span class=\"number\">0</span>] - par.currentX;</span><br><span class=\"line\">\t\t\t\t\t\t\tdis[<span class=\"number\">1</span>] = now[<span class=\"number\">1</span>] - par.currentY;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(attr == <span class=\"string\">\"left\"</span> || attr == <span class=\"string\">\"width\"</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\ttarget.style[attr] = <span class=\"built_in\">parseInt</span>(par[attr]) + dis[<span class=\"number\">0</span>] + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\ttarget.style[attr] = <span class=\"built_in\">parseInt</span>(par[attr]) + dis[<span class=\"number\">1</span>] + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> stopDrag = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\tpar.flag = <span class=\"literal\">false</span>;<span class=\"comment\">//鼠标释放</span></span><br><span class=\"line\">\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);<span class=\"comment\">//获取此时的样式值</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(bar.releaseCapture) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.onmousemove = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.onmouseup = <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.releaseCapture();</span><br><span class=\"line\">\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(<span class=\"built_in\">document</span>,<span class=\"string\">\"mousemove\"</span>,startDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.removeEvent(<span class=\"built_in\">document</span>,<span class=\"string\">\"mouseup\"</span>,stopDrag);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tGLOBAL.Eve.addEvent(bar, <span class=\"string\">\"mousedown\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//首先获取当前的Div的left，right值存放起来</span></span><br><span class=\"line\">\t\t\t\t\t\tpar[attr] = GLOBAL.Dom.getCssAttr(target, attr);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> e = event ? event: <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//鼠标按下，记录当前鼠标所在的位置</span></span><br><span class=\"line\">\t\t\t\t\t\tpar.flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\tpar.currentX = e.clientX;</span><br><span class=\"line\">\t\t\t\t\t\tpar.currentY = e.clientY;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//ie中才有setCapture</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(bar.setCapture) &#123;\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, <span class=\"string\">\"mousemove\"</span>, startDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(bar, <span class=\"string\">\"mouseup\"</span>, stopDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tbar.setCapture();</span><br><span class=\"line\">\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(<span class=\"built_in\">document</span>, <span class=\"string\">\"mousemove\"</span>, startDrag);</span><br><span class=\"line\">\t\t\t\t\t\t\tGLOBAL.Eve.addEvent(<span class=\"built_in\">document</span>, <span class=\"string\">\"mouseup\"</span>, stopDrag);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;);\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"学习koa.js","date":"2016-08-03T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是koa.js?\n\nkoa.js是一个基于nodejs的web框架，主要利用了ES6里面的generator的新特性。\n\n**koa的作用：**\n\n利用一个个**中间件**对HTTP请求进行处理。例如：生成缓存／指定代理／请求重定向等。\n \n总之，一个koa应用是一个对象，这个对象中包含一个中间件的数组，数组是由一系列Generator函数组成的。\n\n#### koa.js和express的对比\n\n1. Express是在ES6之前的，中间件的原理还是基于callback方式；\nkoa是基于ES6中的generator特性和co框架（co会把所有generator的返回封装成为Promise对象）\n\nexpress让请求逐个通过中间件，实现处理网络请求，是串联的；而koa加上了中间件的回溯，即先逐个通过中间件再反穿回来。\n\n2. Express自身封装来很多功能：比如路由，视图处理等等。\nkoa框架自身没有集成太多功能，大部分需要用户自己去require中间件去解决，这样使用起来反而更灵活。\n\n###  二. koa实例的几种方法\n\n`var koa = require('koa');`\n`var app = koa();`\n\n- app.use()：使用中间件\n- app.listen()：监听某一个端口\n- app.on()：可以用来监听事件，例如：app.on('error', function)\n- app.callback()\n- app.keys = ：用来设置签名cookie密钥\n\n### 三.  koa的中间件\n\n#### 1. 什么是中间件？\n\n**koa的中间件：**\n\nkoa的中间件是一个generator函数，这些函数是用来处理http请求。\n\ngenerator函数最大的特点是：函数可以在运行的时候跳出然后再跳回来。\n\n可以自己写中间件，也可以用已经封装好了的中间件。\n\n#### 2. 如何使用中间件？\n\n使用`.use()`函数\n\n`eg.` \n\n`var koa = require('koa');`\n\n`var app = koa();`\n\n`app.use(function* (next) {`\n\n​\t`//函数内容`\n\n`});`\n\n#### 3. 中间件的执行顺序\n\n中间件之间是级联式的结构。\n\nkoa中间件的参数只有一个next，用于指向下一个中间件。\n\n使用`yield next`；执行下一个中间件，执行完毕之后，又返回该中间件继续执行。\n\n举例：\n\n```\n\tvar koa = require('koa');\n\tvar app = koa();\n\n\tapp.use(function* f1(next) {\n    \tconsole.log('f1: pre next');\n    \tyield next;\n    \tconsole.log('f1: post next');\n\t});\n\n\tapp.use(function* f2(next) {\n    \tconsole.log('  f2: pre next');\n    \tyield next;\n    \tconsole.log('  f2: post next');\n\t});\n\n\tapp.use(function* f3(next) {\n    \tconsole.log('    f3: pre next');\n    \tthis.body = 'hello world';\n    \tconsole.log('    f3: post next');\n\t});\n\n\tapp.listen(4000);\n\n\t控制台输出：\n\tf1: pre next\n  \t\tf2: pre next\n    \t\tf3: pre next\n    \t\tf3: post next\n  \t\tf2: post next\n\tf1: post next\n```\n\n#### 4. 合并中间件\n\n使用`.call(this,next)`将多个中间件进行合并。\n\n`eg.`\n\n`function* a(next) {`\n\n​\t`yield next;`\n\n`}`\n\n`function* b(next) {`\n\n​\t`yield next;`\n\n`}`\n\n`function* AandB(next) {`\n\n​\t`yield a.call(this, b.call(this, next));`\n\n`}`\n\n### 四. koa中的context／请求／响应对象\n\n#### 1. koa的context对象\n\ncontext对象可通过this标识符来引用。\n\n**context对象的全局属性：**\n\nctx.request：Request对象\n\nctx.response：Response对象\n\nctx.req：指向Node的request对象\n\nctx.res：指向Node的reponse对象（和reponse有啥区别）\n\nctx.app：指向App对象\n\n**context对象的全局方法：**\n\nthrow()：抛出错误\n\nassert(‘value’, 状态码, 提示信息)：\n\n#### 2. koa中的请求（request）对象\n\nKoa Request 对象是对 node 的 Request 进一步抽象和封装\n\n#### 3. koa中的请求（response）对象\n\nKoa Response 对象是对 node 的 Response 进一步抽象和封装\n\n### 五 . koa的使用——实现路由功能\n\n>收到客户端的请求，服务器需要通过识别请求的方法（HTTP Method: GET, POST, PUT...）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。\n\n#### 1. 用this.path属性来判断用户请求的路径\n\n```\n\tvar koa = require('koa');\n\tvar app = koa();\n\t\n\tapp.use(function* (next) {\n\t\tif(this.path == '/') {\n\t\t\tthis.body = 'hello world';\n\t\t}\n\t});\n```\n\n#### 2. koa-router中间件\n\n如何使用koa-router中间件\n\n首先，安装koa-router\n\n`npm install koa-router --save-dev`\n\n使用中间件\n\n```\n\tvar koa = require('koa');\n\tvar Router = require('koa-router');\n\tvar app = koa();\n\tvar router = Router();\n\t\n\trouter.get('/', function* (){\n\t\t//请求‘/’这个路径的回调函数\n\t});\n\t\n\tapp.use(router.routes())；\n\n```\n**koa-router提供的方法有：**\n\n`router.routes()`: 返回一个符合这个请求路径的中间件\n\n`router.get()`\n\n`router.post()`\n\n`router.use()`\n\n<font color='red'>今天使用koa的一个大坑！！！</font>\n\n\t通过页面发起ajax请求，在koa-router的post方法里面对请求进行处理，一直都获取不到post请求里面的data数据\n\n\t原因是：缺少一个对请求体进行解析的中间件！！！koa-bodyparser\n\nkoa-router源码实现？？？\n\n\n\n","source":"_posts/2016-08-04-学习koa.js.md","raw":"---\nlayout: post\ntitle: 学习koa.js\ndate: 2016-08-04\ncategories: 前端笔记\ntags: [HTTP]\ndescription: \n---\n\n### 一. 什么是koa.js?\n\nkoa.js是一个基于nodejs的web框架，主要利用了ES6里面的generator的新特性。\n\n**koa的作用：**\n\n利用一个个**中间件**对HTTP请求进行处理。例如：生成缓存／指定代理／请求重定向等。\n \n总之，一个koa应用是一个对象，这个对象中包含一个中间件的数组，数组是由一系列Generator函数组成的。\n\n#### koa.js和express的对比\n\n1. Express是在ES6之前的，中间件的原理还是基于callback方式；\nkoa是基于ES6中的generator特性和co框架（co会把所有generator的返回封装成为Promise对象）\n\nexpress让请求逐个通过中间件，实现处理网络请求，是串联的；而koa加上了中间件的回溯，即先逐个通过中间件再反穿回来。\n\n2. Express自身封装来很多功能：比如路由，视图处理等等。\nkoa框架自身没有集成太多功能，大部分需要用户自己去require中间件去解决，这样使用起来反而更灵活。\n\n###  二. koa实例的几种方法\n\n`var koa = require('koa');`\n`var app = koa();`\n\n- app.use()：使用中间件\n- app.listen()：监听某一个端口\n- app.on()：可以用来监听事件，例如：app.on('error', function)\n- app.callback()\n- app.keys = ：用来设置签名cookie密钥\n\n### 三.  koa的中间件\n\n#### 1. 什么是中间件？\n\n**koa的中间件：**\n\nkoa的中间件是一个generator函数，这些函数是用来处理http请求。\n\ngenerator函数最大的特点是：函数可以在运行的时候跳出然后再跳回来。\n\n可以自己写中间件，也可以用已经封装好了的中间件。\n\n#### 2. 如何使用中间件？\n\n使用`.use()`函数\n\n`eg.` \n\n`var koa = require('koa');`\n\n`var app = koa();`\n\n`app.use(function* (next) {`\n\n​\t`//函数内容`\n\n`});`\n\n#### 3. 中间件的执行顺序\n\n中间件之间是级联式的结构。\n\nkoa中间件的参数只有一个next，用于指向下一个中间件。\n\n使用`yield next`；执行下一个中间件，执行完毕之后，又返回该中间件继续执行。\n\n举例：\n\n```\n\tvar koa = require('koa');\n\tvar app = koa();\n\n\tapp.use(function* f1(next) {\n    \tconsole.log('f1: pre next');\n    \tyield next;\n    \tconsole.log('f1: post next');\n\t});\n\n\tapp.use(function* f2(next) {\n    \tconsole.log('  f2: pre next');\n    \tyield next;\n    \tconsole.log('  f2: post next');\n\t});\n\n\tapp.use(function* f3(next) {\n    \tconsole.log('    f3: pre next');\n    \tthis.body = 'hello world';\n    \tconsole.log('    f3: post next');\n\t});\n\n\tapp.listen(4000);\n\n\t控制台输出：\n\tf1: pre next\n  \t\tf2: pre next\n    \t\tf3: pre next\n    \t\tf3: post next\n  \t\tf2: post next\n\tf1: post next\n```\n\n#### 4. 合并中间件\n\n使用`.call(this,next)`将多个中间件进行合并。\n\n`eg.`\n\n`function* a(next) {`\n\n​\t`yield next;`\n\n`}`\n\n`function* b(next) {`\n\n​\t`yield next;`\n\n`}`\n\n`function* AandB(next) {`\n\n​\t`yield a.call(this, b.call(this, next));`\n\n`}`\n\n### 四. koa中的context／请求／响应对象\n\n#### 1. koa的context对象\n\ncontext对象可通过this标识符来引用。\n\n**context对象的全局属性：**\n\nctx.request：Request对象\n\nctx.response：Response对象\n\nctx.req：指向Node的request对象\n\nctx.res：指向Node的reponse对象（和reponse有啥区别）\n\nctx.app：指向App对象\n\n**context对象的全局方法：**\n\nthrow()：抛出错误\n\nassert(‘value’, 状态码, 提示信息)：\n\n#### 2. koa中的请求（request）对象\n\nKoa Request 对象是对 node 的 Request 进一步抽象和封装\n\n#### 3. koa中的请求（response）对象\n\nKoa Response 对象是对 node 的 Response 进一步抽象和封装\n\n### 五 . koa的使用——实现路由功能\n\n>收到客户端的请求，服务器需要通过识别请求的方法（HTTP Method: GET, POST, PUT...）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。\n\n#### 1. 用this.path属性来判断用户请求的路径\n\n```\n\tvar koa = require('koa');\n\tvar app = koa();\n\t\n\tapp.use(function* (next) {\n\t\tif(this.path == '/') {\n\t\t\tthis.body = 'hello world';\n\t\t}\n\t});\n```\n\n#### 2. koa-router中间件\n\n如何使用koa-router中间件\n\n首先，安装koa-router\n\n`npm install koa-router --save-dev`\n\n使用中间件\n\n```\n\tvar koa = require('koa');\n\tvar Router = require('koa-router');\n\tvar app = koa();\n\tvar router = Router();\n\t\n\trouter.get('/', function* (){\n\t\t//请求‘/’这个路径的回调函数\n\t});\n\t\n\tapp.use(router.routes())；\n\n```\n**koa-router提供的方法有：**\n\n`router.routes()`: 返回一个符合这个请求路径的中间件\n\n`router.get()`\n\n`router.post()`\n\n`router.use()`\n\n<font color='red'>今天使用koa的一个大坑！！！</font>\n\n\t通过页面发起ajax请求，在koa-router的post方法里面对请求进行处理，一直都获取不到post请求里面的data数据\n\n\t原因是：缺少一个对请求体进行解析的中间件！！！koa-bodyparser\n\nkoa-router源码实现？？？\n\n\n\n","slug":"2016-08-04-学习koa.js","published":1,"updated":"2016-10-16T13:27:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjj00bbd5u8lslarry5","content":"<h3 id=\"一-什么是koa-js\"><a href=\"#一-什么是koa-js\" class=\"headerlink\" title=\"一. 什么是koa.js?\"></a>一. 什么是koa.js?</h3><p>koa.js是一个基于nodejs的web框架，主要利用了ES6里面的generator的新特性。</p>\n<p><strong>koa的作用：</strong></p>\n<p>利用一个个<strong>中间件</strong>对HTTP请求进行处理。例如：生成缓存／指定代理／请求重定向等。</p>\n<p>总之，一个koa应用是一个对象，这个对象中包含一个中间件的数组，数组是由一系列Generator函数组成的。</p>\n<h4 id=\"koa-js和express的对比\"><a href=\"#koa-js和express的对比\" class=\"headerlink\" title=\"koa.js和express的对比\"></a>koa.js和express的对比</h4><ol>\n<li>Express是在ES6之前的，中间件的原理还是基于callback方式；<br>koa是基于ES6中的generator特性和co框架（co会把所有generator的返回封装成为Promise对象）</li>\n</ol>\n<p>express让请求逐个通过中间件，实现处理网络请求，是串联的；而koa加上了中间件的回溯，即先逐个通过中间件再反穿回来。</p>\n<ol>\n<li>Express自身封装来很多功能：比如路由，视图处理等等。<br>koa框架自身没有集成太多功能，大部分需要用户自己去require中间件去解决，这样使用起来反而更灵活。</li>\n</ol>\n<h3 id=\"二-koa实例的几种方法\"><a href=\"#二-koa实例的几种方法\" class=\"headerlink\" title=\"二. koa实例的几种方法\"></a>二. koa实例的几种方法</h3><p><code>var koa = require(&#39;koa&#39;);</code><br><code>var app = koa();</code></p>\n<ul>\n<li>app.use()：使用中间件</li>\n<li>app.listen()：监听某一个端口</li>\n<li>app.on()：可以用来监听事件，例如：app.on(‘error’, function)</li>\n<li>app.callback()</li>\n<li>app.keys = ：用来设置签名cookie密钥</li>\n</ul>\n<h3 id=\"三-koa的中间件\"><a href=\"#三-koa的中间件\" class=\"headerlink\" title=\"三.  koa的中间件\"></a>三.  koa的中间件</h3><h4 id=\"1-什么是中间件？\"><a href=\"#1-什么是中间件？\" class=\"headerlink\" title=\"1. 什么是中间件？\"></a>1. 什么是中间件？</h4><p><strong>koa的中间件：</strong></p>\n<p>koa的中间件是一个generator函数，这些函数是用来处理http请求。</p>\n<p>generator函数最大的特点是：函数可以在运行的时候跳出然后再跳回来。</p>\n<p>可以自己写中间件，也可以用已经封装好了的中间件。</p>\n<h4 id=\"2-如何使用中间件？\"><a href=\"#2-如何使用中间件？\" class=\"headerlink\" title=\"2. 如何使用中间件？\"></a>2. 如何使用中间件？</h4><p>使用<code>.use()</code>函数</p>\n<p><code>eg.</code> </p>\n<p><code>var koa = require(&#39;koa&#39;);</code></p>\n<p><code>var app = koa();</code></p>\n<p><code>app.use(function* (next) {</code></p>\n<p>​    <code>//函数内容</code></p>\n<p><code>});</code></p>\n<h4 id=\"3-中间件的执行顺序\"><a href=\"#3-中间件的执行顺序\" class=\"headerlink\" title=\"3. 中间件的执行顺序\"></a>3. 中间件的执行顺序</h4><p>中间件之间是级联式的结构。</p>\n<p>koa中间件的参数只有一个next，用于指向下一个中间件。</p>\n<p>使用<code>yield next</code>；执行下一个中间件，执行完毕之后，又返回该中间件继续执行。</p>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'f1: pre next'</span>);</span><br><span class=\"line\">   \t<span class=\"keyword\">yield</span> next;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'f1: post next'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'  f2: pre next'</span>);</span><br><span class=\"line\">   \t<span class=\"keyword\">yield</span> next;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'  f2: post next'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'    f3: pre next'</span>);</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.body = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'    f3: post next'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">4000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">控制台输出：</span><br><span class=\"line\">f1: pre next</span><br><span class=\"line\"> \t\tf2: pre next</span><br><span class=\"line\">   \t\tf3: pre next</span><br><span class=\"line\">   \t\tf3: post next</span><br><span class=\"line\"> \t\tf2: post next</span><br><span class=\"line\">f1: post next</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-合并中间件\"><a href=\"#4-合并中间件\" class=\"headerlink\" title=\"4. 合并中间件\"></a>4. 合并中间件</h4><p>使用<code>.call(this,next)</code>将多个中间件进行合并。</p>\n<p><code>eg.</code></p>\n<p><code>function* a(next) {</code></p>\n<p>​    <code>yield next;</code></p>\n<p><code>}</code></p>\n<p><code>function* b(next) {</code></p>\n<p>​    <code>yield next;</code></p>\n<p><code>}</code></p>\n<p><code>function* AandB(next) {</code></p>\n<p>​    <code>yield a.call(this, b.call(this, next));</code></p>\n<p><code>}</code></p>\n<h3 id=\"四-koa中的context／请求／响应对象\"><a href=\"#四-koa中的context／请求／响应对象\" class=\"headerlink\" title=\"四. koa中的context／请求／响应对象\"></a>四. koa中的context／请求／响应对象</h3><h4 id=\"1-koa的context对象\"><a href=\"#1-koa的context对象\" class=\"headerlink\" title=\"1. koa的context对象\"></a>1. koa的context对象</h4><p>context对象可通过this标识符来引用。</p>\n<p><strong>context对象的全局属性：</strong></p>\n<p>ctx.request：Request对象</p>\n<p>ctx.response：Response对象</p>\n<p>ctx.req：指向Node的request对象</p>\n<p>ctx.res：指向Node的reponse对象（和reponse有啥区别）</p>\n<p>ctx.app：指向App对象</p>\n<p><strong>context对象的全局方法：</strong></p>\n<p>throw()：抛出错误</p>\n<p>assert(‘value’, 状态码, 提示信息)：</p>\n<h4 id=\"2-koa中的请求（request）对象\"><a href=\"#2-koa中的请求（request）对象\" class=\"headerlink\" title=\"2. koa中的请求（request）对象\"></a>2. koa中的请求（request）对象</h4><p>Koa Request 对象是对 node 的 Request 进一步抽象和封装</p>\n<h4 id=\"3-koa中的请求（response）对象\"><a href=\"#3-koa中的请求（response）对象\" class=\"headerlink\" title=\"3. koa中的请求（response）对象\"></a>3. koa中的请求（response）对象</h4><p>Koa Response 对象是对 node 的 Response 进一步抽象和封装</p>\n<h3 id=\"五-koa的使用——实现路由功能\"><a href=\"#五-koa的使用——实现路由功能\" class=\"headerlink\" title=\"五 . koa的使用——实现路由功能\"></a>五 . koa的使用——实现路由功能</h3><blockquote>\n<p>收到客户端的请求，服务器需要通过识别请求的方法（HTTP Method: GET, POST, PUT…）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。</p>\n</blockquote>\n<h4 id=\"1-用this-path属性来判断用户请求的路径\"><a href=\"#1-用this-path属性来判断用户请求的路径\" class=\"headerlink\" title=\"1. 用this.path属性来判断用户请求的路径\"></a>1. 用this.path属性来判断用户请求的路径</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.path == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.body = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-koa-router中间件\"><a href=\"#2-koa-router中间件\" class=\"headerlink\" title=\"2. koa-router中间件\"></a>2. koa-router中间件</h4><p>如何使用koa-router中间件</p>\n<p>首先，安装koa-router</p>\n<p><code>npm install koa-router --save-dev</code></p>\n<p>使用中间件</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> koa = <span class=\"keyword\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Router = <span class=\"keyword\">require</span>(<span class=\"string\">'koa-router'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = koa();</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = Router();</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//请求‘/’这个路径的回调函数</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">use</span>(router.routes())；</span><br></pre></td></tr></table></figure>\n<p><strong>koa-router提供的方法有：</strong></p>\n<p><code>router.routes()</code>: 返回一个符合这个请求路径的中间件</p>\n<p><code>router.get()</code></p>\n<p><code>router.post()</code></p>\n<p><code>router.use()</code></p>\n<font color=\"red\">今天使用koa的一个大坑！！！</font>\n\n<pre><code>通过页面发起ajax请求，在koa-router的post方法里面对请求进行处理，一直都获取不到post请求里面的data数据\n\n原因是：缺少一个对请求体进行解析的中间件！！！koa-bodyparser\n</code></pre><p>koa-router源码实现？？？</p>\n","excerpt":"","more":"<h3 id=\"一-什么是koa-js\"><a href=\"#一-什么是koa-js\" class=\"headerlink\" title=\"一. 什么是koa.js?\"></a>一. 什么是koa.js?</h3><p>koa.js是一个基于nodejs的web框架，主要利用了ES6里面的generator的新特性。</p>\n<p><strong>koa的作用：</strong></p>\n<p>利用一个个<strong>中间件</strong>对HTTP请求进行处理。例如：生成缓存／指定代理／请求重定向等。</p>\n<p>总之，一个koa应用是一个对象，这个对象中包含一个中间件的数组，数组是由一系列Generator函数组成的。</p>\n<h4 id=\"koa-js和express的对比\"><a href=\"#koa-js和express的对比\" class=\"headerlink\" title=\"koa.js和express的对比\"></a>koa.js和express的对比</h4><ol>\n<li>Express是在ES6之前的，中间件的原理还是基于callback方式；<br>koa是基于ES6中的generator特性和co框架（co会把所有generator的返回封装成为Promise对象）</li>\n</ol>\n<p>express让请求逐个通过中间件，实现处理网络请求，是串联的；而koa加上了中间件的回溯，即先逐个通过中间件再反穿回来。</p>\n<ol>\n<li>Express自身封装来很多功能：比如路由，视图处理等等。<br>koa框架自身没有集成太多功能，大部分需要用户自己去require中间件去解决，这样使用起来反而更灵活。</li>\n</ol>\n<h3 id=\"二-koa实例的几种方法\"><a href=\"#二-koa实例的几种方法\" class=\"headerlink\" title=\"二. koa实例的几种方法\"></a>二. koa实例的几种方法</h3><p><code>var koa = require(&#39;koa&#39;);</code><br><code>var app = koa();</code></p>\n<ul>\n<li>app.use()：使用中间件</li>\n<li>app.listen()：监听某一个端口</li>\n<li>app.on()：可以用来监听事件，例如：app.on(‘error’, function)</li>\n<li>app.callback()</li>\n<li>app.keys = ：用来设置签名cookie密钥</li>\n</ul>\n<h3 id=\"三-koa的中间件\"><a href=\"#三-koa的中间件\" class=\"headerlink\" title=\"三.  koa的中间件\"></a>三.  koa的中间件</h3><h4 id=\"1-什么是中间件？\"><a href=\"#1-什么是中间件？\" class=\"headerlink\" title=\"1. 什么是中间件？\"></a>1. 什么是中间件？</h4><p><strong>koa的中间件：</strong></p>\n<p>koa的中间件是一个generator函数，这些函数是用来处理http请求。</p>\n<p>generator函数最大的特点是：函数可以在运行的时候跳出然后再跳回来。</p>\n<p>可以自己写中间件，也可以用已经封装好了的中间件。</p>\n<h4 id=\"2-如何使用中间件？\"><a href=\"#2-如何使用中间件？\" class=\"headerlink\" title=\"2. 如何使用中间件？\"></a>2. 如何使用中间件？</h4><p>使用<code>.use()</code>函数</p>\n<p><code>eg.</code> </p>\n<p><code>var koa = require(&#39;koa&#39;);</code></p>\n<p><code>var app = koa();</code></p>\n<p><code>app.use(function* (next) {</code></p>\n<p>​    <code>//函数内容</code></p>\n<p><code>});</code></p>\n<h4 id=\"3-中间件的执行顺序\"><a href=\"#3-中间件的执行顺序\" class=\"headerlink\" title=\"3. 中间件的执行顺序\"></a>3. 中间件的执行顺序</h4><p>中间件之间是级联式的结构。</p>\n<p>koa中间件的参数只有一个next，用于指向下一个中间件。</p>\n<p>使用<code>yield next</code>；执行下一个中间件，执行完毕之后，又返回该中间件继续执行。</p>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'f1: pre next'</span>);</span><br><span class=\"line\">   \t<span class=\"keyword\">yield</span> next;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'f1: post next'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'  f2: pre next'</span>);</span><br><span class=\"line\">   \t<span class=\"keyword\">yield</span> next;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'  f2: post next'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'    f3: pre next'</span>);</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.body = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'    f3: post next'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">4000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">控制台输出：</span><br><span class=\"line\">f1: pre next</span><br><span class=\"line\"> \t\tf2: pre next</span><br><span class=\"line\">   \t\tf3: pre next</span><br><span class=\"line\">   \t\tf3: post next</span><br><span class=\"line\"> \t\tf2: post next</span><br><span class=\"line\">f1: post next</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-合并中间件\"><a href=\"#4-合并中间件\" class=\"headerlink\" title=\"4. 合并中间件\"></a>4. 合并中间件</h4><p>使用<code>.call(this,next)</code>将多个中间件进行合并。</p>\n<p><code>eg.</code></p>\n<p><code>function* a(next) {</code></p>\n<p>​    <code>yield next;</code></p>\n<p><code>}</code></p>\n<p><code>function* b(next) {</code></p>\n<p>​    <code>yield next;</code></p>\n<p><code>}</code></p>\n<p><code>function* AandB(next) {</code></p>\n<p>​    <code>yield a.call(this, b.call(this, next));</code></p>\n<p><code>}</code></p>\n<h3 id=\"四-koa中的context／请求／响应对象\"><a href=\"#四-koa中的context／请求／响应对象\" class=\"headerlink\" title=\"四. koa中的context／请求／响应对象\"></a>四. koa中的context／请求／响应对象</h3><h4 id=\"1-koa的context对象\"><a href=\"#1-koa的context对象\" class=\"headerlink\" title=\"1. koa的context对象\"></a>1. koa的context对象</h4><p>context对象可通过this标识符来引用。</p>\n<p><strong>context对象的全局属性：</strong></p>\n<p>ctx.request：Request对象</p>\n<p>ctx.response：Response对象</p>\n<p>ctx.req：指向Node的request对象</p>\n<p>ctx.res：指向Node的reponse对象（和reponse有啥区别）</p>\n<p>ctx.app：指向App对象</p>\n<p><strong>context对象的全局方法：</strong></p>\n<p>throw()：抛出错误</p>\n<p>assert(‘value’, 状态码, 提示信息)：</p>\n<h4 id=\"2-koa中的请求（request）对象\"><a href=\"#2-koa中的请求（request）对象\" class=\"headerlink\" title=\"2. koa中的请求（request）对象\"></a>2. koa中的请求（request）对象</h4><p>Koa Request 对象是对 node 的 Request 进一步抽象和封装</p>\n<h4 id=\"3-koa中的请求（response）对象\"><a href=\"#3-koa中的请求（response）对象\" class=\"headerlink\" title=\"3. koa中的请求（response）对象\"></a>3. koa中的请求（response）对象</h4><p>Koa Response 对象是对 node 的 Response 进一步抽象和封装</p>\n<h3 id=\"五-koa的使用——实现路由功能\"><a href=\"#五-koa的使用——实现路由功能\" class=\"headerlink\" title=\"五 . koa的使用——实现路由功能\"></a>五 . koa的使用——实现路由功能</h3><blockquote>\n<p>收到客户端的请求，服务器需要通过识别请求的方法（HTTP Method: GET, POST, PUT…）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。</p>\n</blockquote>\n<h4 id=\"1-用this-path属性来判断用户请求的路径\"><a href=\"#1-用this-path属性来判断用户请求的路径\" class=\"headerlink\" title=\"1. 用this.path属性来判断用户请求的路径\"></a>1. 用this.path属性来判断用户请求的路径</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.path == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.body = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-koa-router中间件\"><a href=\"#2-koa-router中间件\" class=\"headerlink\" title=\"2. koa-router中间件\"></a>2. koa-router中间件</h4><p>如何使用koa-router中间件</p>\n<p>首先，安装koa-router</p>\n<p><code>npm install koa-router --save-dev</code></p>\n<p>使用中间件</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> koa = <span class=\"keyword\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Router = <span class=\"keyword\">require</span>(<span class=\"string\">'koa-router'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = koa();</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = Router();</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//请求‘/’这个路径的回调函数</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">use</span>(router.routes())；</span><br></pre></td></tr></table></figure>\n<p><strong>koa-router提供的方法有：</strong></p>\n<p><code>router.routes()</code>: 返回一个符合这个请求路径的中间件</p>\n<p><code>router.get()</code></p>\n<p><code>router.post()</code></p>\n<p><code>router.use()</code></p>\n<font color='red'>今天使用koa的一个大坑！！！</font>\n\n<pre><code>通过页面发起ajax请求，在koa-router的post方法里面对请求进行处理，一直都获取不到post请求里面的data数据\n\n原因是：缺少一个对请求体进行解析的中间件！！！koa-bodyparser\n</code></pre><p>koa-router源码实现？？？</p>\n"},{"layout":"post","title":"charles的使用","date":"2016-08-03T16:00:00.000Z","description":null,"_content":"\n### 一. charles简介\n\ncharles是Mac下的网络抓包工具\n\nCharles是通过将自己设置成**代理服务器**来完成封包截取的\n\n**Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。**\n\n1. Structure 视图将网络请求按访问的**域名**分类。\n2. Sequence 视图将网络请求按访问的**时间**排序。\n\n### 二. 破解Charles\n\n没有被破解的Charles在启动30分钟之后，就会让你重新启动一次，挺烦的，我是按照下面这篇文章进行破解的，替换这个charles.jar文件即可。\n\n[Charles破解方法](http://wiki.sankuai.com/pages/viewpage.action?pageId=546943557)\n\n\n### 三. 使用\n\n#### 1. 使用charles截取iPhone上的网络封包：\n\n **charles上设置：**\n\n“Proxy”->”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置\n\n**iPhone上的设置：**\n\n在无线局域网里添加代理，填入本机的IP地址及端口号\n\n#### 2. 将网络请求重定向到另外一个请求\n\nMap Remote 是将指定的网络请求重定向到另一个网址请求地址\n\nTools －> Map Remote中填入\n\n#### 3. 使用Charles截取Https的通讯信息\n\n首先，安装证书：选择 “Help” -> “SSL Proxying” -> “Install Charles Root Certificate”；\n\n然后，在该网络请求上右击SSL Proxying","source":"_posts/2016-08-04-charles的使用.md","raw":"---\nlayout: post\ntitle: charles的使用\ndate: 2016-08-04\ncategories: 前端笔记\ntags: [工具]\ndescription: \n---\n\n### 一. charles简介\n\ncharles是Mac下的网络抓包工具\n\nCharles是通过将自己设置成**代理服务器**来完成封包截取的\n\n**Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。**\n\n1. Structure 视图将网络请求按访问的**域名**分类。\n2. Sequence 视图将网络请求按访问的**时间**排序。\n\n### 二. 破解Charles\n\n没有被破解的Charles在启动30分钟之后，就会让你重新启动一次，挺烦的，我是按照下面这篇文章进行破解的，替换这个charles.jar文件即可。\n\n[Charles破解方法](http://wiki.sankuai.com/pages/viewpage.action?pageId=546943557)\n\n\n### 三. 使用\n\n#### 1. 使用charles截取iPhone上的网络封包：\n\n **charles上设置：**\n\n“Proxy”->”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置\n\n**iPhone上的设置：**\n\n在无线局域网里添加代理，填入本机的IP地址及端口号\n\n#### 2. 将网络请求重定向到另外一个请求\n\nMap Remote 是将指定的网络请求重定向到另一个网址请求地址\n\nTools －> Map Remote中填入\n\n#### 3. 使用Charles截取Https的通讯信息\n\n首先，安装证书：选择 “Help” -> “SSL Proxying” -> “Install Charles Root Certificate”；\n\n然后，在该网络请求上右击SSL Proxying","slug":"2016-08-04-charles的使用","published":1,"updated":"2016-08-11T01:21:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjl00bed5u86e1st4nm","content":"<h3 id=\"一-charles简介\"><a href=\"#一-charles简介\" class=\"headerlink\" title=\"一. charles简介\"></a>一. charles简介</h3><p>charles是Mac下的网络抓包工具</p>\n<p>Charles是通过将自己设置成<strong>代理服务器</strong>来完成封包截取的</p>\n<p><strong>Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。</strong></p>\n<ol>\n<li>Structure 视图将网络请求按访问的<strong>域名</strong>分类。</li>\n<li>Sequence 视图将网络请求按访问的<strong>时间</strong>排序。</li>\n</ol>\n<h3 id=\"二-破解Charles\"><a href=\"#二-破解Charles\" class=\"headerlink\" title=\"二. 破解Charles\"></a>二. 破解Charles</h3><p>没有被破解的Charles在启动30分钟之后，就会让你重新启动一次，挺烦的，我是按照下面这篇文章进行破解的，替换这个charles.jar文件即可。</p>\n<p><a href=\"http://wiki.sankuai.com/pages/viewpage.action?pageId=546943557\" target=\"_blank\" rel=\"external\">Charles破解方法</a></p>\n<h3 id=\"三-使用\"><a href=\"#三-使用\" class=\"headerlink\" title=\"三. 使用\"></a>三. 使用</h3><h4 id=\"1-使用charles截取iPhone上的网络封包：\"><a href=\"#1-使用charles截取iPhone上的网络封包：\" class=\"headerlink\" title=\"1. 使用charles截取iPhone上的网络封包：\"></a>1. 使用charles截取iPhone上的网络封包：</h4><p> <strong>charles上设置：</strong></p>\n<p>“Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置</p>\n<p><strong>iPhone上的设置：</strong></p>\n<p>在无线局域网里添加代理，填入本机的IP地址及端口号</p>\n<h4 id=\"2-将网络请求重定向到另外一个请求\"><a href=\"#2-将网络请求重定向到另外一个请求\" class=\"headerlink\" title=\"2. 将网络请求重定向到另外一个请求\"></a>2. 将网络请求重定向到另外一个请求</h4><p>Map Remote 是将指定的网络请求重定向到另一个网址请求地址</p>\n<p>Tools －&gt; Map Remote中填入</p>\n<h4 id=\"3-使用Charles截取Https的通讯信息\"><a href=\"#3-使用Charles截取Https的通讯信息\" class=\"headerlink\" title=\"3. 使用Charles截取Https的通讯信息\"></a>3. 使用Charles截取Https的通讯信息</h4><p>首先，安装证书：选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”；</p>\n<p>然后，在该网络请求上右击SSL Proxying</p>\n","excerpt":"","more":"<h3 id=\"一-charles简介\"><a href=\"#一-charles简介\" class=\"headerlink\" title=\"一. charles简介\"></a>一. charles简介</h3><p>charles是Mac下的网络抓包工具</p>\n<p>Charles是通过将自己设置成<strong>代理服务器</strong>来完成封包截取的</p>\n<p><strong>Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。</strong></p>\n<ol>\n<li>Structure 视图将网络请求按访问的<strong>域名</strong>分类。</li>\n<li>Sequence 视图将网络请求按访问的<strong>时间</strong>排序。</li>\n</ol>\n<h3 id=\"二-破解Charles\"><a href=\"#二-破解Charles\" class=\"headerlink\" title=\"二. 破解Charles\"></a>二. 破解Charles</h3><p>没有被破解的Charles在启动30分钟之后，就会让你重新启动一次，挺烦的，我是按照下面这篇文章进行破解的，替换这个charles.jar文件即可。</p>\n<p><a href=\"http://wiki.sankuai.com/pages/viewpage.action?pageId=546943557\">Charles破解方法</a></p>\n<h3 id=\"三-使用\"><a href=\"#三-使用\" class=\"headerlink\" title=\"三. 使用\"></a>三. 使用</h3><h4 id=\"1-使用charles截取iPhone上的网络封包：\"><a href=\"#1-使用charles截取iPhone上的网络封包：\" class=\"headerlink\" title=\"1. 使用charles截取iPhone上的网络封包：\"></a>1. 使用charles截取iPhone上的网络封包：</h4><p> <strong>charles上设置：</strong></p>\n<p>“Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置</p>\n<p><strong>iPhone上的设置：</strong></p>\n<p>在无线局域网里添加代理，填入本机的IP地址及端口号</p>\n<h4 id=\"2-将网络请求重定向到另外一个请求\"><a href=\"#2-将网络请求重定向到另外一个请求\" class=\"headerlink\" title=\"2. 将网络请求重定向到另外一个请求\"></a>2. 将网络请求重定向到另外一个请求</h4><p>Map Remote 是将指定的网络请求重定向到另一个网址请求地址</p>\n<p>Tools －&gt; Map Remote中填入</p>\n<h4 id=\"3-使用Charles截取Https的通讯信息\"><a href=\"#3-使用Charles截取Https的通讯信息\" class=\"headerlink\" title=\"3. 使用Charles截取Https的通讯信息\"></a>3. 使用Charles截取Https的通讯信息</h4><p>首先，安装证书：选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”；</p>\n<p>然后，在该网络请求上右击SSL Proxying</p>\n"},{"layout":"post","title":"ECMAScript 6入门","date":"2016-07-30T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是ECMAScript?与javaScript有什么关系？\n\nECMA————国际标准化组织\n\nECMAScript是针对javaScript语言的制定的标准。\n\nECMAScript是javaScript的规格，javaScript是ECMAScript的实现。\n\n随着时间的推移，浏览器对ES6中的支持已经越来越高，大部分特效已经实现了。\n\n### 二. Babel\n\n由于现在的浏览器对ES6的支持还没那么好，所以引入ES6代码之前需要对其进行转码。babel就是一个将ES6代码转为ES5代码的转码器。\n\n### 三. ES6中的新特性\n\n#### 1. ES6中新增的声明变量的方法\n\nES6中新增了2种声明变量的方法：**let**和**const**\n\n使用let和const声明的变量，都是在**块级作用域**内有效，不存在变量提升，且不能被重复声明。\n\n##### (1). 块级作用域｛｝\n\nES6中增加了块级作用域的概念，块级作用域的特点：\n\n- 外层作用域无法读取内层作用域的变量\n- 外层代码块不受内层代码块的影响\n\n##### (2). let命令\n\nlet命令和var命令一样，都是用来声明变量的\n\n**let与var不同之处：**\n\n- let所声明的变量只在块级作用域内有效，而var声明的变量为函数作用域\n- let声明的变量在相同作用域内，不能重复声明\n- let不存在变量提升\n- 存在暂时性死区：在该作用域内，在使用let声明变量之前，是不能使用该变量的。\n- var声明的变量是全局变量的属性，let声明的变量不是全局变量的属性\n\n##### (3). const命令\n\nconst命令用来声明常量，其特点如下：\n\n- 若声明的常量是基本类型的常量，声明之后其值不能改变；若声明的常量是复合类型的常量，声明之后其地址不能改变。\n- 不能重复声明\n- 声明常量时需要立即初始化\n- 只在块级作用域内有效\n\n```\n//当声明的常量是一个数组时，其地址不能改变，但是其值可以改变\nconst a = [];\na.push('Hello'); // a的值可以改变\na.length = 0; // 可执行\na = ['Dave']; // 不能将一个地址赋值给a\n\n//若需要声明一个不能修改的对象常量，使用Object.freeze()方法\nconst foo = Object.freeze({ a: 2});\n\nObject.freeze()是用来冻结一个对象的\n```\n\n##### (4). 使用const和let声明变量的好处\n\n- 使用let可以代替ES5中的自执行函数，块级作用域\n- 避免由变量声明提升带来的一些问题\n\n#### 2. for-of循环\n\n遍历数组的几种方法：\n\n```\n//最原始的方法\nfor(var index=0; index < myArr.length; index++) {\n\tconsole.log(myArr[index]);\n}\n\n//使用forEach，这种方法的缺点：不能使用break语句中断循环，也不能使用return语句返回到外层函数\nmyArr.forEach(function(item,index,arr){\n\tconsole.log(item);\n});\n\n//使用for-in，这种方法的缺点是会遍历所有的可枚举的属性，这里的index指的是字符串\nfor(var index in myArr) {\n\tconsole.log(myArr[index])\n}\n```\n\n上面三种做法都有缺点，ES6提出了一种新的遍历数组的方法for-of，**for-of循环语句通过方法调用来遍历各种集合**。\n\n**使用for-of遍历数组**\n\n```\nfor (var i of [1,2,3]) {\n  console.log(i);\n}\n\n输出：\n1 \n2\n3\n```\n**使用for-of遍历字符串**\n\n```\nfor (var i of 'qwe') {\n  console.log(i);\n}\n\n输出：\nq\nw\ne\n```\n\nfor-of用来遍历ES6中的一些新的对象（有迭代器方法的对象）：\n\n数组、类数组对象、Map、Set、Generator、字符串\n\n**什么是遍历器对象？**\n\n有next方法的对象，就具备了遍历器功能。\nnext方法必须返回一个包含value和done两个属性的对象。\nvalue属性是当前遍历的位置的值，而done属性是一个布尔值，用来表示遍历是否结束。\n\neg:\n\n```\n\t\n\tfunction iterator() {\n\t\tvar index = 0;\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {value: index++, done: false}\t\n\t\t\t}\n\t\t}\n\t}\n\n\tvar it = iterator();\n\tit.next().value; // 0\n\tit.next().value; // 1\n\tit.next().value; // 2\n\n\tfor(var n of it) {\n\t\tif(n > 5) {\n\t\t\tbreak;\n\t\t}\n\t\tconsole.log(n);\n\t}\n\t\n\t控制台：0 1 2 3 4 5\n```\n\n\n\n#### 3. 函数的扩展\n\n##### （1）. 箭头函数：=>\n```\n  param => {\n    statements\n  }\n```\n**箭头函数的特点：**\n\n- 若箭头后面是一个表达式，那么这个表达式的值会被return\n- 若箭头后面是一个代码块，那么需要用return语句来给函数返回值\n- 箭头函数不能当成构造函数使用\n- 箭头函数内部不能使用arguments对象\n\n**与ES5中的函数写法相比：**\n\n解决了this的指向问题\n\n- **在ES5中：**this对象的指向与函数具体是在什么样的情境下使用有关（一共有4种情况，普通函数，构造函数，对象的方法，apply/call/bind）\n- **在ES6中：**箭头函数中this的指向是固定的，箭头函数内的this值指向绑定时所在对象，而不是使用时。\n\n##### （2）. 可以给函数参数设置默认值\n```\n\tfunction log(x,y='world') {\n  \t\tconsole.log(x,y);\n\t}\n```\n\n**与ES5的写法相比：**\n\n- 在ES5中：以前给参数设默认值，var y = y || 'world';\n- 在ES6中：给函数参数设置默认值的这种方式更简便一些。\n\n##### （3）. 引入不定参数（形式为‘...变量名’）\n\n不定参数是一个数组，将多余的参数放在了该数组中。\n\n在所有函数参数中，只有最后一个才可以被标记为不定参数。\n\n若没有多余的参数，那么不定参数是一个空数组。\n\n可以代替ES5中arguments变量，arguments是一个类数组对象。\n\n**与ES5的写法相比：**\n\n- **在ES5中：**之前我们需要使用函数的参数时，需要将arguments类数组对象转换成一个数组。\n\nArray.prototype.slice.call(arguments)\n\n- **在ES6中：**就可以直接使用不定参数了。\n\n##### （4）. 扩展运算符 ...\n\n作用：将一个**数组**转为**用逗号分隔的参数序列**。\n\n```\nconsole.log(...[1,2,3]); //1 2 3\n```\n\n**与ES5相比：**在ES5中需要使用apply函数才能将数组转换成函数的参数。\n\n举个栗子：将两个数组合并\n\n```\n  //在ES5中\n  var a = [1,2,3];\n  var b = [4,5,6];\n  Array.prototype.push.apply(a,b);\n  \n  //使用ES6的扩展运算符\n  a.push(...b)\n```\n#### 4. 生成器函数Generator\n\n协程：多个线程互相协作，完成异步任务。\n\n（1）generator函数的定义          \n\n`function* myFunc () {  }`\n\n（2）generator函数的返回值，是一个遍历器对象\n\n```\n\tfunction* helloWorld () {\n\t    yield 'hello';\n\t}\n\n\tvar hw = helloWorld();//返回一个遍历器对象\n\t\n\t//执行遍历器对象的next方法，会返回一个对象，移动内部指针，即执行异步任务的第一阶段，遇到yeild会停止\n \tvar g = hw.next(); //g = {value: 'hello', done: bool};\n```\n\n遍历器对象有两个属性：value和done。\n\n- value 属性是 yield 语句后面表达式的值，表示当前阶段的值；\n- done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段\n\n在函数外面可以使用**g.throw()**捕获错误\n\n(3). 调用Generator函数时，函数并不执行，而是返回一个指向内部状态的指针对象——遍历器对象。\n\n\n\n(4). Generator中yield语句和return语句\n\n相同点：执行yield语句和return语句都能返回紧跟在语句后的值\n\n不同点：一个Generator函数中只能出现一次return语句，但是可以出现多次yield语句。\n\n#### 5. promise对象\n\n是js中的一种**异步编程**的模式。\n\n**与回调函数的不同点：**\n\n将回调函数变成了链式写法，每一个异步任务返回一个Promise对象，该对象有一个then方法。\n\npromise对象保存一个异步操作的结果。\n\n**（1）promise对象的三种状态**\n\n- pending进行中\n- resolved已完成\n- rejected已失败\n\n对象状态不会被外部改变，由异步操作的结果确定\n\n对象状态发生改变了之后就不会再改变了\n\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数\n\n#### 6. 模版字符串\n\n使用反撇号` `` `\n\n模板字符串内部使用`${}`将js表达式包起来\n\n与一般字符串的不同点：支持多行书写，比`+`号更优雅\n\n#### 7. 解构赋值\n\n#### 8. symbol类型\n\nsymbol是js中新增的一种数据类型。\n\n作用：可用作唯一的属性键，用来标识状态\n\n举个栗子：\n\n```\n\t// isMoving是一个Symbol对象\n    var isMoving = Symbol(\"isMoving\");\n    ...\n    if (element[isMoving]) {\n      smoothAnimations(element);\n    }\n    element[isMoving] = true;\n```\n\n#### 9. class类\n\n##### 1. 定义class\n\nclass关键字可以定义类\n\n**ES5中通过构造函数来定义对象**\n\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n**ES6中通过 class关键字定义类**\n\n```\n//定义类\nclass Point {\n//ES6中的构造方法constructor方法相当于ES5中的构造函数Point()\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n//使用类，与ES5的方法一致\n\n```\n var a = new Point();\n```\n\n注意：(1). 类里面的构造函数之间不需要逗号分隔\n(2). 用class声明的类的数据类型就是函数\n(3). 类里面定义的所有的方法都试定义在类的原型(prototype)上\n(4). 一个类必须有constructor方法\n(5). 不存在变量提升\n(6). class 与function类似，可以使用表达式的形式定义\n              ```\n const MyClass = class { /* ... */ };\n              ```\n(7). 用_fn的命名方式，定义私有方法\n\n##### 2. class的继承\n\n通过关键字extends实现继承\n\n```\n//ColorPoint继承了Point的所有属性和方法\nclass ColorPoint extends Point {}\nsuper(); //调用父类的构造函数方法\n子类必须在constructor方法中调用super方法\n```\n\n##### 3. class的取值函数和存值函数\n\n对某个属性设置取值函数和存值函数\n\n```\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  //prop属性的取值函数\n  get prop() {\n    return 'getter';\n  }\n  //prop属性的存值函数\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n```\n\n##### 4. class的静态方法\n\n(1). 使用`static`关键字声明的静态方法不会被实例继承\n(2). 父类的静态方法可以被子类调用\n(3). 子类的静态方法可以被super对象调用\n\n##### 5. class的静态属性和实例属性\nclass的静态属性：指的是class本身的属性，而不是定义在实例对象上的属性。\n\n```\neg:\nclass Foo {\n   static prop = 1;\n}\nclass的实例属性，可以用等式，写入类的定义之中。\nclass MyClass {\n  myProp = 42;\n\n  constructor() {\n    console.log(this.myProp); // 42\n  }\n}\n```\n\nES6中的class解决的问题：\n\n#### 10. ES6中新增的模块系统\n\nexport\nimport\n\n在ES6中，无论是否加入'use strict;'语句，默认情况下都是在严格模式下进行的。\n\n##### 1. 导出\n\n用export声明的部分，可以供其他模块使用。\n\n只写一行你想要导出的变量列表，再用花括号包起来。\n```\nexport {module1, module2...}\n```\n\n默认导出 \n```\nexport default ...\n```\nexport default命令用于指定模块的默认输出。一个模块只能有一个默认输出。\n\n本质上，export default就是输出一个叫做default的变量或方法，在导入时，可以为其取任意名字。\n\n在ES6中，使用CommonJS、AMD模块都有一个默认导出\n\n```\n//下面两种写法是等价的\nvar colors = require('colors.js');\nimport colors from colors.js;\n```\n\n##### 2. 导入\n```\nimport {module1, module2} from \"other.js\";\nimprot module form \"other.js\";\n```\n\n##### 3. 给导入或者导出的变量重新命名，使用as\n\n```\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n```","source":"_posts/2016-07-31-ECMAScript 6入门.md","raw":"---\nlayout: post\ntitle: ECMAScript 6入门\ndate: 2016-07-31\ncategories: javaScript\ntags: [javaScript,ES6]\ndescription: \n---\n\n### 一. 什么是ECMAScript?与javaScript有什么关系？\n\nECMA————国际标准化组织\n\nECMAScript是针对javaScript语言的制定的标准。\n\nECMAScript是javaScript的规格，javaScript是ECMAScript的实现。\n\n随着时间的推移，浏览器对ES6中的支持已经越来越高，大部分特效已经实现了。\n\n### 二. Babel\n\n由于现在的浏览器对ES6的支持还没那么好，所以引入ES6代码之前需要对其进行转码。babel就是一个将ES6代码转为ES5代码的转码器。\n\n### 三. ES6中的新特性\n\n#### 1. ES6中新增的声明变量的方法\n\nES6中新增了2种声明变量的方法：**let**和**const**\n\n使用let和const声明的变量，都是在**块级作用域**内有效，不存在变量提升，且不能被重复声明。\n\n##### (1). 块级作用域｛｝\n\nES6中增加了块级作用域的概念，块级作用域的特点：\n\n- 外层作用域无法读取内层作用域的变量\n- 外层代码块不受内层代码块的影响\n\n##### (2). let命令\n\nlet命令和var命令一样，都是用来声明变量的\n\n**let与var不同之处：**\n\n- let所声明的变量只在块级作用域内有效，而var声明的变量为函数作用域\n- let声明的变量在相同作用域内，不能重复声明\n- let不存在变量提升\n- 存在暂时性死区：在该作用域内，在使用let声明变量之前，是不能使用该变量的。\n- var声明的变量是全局变量的属性，let声明的变量不是全局变量的属性\n\n##### (3). const命令\n\nconst命令用来声明常量，其特点如下：\n\n- 若声明的常量是基本类型的常量，声明之后其值不能改变；若声明的常量是复合类型的常量，声明之后其地址不能改变。\n- 不能重复声明\n- 声明常量时需要立即初始化\n- 只在块级作用域内有效\n\n```\n//当声明的常量是一个数组时，其地址不能改变，但是其值可以改变\nconst a = [];\na.push('Hello'); // a的值可以改变\na.length = 0; // 可执行\na = ['Dave']; // 不能将一个地址赋值给a\n\n//若需要声明一个不能修改的对象常量，使用Object.freeze()方法\nconst foo = Object.freeze({ a: 2});\n\nObject.freeze()是用来冻结一个对象的\n```\n\n##### (4). 使用const和let声明变量的好处\n\n- 使用let可以代替ES5中的自执行函数，块级作用域\n- 避免由变量声明提升带来的一些问题\n\n#### 2. for-of循环\n\n遍历数组的几种方法：\n\n```\n//最原始的方法\nfor(var index=0; index < myArr.length; index++) {\n\tconsole.log(myArr[index]);\n}\n\n//使用forEach，这种方法的缺点：不能使用break语句中断循环，也不能使用return语句返回到外层函数\nmyArr.forEach(function(item,index,arr){\n\tconsole.log(item);\n});\n\n//使用for-in，这种方法的缺点是会遍历所有的可枚举的属性，这里的index指的是字符串\nfor(var index in myArr) {\n\tconsole.log(myArr[index])\n}\n```\n\n上面三种做法都有缺点，ES6提出了一种新的遍历数组的方法for-of，**for-of循环语句通过方法调用来遍历各种集合**。\n\n**使用for-of遍历数组**\n\n```\nfor (var i of [1,2,3]) {\n  console.log(i);\n}\n\n输出：\n1 \n2\n3\n```\n**使用for-of遍历字符串**\n\n```\nfor (var i of 'qwe') {\n  console.log(i);\n}\n\n输出：\nq\nw\ne\n```\n\nfor-of用来遍历ES6中的一些新的对象（有迭代器方法的对象）：\n\n数组、类数组对象、Map、Set、Generator、字符串\n\n**什么是遍历器对象？**\n\n有next方法的对象，就具备了遍历器功能。\nnext方法必须返回一个包含value和done两个属性的对象。\nvalue属性是当前遍历的位置的值，而done属性是一个布尔值，用来表示遍历是否结束。\n\neg:\n\n```\n\t\n\tfunction iterator() {\n\t\tvar index = 0;\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {value: index++, done: false}\t\n\t\t\t}\n\t\t}\n\t}\n\n\tvar it = iterator();\n\tit.next().value; // 0\n\tit.next().value; // 1\n\tit.next().value; // 2\n\n\tfor(var n of it) {\n\t\tif(n > 5) {\n\t\t\tbreak;\n\t\t}\n\t\tconsole.log(n);\n\t}\n\t\n\t控制台：0 1 2 3 4 5\n```\n\n\n\n#### 3. 函数的扩展\n\n##### （1）. 箭头函数：=>\n```\n  param => {\n    statements\n  }\n```\n**箭头函数的特点：**\n\n- 若箭头后面是一个表达式，那么这个表达式的值会被return\n- 若箭头后面是一个代码块，那么需要用return语句来给函数返回值\n- 箭头函数不能当成构造函数使用\n- 箭头函数内部不能使用arguments对象\n\n**与ES5中的函数写法相比：**\n\n解决了this的指向问题\n\n- **在ES5中：**this对象的指向与函数具体是在什么样的情境下使用有关（一共有4种情况，普通函数，构造函数，对象的方法，apply/call/bind）\n- **在ES6中：**箭头函数中this的指向是固定的，箭头函数内的this值指向绑定时所在对象，而不是使用时。\n\n##### （2）. 可以给函数参数设置默认值\n```\n\tfunction log(x,y='world') {\n  \t\tconsole.log(x,y);\n\t}\n```\n\n**与ES5的写法相比：**\n\n- 在ES5中：以前给参数设默认值，var y = y || 'world';\n- 在ES6中：给函数参数设置默认值的这种方式更简便一些。\n\n##### （3）. 引入不定参数（形式为‘...变量名’）\n\n不定参数是一个数组，将多余的参数放在了该数组中。\n\n在所有函数参数中，只有最后一个才可以被标记为不定参数。\n\n若没有多余的参数，那么不定参数是一个空数组。\n\n可以代替ES5中arguments变量，arguments是一个类数组对象。\n\n**与ES5的写法相比：**\n\n- **在ES5中：**之前我们需要使用函数的参数时，需要将arguments类数组对象转换成一个数组。\n\nArray.prototype.slice.call(arguments)\n\n- **在ES6中：**就可以直接使用不定参数了。\n\n##### （4）. 扩展运算符 ...\n\n作用：将一个**数组**转为**用逗号分隔的参数序列**。\n\n```\nconsole.log(...[1,2,3]); //1 2 3\n```\n\n**与ES5相比：**在ES5中需要使用apply函数才能将数组转换成函数的参数。\n\n举个栗子：将两个数组合并\n\n```\n  //在ES5中\n  var a = [1,2,3];\n  var b = [4,5,6];\n  Array.prototype.push.apply(a,b);\n  \n  //使用ES6的扩展运算符\n  a.push(...b)\n```\n#### 4. 生成器函数Generator\n\n协程：多个线程互相协作，完成异步任务。\n\n（1）generator函数的定义          \n\n`function* myFunc () {  }`\n\n（2）generator函数的返回值，是一个遍历器对象\n\n```\n\tfunction* helloWorld () {\n\t    yield 'hello';\n\t}\n\n\tvar hw = helloWorld();//返回一个遍历器对象\n\t\n\t//执行遍历器对象的next方法，会返回一个对象，移动内部指针，即执行异步任务的第一阶段，遇到yeild会停止\n \tvar g = hw.next(); //g = {value: 'hello', done: bool};\n```\n\n遍历器对象有两个属性：value和done。\n\n- value 属性是 yield 语句后面表达式的值，表示当前阶段的值；\n- done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段\n\n在函数外面可以使用**g.throw()**捕获错误\n\n(3). 调用Generator函数时，函数并不执行，而是返回一个指向内部状态的指针对象——遍历器对象。\n\n\n\n(4). Generator中yield语句和return语句\n\n相同点：执行yield语句和return语句都能返回紧跟在语句后的值\n\n不同点：一个Generator函数中只能出现一次return语句，但是可以出现多次yield语句。\n\n#### 5. promise对象\n\n是js中的一种**异步编程**的模式。\n\n**与回调函数的不同点：**\n\n将回调函数变成了链式写法，每一个异步任务返回一个Promise对象，该对象有一个then方法。\n\npromise对象保存一个异步操作的结果。\n\n**（1）promise对象的三种状态**\n\n- pending进行中\n- resolved已完成\n- rejected已失败\n\n对象状态不会被外部改变，由异步操作的结果确定\n\n对象状态发生改变了之后就不会再改变了\n\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数\n\n#### 6. 模版字符串\n\n使用反撇号` `` `\n\n模板字符串内部使用`${}`将js表达式包起来\n\n与一般字符串的不同点：支持多行书写，比`+`号更优雅\n\n#### 7. 解构赋值\n\n#### 8. symbol类型\n\nsymbol是js中新增的一种数据类型。\n\n作用：可用作唯一的属性键，用来标识状态\n\n举个栗子：\n\n```\n\t// isMoving是一个Symbol对象\n    var isMoving = Symbol(\"isMoving\");\n    ...\n    if (element[isMoving]) {\n      smoothAnimations(element);\n    }\n    element[isMoving] = true;\n```\n\n#### 9. class类\n\n##### 1. 定义class\n\nclass关键字可以定义类\n\n**ES5中通过构造函数来定义对象**\n\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n**ES6中通过 class关键字定义类**\n\n```\n//定义类\nclass Point {\n//ES6中的构造方法constructor方法相当于ES5中的构造函数Point()\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n//使用类，与ES5的方法一致\n\n```\n var a = new Point();\n```\n\n注意：(1). 类里面的构造函数之间不需要逗号分隔\n(2). 用class声明的类的数据类型就是函数\n(3). 类里面定义的所有的方法都试定义在类的原型(prototype)上\n(4). 一个类必须有constructor方法\n(5). 不存在变量提升\n(6). class 与function类似，可以使用表达式的形式定义\n              ```\n const MyClass = class { /* ... */ };\n              ```\n(7). 用_fn的命名方式，定义私有方法\n\n##### 2. class的继承\n\n通过关键字extends实现继承\n\n```\n//ColorPoint继承了Point的所有属性和方法\nclass ColorPoint extends Point {}\nsuper(); //调用父类的构造函数方法\n子类必须在constructor方法中调用super方法\n```\n\n##### 3. class的取值函数和存值函数\n\n对某个属性设置取值函数和存值函数\n\n```\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  //prop属性的取值函数\n  get prop() {\n    return 'getter';\n  }\n  //prop属性的存值函数\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n```\n\n##### 4. class的静态方法\n\n(1). 使用`static`关键字声明的静态方法不会被实例继承\n(2). 父类的静态方法可以被子类调用\n(3). 子类的静态方法可以被super对象调用\n\n##### 5. class的静态属性和实例属性\nclass的静态属性：指的是class本身的属性，而不是定义在实例对象上的属性。\n\n```\neg:\nclass Foo {\n   static prop = 1;\n}\nclass的实例属性，可以用等式，写入类的定义之中。\nclass MyClass {\n  myProp = 42;\n\n  constructor() {\n    console.log(this.myProp); // 42\n  }\n}\n```\n\nES6中的class解决的问题：\n\n#### 10. ES6中新增的模块系统\n\nexport\nimport\n\n在ES6中，无论是否加入'use strict;'语句，默认情况下都是在严格模式下进行的。\n\n##### 1. 导出\n\n用export声明的部分，可以供其他模块使用。\n\n只写一行你想要导出的变量列表，再用花括号包起来。\n```\nexport {module1, module2...}\n```\n\n默认导出 \n```\nexport default ...\n```\nexport default命令用于指定模块的默认输出。一个模块只能有一个默认输出。\n\n本质上，export default就是输出一个叫做default的变量或方法，在导入时，可以为其取任意名字。\n\n在ES6中，使用CommonJS、AMD模块都有一个默认导出\n\n```\n//下面两种写法是等价的\nvar colors = require('colors.js');\nimport colors from colors.js;\n```\n\n##### 2. 导入\n```\nimport {module1, module2} from \"other.js\";\nimprot module form \"other.js\";\n```\n\n##### 3. 给导入或者导出的变量重新命名，使用as\n\n```\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n```","slug":"2016-07-31-ECMAScript 6入门","published":1,"updated":"2016-10-16T13:56:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjm00bid5u8lr46bn54","content":"<h3 id=\"一-什么是ECMAScript-与javaScript有什么关系？\"><a href=\"#一-什么是ECMAScript-与javaScript有什么关系？\" class=\"headerlink\" title=\"一. 什么是ECMAScript?与javaScript有什么关系？\"></a>一. 什么是ECMAScript?与javaScript有什么关系？</h3><p>ECMA————国际标准化组织</p>\n<p>ECMAScript是针对javaScript语言的制定的标准。</p>\n<p>ECMAScript是javaScript的规格，javaScript是ECMAScript的实现。</p>\n<p>随着时间的推移，浏览器对ES6中的支持已经越来越高，大部分特效已经实现了。</p>\n<h3 id=\"二-Babel\"><a href=\"#二-Babel\" class=\"headerlink\" title=\"二. Babel\"></a>二. Babel</h3><p>由于现在的浏览器对ES6的支持还没那么好，所以引入ES6代码之前需要对其进行转码。babel就是一个将ES6代码转为ES5代码的转码器。</p>\n<h3 id=\"三-ES6中的新特性\"><a href=\"#三-ES6中的新特性\" class=\"headerlink\" title=\"三. ES6中的新特性\"></a>三. ES6中的新特性</h3><h4 id=\"1-ES6中新增的声明变量的方法\"><a href=\"#1-ES6中新增的声明变量的方法\" class=\"headerlink\" title=\"1. ES6中新增的声明变量的方法\"></a>1. ES6中新增的声明变量的方法</h4><p>ES6中新增了2种声明变量的方法：<strong>let</strong>和<strong>const</strong></p>\n<p>使用let和const声明的变量，都是在<strong>块级作用域</strong>内有效，不存在变量提升，且不能被重复声明。</p>\n<h5 id=\"1-块级作用域｛｝\"><a href=\"#1-块级作用域｛｝\" class=\"headerlink\" title=\"(1). 块级作用域｛｝\"></a>(1). 块级作用域｛｝</h5><p>ES6中增加了块级作用域的概念，块级作用域的特点：</p>\n<ul>\n<li>外层作用域无法读取内层作用域的变量</li>\n<li>外层代码块不受内层代码块的影响</li>\n</ul>\n<h5 id=\"2-let命令\"><a href=\"#2-let命令\" class=\"headerlink\" title=\"(2). let命令\"></a>(2). let命令</h5><p>let命令和var命令一样，都是用来声明变量的</p>\n<p><strong>let与var不同之处：</strong></p>\n<ul>\n<li>let所声明的变量只在块级作用域内有效，而var声明的变量为函数作用域</li>\n<li>let声明的变量在相同作用域内，不能重复声明</li>\n<li>let不存在变量提升</li>\n<li>存在暂时性死区：在该作用域内，在使用let声明变量之前，是不能使用该变量的。</li>\n<li>var声明的变量是全局变量的属性，let声明的变量不是全局变量的属性</li>\n</ul>\n<h5 id=\"3-const命令\"><a href=\"#3-const命令\" class=\"headerlink\" title=\"(3). const命令\"></a>(3). const命令</h5><p>const命令用来声明常量，其特点如下：</p>\n<ul>\n<li>若声明的常量是基本类型的常量，声明之后其值不能改变；若声明的常量是复合类型的常量，声明之后其地址不能改变。</li>\n<li>不能重复声明</li>\n<li>声明常量时需要立即初始化</li>\n<li>只在块级作用域内有效</li>\n</ul>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当声明的常量是一个数组时，其地址不能改变，但是其值可以改变</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// a的值可以改变</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>; <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">'Dave'</span>]; <span class=\"comment\">// 不能将一个地址赋值给a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//若需要声明一个不能修改的对象常量，使用Object.freeze()方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">Object</span>.freeze(<span class=\"comment\">&#123; a: 2&#125;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Object</span>.freeze()是用来冻结一个对象的</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-使用const和let声明变量的好处\"><a href=\"#4-使用const和let声明变量的好处\" class=\"headerlink\" title=\"(4). 使用const和let声明变量的好处\"></a>(4). 使用const和let声明变量的好处</h5><ul>\n<li>使用let可以代替ES5中的自执行函数，块级作用域</li>\n<li>避免由变量声明提升带来的一些问题</li>\n</ul>\n<h4 id=\"2-for-of循环\"><a href=\"#2-for-of循环\" class=\"headerlink\" title=\"2. for-of循环\"></a>2. for-of循环</h4><p>遍历数组的几种方法：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最原始的方法</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(var <span class=\"keyword\">index</span>=<span class=\"number\">0</span>; <span class=\"keyword\">index</span> &lt; myArr.<span class=\"built_in\">length</span>; <span class=\"keyword\">index</span>++) &#123;</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(myArr[<span class=\"keyword\">index</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用forEach，这种方法的缺点：不能使用break语句中断循环，也不能使用return语句返回到外层函数</span></span><br><span class=\"line\">myArr.forEach(function(item,<span class=\"keyword\">index</span>,arr)&#123;</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(item);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用for-in，这种方法的缺点是会遍历所有的可枚举的属性，这里的index指的是字符串</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(var <span class=\"keyword\">index</span> <span class=\"keyword\">in</span> myArr) &#123;</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(myArr[<span class=\"keyword\">index</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面三种做法都有缺点，ES6提出了一种新的遍历数组的方法for-of，<strong>for-of循环语句通过方法调用来遍历各种集合</strong>。</p>\n<p><strong>使用for-of遍历数组</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用for-of遍历字符串</strong></p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i of 'qwe') &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"built_in\">q</span></span><br><span class=\"line\"><span class=\"built_in\">w</span></span><br><span class=\"line\"><span class=\"built_in\">e</span></span><br></pre></td></tr></table></figure>\n<p>for-of用来遍历ES6中的一些新的对象（有迭代器方法的对象）：</p>\n<p>数组、类数组对象、Map、Set、Generator、字符串</p>\n<p><strong>什么是遍历器对象？</strong></p>\n<p>有next方法的对象，就具备了遍历器功能。<br>next方法必须返回一个包含value和done两个属性的对象。<br>value属性是当前遍历的位置的值，而done属性是一个布尔值，用来表示遍历是否结束。</p>\n<p>eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">iterator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tnext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;value: index++, done: <span class=\"literal\">false</span>&#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = iterator();</span><br><span class=\"line\">it.next().value; <span class=\"comment\">// 0</span></span><br><span class=\"line\">it.next().value; <span class=\"comment\">// 1</span></span><br><span class=\"line\">it.next().value; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> n <span class=\"keyword\">of</span> it) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">控制台：<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-函数的扩展\"><a href=\"#3-函数的扩展\" class=\"headerlink\" title=\"3. 函数的扩展\"></a>3. 函数的扩展</h4><h5 id=\"（1）-箭头函数：-gt\"><a href=\"#（1）-箭头函数：-gt\" class=\"headerlink\" title=\"（1）. 箭头函数：=&gt;\"></a>（1）. 箭头函数：=&gt;</h5><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param =&gt; &#123;</span><br><span class=\"line\">  statements</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>箭头函数的特点：</strong></p>\n<ul>\n<li>若箭头后面是一个表达式，那么这个表达式的值会被return</li>\n<li>若箭头后面是一个代码块，那么需要用return语句来给函数返回值</li>\n<li>箭头函数不能当成构造函数使用</li>\n<li>箭头函数内部不能使用arguments对象</li>\n</ul>\n<p><strong>与ES5中的函数写法相比：</strong></p>\n<p>解决了this的指向问题</p>\n<ul>\n<li><strong>在ES5中：</strong>this对象的指向与函数具体是在什么样的情境下使用有关（一共有4种情况，普通函数，构造函数，对象的方法，apply/call/bind）</li>\n<li><strong>在ES6中：</strong>箭头函数中this的指向是固定的，箭头函数内的this值指向绑定时所在对象，而不是使用时。</li>\n</ul>\n<h5 id=\"（2）-可以给函数参数设置默认值\"><a href=\"#（2）-可以给函数参数设置默认值\" class=\"headerlink\" title=\"（2）. 可以给函数参数设置默认值\"></a>（2）. 可以给函数参数设置默认值</h5><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">function</span> <span class=\"selector-tag\">log</span>(x,y=<span class=\"string\">'world'</span>) &#123;</span><br><span class=\"line\"> \t\tconsole<span class=\"selector-class\">.log</span>(x,y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>与ES5的写法相比：</strong></p>\n<ul>\n<li>在ES5中：以前给参数设默认值，var y = y || ‘world’;</li>\n<li>在ES6中：给函数参数设置默认值的这种方式更简便一些。</li>\n</ul>\n<h5 id=\"（3）-引入不定参数（形式为‘…变量名’）\"><a href=\"#（3）-引入不定参数（形式为‘…变量名’）\" class=\"headerlink\" title=\"（3）. 引入不定参数（形式为‘…变量名’）\"></a>（3）. 引入不定参数（形式为‘…变量名’）</h5><p>不定参数是一个数组，将多余的参数放在了该数组中。</p>\n<p>在所有函数参数中，只有最后一个才可以被标记为不定参数。</p>\n<p>若没有多余的参数，那么不定参数是一个空数组。</p>\n<p>可以代替ES5中arguments变量，arguments是一个类数组对象。</p>\n<p><strong>与ES5的写法相比：</strong></p>\n<ul>\n<li><strong>在ES5中：</strong>之前我们需要使用函数的参数时，需要将arguments类数组对象转换成一个数组。</li>\n</ul>\n<p>Array.prototype.slice.call(arguments)</p>\n<ul>\n<li><strong>在ES6中：</strong>就可以直接使用不定参数了。</li>\n</ul>\n<h5 id=\"（4）-扩展运算符-…\"><a href=\"#（4）-扩展运算符-…\" class=\"headerlink\" title=\"（4）. 扩展运算符 …\"></a>（4）. 扩展运算符 …</h5><p>作用：将一个<strong>数组</strong>转为<strong>用逗号分隔的参数序列</strong>。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console<span class=\"selector-class\">.log</span>(...[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]); <span class=\"comment\">//1 2 3</span></span><br></pre></td></tr></table></figure>\n<p><strong>与ES5相比：</strong>在ES5中需要使用apply函数才能将数组转换成函数的参数。</p>\n<p>举个栗子：将两个数组合并</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在ES5中</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">Array</span>.prototype.push.apply(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用ES6的扩展运算符</span></span><br><span class=\"line\">a.push(...b)</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-生成器函数Generator\"><a href=\"#4-生成器函数Generator\" class=\"headerlink\" title=\"4. 生成器函数Generator\"></a>4. 生成器函数Generator</h4><p>协程：多个线程互相协作，完成异步任务。</p>\n<p>（1）generator函数的定义          </p>\n<p><code>function* myFunc () {  }</code></p>\n<p>（2）generator函数的返回值，是一个遍历器对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorld</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorld();<span class=\"comment\">//返回一个遍历器对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行遍历器对象的next方法，会返回一个对象，移动内部指针，即执行异步任务的第一阶段，遇到yeild会停止</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> g = hw.next(); <span class=\"comment\">//g = &#123;value: 'hello', done: bool&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>遍历器对象有两个属性：value和done。</p>\n<ul>\n<li>value 属性是 yield 语句后面表达式的值，表示当前阶段的值；</li>\n<li>done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段</li>\n</ul>\n<p>在函数外面可以使用<strong>g.throw()</strong>捕获错误</p>\n<p>(3). 调用Generator函数时，函数并不执行，而是返回一个指向内部状态的指针对象——遍历器对象。</p>\n<p>(4). Generator中yield语句和return语句</p>\n<p>相同点：执行yield语句和return语句都能返回紧跟在语句后的值</p>\n<p>不同点：一个Generator函数中只能出现一次return语句，但是可以出现多次yield语句。</p>\n<h4 id=\"5-promise对象\"><a href=\"#5-promise对象\" class=\"headerlink\" title=\"5. promise对象\"></a>5. promise对象</h4><p>是js中的一种<strong>异步编程</strong>的模式。</p>\n<p><strong>与回调函数的不同点：</strong></p>\n<p>将回调函数变成了链式写法，每一个异步任务返回一个Promise对象，该对象有一个then方法。</p>\n<p>promise对象保存一个异步操作的结果。</p>\n<p><strong>（1）promise对象的三种状态</strong></p>\n<ul>\n<li>pending进行中</li>\n<li>resolved已完成</li>\n<li>rejected已失败</li>\n</ul>\n<p>对象状态不会被外部改变，由异步操作的结果确定</p>\n<p>对象状态发生改变了之后就不会再改变了</p>\n<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p>\n<h4 id=\"6-模版字符串\"><a href=\"#6-模版字符串\" class=\"headerlink\" title=\"6. 模版字符串\"></a>6. 模版字符串</h4><p>使用反撇号<code>`` </code></p>\n<p>模板字符串内部使用<code>${}</code>将js表达式包起来</p>\n<p>与一般字符串的不同点：支持多行书写，比<code>+</code>号更优雅</p>\n<h4 id=\"7-解构赋值\"><a href=\"#7-解构赋值\" class=\"headerlink\" title=\"7. 解构赋值\"></a>7. 解构赋值</h4><h4 id=\"8-symbol类型\"><a href=\"#8-symbol类型\" class=\"headerlink\" title=\"8. symbol类型\"></a>8. symbol类型</h4><p>symbol是js中新增的一种数据类型。</p>\n<p>作用：可用作唯一的属性键，用来标识状态</p>\n<p>举个栗子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// isMoving是一个Symbol对象</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> isMoving = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"isMoving\"</span>);</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (element[isMoving]) &#123;</span><br><span class=\"line\">     smoothAnimations(element);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   element[isMoving] = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-class类\"><a href=\"#9-class类\" class=\"headerlink\" title=\"9. class类\"></a>9. class类</h4><h5 id=\"1-定义class\"><a href=\"#1-定义class\" class=\"headerlink\" title=\"1. 定义class\"></a>1. 定义class</h5><p>class关键字可以定义类</p>\n<p><strong>ES5中通过构造函数来定义对象</strong></p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>ES6中通过 class关键字定义类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//ES6中的构造方法constructor方法相当于ES5中的构造函数Point()</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//使用类，与ES5的方法一致</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Point();</span><br></pre></td></tr></table></figure>\n<p>注意：(1). 类里面的构造函数之间不需要逗号分隔<br>(2). 用class声明的类的数据类型就是函数<br>(3). 类里面定义的所有的方法都试定义在类的原型(prototype)上<br>(4). 一个类必须有constructor方法<br>(5). 不存在变量提升<br>(6). class 与function类似，可以使用表达式的形式定义<br>              <figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>(7). 用_fn的命名方式，定义私有方法</p>\n<h5 id=\"2-class的继承\"><a href=\"#2-class的继承\" class=\"headerlink\" title=\"2. class的继承\"></a>2. class的继承</h5><p>通过关键字extends实现继承</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ColorPoint继承了Point的所有属性和方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">super</span>(); <span class=\"comment\">//调用父类的构造函数方法</span></span><br><span class=\"line\">子类必须在constructor方法中调用<span class=\"keyword\">super</span>方法</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-class的取值函数和存值函数\"><a href=\"#3-class的取值函数和存值函数\" class=\"headerlink\" title=\"3. class的取值函数和存值函数\"></a>3. class的取值函数和存值函数</h5><p>对某个属性设置取值函数和存值函数</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//prop属性的取值函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">get</span> <span class=\"title\">prop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//prop属性的存值函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">set</span> <span class=\"title\">prop</span>(<span class=\"params\"><span class=\"keyword\">value</span></span>) </span>&#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'setter: '</span>+<span class=\"keyword\">value</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-class的静态方法\"><a href=\"#4-class的静态方法\" class=\"headerlink\" title=\"4. class的静态方法\"></a>4. class的静态方法</h5><p>(1). 使用<code>static</code>关键字声明的静态方法不会被实例继承<br>(2). 父类的静态方法可以被子类调用<br>(3). 子类的静态方法可以被super对象调用</p>\n<h5 id=\"5-class的静态属性和实例属性\"><a href=\"#5-class的静态属性和实例属性\" class=\"headerlink\" title=\"5. class的静态属性和实例属性\"></a>5. class的静态属性和实例属性</h5><p>class的静态属性：指的是class本身的属性，而不是定义在实例对象上的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> prop = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>的实例属性，可以用等式，写入类的定义之中。</span><br><span class=\"line\"><span class=\"title\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  myProp = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myProp); <span class=\"comment\">// 42</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6中的class解决的问题：</p>\n<h4 id=\"10-ES6中新增的模块系统\"><a href=\"#10-ES6中新增的模块系统\" class=\"headerlink\" title=\"10. ES6中新增的模块系统\"></a>10. ES6中新增的模块系统</h4><p>export<br>import</p>\n<p>在ES6中，无论是否加入’use strict;’语句，默认情况下都是在严格模式下进行的。</p>\n<h5 id=\"1-导出\"><a href=\"#1-导出\" class=\"headerlink\" title=\"1. 导出\"></a>1. 导出</h5><p>用export声明的部分，可以供其他模块使用。</p>\n<p>只写一行你想要导出的变量列表，再用花括号包起来。<br><figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;<span class=\"keyword\">module</span><span class=\"number\">1</span>, <span class=\"keyword\">module</span><span class=\"number\">2</span>...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认导出<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ...</span><br></pre></td></tr></table></figure></p>\n<p>export default命令用于指定模块的默认输出。一个模块只能有一个默认输出。</p>\n<p>本质上，export default就是输出一个叫做default的变量或方法，在导入时，可以为其取任意名字。</p>\n<p>在ES6中，使用CommonJS、AMD模块都有一个默认导出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面两种写法是等价的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> colors = <span class=\"built_in\">require</span>(<span class=\"string\">'colors.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> colors <span class=\"keyword\">from</span> colors.js;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-导入\"><a href=\"#2-导入\" class=\"headerlink\" title=\"2. 导入\"></a>2. 导入</h5><figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"keyword\">module</span><span class=\"number\">1</span>, <span class=\"keyword\">module</span><span class=\"number\">2</span>&#125; from <span class=\"string\">\"other.js\"</span>;</span><br><span class=\"line\">improt <span class=\"keyword\">module</span> form <span class=\"string\">\"other.js\"</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-给导入或者导出的变量重新命名，使用as\"><a href=\"#3-给导入或者导出的变量重新命名，使用as\" class=\"headerlink\" title=\"3. 给导入或者导出的变量重新命名，使用as\"></a>3. 给导入或者导出的变量重新命名，使用as</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v1</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v2</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  v1 <span class=\"keyword\">as</span> streamV1,</span><br><span class=\"line\">  v2 <span class=\"keyword\">as</span> streamV2,</span><br><span class=\"line\">  v2 <span class=\"keyword\">as</span> streamLatestVersion</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-什么是ECMAScript-与javaScript有什么关系？\"><a href=\"#一-什么是ECMAScript-与javaScript有什么关系？\" class=\"headerlink\" title=\"一. 什么是ECMAScript?与javaScript有什么关系？\"></a>一. 什么是ECMAScript?与javaScript有什么关系？</h3><p>ECMA————国际标准化组织</p>\n<p>ECMAScript是针对javaScript语言的制定的标准。</p>\n<p>ECMAScript是javaScript的规格，javaScript是ECMAScript的实现。</p>\n<p>随着时间的推移，浏览器对ES6中的支持已经越来越高，大部分特效已经实现了。</p>\n<h3 id=\"二-Babel\"><a href=\"#二-Babel\" class=\"headerlink\" title=\"二. Babel\"></a>二. Babel</h3><p>由于现在的浏览器对ES6的支持还没那么好，所以引入ES6代码之前需要对其进行转码。babel就是一个将ES6代码转为ES5代码的转码器。</p>\n<h3 id=\"三-ES6中的新特性\"><a href=\"#三-ES6中的新特性\" class=\"headerlink\" title=\"三. ES6中的新特性\"></a>三. ES6中的新特性</h3><h4 id=\"1-ES6中新增的声明变量的方法\"><a href=\"#1-ES6中新增的声明变量的方法\" class=\"headerlink\" title=\"1. ES6中新增的声明变量的方法\"></a>1. ES6中新增的声明变量的方法</h4><p>ES6中新增了2种声明变量的方法：<strong>let</strong>和<strong>const</strong></p>\n<p>使用let和const声明的变量，都是在<strong>块级作用域</strong>内有效，不存在变量提升，且不能被重复声明。</p>\n<h5 id=\"1-块级作用域｛｝\"><a href=\"#1-块级作用域｛｝\" class=\"headerlink\" title=\"(1). 块级作用域｛｝\"></a>(1). 块级作用域｛｝</h5><p>ES6中增加了块级作用域的概念，块级作用域的特点：</p>\n<ul>\n<li>外层作用域无法读取内层作用域的变量</li>\n<li>外层代码块不受内层代码块的影响</li>\n</ul>\n<h5 id=\"2-let命令\"><a href=\"#2-let命令\" class=\"headerlink\" title=\"(2). let命令\"></a>(2). let命令</h5><p>let命令和var命令一样，都是用来声明变量的</p>\n<p><strong>let与var不同之处：</strong></p>\n<ul>\n<li>let所声明的变量只在块级作用域内有效，而var声明的变量为函数作用域</li>\n<li>let声明的变量在相同作用域内，不能重复声明</li>\n<li>let不存在变量提升</li>\n<li>存在暂时性死区：在该作用域内，在使用let声明变量之前，是不能使用该变量的。</li>\n<li>var声明的变量是全局变量的属性，let声明的变量不是全局变量的属性</li>\n</ul>\n<h5 id=\"3-const命令\"><a href=\"#3-const命令\" class=\"headerlink\" title=\"(3). const命令\"></a>(3). const命令</h5><p>const命令用来声明常量，其特点如下：</p>\n<ul>\n<li>若声明的常量是基本类型的常量，声明之后其值不能改变；若声明的常量是复合类型的常量，声明之后其地址不能改变。</li>\n<li>不能重复声明</li>\n<li>声明常量时需要立即初始化</li>\n<li>只在块级作用域内有效</li>\n</ul>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当声明的常量是一个数组时，其地址不能改变，但是其值可以改变</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// a的值可以改变</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>; <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">'Dave'</span>]; <span class=\"comment\">// 不能将一个地址赋值给a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//若需要声明一个不能修改的对象常量，使用Object.freeze()方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">Object</span>.freeze(<span class=\"comment\">&#123; a: 2&#125;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Object</span>.freeze()是用来冻结一个对象的</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-使用const和let声明变量的好处\"><a href=\"#4-使用const和let声明变量的好处\" class=\"headerlink\" title=\"(4). 使用const和let声明变量的好处\"></a>(4). 使用const和let声明变量的好处</h5><ul>\n<li>使用let可以代替ES5中的自执行函数，块级作用域</li>\n<li>避免由变量声明提升带来的一些问题</li>\n</ul>\n<h4 id=\"2-for-of循环\"><a href=\"#2-for-of循环\" class=\"headerlink\" title=\"2. for-of循环\"></a>2. for-of循环</h4><p>遍历数组的几种方法：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最原始的方法</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(var <span class=\"keyword\">index</span>=<span class=\"number\">0</span>; <span class=\"keyword\">index</span> &lt; myArr.<span class=\"built_in\">length</span>; <span class=\"keyword\">index</span>++) &#123;</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(myArr[<span class=\"keyword\">index</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用forEach，这种方法的缺点：不能使用break语句中断循环，也不能使用return语句返回到外层函数</span></span><br><span class=\"line\">myArr.forEach(function(item,<span class=\"keyword\">index</span>,arr)&#123;</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(item);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用for-in，这种方法的缺点是会遍历所有的可枚举的属性，这里的index指的是字符串</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(var <span class=\"keyword\">index</span> <span class=\"keyword\">in</span> myArr) &#123;</span><br><span class=\"line\">\tconsole.<span class=\"built_in\">log</span>(myArr[<span class=\"keyword\">index</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面三种做法都有缺点，ES6提出了一种新的遍历数组的方法for-of，<strong>for-of循环语句通过方法调用来遍历各种集合</strong>。</p>\n<p><strong>使用for-of遍历数组</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用for-of遍历字符串</strong></p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i of 'qwe') &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"built_in\">q</span></span><br><span class=\"line\"><span class=\"built_in\">w</span></span><br><span class=\"line\"><span class=\"built_in\">e</span></span><br></pre></td></tr></table></figure>\n<p>for-of用来遍历ES6中的一些新的对象（有迭代器方法的对象）：</p>\n<p>数组、类数组对象、Map、Set、Generator、字符串</p>\n<p><strong>什么是遍历器对象？</strong></p>\n<p>有next方法的对象，就具备了遍历器功能。<br>next方法必须返回一个包含value和done两个属性的对象。<br>value属性是当前遍历的位置的值，而done属性是一个布尔值，用来表示遍历是否结束。</p>\n<p>eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">iterator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tnext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123;value: index++, done: <span class=\"literal\">false</span>&#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = iterator();</span><br><span class=\"line\">it.next().value; <span class=\"comment\">// 0</span></span><br><span class=\"line\">it.next().value; <span class=\"comment\">// 1</span></span><br><span class=\"line\">it.next().value; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> n <span class=\"keyword\">of</span> it) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">控制台：<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-函数的扩展\"><a href=\"#3-函数的扩展\" class=\"headerlink\" title=\"3. 函数的扩展\"></a>3. 函数的扩展</h4><h5 id=\"（1）-箭头函数：-gt\"><a href=\"#（1）-箭头函数：-gt\" class=\"headerlink\" title=\"（1）. 箭头函数：=&gt;\"></a>（1）. 箭头函数：=&gt;</h5><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param =&gt; &#123;</span><br><span class=\"line\">  statements</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>箭头函数的特点：</strong></p>\n<ul>\n<li>若箭头后面是一个表达式，那么这个表达式的值会被return</li>\n<li>若箭头后面是一个代码块，那么需要用return语句来给函数返回值</li>\n<li>箭头函数不能当成构造函数使用</li>\n<li>箭头函数内部不能使用arguments对象</li>\n</ul>\n<p><strong>与ES5中的函数写法相比：</strong></p>\n<p>解决了this的指向问题</p>\n<ul>\n<li><strong>在ES5中：</strong>this对象的指向与函数具体是在什么样的情境下使用有关（一共有4种情况，普通函数，构造函数，对象的方法，apply/call/bind）</li>\n<li><strong>在ES6中：</strong>箭头函数中this的指向是固定的，箭头函数内的this值指向绑定时所在对象，而不是使用时。</li>\n</ul>\n<h5 id=\"（2）-可以给函数参数设置默认值\"><a href=\"#（2）-可以给函数参数设置默认值\" class=\"headerlink\" title=\"（2）. 可以给函数参数设置默认值\"></a>（2）. 可以给函数参数设置默认值</h5><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">function</span> <span class=\"selector-tag\">log</span>(x,y=<span class=\"string\">'world'</span>) &#123;</span><br><span class=\"line\"> \t\tconsole<span class=\"selector-class\">.log</span>(x,y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>与ES5的写法相比：</strong></p>\n<ul>\n<li>在ES5中：以前给参数设默认值，var y = y || ‘world’;</li>\n<li>在ES6中：给函数参数设置默认值的这种方式更简便一些。</li>\n</ul>\n<h5 id=\"（3）-引入不定参数（形式为‘…变量名’）\"><a href=\"#（3）-引入不定参数（形式为‘…变量名’）\" class=\"headerlink\" title=\"（3）. 引入不定参数（形式为‘…变量名’）\"></a>（3）. 引入不定参数（形式为‘…变量名’）</h5><p>不定参数是一个数组，将多余的参数放在了该数组中。</p>\n<p>在所有函数参数中，只有最后一个才可以被标记为不定参数。</p>\n<p>若没有多余的参数，那么不定参数是一个空数组。</p>\n<p>可以代替ES5中arguments变量，arguments是一个类数组对象。</p>\n<p><strong>与ES5的写法相比：</strong></p>\n<ul>\n<li><strong>在ES5中：</strong>之前我们需要使用函数的参数时，需要将arguments类数组对象转换成一个数组。</li>\n</ul>\n<p>Array.prototype.slice.call(arguments)</p>\n<ul>\n<li><strong>在ES6中：</strong>就可以直接使用不定参数了。</li>\n</ul>\n<h5 id=\"（4）-扩展运算符-…\"><a href=\"#（4）-扩展运算符-…\" class=\"headerlink\" title=\"（4）. 扩展运算符 …\"></a>（4）. 扩展运算符 …</h5><p>作用：将一个<strong>数组</strong>转为<strong>用逗号分隔的参数序列</strong>。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console<span class=\"selector-class\">.log</span>(...[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]); <span class=\"comment\">//1 2 3</span></span><br></pre></td></tr></table></figure>\n<p><strong>与ES5相比：</strong>在ES5中需要使用apply函数才能将数组转换成函数的参数。</p>\n<p>举个栗子：将两个数组合并</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在ES5中</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">Array</span>.prototype.push.apply(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用ES6的扩展运算符</span></span><br><span class=\"line\">a.push(...b)</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-生成器函数Generator\"><a href=\"#4-生成器函数Generator\" class=\"headerlink\" title=\"4. 生成器函数Generator\"></a>4. 生成器函数Generator</h4><p>协程：多个线程互相协作，完成异步任务。</p>\n<p>（1）generator函数的定义          </p>\n<p><code>function* myFunc () {  }</code></p>\n<p>（2）generator函数的返回值，是一个遍历器对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorld</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorld();<span class=\"comment\">//返回一个遍历器对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行遍历器对象的next方法，会返回一个对象，移动内部指针，即执行异步任务的第一阶段，遇到yeild会停止</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> g = hw.next(); <span class=\"comment\">//g = &#123;value: 'hello', done: bool&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>遍历器对象有两个属性：value和done。</p>\n<ul>\n<li>value 属性是 yield 语句后面表达式的值，表示当前阶段的值；</li>\n<li>done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段</li>\n</ul>\n<p>在函数外面可以使用<strong>g.throw()</strong>捕获错误</p>\n<p>(3). 调用Generator函数时，函数并不执行，而是返回一个指向内部状态的指针对象——遍历器对象。</p>\n<p>(4). Generator中yield语句和return语句</p>\n<p>相同点：执行yield语句和return语句都能返回紧跟在语句后的值</p>\n<p>不同点：一个Generator函数中只能出现一次return语句，但是可以出现多次yield语句。</p>\n<h4 id=\"5-promise对象\"><a href=\"#5-promise对象\" class=\"headerlink\" title=\"5. promise对象\"></a>5. promise对象</h4><p>是js中的一种<strong>异步编程</strong>的模式。</p>\n<p><strong>与回调函数的不同点：</strong></p>\n<p>将回调函数变成了链式写法，每一个异步任务返回一个Promise对象，该对象有一个then方法。</p>\n<p>promise对象保存一个异步操作的结果。</p>\n<p><strong>（1）promise对象的三种状态</strong></p>\n<ul>\n<li>pending进行中</li>\n<li>resolved已完成</li>\n<li>rejected已失败</li>\n</ul>\n<p>对象状态不会被外部改变，由异步操作的结果确定</p>\n<p>对象状态发生改变了之后就不会再改变了</p>\n<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p>\n<h4 id=\"6-模版字符串\"><a href=\"#6-模版字符串\" class=\"headerlink\" title=\"6. 模版字符串\"></a>6. 模版字符串</h4><p>使用反撇号<code>`` </code></p>\n<p>模板字符串内部使用<code>${}</code>将js表达式包起来</p>\n<p>与一般字符串的不同点：支持多行书写，比<code>+</code>号更优雅</p>\n<h4 id=\"7-解构赋值\"><a href=\"#7-解构赋值\" class=\"headerlink\" title=\"7. 解构赋值\"></a>7. 解构赋值</h4><h4 id=\"8-symbol类型\"><a href=\"#8-symbol类型\" class=\"headerlink\" title=\"8. symbol类型\"></a>8. symbol类型</h4><p>symbol是js中新增的一种数据类型。</p>\n<p>作用：可用作唯一的属性键，用来标识状态</p>\n<p>举个栗子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// isMoving是一个Symbol对象</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> isMoving = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"isMoving\"</span>);</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (element[isMoving]) &#123;</span><br><span class=\"line\">     smoothAnimations(element);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   element[isMoving] = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-class类\"><a href=\"#9-class类\" class=\"headerlink\" title=\"9. class类\"></a>9. class类</h4><h5 id=\"1-定义class\"><a href=\"#1-定义class\" class=\"headerlink\" title=\"1. 定义class\"></a>1. 定义class</h5><p>class关键字可以定义类</p>\n<p><strong>ES5中通过构造函数来定义对象</strong></p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>ES6中通过 class关键字定义类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//ES6中的构造方法constructor方法相当于ES5中的构造函数Point()</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//使用类，与ES5的方法一致</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Point();</span><br></pre></td></tr></table></figure>\n<p>注意：(1). 类里面的构造函数之间不需要逗号分隔<br>(2). 用class声明的类的数据类型就是函数<br>(3). 类里面定义的所有的方法都试定义在类的原型(prototype)上<br>(4). 一个类必须有constructor方法<br>(5). 不存在变量提升<br>(6). class 与function类似，可以使用表达式的形式定义<br>              <figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>(7). 用_fn的命名方式，定义私有方法</p>\n<h5 id=\"2-class的继承\"><a href=\"#2-class的继承\" class=\"headerlink\" title=\"2. class的继承\"></a>2. class的继承</h5><p>通过关键字extends实现继承</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ColorPoint继承了Point的所有属性和方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">super</span>(); <span class=\"comment\">//调用父类的构造函数方法</span></span><br><span class=\"line\">子类必须在constructor方法中调用<span class=\"keyword\">super</span>方法</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-class的取值函数和存值函数\"><a href=\"#3-class的取值函数和存值函数\" class=\"headerlink\" title=\"3. class的取值函数和存值函数\"></a>3. class的取值函数和存值函数</h5><p>对某个属性设置取值函数和存值函数</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//prop属性的取值函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">get</span> <span class=\"title\">prop</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//prop属性的存值函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">set</span> <span class=\"title\">prop</span>(<span class=\"params\"><span class=\"keyword\">value</span></span>) </span>&#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'setter: '</span>+<span class=\"keyword\">value</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-class的静态方法\"><a href=\"#4-class的静态方法\" class=\"headerlink\" title=\"4. class的静态方法\"></a>4. class的静态方法</h5><p>(1). 使用<code>static</code>关键字声明的静态方法不会被实例继承<br>(2). 父类的静态方法可以被子类调用<br>(3). 子类的静态方法可以被super对象调用</p>\n<h5 id=\"5-class的静态属性和实例属性\"><a href=\"#5-class的静态属性和实例属性\" class=\"headerlink\" title=\"5. class的静态属性和实例属性\"></a>5. class的静态属性和实例属性</h5><p>class的静态属性：指的是class本身的属性，而不是定义在实例对象上的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> prop = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>的实例属性，可以用等式，写入类的定义之中。</span><br><span class=\"line\"><span class=\"title\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  myProp = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myProp); <span class=\"comment\">// 42</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6中的class解决的问题：</p>\n<h4 id=\"10-ES6中新增的模块系统\"><a href=\"#10-ES6中新增的模块系统\" class=\"headerlink\" title=\"10. ES6中新增的模块系统\"></a>10. ES6中新增的模块系统</h4><p>export<br>import</p>\n<p>在ES6中，无论是否加入’use strict;’语句，默认情况下都是在严格模式下进行的。</p>\n<h5 id=\"1-导出\"><a href=\"#1-导出\" class=\"headerlink\" title=\"1. 导出\"></a>1. 导出</h5><p>用export声明的部分，可以供其他模块使用。</p>\n<p>只写一行你想要导出的变量列表，再用花括号包起来。<br><figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123;<span class=\"keyword\">module</span><span class=\"number\">1</span>, <span class=\"keyword\">module</span><span class=\"number\">2</span>...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认导出<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ...</span><br></pre></td></tr></table></figure></p>\n<p>export default命令用于指定模块的默认输出。一个模块只能有一个默认输出。</p>\n<p>本质上，export default就是输出一个叫做default的变量或方法，在导入时，可以为其取任意名字。</p>\n<p>在ES6中，使用CommonJS、AMD模块都有一个默认导出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面两种写法是等价的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> colors = <span class=\"built_in\">require</span>(<span class=\"string\">'colors.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> colors <span class=\"keyword\">from</span> colors.js;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-导入\"><a href=\"#2-导入\" class=\"headerlink\" title=\"2. 导入\"></a>2. 导入</h5><figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"keyword\">module</span><span class=\"number\">1</span>, <span class=\"keyword\">module</span><span class=\"number\">2</span>&#125; from <span class=\"string\">\"other.js\"</span>;</span><br><span class=\"line\">improt <span class=\"keyword\">module</span> form <span class=\"string\">\"other.js\"</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-给导入或者导出的变量重新命名，使用as\"><a href=\"#3-给导入或者导出的变量重新命名，使用as\" class=\"headerlink\" title=\"3. 给导入或者导出的变量重新命名，使用as\"></a>3. 给导入或者导出的变量重新命名，使用as</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v1</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v2</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  v1 <span class=\"keyword\">as</span> streamV1,</span><br><span class=\"line\">  v2 <span class=\"keyword\">as</span> streamV2,</span><br><span class=\"line\">  v2 <span class=\"keyword\">as</span> streamLatestVersion</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"用原生js实现由className获取dom节点","date":"2016-07-31T16:00:00.000Z","description":null,"_content":"可以实现传入多个类名获取相应的dom节点\n\n- 由（a）获取 `<p class='a'></p>`\n- 由（a）获取 `<p class='a b'></p>`\n- 由（a b）获取 `<p class='a b'></p>`\n- 由（a b）获取 `<p class='a b c'></p>`\n\n```\nvar getElementsByClassName = function (searchClass, node,tag) {\n  \t  //函数后面两个参数可选，设置默认参数\n      node = node || document;\n      tag = tag || \"*\";\n\n      //将传入的class按照空格分裂开\n      var classes = searchClass.split(\" \");\n      var elements = node.getElementsByTagName(tag),\n      patterns = [],\n      current,\n      match;\n\n      //将传入的class变成正则表达式\n      for(var i = 0; i < classes.length; i++) {\n        patterns.push(new RegExp(\"(^|\\\\s)\" + classes[i] + \"(\\\\s|$)\"));\n      }\n\n      for(var j = 0; j < elements.length; j++) {\n        current = elements[j];\n        match = false;\n        for(var k = 0; k < patterns.length; k++){\n\n          //Reg.test(string)判断string中是否有匹配的字符串，如果有，返回true\n          match = patterns[k].test(current.className);\n          if (!match)  {\n            break;//跳出最内层循环\n          }\n        }\n        if (match) {\n          result.push(current);\n        }\n      }\n        \n      \n      return result;\n    }\n  }\n```","source":"_posts/2016-08-01-用原生js实现由className获取dom节点.md","raw":"---\nlayout: post\ntitle: 用原生js实现由className获取dom节点\ndate: 2016-08-01\ncategories: javaScript\ntags: [javaScript,DOM]\ndescription: \n---\n可以实现传入多个类名获取相应的dom节点\n\n- 由（a）获取 `<p class='a'></p>`\n- 由（a）获取 `<p class='a b'></p>`\n- 由（a b）获取 `<p class='a b'></p>`\n- 由（a b）获取 `<p class='a b c'></p>`\n\n```\nvar getElementsByClassName = function (searchClass, node,tag) {\n  \t  //函数后面两个参数可选，设置默认参数\n      node = node || document;\n      tag = tag || \"*\";\n\n      //将传入的class按照空格分裂开\n      var classes = searchClass.split(\" \");\n      var elements = node.getElementsByTagName(tag),\n      patterns = [],\n      current,\n      match;\n\n      //将传入的class变成正则表达式\n      for(var i = 0; i < classes.length; i++) {\n        patterns.push(new RegExp(\"(^|\\\\s)\" + classes[i] + \"(\\\\s|$)\"));\n      }\n\n      for(var j = 0; j < elements.length; j++) {\n        current = elements[j];\n        match = false;\n        for(var k = 0; k < patterns.length; k++){\n\n          //Reg.test(string)判断string中是否有匹配的字符串，如果有，返回true\n          match = patterns[k].test(current.className);\n          if (!match)  {\n            break;//跳出最内层循环\n          }\n        }\n        if (match) {\n          result.push(current);\n        }\n      }\n        \n      \n      return result;\n    }\n  }\n```","slug":"2016-08-01-用原生js实现由className获取dom节点","published":1,"updated":"2016-08-18T08:35:38.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjo00bld5u8ke6t1qb0","content":"<p>可以实现传入多个类名获取相应的dom节点</p>\n<ul>\n<li>由（a）获取 <code>&lt;p class=&#39;a&#39;&gt;&lt;/p&gt;</code></li>\n<li>由（a）获取 <code>&lt;p class=&#39;a b&#39;&gt;&lt;/p&gt;</code></li>\n<li>由（a b）获取 <code>&lt;p class=&#39;a b&#39;&gt;&lt;/p&gt;</code></li>\n<li>由（a b）获取 <code>&lt;p class=&#39;a b c&#39;&gt;&lt;/p&gt;</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getElementsByClassName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">searchClass, node,tag</span>) </span>&#123;</span><br><span class=\"line\">  \t  <span class=\"comment\">//函数后面两个参数可选，设置默认参数</span></span><br><span class=\"line\">      node = node || <span class=\"built_in\">document</span>;</span><br><span class=\"line\">      tag = tag || <span class=\"string\">\"*\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//将传入的class按照空格分裂开</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> classes = searchClass.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> elements = node.getElementsByTagName(tag),</span><br><span class=\"line\">      patterns = [],</span><br><span class=\"line\">      current,</span><br><span class=\"line\">      match;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//将传入的class变成正则表达式</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; classes.length; i++) &#123;</span><br><span class=\"line\">        patterns.push(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|\\\\s)\"</span> + classes[i] + <span class=\"string\">\"(\\\\s|$)\"</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; elements.length; j++) &#123;</span><br><span class=\"line\">        current = elements[j];</span><br><span class=\"line\">        match = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; patterns.length; k++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">//Reg.test(string)判断string中是否有匹配的字符串，如果有，返回true</span></span><br><span class=\"line\">          match = patterns[k].test(current.className);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!match)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;<span class=\"comment\">//跳出最内层循环</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (match) &#123;</span><br><span class=\"line\">          result.push(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>可以实现传入多个类名获取相应的dom节点</p>\n<ul>\n<li>由（a）获取 <code>&lt;p class=&#39;a&#39;&gt;&lt;/p&gt;</code></li>\n<li>由（a）获取 <code>&lt;p class=&#39;a b&#39;&gt;&lt;/p&gt;</code></li>\n<li>由（a b）获取 <code>&lt;p class=&#39;a b&#39;&gt;&lt;/p&gt;</code></li>\n<li>由（a b）获取 <code>&lt;p class=&#39;a b c&#39;&gt;&lt;/p&gt;</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getElementsByClassName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">searchClass, node,tag</span>) </span>&#123;</span><br><span class=\"line\">  \t  <span class=\"comment\">//函数后面两个参数可选，设置默认参数</span></span><br><span class=\"line\">      node = node || <span class=\"built_in\">document</span>;</span><br><span class=\"line\">      tag = tag || <span class=\"string\">\"*\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//将传入的class按照空格分裂开</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> classes = searchClass.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> elements = node.getElementsByTagName(tag),</span><br><span class=\"line\">      patterns = [],</span><br><span class=\"line\">      current,</span><br><span class=\"line\">      match;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//将传入的class变成正则表达式</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; classes.length; i++) &#123;</span><br><span class=\"line\">        patterns.push(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|\\\\s)\"</span> + classes[i] + <span class=\"string\">\"(\\\\s|$)\"</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; elements.length; j++) &#123;</span><br><span class=\"line\">        current = elements[j];</span><br><span class=\"line\">        match = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; patterns.length; k++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">//Reg.test(string)判断string中是否有匹配的字符串，如果有，返回true</span></span><br><span class=\"line\">          match = patterns[k].test(current.className);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!match)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;<span class=\"comment\">//跳出最内层循环</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (match) &#123;</span><br><span class=\"line\">          result.push(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"webpack","date":"2016-08-15T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是webpack\n\nwebpack是一个前端构建工具，其主要思想是将项目中用到的一切静态资源都看成是模块，webpack可以对其进行统一的管理和发布。\n\nwebpack中支持使用AMD和CommonJS规范。\n\n>webpack可以看成模块打包机，它所做的功能：分析项目结构，找到js模块，和其他一些模块（Scss等），并将其进行相应的处理，打包为合适的格式给浏览器使用。\n\n### 二. webpack模块加载器Loaders\n\nwebpack本身只支持将js模块打包，对于图片、CSS、LESS、JSX等等，需要首先使用对应的模块加载器进行转换。\n\n举个栗子：\n\nLESS文件 ——> 通过less-load处理成css ——> 通过css-loader加载成css模块 ——> 由style-loader做最后的处理\n\nWebpack的加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。\n\n### 三. 打包成多个资源文件\n\n将项目中的模块打包成多个资源文件有两个目的：\n\n1. 将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率；\n2. 按需加载，减少页面初次加载时间。\n\n### 四. webpack打包之后的文件\n\nwebpack兼容commonjs规范、AMD\n\n打包之前的2个模块：\n\n**parent.js**\n\n```\nvar cats = ['dave','henry','martha'];\n//commonJS的写法\nmodule.exports = cats;\n```\n\n**app.js**\n\n```\ncats = require('./parent.js');\n```\n\n**打包之后的文件：**\n\n```\n([\n\tfunction(module, exports, __webpack_require__) {\n    \tcats = __webpack_require__(1);\n    \tconsole.log(cats);\n\t},\n    \n\tfunction(module, exports) {\n        var cats = ['dave', 'henry', 'martha'];\n        module.exports = cats;\n\t}\n])\n```\n\n数组第一个元素是app.js里面的内容，第二个元素是依赖的内容\n\n由此可见，不仅app.js里面的内容被打包进app.bundle.js，app.js所依赖度cats.js也被打包了进来。\n\nwebpack打包原理是边读边分析入口文件的依赖，分析入口文件依赖的文件的依赖，以此类推，只要有依赖都去分析并打包到输出文件(app.bundle.js)中\n\n### 五. 生成source maps\n\n使得调试更容易\n\n在配置文件中加上`devtool`字段\n\ndevtool的取值有\n\n- source-map\n- cheap-module-source-map\n- eval-source-map\n- cheap-module-eval-source-map","source":"_posts/2016-08-16- webpack.md","raw":"---\nlayout: post\ntitle: webpack\ndate: 2016-08-16\ncategories: 工具\ntags: [工具]\ndescription: \n---\n\n### 一. 什么是webpack\n\nwebpack是一个前端构建工具，其主要思想是将项目中用到的一切静态资源都看成是模块，webpack可以对其进行统一的管理和发布。\n\nwebpack中支持使用AMD和CommonJS规范。\n\n>webpack可以看成模块打包机，它所做的功能：分析项目结构，找到js模块，和其他一些模块（Scss等），并将其进行相应的处理，打包为合适的格式给浏览器使用。\n\n### 二. webpack模块加载器Loaders\n\nwebpack本身只支持将js模块打包，对于图片、CSS、LESS、JSX等等，需要首先使用对应的模块加载器进行转换。\n\n举个栗子：\n\nLESS文件 ——> 通过less-load处理成css ——> 通过css-loader加载成css模块 ——> 由style-loader做最后的处理\n\nWebpack的加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。\n\n### 三. 打包成多个资源文件\n\n将项目中的模块打包成多个资源文件有两个目的：\n\n1. 将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率；\n2. 按需加载，减少页面初次加载时间。\n\n### 四. webpack打包之后的文件\n\nwebpack兼容commonjs规范、AMD\n\n打包之前的2个模块：\n\n**parent.js**\n\n```\nvar cats = ['dave','henry','martha'];\n//commonJS的写法\nmodule.exports = cats;\n```\n\n**app.js**\n\n```\ncats = require('./parent.js');\n```\n\n**打包之后的文件：**\n\n```\n([\n\tfunction(module, exports, __webpack_require__) {\n    \tcats = __webpack_require__(1);\n    \tconsole.log(cats);\n\t},\n    \n\tfunction(module, exports) {\n        var cats = ['dave', 'henry', 'martha'];\n        module.exports = cats;\n\t}\n])\n```\n\n数组第一个元素是app.js里面的内容，第二个元素是依赖的内容\n\n由此可见，不仅app.js里面的内容被打包进app.bundle.js，app.js所依赖度cats.js也被打包了进来。\n\nwebpack打包原理是边读边分析入口文件的依赖，分析入口文件依赖的文件的依赖，以此类推，只要有依赖都去分析并打包到输出文件(app.bundle.js)中\n\n### 五. 生成source maps\n\n使得调试更容易\n\n在配置文件中加上`devtool`字段\n\ndevtool的取值有\n\n- source-map\n- cheap-module-source-map\n- eval-source-map\n- cheap-module-eval-source-map","slug":"2016-08-16- webpack","published":1,"updated":"2016-09-07T12:58:34.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjp00bpd5u8786shlzr","content":"<h3 id=\"一-什么是webpack\"><a href=\"#一-什么是webpack\" class=\"headerlink\" title=\"一. 什么是webpack\"></a>一. 什么是webpack</h3><p>webpack是一个前端构建工具，其主要思想是将项目中用到的一切静态资源都看成是模块，webpack可以对其进行统一的管理和发布。</p>\n<p>webpack中支持使用AMD和CommonJS规范。</p>\n<blockquote>\n<p>webpack可以看成模块打包机，它所做的功能：分析项目结构，找到js模块，和其他一些模块（Scss等），并将其进行相应的处理，打包为合适的格式给浏览器使用。</p>\n</blockquote>\n<h3 id=\"二-webpack模块加载器Loaders\"><a href=\"#二-webpack模块加载器Loaders\" class=\"headerlink\" title=\"二. webpack模块加载器Loaders\"></a>二. webpack模块加载器Loaders</h3><p>webpack本身只支持将js模块打包，对于图片、CSS、LESS、JSX等等，需要首先使用对应的模块加载器进行转换。</p>\n<p>举个栗子：</p>\n<p>LESS文件 ——&gt; 通过less-load处理成css ——&gt; 通过css-loader加载成css模块 ——&gt; 由style-loader做最后的处理</p>\n<p>Webpack的加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。</p>\n<h3 id=\"三-打包成多个资源文件\"><a href=\"#三-打包成多个资源文件\" class=\"headerlink\" title=\"三. 打包成多个资源文件\"></a>三. 打包成多个资源文件</h3><p>将项目中的模块打包成多个资源文件有两个目的：</p>\n<ol>\n<li>将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率；</li>\n<li>按需加载，减少页面初次加载时间。</li>\n</ol>\n<h3 id=\"四-webpack打包之后的文件\"><a href=\"#四-webpack打包之后的文件\" class=\"headerlink\" title=\"四. webpack打包之后的文件\"></a>四. webpack打包之后的文件</h3><p>webpack兼容commonjs规范、AMD</p>\n<p>打包之前的2个模块：</p>\n<p><strong>parent.js</strong></p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cats = [<span class=\"string\">'dave'</span>,<span class=\"string\">'henry'</span>,<span class=\"string\">'martha'</span>];</span><br><span class=\"line\"><span class=\"comment\">//commonJS的写法</span></span><br><span class=\"line\">module.<span class=\"keyword\">exports</span> = cats;</span><br></pre></td></tr></table></figure>\n<p><strong>app.js</strong></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">cats</span> = require(<span class=\"string\">'./parent.js'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>打包之后的文件：</strong></p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([</span><br><span class=\"line\">\tfunction(<span class=\"name\">module</span>, exports, __webpack_require__) &#123;</span><br><span class=\"line\">    \tcats = __webpack_require__(<span class=\"name\">1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    \tconsole.log(<span class=\"name\">cats</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">\tfunction(<span class=\"name\">module</span>, exports) &#123;</span><br><span class=\"line\">        var cats = [<span class=\"symbol\">'dave</span>', <span class=\"symbol\">'henry</span>', <span class=\"symbol\">'martha</span>']<span class=\"comment\">;</span></span><br><span class=\"line\">        module.exports = cats<span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<p>数组第一个元素是app.js里面的内容，第二个元素是依赖的内容</p>\n<p>由此可见，不仅app.js里面的内容被打包进app.bundle.js，app.js所依赖度cats.js也被打包了进来。</p>\n<p>webpack打包原理是边读边分析入口文件的依赖，分析入口文件依赖的文件的依赖，以此类推，只要有依赖都去分析并打包到输出文件(app.bundle.js)中</p>\n<h3 id=\"五-生成source-maps\"><a href=\"#五-生成source-maps\" class=\"headerlink\" title=\"五. 生成source maps\"></a>五. 生成source maps</h3><p>使得调试更容易</p>\n<p>在配置文件中加上<code>devtool</code>字段</p>\n<p>devtool的取值有</p>\n<ul>\n<li>source-map</li>\n<li>cheap-module-source-map</li>\n<li>eval-source-map</li>\n<li>cheap-module-eval-source-map</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-什么是webpack\"><a href=\"#一-什么是webpack\" class=\"headerlink\" title=\"一. 什么是webpack\"></a>一. 什么是webpack</h3><p>webpack是一个前端构建工具，其主要思想是将项目中用到的一切静态资源都看成是模块，webpack可以对其进行统一的管理和发布。</p>\n<p>webpack中支持使用AMD和CommonJS规范。</p>\n<blockquote>\n<p>webpack可以看成模块打包机，它所做的功能：分析项目结构，找到js模块，和其他一些模块（Scss等），并将其进行相应的处理，打包为合适的格式给浏览器使用。</p>\n</blockquote>\n<h3 id=\"二-webpack模块加载器Loaders\"><a href=\"#二-webpack模块加载器Loaders\" class=\"headerlink\" title=\"二. webpack模块加载器Loaders\"></a>二. webpack模块加载器Loaders</h3><p>webpack本身只支持将js模块打包，对于图片、CSS、LESS、JSX等等，需要首先使用对应的模块加载器进行转换。</p>\n<p>举个栗子：</p>\n<p>LESS文件 ——&gt; 通过less-load处理成css ——&gt; 通过css-loader加载成css模块 ——&gt; 由style-loader做最后的处理</p>\n<p>Webpack的加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。</p>\n<h3 id=\"三-打包成多个资源文件\"><a href=\"#三-打包成多个资源文件\" class=\"headerlink\" title=\"三. 打包成多个资源文件\"></a>三. 打包成多个资源文件</h3><p>将项目中的模块打包成多个资源文件有两个目的：</p>\n<ol>\n<li>将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率；</li>\n<li>按需加载，减少页面初次加载时间。</li>\n</ol>\n<h3 id=\"四-webpack打包之后的文件\"><a href=\"#四-webpack打包之后的文件\" class=\"headerlink\" title=\"四. webpack打包之后的文件\"></a>四. webpack打包之后的文件</h3><p>webpack兼容commonjs规范、AMD</p>\n<p>打包之前的2个模块：</p>\n<p><strong>parent.js</strong></p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cats = [<span class=\"string\">'dave'</span>,<span class=\"string\">'henry'</span>,<span class=\"string\">'martha'</span>];</span><br><span class=\"line\"><span class=\"comment\">//commonJS的写法</span></span><br><span class=\"line\">module.<span class=\"keyword\">exports</span> = cats;</span><br></pre></td></tr></table></figure>\n<p><strong>app.js</strong></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">cats</span> = require(<span class=\"string\">'./parent.js'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>打包之后的文件：</strong></p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([</span><br><span class=\"line\">\tfunction(<span class=\"name\">module</span>, exports, __webpack_require__) &#123;</span><br><span class=\"line\">    \tcats = __webpack_require__(<span class=\"name\">1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    \tconsole.log(<span class=\"name\">cats</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">\tfunction(<span class=\"name\">module</span>, exports) &#123;</span><br><span class=\"line\">        var cats = [<span class=\"symbol\">'dave</span>', <span class=\"symbol\">'henry</span>', <span class=\"symbol\">'martha</span>']<span class=\"comment\">;</span></span><br><span class=\"line\">        module.exports = cats<span class=\"comment\">;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<p>数组第一个元素是app.js里面的内容，第二个元素是依赖的内容</p>\n<p>由此可见，不仅app.js里面的内容被打包进app.bundle.js，app.js所依赖度cats.js也被打包了进来。</p>\n<p>webpack打包原理是边读边分析入口文件的依赖，分析入口文件依赖的文件的依赖，以此类推，只要有依赖都去分析并打包到输出文件(app.bundle.js)中</p>\n<h3 id=\"五-生成source-maps\"><a href=\"#五-生成source-maps\" class=\"headerlink\" title=\"五. 生成source maps\"></a>五. 生成source maps</h3><p>使得调试更容易</p>\n<p>在配置文件中加上<code>devtool</code>字段</p>\n<p>devtool的取值有</p>\n<ul>\n<li>source-map</li>\n<li>cheap-module-source-map</li>\n<li>eval-source-map</li>\n<li>cheap-module-eval-source-map</li>\n</ul>\n"},{"layout":"post","title":"css3动画的回调处理","date":"2016-08-10T16:00:00.000Z","description":null,"_content":"\n### 一. css3的新属性\n\n边框\n文本\n背景\n转换\n过渡\n动画\n\n#### 1. 边框\n\n- border-radius\n- box-shadow\n- border-image\n\n#### 2. 背景\n\n- background-size\n- background-origin\n\n#### 3. 文本\n\n- text-shadow\n- word-wrap\n\n#### 4. 字体\n\n#### 5. 转换 transform\n\n- transform:translate()\n- transform:rotate()\n- transform:scale()\n- transform:skew()\n- transform:matrix()\n\n#### 6. 过渡 transition\n\n```\nanimation: myfirst 5s;\n\n@keyframes myfirst\n{\n  from {background: red;}\n  to {background: yellow;}\n}\n```\n\n### 二. 过渡／动画的回调处理\n\n一个动画完成后执行一些回调操作\n\n#### 1. Transition Events\n\n- webkit: 'webkitTransitionEnd'\n- Moz: 'transitionend'\n- O: 'oTransitionEnd'\n- ms: 'MSTransitionEnd' \n\n```\nvar Div = document.getElementById(\"myDIV\");\nDiv.addEventListener(\"webkitTransitionEnd\", myFunction,false);\n```\n\n注意：如果transition中变换的属性有多个比如设置宽高过渡（transition :width:.2s,height:.4s）, transitionend事件会促发2次\n\n#### 2. Animation Events\n\nanimationend\n\n```\nvar Div = document.getElementById(\"myDIV\");\nDiv.addEventListener('webkitAnimationEnd', function () {\n        alert('动画执行完毕！');\n        // callback here\n      }, false);\n```\n\n\n\n","source":"_posts/2016-08-11-css3动画的回调处理.md","raw":"---\nlayout: post\ntitle: css3动画的回调处理\ndate: 2016-08-11\ncategories: css\ntags: [css]\ndescription: \n---\n\n### 一. css3的新属性\n\n边框\n文本\n背景\n转换\n过渡\n动画\n\n#### 1. 边框\n\n- border-radius\n- box-shadow\n- border-image\n\n#### 2. 背景\n\n- background-size\n- background-origin\n\n#### 3. 文本\n\n- text-shadow\n- word-wrap\n\n#### 4. 字体\n\n#### 5. 转换 transform\n\n- transform:translate()\n- transform:rotate()\n- transform:scale()\n- transform:skew()\n- transform:matrix()\n\n#### 6. 过渡 transition\n\n```\nanimation: myfirst 5s;\n\n@keyframes myfirst\n{\n  from {background: red;}\n  to {background: yellow;}\n}\n```\n\n### 二. 过渡／动画的回调处理\n\n一个动画完成后执行一些回调操作\n\n#### 1. Transition Events\n\n- webkit: 'webkitTransitionEnd'\n- Moz: 'transitionend'\n- O: 'oTransitionEnd'\n- ms: 'MSTransitionEnd' \n\n```\nvar Div = document.getElementById(\"myDIV\");\nDiv.addEventListener(\"webkitTransitionEnd\", myFunction,false);\n```\n\n注意：如果transition中变换的属性有多个比如设置宽高过渡（transition :width:.2s,height:.4s）, transitionend事件会促发2次\n\n#### 2. Animation Events\n\nanimationend\n\n```\nvar Div = document.getElementById(\"myDIV\");\nDiv.addEventListener('webkitAnimationEnd', function () {\n        alert('动画执行完毕！');\n        // callback here\n      }, false);\n```\n\n\n\n","slug":"2016-08-11-css3动画的回调处理","published":1,"updated":"2016-08-20T08:51:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjr00bsd5u8z5iuowjg","content":"<h3 id=\"一-css3的新属性\"><a href=\"#一-css3的新属性\" class=\"headerlink\" title=\"一. css3的新属性\"></a>一. css3的新属性</h3><p>边框<br>文本<br>背景<br>转换<br>过渡<br>动画</p>\n<h4 id=\"1-边框\"><a href=\"#1-边框\" class=\"headerlink\" title=\"1. 边框\"></a>1. 边框</h4><ul>\n<li>border-radius</li>\n<li>box-shadow</li>\n<li>border-image</li>\n</ul>\n<h4 id=\"2-背景\"><a href=\"#2-背景\" class=\"headerlink\" title=\"2. 背景\"></a>2. 背景</h4><ul>\n<li>background-size</li>\n<li>background-origin</li>\n</ul>\n<h4 id=\"3-文本\"><a href=\"#3-文本\" class=\"headerlink\" title=\"3. 文本\"></a>3. 文本</h4><ul>\n<li>text-shadow</li>\n<li>word-wrap</li>\n</ul>\n<h4 id=\"4-字体\"><a href=\"#4-字体\" class=\"headerlink\" title=\"4. 字体\"></a>4. 字体</h4><h4 id=\"5-转换-transform\"><a href=\"#5-转换-transform\" class=\"headerlink\" title=\"5. 转换 transform\"></a>5. 转换 transform</h4><ul>\n<li>transform:translate()</li>\n<li>transform:rotate()</li>\n<li>transform:scale()</li>\n<li>transform:skew()</li>\n<li>transform:matrix()</li>\n</ul>\n<h4 id=\"6-过渡-transition\"><a href=\"#6-过渡-transition\" class=\"headerlink\" title=\"6. 过渡 transition\"></a>6. 过渡 transition</h4><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation</span>: myfirst 5s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\">@<span class=\"keyword\">keyframes</span> myfirst</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">from</span> &#123;<span class=\"attribute\">background</span>: red;&#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">to</span> &#123;<span class=\"attribute\">background</span>: yellow;&#125;</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-过渡／动画的回调处理\"><a href=\"#二-过渡／动画的回调处理\" class=\"headerlink\" title=\"二. 过渡／动画的回调处理\"></a>二. 过渡／动画的回调处理</h3><p>一个动画完成后执行一些回调操作</p>\n<h4 id=\"1-Transition-Events\"><a href=\"#1-Transition-Events\" class=\"headerlink\" title=\"1. Transition Events\"></a>1. Transition Events</h4><ul>\n<li>webkit: ‘webkitTransitionEnd’</li>\n<li>Moz: ‘transitionend’</li>\n<li>O: ‘oTransitionEnd’</li>\n<li>ms: ‘MSTransitionEnd’ </li>\n</ul>\n<figure class=\"highlight cal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">Div</span> = document.getElementById(<span class=\"string\">\"myDIV\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">Div</span>.addEventListener(<span class=\"string\">\"webkitTransitionEnd\"</span>, myFunction,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：如果transition中变换的属性有多个比如设置宽高过渡（transition :width:.2s,height:.4s）, transitionend事件会促发2次</p>\n<h4 id=\"2-Animation-Events\"><a href=\"#2-Animation-Events\" class=\"headerlink\" title=\"2. Animation Events\"></a>2. Animation Events</h4><p>animationend</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDIV\"</span>);</span><br><span class=\"line\">Div.addEventListener(<span class=\"string\">'webkitAnimationEnd'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">'动画执行完毕！'</span>);</span><br><span class=\"line\">        <span class=\"comment\">// callback here</span></span><br><span class=\"line\">      &#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-css3的新属性\"><a href=\"#一-css3的新属性\" class=\"headerlink\" title=\"一. css3的新属性\"></a>一. css3的新属性</h3><p>边框<br>文本<br>背景<br>转换<br>过渡<br>动画</p>\n<h4 id=\"1-边框\"><a href=\"#1-边框\" class=\"headerlink\" title=\"1. 边框\"></a>1. 边框</h4><ul>\n<li>border-radius</li>\n<li>box-shadow</li>\n<li>border-image</li>\n</ul>\n<h4 id=\"2-背景\"><a href=\"#2-背景\" class=\"headerlink\" title=\"2. 背景\"></a>2. 背景</h4><ul>\n<li>background-size</li>\n<li>background-origin</li>\n</ul>\n<h4 id=\"3-文本\"><a href=\"#3-文本\" class=\"headerlink\" title=\"3. 文本\"></a>3. 文本</h4><ul>\n<li>text-shadow</li>\n<li>word-wrap</li>\n</ul>\n<h4 id=\"4-字体\"><a href=\"#4-字体\" class=\"headerlink\" title=\"4. 字体\"></a>4. 字体</h4><h4 id=\"5-转换-transform\"><a href=\"#5-转换-transform\" class=\"headerlink\" title=\"5. 转换 transform\"></a>5. 转换 transform</h4><ul>\n<li>transform:translate()</li>\n<li>transform:rotate()</li>\n<li>transform:scale()</li>\n<li>transform:skew()</li>\n<li>transform:matrix()</li>\n</ul>\n<h4 id=\"6-过渡-transition\"><a href=\"#6-过渡-transition\" class=\"headerlink\" title=\"6. 过渡 transition\"></a>6. 过渡 transition</h4><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation</span>: myfirst 5s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"css\">@<span class=\"keyword\">keyframes</span> myfirst</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">from</span> &#123;<span class=\"attribute\">background</span>: red;&#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">to</span> &#123;<span class=\"attribute\">background</span>: yellow;&#125;</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-过渡／动画的回调处理\"><a href=\"#二-过渡／动画的回调处理\" class=\"headerlink\" title=\"二. 过渡／动画的回调处理\"></a>二. 过渡／动画的回调处理</h3><p>一个动画完成后执行一些回调操作</p>\n<h4 id=\"1-Transition-Events\"><a href=\"#1-Transition-Events\" class=\"headerlink\" title=\"1. Transition Events\"></a>1. Transition Events</h4><ul>\n<li>webkit: ‘webkitTransitionEnd’</li>\n<li>Moz: ‘transitionend’</li>\n<li>O: ‘oTransitionEnd’</li>\n<li>ms: ‘MSTransitionEnd’ </li>\n</ul>\n<figure class=\"highlight cal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">Div</span> = document.getElementById(<span class=\"string\">\"myDIV\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">Div</span>.addEventListener(<span class=\"string\">\"webkitTransitionEnd\"</span>, myFunction,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：如果transition中变换的属性有多个比如设置宽高过渡（transition :width:.2s,height:.4s）, transitionend事件会促发2次</p>\n<h4 id=\"2-Animation-Events\"><a href=\"#2-Animation-Events\" class=\"headerlink\" title=\"2. Animation Events\"></a>2. Animation Events</h4><p>animationend</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDIV\"</span>);</span><br><span class=\"line\">Div.addEventListener(<span class=\"string\">'webkitAnimationEnd'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">'动画执行完毕！'</span>);</span><br><span class=\"line\">        <span class=\"comment\">// callback here</span></span><br><span class=\"line\">      &#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"对mvc的理解","date":"2016-08-04T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是mvc\n\n设计思想：每一部分都相对独立，职责单一\n\n**model：**数据层\n\n- 指的是data，对应存在数据库中的内容\n- 独立于view，被controller修改\n\n**view：**视图层\n\n展现。界面，对应HTML模版\n\n**controller：**控制层\n\n从视图层读取输入\n选取数据层中对应的数据，进行相应的操作，产生最终的结果\n\n\n举个栗子：\n\n\t计算器\n\n\tmodel：做计算要用到的数字\n\tview：计算器的输出框、输入按钮\n\tcontroller：内部的一些加减乘除的计算\n","source":"_posts/2016-08-05-对mvc的理解.md","raw":"---\nlayout: post\ntitle: 对mvc的理解\ndate: 2016-08-05\ncategories: 前端框架\ntags: [框架]\ndescription: \n---\n\n### 一. 什么是mvc\n\n设计思想：每一部分都相对独立，职责单一\n\n**model：**数据层\n\n- 指的是data，对应存在数据库中的内容\n- 独立于view，被controller修改\n\n**view：**视图层\n\n展现。界面，对应HTML模版\n\n**controller：**控制层\n\n从视图层读取输入\n选取数据层中对应的数据，进行相应的操作，产生最终的结果\n\n\n举个栗子：\n\n\t计算器\n\n\tmodel：做计算要用到的数字\n\tview：计算器的输出框、输入按钮\n\tcontroller：内部的一些加减乘除的计算\n","slug":"2016-08-05-对mvc的理解","published":1,"updated":"2016-08-22T03:21:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjt00bwd5u8t8p28x67","content":"<h3 id=\"一-什么是mvc\"><a href=\"#一-什么是mvc\" class=\"headerlink\" title=\"一. 什么是mvc\"></a>一. 什么是mvc</h3><p>设计思想：每一部分都相对独立，职责单一</p>\n<p><strong>model：</strong>数据层</p>\n<ul>\n<li>指的是data，对应存在数据库中的内容</li>\n<li>独立于view，被controller修改</li>\n</ul>\n<p><strong>view：</strong>视图层</p>\n<p>展现。界面，对应HTML模版</p>\n<p><strong>controller：</strong>控制层</p>\n<p>从视图层读取输入<br>选取数据层中对应的数据，进行相应的操作，产生最终的结果</p>\n<p>举个栗子：</p>\n<pre><code>计算器\n\nmodel：做计算要用到的数字\nview：计算器的输出框、输入按钮\ncontroller：内部的一些加减乘除的计算\n</code></pre>","excerpt":"","more":"<h3 id=\"一-什么是mvc\"><a href=\"#一-什么是mvc\" class=\"headerlink\" title=\"一. 什么是mvc\"></a>一. 什么是mvc</h3><p>设计思想：每一部分都相对独立，职责单一</p>\n<p><strong>model：</strong>数据层</p>\n<ul>\n<li>指的是data，对应存在数据库中的内容</li>\n<li>独立于view，被controller修改</li>\n</ul>\n<p><strong>view：</strong>视图层</p>\n<p>展现。界面，对应HTML模版</p>\n<p><strong>controller：</strong>控制层</p>\n<p>从视图层读取输入<br>选取数据层中对应的数据，进行相应的操作，产生最终的结果</p>\n<p>举个栗子：</p>\n<pre><code>计算器\n\nmodel：做计算要用到的数字\nview：计算器的输出框、输入按钮\ncontroller：内部的一些加减乘除的计算\n</code></pre>"},{"layout":"post","title":"学习react","date":"2016-08-15T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是react\n\nreact是一个前端框架，相当于MVC框架中的V的部分。\n\n可以理解成一个做UI组件的javaScript库\n\n> MVC分别代表的是model（模型）／view（视图）／controller（控制器）\n\n#### 1. react的优点有：\n\n**a.组件化 —— 封装起来的具有独立功能的UI部件**\n\n>所谓组件，就是状态机器\n\n>React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。\n\n>在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。\n\n**b. 使用虚拟DOM(虚拟DOM是内存里的一种特殊的结构)，能够提高性能**\n\n>基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。\n\n**为什么使用虚拟dom能够提高性能？**\n\n虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的\n\n**c. 代码可预测：使用react写出来的代码简单易懂直观，方便维护**\n\n> 以简单直观、符合习惯的（idiomatic）方式去编程，让代码更容易被理解，从而易于维护和不断演进。这正是React的设计哲学。\n\n#### 2. 调试react页面的小工具\n\nchrome有提供一个插件**react develop tools**，可以方便我们在控制台直接查看react相关的组件。\n\n**jsfiddle**是一个可以使用react的前端代码在线演示的网站\n\n### 二. JSX语法\n\n我们在使用react时，会经常使用JSX语法，这样可以增加程序的可读性。\n\n但是浏览器不能直接运行jsx，需要首先对jsx进行编译。\n\n#### 1. 什么是JSX\nJSX是 JavaScript XML的缩写，是Facebook为react开发的一套语法糖，\n**JSX允许我们在javaScript中使用HTML的语法**。\n\n**目的：**增加程序的可读性\n\n#### 2. JSX语法的基本规则\n遇到`<>`，就使用HTML的规则解析\n遇到`{}`，就使用JavaScript的规则解析\n\n### 三. 如何使用react\n\n在HTML文件中，需要引入react的相关js文件\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    \n    //这里的type＝“text/jsx”表明这里的代码是jsx\n    <script type=\"text/jsx\">\n      // 在这里写相关的js文件\n    </script>\n  </body>\n</html>\n```\n### 四. react中的基本方法\n\n#### 1. 全局的方法\n\n##### 渲染DOM的方法\nReactDOM.render(要渲染的模版, 渲染的组件要插入的容器);\n\n##### 创建组件的方法 \nReact.createClass({...}); \n\n##### 找到真实的DOM节点\nReactDOM.findDOMNode(this.refs.［ref.name］)\n\n#### 2. 组件内部使用的方法\n- render\n- getInitialState\n- this.setState\n\neg:\n\n```\n React.createClass({\n\t//组件返回的方法\n\t render: function() {\n\t \treturn (\n\t \t\t// 注意：这里只能返回一个<div>\n\t \t)\n\t }\n    //给组件定义一个初始状态，设置state的初始值\n\tgetInitialState: function() {\n    \treturn {liked: false};\n  \t}\n  \t\t\n }); \n ```\n#### 3.this.props和this.state的区别\n\nprops和state都是描述react组件的状态的属性。\n\n##### 其区别如下：\n\n- `this.props` props是组件对外的接口，是通过使用组件时传入，一般不可变，通过props可以在外部控制组件的状态和行为\n- `this.state` 属于组件本身，可以改变，通过`setState()`函数可以给state赋值\n\n如果组件的某些状态需要被改变，并且会影响到组件的render，那么这个状态就应该用state表示。\n\n<div style='color: red;'>注意：在组件内部如果要修改state的值，一定要使用setState()函数，而不能直接给state的某个属性赋值！！！</div>\n\n##### 获取组件的所有子节点：this.props.children \n\n- 没有子节点，类型为undefined\n- 有一个子节点，类型为object\n- 有2个或以上的节点，类型为array\n\n### 五. react中的组件\n\n#### 1. 组件命名规则\n\n- 组件名首字母大写\n- 可以像html标签那样使用，可以添加任意属性。但是需要注意以下几点：\n\n  a. class和for需要写成className和htmlFor，原因如下：\n\n```\n\t//这里不能像HTML中，直接用class添加类名，因为这是一个js的运行环境，而class是ES6里的关键字\n\t<div className=\"myDiv\"></div> \n```\n  b. 这里不能像HTML中，直接使用style＝“”来添加行内样式，在react中，行内样式不是用字符串表示，而是用一个样式对象表示，样式对象的属性是用css样式的驼峰命名法\n  \n```\n\tvar obj = {\n\t\tcolor: \"red\"\n\t}\n\t<div style={obj}></div>\n```\n#### 2. 组件的生命周期\n\n**React Components的生命周期分3种状态：**\n \n - Mounting： 组件已被render解析，生成对应的dom节点，并插入浏览器的DOM结构\n - Updating： 一个已被Mounted的组件被重新render的过程（组件的state发生了改变）\n - Unmounting：一个已被Mounted的组件被从dom结构中移除的状态\n\n\n**基于这三种状态的组件的生命周期方法有7种：**\n\n**Mounting：**\n\n- componentWillMount()\n- componentDidMount()\n\n**Updating：**\n\n- componentWillReceiceProps(object nextProps)：已加载组件收到新的参数时调用\n- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用，返回值为bool值\n- componentWillUpdate(object nextProps, object nextState)\n- componentDidUpdate(object nextProps, object nextState)\n\n**Unmounting：**\n\n- componentDidUnmount() \n\n<font color='red'>react组件生命周期不同阶段中的调用的方法</font>\n\n\t1. 组件实例化（Mounting）：也就是将真实的dom结构插入html页面中\n\n\t首次实例化\n\n\tgetDefaultProps()：对于组件而言，只会调用一次，如果是引用值，会被所有的实例共享，返回对象用于设置默认的props\n\n    getInitialState()：组件mounted之前调用一次，返回值作为this.state的初始值，对于组件的实例来说，只调用一次\n\n\tcomponentWillMount()：挂载之前立刻调用\n\t\n\trender()：渲染组件，创建虚拟的DOM\t\n\n\tcomponentDidMount()：挂载之后立刻调用\n\n\t2. 组件属性改变：props发生改变\n\n\tcomponentWillReceiveProps()：在prop传入之后，render()渲染之前更新state的机会，\n\n\treact是单向数据流，数据从组件的属性流入，再结合组件的状态，流入生命周期方法，直到渲染结束这都应该是一个单向的过程，其间不能随意改变组件的状态\n\n\tshouldComponentUpdate()：通过判断state和props是否导致组件更新，来返回true或者false\n\n\tcomponentWillUpdate()：在接收到新的props或者state之后，进行渲染之前调用\n\n\trender()：\n\n\tcomponentDidUpdate()：\n\n    3. 组件状态改变：state发生改变\n    \n\tshouldComponentUpdate()\n\n    componentWillUpdate()\n\n    render()\n\n    componentDidupdate()\n\n\t4. 销毁掉组件\n\n\tcomponentWillUnmount()：组件被移除之前调用，可以用于做一些清理工作，例如：创建的定时器或添加的事件监听器\n\n参考至：[https://segmentfault.com/a/1190000003940416](https://segmentfault.com/a/1190000003940416)\n\n#### 3. react中绑定事件\n\n在React里只需把事件处理器当作组件的 props 传入即可，以驼峰命名的方式。\n\n##### 给按钮绑定事件\n\n**在原生的js里面的写法：**\n\n```\n$('#my-button').on('click', this.checkAndSubmit.bind(this));\n```\n\n**使用react搭配jsx的语法：**\n\n```\n<button onClick={this.checkAndSubmit.bind(this)}>Submit</button>\n```\n\n事件使用驼峰命名\n\n使用react的优点：\n\n- 事件和绑定事件的元素写在一起了，方便易读\n- 不用考虑解除事件的绑定，React会在对应的真实DOM节点移除时就自动解除了事件绑定\n\n#### 4. 如何获取组件内部的dom节点\n\n由于react组件中的DOM节点在被插入浏览器的DOM结构之前，是一个虚拟的DOM，因此在创建组件时，应该怎么获取到组件内部的DOM节点呢？\n\n- 给render() 输出的组件中的dom节点设置ref属性\n- 通过ReactDOM.findDOMNode(this.refs.[refsName])来获取真实的dom节点\n\n**举个绑定事件和获取真实dom节点的栗子：**\n\n```\nvar Input = React.creatClass({\n\thandleClick: function(event) {\n\t\tvar warn = ReactDOM.findDOMNode(this.refs.waring);\n\t\t\n\t\tif(warn.style.display === 'none') {\n\t\t\twarn.style.display = 'block';\n\t\t} else {\n\t\t\twarn.style.display = 'none';\n\t\t}\n\t}\n\t\n\trender: function() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<button onClick={this.handleClick}>显示／隐藏</button>\n\t\t\t\t<span style={{display: 'none'}} ref='waring' >test</span>\n\t\t\t</div>\n\t\t)\n\t}\n});\n```\n\n### 六. react中组件之间的通信\n\n- react中顶层的组件可以通过props属性向下层组件传递数据\n- 下层组件不能向上层组件传递数据\n- 兄弟组件之间也不能传递数据\n\n单向数据流，只能由上至下\n\n#### 1. 使用属性的方式\n\n上层组件通过属性向下层组件传递回调函数，下层组件触发回调来更新上层组件的数据\n\n#### 2. 使用事件的形式\n\n#### 3. 使用Flux\n\nreact相当于是针对mvc框架中的view的框架。\n\nFlux定义了一种**单向数据流**的方式，主要解决的是数据在 React 应用中的流动方式及过程。\n\n**在传统的MVC框架中，View和Model是双向绑定。**\n\n- Model中的数据发生变化 ——> 一个或多个View会发生变化\n- View接受了用户输入发生改变 ——> Model中的数据也会发生变化\n\n一个state发生变化可能会引起多个view发生变化；一个view上的动作可能会引起多个state的改变。\n\n**在Flux中**\n\n- view 视图层\n- action 动作\n- dispatcher 派发器\n- store 数据层\n\nView不直接改变应用状态，只能触发action。应用的状态独立放到store中进行管理。\n\nView完全是Store的展现形式，Store的更新则完全由Action触发。\n\n#### 4. redux\n\nredux主要分为三个部分：action、reducer、store\n\naction和reducer为多对多的关系\n\n**action**\n\n主要用来传递操作State的信息\n\n```\n//下面是一个 增加电影 的操作\nfunction addFilm(name) {\n  return { type: 'ADD_FILM', name: name };\n}\n```\n\n**reducer**\n\n根据action的指示来更新State\n\n```\n//state指的是旧的state\n//指示操作的action\nfunction films(state, action) {\n\tswitch(action.type) {\n\t\tcase 'ADD_FILM':\n\t\t\n\t\t//进行增加电影的操作\n\t\treturn...\n\t}\n}\n```\ncombineReducers() 接收一个对象作为参数，对象的key为state中的一部分数据，其value值为对应的reducer\n\n**store**\n\nredux中，store是单一的，维护着一个全局的State，根据Action进行事件分发处理State。\n\n","source":"_posts/2016-08-16-学习react.md","raw":"---\nlayout: post\ntitle: 学习react\ndate: 2016-08-16\ncategories: 前端框架\ntags: [框架]\ndescription: \n---\n\n### 一. 什么是react\n\nreact是一个前端框架，相当于MVC框架中的V的部分。\n\n可以理解成一个做UI组件的javaScript库\n\n> MVC分别代表的是model（模型）／view（视图）／controller（控制器）\n\n#### 1. react的优点有：\n\n**a.组件化 —— 封装起来的具有独立功能的UI部件**\n\n>所谓组件，就是状态机器\n\n>React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。\n\n>在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。\n\n**b. 使用虚拟DOM(虚拟DOM是内存里的一种特殊的结构)，能够提高性能**\n\n>基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。\n\n**为什么使用虚拟dom能够提高性能？**\n\n虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的\n\n**c. 代码可预测：使用react写出来的代码简单易懂直观，方便维护**\n\n> 以简单直观、符合习惯的（idiomatic）方式去编程，让代码更容易被理解，从而易于维护和不断演进。这正是React的设计哲学。\n\n#### 2. 调试react页面的小工具\n\nchrome有提供一个插件**react develop tools**，可以方便我们在控制台直接查看react相关的组件。\n\n**jsfiddle**是一个可以使用react的前端代码在线演示的网站\n\n### 二. JSX语法\n\n我们在使用react时，会经常使用JSX语法，这样可以增加程序的可读性。\n\n但是浏览器不能直接运行jsx，需要首先对jsx进行编译。\n\n#### 1. 什么是JSX\nJSX是 JavaScript XML的缩写，是Facebook为react开发的一套语法糖，\n**JSX允许我们在javaScript中使用HTML的语法**。\n\n**目的：**增加程序的可读性\n\n#### 2. JSX语法的基本规则\n遇到`<>`，就使用HTML的规则解析\n遇到`{}`，就使用JavaScript的规则解析\n\n### 三. 如何使用react\n\n在HTML文件中，需要引入react的相关js文件\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    \n    //这里的type＝“text/jsx”表明这里的代码是jsx\n    <script type=\"text/jsx\">\n      // 在这里写相关的js文件\n    </script>\n  </body>\n</html>\n```\n### 四. react中的基本方法\n\n#### 1. 全局的方法\n\n##### 渲染DOM的方法\nReactDOM.render(要渲染的模版, 渲染的组件要插入的容器);\n\n##### 创建组件的方法 \nReact.createClass({...}); \n\n##### 找到真实的DOM节点\nReactDOM.findDOMNode(this.refs.［ref.name］)\n\n#### 2. 组件内部使用的方法\n- render\n- getInitialState\n- this.setState\n\neg:\n\n```\n React.createClass({\n\t//组件返回的方法\n\t render: function() {\n\t \treturn (\n\t \t\t// 注意：这里只能返回一个<div>\n\t \t)\n\t }\n    //给组件定义一个初始状态，设置state的初始值\n\tgetInitialState: function() {\n    \treturn {liked: false};\n  \t}\n  \t\t\n }); \n ```\n#### 3.this.props和this.state的区别\n\nprops和state都是描述react组件的状态的属性。\n\n##### 其区别如下：\n\n- `this.props` props是组件对外的接口，是通过使用组件时传入，一般不可变，通过props可以在外部控制组件的状态和行为\n- `this.state` 属于组件本身，可以改变，通过`setState()`函数可以给state赋值\n\n如果组件的某些状态需要被改变，并且会影响到组件的render，那么这个状态就应该用state表示。\n\n<div style='color: red;'>注意：在组件内部如果要修改state的值，一定要使用setState()函数，而不能直接给state的某个属性赋值！！！</div>\n\n##### 获取组件的所有子节点：this.props.children \n\n- 没有子节点，类型为undefined\n- 有一个子节点，类型为object\n- 有2个或以上的节点，类型为array\n\n### 五. react中的组件\n\n#### 1. 组件命名规则\n\n- 组件名首字母大写\n- 可以像html标签那样使用，可以添加任意属性。但是需要注意以下几点：\n\n  a. class和for需要写成className和htmlFor，原因如下：\n\n```\n\t//这里不能像HTML中，直接用class添加类名，因为这是一个js的运行环境，而class是ES6里的关键字\n\t<div className=\"myDiv\"></div> \n```\n  b. 这里不能像HTML中，直接使用style＝“”来添加行内样式，在react中，行内样式不是用字符串表示，而是用一个样式对象表示，样式对象的属性是用css样式的驼峰命名法\n  \n```\n\tvar obj = {\n\t\tcolor: \"red\"\n\t}\n\t<div style={obj}></div>\n```\n#### 2. 组件的生命周期\n\n**React Components的生命周期分3种状态：**\n \n - Mounting： 组件已被render解析，生成对应的dom节点，并插入浏览器的DOM结构\n - Updating： 一个已被Mounted的组件被重新render的过程（组件的state发生了改变）\n - Unmounting：一个已被Mounted的组件被从dom结构中移除的状态\n\n\n**基于这三种状态的组件的生命周期方法有7种：**\n\n**Mounting：**\n\n- componentWillMount()\n- componentDidMount()\n\n**Updating：**\n\n- componentWillReceiceProps(object nextProps)：已加载组件收到新的参数时调用\n- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用，返回值为bool值\n- componentWillUpdate(object nextProps, object nextState)\n- componentDidUpdate(object nextProps, object nextState)\n\n**Unmounting：**\n\n- componentDidUnmount() \n\n<font color='red'>react组件生命周期不同阶段中的调用的方法</font>\n\n\t1. 组件实例化（Mounting）：也就是将真实的dom结构插入html页面中\n\n\t首次实例化\n\n\tgetDefaultProps()：对于组件而言，只会调用一次，如果是引用值，会被所有的实例共享，返回对象用于设置默认的props\n\n    getInitialState()：组件mounted之前调用一次，返回值作为this.state的初始值，对于组件的实例来说，只调用一次\n\n\tcomponentWillMount()：挂载之前立刻调用\n\t\n\trender()：渲染组件，创建虚拟的DOM\t\n\n\tcomponentDidMount()：挂载之后立刻调用\n\n\t2. 组件属性改变：props发生改变\n\n\tcomponentWillReceiveProps()：在prop传入之后，render()渲染之前更新state的机会，\n\n\treact是单向数据流，数据从组件的属性流入，再结合组件的状态，流入生命周期方法，直到渲染结束这都应该是一个单向的过程，其间不能随意改变组件的状态\n\n\tshouldComponentUpdate()：通过判断state和props是否导致组件更新，来返回true或者false\n\n\tcomponentWillUpdate()：在接收到新的props或者state之后，进行渲染之前调用\n\n\trender()：\n\n\tcomponentDidUpdate()：\n\n    3. 组件状态改变：state发生改变\n    \n\tshouldComponentUpdate()\n\n    componentWillUpdate()\n\n    render()\n\n    componentDidupdate()\n\n\t4. 销毁掉组件\n\n\tcomponentWillUnmount()：组件被移除之前调用，可以用于做一些清理工作，例如：创建的定时器或添加的事件监听器\n\n参考至：[https://segmentfault.com/a/1190000003940416](https://segmentfault.com/a/1190000003940416)\n\n#### 3. react中绑定事件\n\n在React里只需把事件处理器当作组件的 props 传入即可，以驼峰命名的方式。\n\n##### 给按钮绑定事件\n\n**在原生的js里面的写法：**\n\n```\n$('#my-button').on('click', this.checkAndSubmit.bind(this));\n```\n\n**使用react搭配jsx的语法：**\n\n```\n<button onClick={this.checkAndSubmit.bind(this)}>Submit</button>\n```\n\n事件使用驼峰命名\n\n使用react的优点：\n\n- 事件和绑定事件的元素写在一起了，方便易读\n- 不用考虑解除事件的绑定，React会在对应的真实DOM节点移除时就自动解除了事件绑定\n\n#### 4. 如何获取组件内部的dom节点\n\n由于react组件中的DOM节点在被插入浏览器的DOM结构之前，是一个虚拟的DOM，因此在创建组件时，应该怎么获取到组件内部的DOM节点呢？\n\n- 给render() 输出的组件中的dom节点设置ref属性\n- 通过ReactDOM.findDOMNode(this.refs.[refsName])来获取真实的dom节点\n\n**举个绑定事件和获取真实dom节点的栗子：**\n\n```\nvar Input = React.creatClass({\n\thandleClick: function(event) {\n\t\tvar warn = ReactDOM.findDOMNode(this.refs.waring);\n\t\t\n\t\tif(warn.style.display === 'none') {\n\t\t\twarn.style.display = 'block';\n\t\t} else {\n\t\t\twarn.style.display = 'none';\n\t\t}\n\t}\n\t\n\trender: function() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<button onClick={this.handleClick}>显示／隐藏</button>\n\t\t\t\t<span style={{display: 'none'}} ref='waring' >test</span>\n\t\t\t</div>\n\t\t)\n\t}\n});\n```\n\n### 六. react中组件之间的通信\n\n- react中顶层的组件可以通过props属性向下层组件传递数据\n- 下层组件不能向上层组件传递数据\n- 兄弟组件之间也不能传递数据\n\n单向数据流，只能由上至下\n\n#### 1. 使用属性的方式\n\n上层组件通过属性向下层组件传递回调函数，下层组件触发回调来更新上层组件的数据\n\n#### 2. 使用事件的形式\n\n#### 3. 使用Flux\n\nreact相当于是针对mvc框架中的view的框架。\n\nFlux定义了一种**单向数据流**的方式，主要解决的是数据在 React 应用中的流动方式及过程。\n\n**在传统的MVC框架中，View和Model是双向绑定。**\n\n- Model中的数据发生变化 ——> 一个或多个View会发生变化\n- View接受了用户输入发生改变 ——> Model中的数据也会发生变化\n\n一个state发生变化可能会引起多个view发生变化；一个view上的动作可能会引起多个state的改变。\n\n**在Flux中**\n\n- view 视图层\n- action 动作\n- dispatcher 派发器\n- store 数据层\n\nView不直接改变应用状态，只能触发action。应用的状态独立放到store中进行管理。\n\nView完全是Store的展现形式，Store的更新则完全由Action触发。\n\n#### 4. redux\n\nredux主要分为三个部分：action、reducer、store\n\naction和reducer为多对多的关系\n\n**action**\n\n主要用来传递操作State的信息\n\n```\n//下面是一个 增加电影 的操作\nfunction addFilm(name) {\n  return { type: 'ADD_FILM', name: name };\n}\n```\n\n**reducer**\n\n根据action的指示来更新State\n\n```\n//state指的是旧的state\n//指示操作的action\nfunction films(state, action) {\n\tswitch(action.type) {\n\t\tcase 'ADD_FILM':\n\t\t\n\t\t//进行增加电影的操作\n\t\treturn...\n\t}\n}\n```\ncombineReducers() 接收一个对象作为参数，对象的key为state中的一部分数据，其value值为对应的reducer\n\n**store**\n\nredux中，store是单一的，维护着一个全局的State，根据Action进行事件分发处理State。\n\n","slug":"2016-08-16-学习react","published":1,"updated":"2016-10-14T12:06:28.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjw00c0d5u8fl73ub2k","content":"<h3 id=\"一-什么是react\"><a href=\"#一-什么是react\" class=\"headerlink\" title=\"一. 什么是react\"></a>一. 什么是react</h3><p>react是一个前端框架，相当于MVC框架中的V的部分。</p>\n<p>可以理解成一个做UI组件的javaScript库</p>\n<blockquote>\n<p>MVC分别代表的是model（模型）／view（视图）／controller（控制器）</p>\n</blockquote>\n<h4 id=\"1-react的优点有：\"><a href=\"#1-react的优点有：\" class=\"headerlink\" title=\"1. react的优点有：\"></a>1. react的优点有：</h4><p><strong>a.组件化 —— 封装起来的具有独立功能的UI部件</strong></p>\n<blockquote>\n<p>所谓组件，就是状态机器</p>\n<p>React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。</p>\n<p>在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。</p>\n</blockquote>\n<p><strong>b. 使用虚拟DOM(虚拟DOM是内存里的一种特殊的结构)，能够提高性能</strong></p>\n<blockquote>\n<p>基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。</p>\n</blockquote>\n<p><strong>为什么使用虚拟dom能够提高性能？</strong></p>\n<p>虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的</p>\n<p><strong>c. 代码可预测：使用react写出来的代码简单易懂直观，方便维护</strong></p>\n<blockquote>\n<p>以简单直观、符合习惯的（idiomatic）方式去编程，让代码更容易被理解，从而易于维护和不断演进。这正是React的设计哲学。</p>\n</blockquote>\n<h4 id=\"2-调试react页面的小工具\"><a href=\"#2-调试react页面的小工具\" class=\"headerlink\" title=\"2. 调试react页面的小工具\"></a>2. 调试react页面的小工具</h4><p>chrome有提供一个插件<strong>react develop tools</strong>，可以方便我们在控制台直接查看react相关的组件。</p>\n<p><strong>jsfiddle</strong>是一个可以使用react的前端代码在线演示的网站</p>\n<h3 id=\"二-JSX语法\"><a href=\"#二-JSX语法\" class=\"headerlink\" title=\"二. JSX语法\"></a>二. JSX语法</h3><p>我们在使用react时，会经常使用JSX语法，这样可以增加程序的可读性。</p>\n<p>但是浏览器不能直接运行jsx，需要首先对jsx进行编译。</p>\n<h4 id=\"1-什么是JSX\"><a href=\"#1-什么是JSX\" class=\"headerlink\" title=\"1. 什么是JSX\"></a>1. 什么是JSX</h4><p>JSX是 JavaScript XML的缩写，是Facebook为react开发的一套语法糖，<br><strong>JSX允许我们在javaScript中使用HTML的语法</strong>。</p>\n<p><strong>目的：</strong>增加程序的可读性</p>\n<h4 id=\"2-JSX语法的基本规则\"><a href=\"#2-JSX语法的基本规则\" class=\"headerlink\" title=\"2. JSX语法的基本规则\"></a>2. JSX语法的基本规则</h4><p>遇到<code>&lt;&gt;</code>，就使用HTML的规则解析<br>遇到<code>{}</code>，就使用JavaScript的规则解析</p>\n<h3 id=\"三-如何使用react\"><a href=\"#三-如何使用react\" class=\"headerlink\" title=\"三. 如何使用react\"></a>三. 如何使用react</h3><p>在HTML文件中，需要引入react的相关js文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../build/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../build/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../build/browser.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    //这里的type＝“text/jsx”表明这里的代码是jsx</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/jsx\"</span>&gt;</span><span class=\"actionscript\"></span><br><span class=\"line\">      <span class=\"comment\">// 在这里写相关的js文件</span></span><br><span class=\"line\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-react中的基本方法\"><a href=\"#四-react中的基本方法\" class=\"headerlink\" title=\"四. react中的基本方法\"></a>四. react中的基本方法</h3><h4 id=\"1-全局的方法\"><a href=\"#1-全局的方法\" class=\"headerlink\" title=\"1. 全局的方法\"></a>1. 全局的方法</h4><h5 id=\"渲染DOM的方法\"><a href=\"#渲染DOM的方法\" class=\"headerlink\" title=\"渲染DOM的方法\"></a>渲染DOM的方法</h5><p>ReactDOM.render(要渲染的模版, 渲染的组件要插入的容器);</p>\n<h5 id=\"创建组件的方法\"><a href=\"#创建组件的方法\" class=\"headerlink\" title=\"创建组件的方法\"></a>创建组件的方法</h5><p>React.createClass({…}); </p>\n<h5 id=\"找到真实的DOM节点\"><a href=\"#找到真实的DOM节点\" class=\"headerlink\" title=\"找到真实的DOM节点\"></a>找到真实的DOM节点</h5><p>ReactDOM.findDOMNode(this.refs.［ref.name］)</p>\n<h4 id=\"2-组件内部使用的方法\"><a href=\"#2-组件内部使用的方法\" class=\"headerlink\" title=\"2. 组件内部使用的方法\"></a>2. 组件内部使用的方法</h4><ul>\n<li>render</li>\n<li>getInitialState</li>\n<li>this.setState</li>\n</ul>\n<p>eg:</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createClass(&#123;</span><br><span class=\"line\"><span class=\"comment\">//组件返回的方法</span></span><br><span class=\"line\"> render: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> (</span><br><span class=\"line\"> \t\t<span class=\"comment\">// 注意：这里只能返回一个&lt;div&gt;</span></span><br><span class=\"line\"> \t)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">   <span class=\"comment\">//给组件定义一个初始状态，设置state的初始值</span></span><br><span class=\"line\">getInitialState: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> &#123;liked: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-this-props和this-state的区别\"><a href=\"#3-this-props和this-state的区别\" class=\"headerlink\" title=\"3.this.props和this.state的区别\"></a>3.this.props和this.state的区别</h4><p>props和state都是描述react组件的状态的属性。</p>\n<h5 id=\"其区别如下：\"><a href=\"#其区别如下：\" class=\"headerlink\" title=\"其区别如下：\"></a>其区别如下：</h5><ul>\n<li><code>this.props</code> props是组件对外的接口，是通过使用组件时传入，一般不可变，通过props可以在外部控制组件的状态和行为</li>\n<li><code>this.state</code> 属于组件本身，可以改变，通过<code>setState()</code>函数可以给state赋值</li>\n</ul>\n<p>如果组件的某些状态需要被改变，并且会影响到组件的render，那么这个状态就应该用state表示。</p>\n<div style=\"color: red;\">注意：在组件内部如果要修改state的值，一定要使用setState()函数，而不能直接给state的某个属性赋值！！！</div>\n\n<h5 id=\"获取组件的所有子节点：this-props-children\"><a href=\"#获取组件的所有子节点：this-props-children\" class=\"headerlink\" title=\"获取组件的所有子节点：this.props.children\"></a>获取组件的所有子节点：this.props.children</h5><ul>\n<li>没有子节点，类型为undefined</li>\n<li>有一个子节点，类型为object</li>\n<li>有2个或以上的节点，类型为array</li>\n</ul>\n<h3 id=\"五-react中的组件\"><a href=\"#五-react中的组件\" class=\"headerlink\" title=\"五. react中的组件\"></a>五. react中的组件</h3><h4 id=\"1-组件命名规则\"><a href=\"#1-组件命名规则\" class=\"headerlink\" title=\"1. 组件命名规则\"></a>1. 组件命名规则</h4><ul>\n<li>组件名首字母大写</li>\n<li><p>可以像html标签那样使用，可以添加任意属性。但是需要注意以下几点：</p>\n<p>a. class和for需要写成className和htmlFor，原因如下：</p>\n</li>\n</ul>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里不能像HTML中，直接用class添加类名，因为这是一个js的运行环境，而class是ES6里的关键字</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">div</span> className=<span class=\"string\">\"myDiv\"</span>&gt;&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>  b. 这里不能像HTML中，直接使用style＝“”来添加行内样式，在react中，行内样式不是用字符串表示，而是用一个样式对象表示，样式对象的属性是用css样式的驼峰命名法</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">color</span>: <span class=\"string\">\"red\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> style=&#123;obj&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-组件的生命周期\"><a href=\"#2-组件的生命周期\" class=\"headerlink\" title=\"2. 组件的生命周期\"></a>2. 组件的生命周期</h4><p><strong>React Components的生命周期分3种状态：</strong></p>\n<ul>\n<li>Mounting： 组件已被render解析，生成对应的dom节点，并插入浏览器的DOM结构</li>\n<li>Updating： 一个已被Mounted的组件被重新render的过程（组件的state发生了改变）</li>\n<li>Unmounting：一个已被Mounted的组件被从dom结构中移除的状态</li>\n</ul>\n<p><strong>基于这三种状态的组件的生命周期方法有7种：</strong></p>\n<p><strong>Mounting：</strong></p>\n<ul>\n<li>componentWillMount()</li>\n<li>componentDidMount()</li>\n</ul>\n<p><strong>Updating：</strong></p>\n<ul>\n<li>componentWillReceiceProps(object nextProps)：已加载组件收到新的参数时调用</li>\n<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用，返回值为bool值</li>\n<li>componentWillUpdate(object nextProps, object nextState)</li>\n<li>componentDidUpdate(object nextProps, object nextState)</li>\n</ul>\n<p><strong>Unmounting：</strong></p>\n<ul>\n<li>componentDidUnmount() </li>\n</ul>\n<font color=\"red\">react组件生命周期不同阶段中的调用的方法</font>\n\n<pre><code>1. 组件实例化（Mounting）：也就是将真实的dom结构插入html页面中\n\n首次实例化\n\ngetDefaultProps()：对于组件而言，只会调用一次，如果是引用值，会被所有的实例共享，返回对象用于设置默认的props\n\ngetInitialState()：组件mounted之前调用一次，返回值作为this.state的初始值，对于组件的实例来说，只调用一次\n\ncomponentWillMount()：挂载之前立刻调用\n\nrender()：渲染组件，创建虚拟的DOM    \n\ncomponentDidMount()：挂载之后立刻调用\n\n2. 组件属性改变：props发生改变\n\ncomponentWillReceiveProps()：在prop传入之后，render()渲染之前更新state的机会，\n\nreact是单向数据流，数据从组件的属性流入，再结合组件的状态，流入生命周期方法，直到渲染结束这都应该是一个单向的过程，其间不能随意改变组件的状态\n\nshouldComponentUpdate()：通过判断state和props是否导致组件更新，来返回true或者false\n\ncomponentWillUpdate()：在接收到新的props或者state之后，进行渲染之前调用\n\nrender()：\n\ncomponentDidUpdate()：\n\n3. 组件状态改变：state发生改变\n\nshouldComponentUpdate()\n\ncomponentWillUpdate()\n\nrender()\n\ncomponentDidupdate()\n\n4. 销毁掉组件\n\ncomponentWillUnmount()：组件被移除之前调用，可以用于做一些清理工作，例如：创建的定时器或添加的事件监听器\n</code></pre><p>参考至：<a href=\"https://segmentfault.com/a/1190000003940416\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000003940416</a></p>\n<h4 id=\"3-react中绑定事件\"><a href=\"#3-react中绑定事件\" class=\"headerlink\" title=\"3. react中绑定事件\"></a>3. react中绑定事件</h4><p>在React里只需把事件处理器当作组件的 props 传入即可，以驼峰命名的方式。</p>\n<h5 id=\"给按钮绑定事件\"><a href=\"#给按钮绑定事件\" class=\"headerlink\" title=\"给按钮绑定事件\"></a>给按钮绑定事件</h5><p><strong>在原生的js里面的写法：</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'#my-button'</span>).on(<span class=\"string\">'click'</span>, <span class=\"keyword\">this</span>.checkAndSubmit.bind(<span class=\"keyword\">this</span>));</span><br></pre></td></tr></table></figure>\n<p><strong>使用react搭配jsx的语法：</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">button</span> onClick=&#123;this<span class=\"selector-class\">.checkAndSubmit</span><span class=\"selector-class\">.bind</span>(this)&#125;&gt;Submit&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<p>事件使用驼峰命名</p>\n<p>使用react的优点：</p>\n<ul>\n<li>事件和绑定事件的元素写在一起了，方便易读</li>\n<li>不用考虑解除事件的绑定，React会在对应的真实DOM节点移除时就自动解除了事件绑定</li>\n</ul>\n<h4 id=\"4-如何获取组件内部的dom节点\"><a href=\"#4-如何获取组件内部的dom节点\" class=\"headerlink\" title=\"4. 如何获取组件内部的dom节点\"></a>4. 如何获取组件内部的dom节点</h4><p>由于react组件中的DOM节点在被插入浏览器的DOM结构之前，是一个虚拟的DOM，因此在创建组件时，应该怎么获取到组件内部的DOM节点呢？</p>\n<ul>\n<li>给render() 输出的组件中的dom节点设置ref属性</li>\n<li>通过ReactDOM.findDOMNode(this.refs.[refsName])来获取真实的dom节点</li>\n</ul>\n<p><strong>举个绑定事件和获取真实dom节点的栗子：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Input = React.creatClass(&#123;</span><br><span class=\"line\">\thandleClick: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> warn = ReactDOM.findDOMNode(<span class=\"keyword\">this</span>.refs.waring);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(warn.style.display === <span class=\"string\">'none'</span>) &#123;</span><br><span class=\"line\">\t\t\twarn.style.display = <span class=\"string\">'block'</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\twarn.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trender: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span>显示／隐藏<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;display:</span> '<span class=\"attr\">none</span>'&#125;&#125; <span class=\"attr\">ref</span>=<span class=\"string\">'waring'</span> &gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"六-react中组件之间的通信\"><a href=\"#六-react中组件之间的通信\" class=\"headerlink\" title=\"六. react中组件之间的通信\"></a>六. react中组件之间的通信</h3><ul>\n<li>react中顶层的组件可以通过props属性向下层组件传递数据</li>\n<li>下层组件不能向上层组件传递数据</li>\n<li>兄弟组件之间也不能传递数据</li>\n</ul>\n<p>单向数据流，只能由上至下</p>\n<h4 id=\"1-使用属性的方式\"><a href=\"#1-使用属性的方式\" class=\"headerlink\" title=\"1. 使用属性的方式\"></a>1. 使用属性的方式</h4><p>上层组件通过属性向下层组件传递回调函数，下层组件触发回调来更新上层组件的数据</p>\n<h4 id=\"2-使用事件的形式\"><a href=\"#2-使用事件的形式\" class=\"headerlink\" title=\"2. 使用事件的形式\"></a>2. 使用事件的形式</h4><h4 id=\"3-使用Flux\"><a href=\"#3-使用Flux\" class=\"headerlink\" title=\"3. 使用Flux\"></a>3. 使用Flux</h4><p>react相当于是针对mvc框架中的view的框架。</p>\n<p>Flux定义了一种<strong>单向数据流</strong>的方式，主要解决的是数据在 React 应用中的流动方式及过程。</p>\n<p><strong>在传统的MVC框架中，View和Model是双向绑定。</strong></p>\n<ul>\n<li>Model中的数据发生变化 ——&gt; 一个或多个View会发生变化</li>\n<li>View接受了用户输入发生改变 ——&gt; Model中的数据也会发生变化</li>\n</ul>\n<p>一个state发生变化可能会引起多个view发生变化；一个view上的动作可能会引起多个state的改变。</p>\n<p><strong>在Flux中</strong></p>\n<ul>\n<li>view 视图层</li>\n<li>action 动作</li>\n<li>dispatcher 派发器</li>\n<li>store 数据层</li>\n</ul>\n<p>View不直接改变应用状态，只能触发action。应用的状态独立放到store中进行管理。</p>\n<p>View完全是Store的展现形式，Store的更新则完全由Action触发。</p>\n<h4 id=\"4-redux\"><a href=\"#4-redux\" class=\"headerlink\" title=\"4. redux\"></a>4. redux</h4><p>redux主要分为三个部分：action、reducer、store</p>\n<p>action和reducer为多对多的关系</p>\n<p><strong>action</strong></p>\n<p>主要用来传递操作State的信息</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面是一个 增加电影 的操作</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">addFilm</span>(name) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">&#123;</span> <span class=\"keyword\">type</span>: <span class=\"symbol\">'ADD_FILM</span>', name: name &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>reducer</strong></p>\n<p>根据action的指示来更新State</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">state</span>指的是旧的<span class=\"keyword\">state</span></span><br><span class=\"line\">//指示操作的action</span><br><span class=\"line\">function films(<span class=\"keyword\">state</span>, action) &#123;</span><br><span class=\"line\">\tswitch(action.type) &#123;</span><br><span class=\"line\">\t\tcase 'ADD_FILM':</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//进行增加电影的操作</span><br><span class=\"line\">\t\treturn...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>combineReducers() 接收一个对象作为参数，对象的key为state中的一部分数据，其value值为对应的reducer</p>\n<p><strong>store</strong></p>\n<p>redux中，store是单一的，维护着一个全局的State，根据Action进行事件分发处理State。</p>\n","excerpt":"","more":"<h3 id=\"一-什么是react\"><a href=\"#一-什么是react\" class=\"headerlink\" title=\"一. 什么是react\"></a>一. 什么是react</h3><p>react是一个前端框架，相当于MVC框架中的V的部分。</p>\n<p>可以理解成一个做UI组件的javaScript库</p>\n<blockquote>\n<p>MVC分别代表的是model（模型）／view（视图）／controller（控制器）</p>\n</blockquote>\n<h4 id=\"1-react的优点有：\"><a href=\"#1-react的优点有：\" class=\"headerlink\" title=\"1. react的优点有：\"></a>1. react的优点有：</h4><p><strong>a.组件化 —— 封装起来的具有独立功能的UI部件</strong></p>\n<blockquote>\n<p>所谓组件，就是状态机器</p>\n<p>React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。</p>\n<p>在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。</p>\n</blockquote>\n<p><strong>b. 使用虚拟DOM(虚拟DOM是内存里的一种特殊的结构)，能够提高性能</strong></p>\n<blockquote>\n<p>基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。</p>\n</blockquote>\n<p><strong>为什么使用虚拟dom能够提高性能？</strong></p>\n<p>虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的</p>\n<p><strong>c. 代码可预测：使用react写出来的代码简单易懂直观，方便维护</strong></p>\n<blockquote>\n<p>以简单直观、符合习惯的（idiomatic）方式去编程，让代码更容易被理解，从而易于维护和不断演进。这正是React的设计哲学。</p>\n</blockquote>\n<h4 id=\"2-调试react页面的小工具\"><a href=\"#2-调试react页面的小工具\" class=\"headerlink\" title=\"2. 调试react页面的小工具\"></a>2. 调试react页面的小工具</h4><p>chrome有提供一个插件<strong>react develop tools</strong>，可以方便我们在控制台直接查看react相关的组件。</p>\n<p><strong>jsfiddle</strong>是一个可以使用react的前端代码在线演示的网站</p>\n<h3 id=\"二-JSX语法\"><a href=\"#二-JSX语法\" class=\"headerlink\" title=\"二. JSX语法\"></a>二. JSX语法</h3><p>我们在使用react时，会经常使用JSX语法，这样可以增加程序的可读性。</p>\n<p>但是浏览器不能直接运行jsx，需要首先对jsx进行编译。</p>\n<h4 id=\"1-什么是JSX\"><a href=\"#1-什么是JSX\" class=\"headerlink\" title=\"1. 什么是JSX\"></a>1. 什么是JSX</h4><p>JSX是 JavaScript XML的缩写，是Facebook为react开发的一套语法糖，<br><strong>JSX允许我们在javaScript中使用HTML的语法</strong>。</p>\n<p><strong>目的：</strong>增加程序的可读性</p>\n<h4 id=\"2-JSX语法的基本规则\"><a href=\"#2-JSX语法的基本规则\" class=\"headerlink\" title=\"2. JSX语法的基本规则\"></a>2. JSX语法的基本规则</h4><p>遇到<code>&lt;&gt;</code>，就使用HTML的规则解析<br>遇到<code>{}</code>，就使用JavaScript的规则解析</p>\n<h3 id=\"三-如何使用react\"><a href=\"#三-如何使用react\" class=\"headerlink\" title=\"三. 如何使用react\"></a>三. 如何使用react</h3><p>在HTML文件中，需要引入react的相关js文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../build/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../build/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../build/browser.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    //这里的type＝“text/jsx”表明这里的代码是jsx</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/jsx\"</span>&gt;</span><span class=\"actionscript\"></span><br><span class=\"line\">      <span class=\"comment\">// 在这里写相关的js文件</span></span><br><span class=\"line\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-react中的基本方法\"><a href=\"#四-react中的基本方法\" class=\"headerlink\" title=\"四. react中的基本方法\"></a>四. react中的基本方法</h3><h4 id=\"1-全局的方法\"><a href=\"#1-全局的方法\" class=\"headerlink\" title=\"1. 全局的方法\"></a>1. 全局的方法</h4><h5 id=\"渲染DOM的方法\"><a href=\"#渲染DOM的方法\" class=\"headerlink\" title=\"渲染DOM的方法\"></a>渲染DOM的方法</h5><p>ReactDOM.render(要渲染的模版, 渲染的组件要插入的容器);</p>\n<h5 id=\"创建组件的方法\"><a href=\"#创建组件的方法\" class=\"headerlink\" title=\"创建组件的方法\"></a>创建组件的方法</h5><p>React.createClass({…}); </p>\n<h5 id=\"找到真实的DOM节点\"><a href=\"#找到真实的DOM节点\" class=\"headerlink\" title=\"找到真实的DOM节点\"></a>找到真实的DOM节点</h5><p>ReactDOM.findDOMNode(this.refs.［ref.name］)</p>\n<h4 id=\"2-组件内部使用的方法\"><a href=\"#2-组件内部使用的方法\" class=\"headerlink\" title=\"2. 组件内部使用的方法\"></a>2. 组件内部使用的方法</h4><ul>\n<li>render</li>\n<li>getInitialState</li>\n<li>this.setState</li>\n</ul>\n<p>eg:</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createClass(&#123;</span><br><span class=\"line\"><span class=\"comment\">//组件返回的方法</span></span><br><span class=\"line\"> render: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> (</span><br><span class=\"line\"> \t\t<span class=\"comment\">// 注意：这里只能返回一个&lt;div&gt;</span></span><br><span class=\"line\"> \t)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">   <span class=\"comment\">//给组件定义一个初始状态，设置state的初始值</span></span><br><span class=\"line\">getInitialState: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> &#123;liked: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-this-props和this-state的区别\"><a href=\"#3-this-props和this-state的区别\" class=\"headerlink\" title=\"3.this.props和this.state的区别\"></a>3.this.props和this.state的区别</h4><p>props和state都是描述react组件的状态的属性。</p>\n<h5 id=\"其区别如下：\"><a href=\"#其区别如下：\" class=\"headerlink\" title=\"其区别如下：\"></a>其区别如下：</h5><ul>\n<li><code>this.props</code> props是组件对外的接口，是通过使用组件时传入，一般不可变，通过props可以在外部控制组件的状态和行为</li>\n<li><code>this.state</code> 属于组件本身，可以改变，通过<code>setState()</code>函数可以给state赋值</li>\n</ul>\n<p>如果组件的某些状态需要被改变，并且会影响到组件的render，那么这个状态就应该用state表示。</p>\n<div style='color: red;'>注意：在组件内部如果要修改state的值，一定要使用setState()函数，而不能直接给state的某个属性赋值！！！</div>\n\n<h5 id=\"获取组件的所有子节点：this-props-children\"><a href=\"#获取组件的所有子节点：this-props-children\" class=\"headerlink\" title=\"获取组件的所有子节点：this.props.children\"></a>获取组件的所有子节点：this.props.children</h5><ul>\n<li>没有子节点，类型为undefined</li>\n<li>有一个子节点，类型为object</li>\n<li>有2个或以上的节点，类型为array</li>\n</ul>\n<h3 id=\"五-react中的组件\"><a href=\"#五-react中的组件\" class=\"headerlink\" title=\"五. react中的组件\"></a>五. react中的组件</h3><h4 id=\"1-组件命名规则\"><a href=\"#1-组件命名规则\" class=\"headerlink\" title=\"1. 组件命名规则\"></a>1. 组件命名规则</h4><ul>\n<li>组件名首字母大写</li>\n<li><p>可以像html标签那样使用，可以添加任意属性。但是需要注意以下几点：</p>\n<p>a. class和for需要写成className和htmlFor，原因如下：</p>\n</li>\n</ul>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里不能像HTML中，直接用class添加类名，因为这是一个js的运行环境，而class是ES6里的关键字</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">div</span> className=<span class=\"string\">\"myDiv\"</span>&gt;&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>  b. 这里不能像HTML中，直接使用style＝“”来添加行内样式，在react中，行内样式不是用字符串表示，而是用一个样式对象表示，样式对象的属性是用css样式的驼峰命名法</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">color</span>: <span class=\"string\">\"red\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> style=&#123;obj&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-组件的生命周期\"><a href=\"#2-组件的生命周期\" class=\"headerlink\" title=\"2. 组件的生命周期\"></a>2. 组件的生命周期</h4><p><strong>React Components的生命周期分3种状态：</strong></p>\n<ul>\n<li>Mounting： 组件已被render解析，生成对应的dom节点，并插入浏览器的DOM结构</li>\n<li>Updating： 一个已被Mounted的组件被重新render的过程（组件的state发生了改变）</li>\n<li>Unmounting：一个已被Mounted的组件被从dom结构中移除的状态</li>\n</ul>\n<p><strong>基于这三种状态的组件的生命周期方法有7种：</strong></p>\n<p><strong>Mounting：</strong></p>\n<ul>\n<li>componentWillMount()</li>\n<li>componentDidMount()</li>\n</ul>\n<p><strong>Updating：</strong></p>\n<ul>\n<li>componentWillReceiceProps(object nextProps)：已加载组件收到新的参数时调用</li>\n<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用，返回值为bool值</li>\n<li>componentWillUpdate(object nextProps, object nextState)</li>\n<li>componentDidUpdate(object nextProps, object nextState)</li>\n</ul>\n<p><strong>Unmounting：</strong></p>\n<ul>\n<li>componentDidUnmount() </li>\n</ul>\n<font color='red'>react组件生命周期不同阶段中的调用的方法</font>\n\n<pre><code>1. 组件实例化（Mounting）：也就是将真实的dom结构插入html页面中\n\n首次实例化\n\ngetDefaultProps()：对于组件而言，只会调用一次，如果是引用值，会被所有的实例共享，返回对象用于设置默认的props\n\ngetInitialState()：组件mounted之前调用一次，返回值作为this.state的初始值，对于组件的实例来说，只调用一次\n\ncomponentWillMount()：挂载之前立刻调用\n\nrender()：渲染组件，创建虚拟的DOM    \n\ncomponentDidMount()：挂载之后立刻调用\n\n2. 组件属性改变：props发生改变\n\ncomponentWillReceiveProps()：在prop传入之后，render()渲染之前更新state的机会，\n\nreact是单向数据流，数据从组件的属性流入，再结合组件的状态，流入生命周期方法，直到渲染结束这都应该是一个单向的过程，其间不能随意改变组件的状态\n\nshouldComponentUpdate()：通过判断state和props是否导致组件更新，来返回true或者false\n\ncomponentWillUpdate()：在接收到新的props或者state之后，进行渲染之前调用\n\nrender()：\n\ncomponentDidUpdate()：\n\n3. 组件状态改变：state发生改变\n\nshouldComponentUpdate()\n\ncomponentWillUpdate()\n\nrender()\n\ncomponentDidupdate()\n\n4. 销毁掉组件\n\ncomponentWillUnmount()：组件被移除之前调用，可以用于做一些清理工作，例如：创建的定时器或添加的事件监听器\n</code></pre><p>参考至：<a href=\"https://segmentfault.com/a/1190000003940416\">https://segmentfault.com/a/1190000003940416</a></p>\n<h4 id=\"3-react中绑定事件\"><a href=\"#3-react中绑定事件\" class=\"headerlink\" title=\"3. react中绑定事件\"></a>3. react中绑定事件</h4><p>在React里只需把事件处理器当作组件的 props 传入即可，以驼峰命名的方式。</p>\n<h5 id=\"给按钮绑定事件\"><a href=\"#给按钮绑定事件\" class=\"headerlink\" title=\"给按钮绑定事件\"></a>给按钮绑定事件</h5><p><strong>在原生的js里面的写法：</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'#my-button'</span>).on(<span class=\"string\">'click'</span>, <span class=\"keyword\">this</span>.checkAndSubmit.bind(<span class=\"keyword\">this</span>));</span><br></pre></td></tr></table></figure>\n<p><strong>使用react搭配jsx的语法：</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">button</span> onClick=&#123;this<span class=\"selector-class\">.checkAndSubmit</span><span class=\"selector-class\">.bind</span>(this)&#125;&gt;Submit&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<p>事件使用驼峰命名</p>\n<p>使用react的优点：</p>\n<ul>\n<li>事件和绑定事件的元素写在一起了，方便易读</li>\n<li>不用考虑解除事件的绑定，React会在对应的真实DOM节点移除时就自动解除了事件绑定</li>\n</ul>\n<h4 id=\"4-如何获取组件内部的dom节点\"><a href=\"#4-如何获取组件内部的dom节点\" class=\"headerlink\" title=\"4. 如何获取组件内部的dom节点\"></a>4. 如何获取组件内部的dom节点</h4><p>由于react组件中的DOM节点在被插入浏览器的DOM结构之前，是一个虚拟的DOM，因此在创建组件时，应该怎么获取到组件内部的DOM节点呢？</p>\n<ul>\n<li>给render() 输出的组件中的dom节点设置ref属性</li>\n<li>通过ReactDOM.findDOMNode(this.refs.[refsName])来获取真实的dom节点</li>\n</ul>\n<p><strong>举个绑定事件和获取真实dom节点的栗子：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Input = React.creatClass(&#123;</span><br><span class=\"line\">\thandleClick: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> warn = ReactDOM.findDOMNode(<span class=\"keyword\">this</span>.refs.waring);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(warn.style.display === <span class=\"string\">'none'</span>) &#123;</span><br><span class=\"line\">\t\t\twarn.style.display = <span class=\"string\">'block'</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\twarn.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trender: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span>显示／隐藏<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;display:</span> '<span class=\"attr\">none</span>'&#125;&#125; <span class=\"attr\">ref</span>=<span class=\"string\">'waring'</span> &gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"六-react中组件之间的通信\"><a href=\"#六-react中组件之间的通信\" class=\"headerlink\" title=\"六. react中组件之间的通信\"></a>六. react中组件之间的通信</h3><ul>\n<li>react中顶层的组件可以通过props属性向下层组件传递数据</li>\n<li>下层组件不能向上层组件传递数据</li>\n<li>兄弟组件之间也不能传递数据</li>\n</ul>\n<p>单向数据流，只能由上至下</p>\n<h4 id=\"1-使用属性的方式\"><a href=\"#1-使用属性的方式\" class=\"headerlink\" title=\"1. 使用属性的方式\"></a>1. 使用属性的方式</h4><p>上层组件通过属性向下层组件传递回调函数，下层组件触发回调来更新上层组件的数据</p>\n<h4 id=\"2-使用事件的形式\"><a href=\"#2-使用事件的形式\" class=\"headerlink\" title=\"2. 使用事件的形式\"></a>2. 使用事件的形式</h4><h4 id=\"3-使用Flux\"><a href=\"#3-使用Flux\" class=\"headerlink\" title=\"3. 使用Flux\"></a>3. 使用Flux</h4><p>react相当于是针对mvc框架中的view的框架。</p>\n<p>Flux定义了一种<strong>单向数据流</strong>的方式，主要解决的是数据在 React 应用中的流动方式及过程。</p>\n<p><strong>在传统的MVC框架中，View和Model是双向绑定。</strong></p>\n<ul>\n<li>Model中的数据发生变化 ——&gt; 一个或多个View会发生变化</li>\n<li>View接受了用户输入发生改变 ——&gt; Model中的数据也会发生变化</li>\n</ul>\n<p>一个state发生变化可能会引起多个view发生变化；一个view上的动作可能会引起多个state的改变。</p>\n<p><strong>在Flux中</strong></p>\n<ul>\n<li>view 视图层</li>\n<li>action 动作</li>\n<li>dispatcher 派发器</li>\n<li>store 数据层</li>\n</ul>\n<p>View不直接改变应用状态，只能触发action。应用的状态独立放到store中进行管理。</p>\n<p>View完全是Store的展现形式，Store的更新则完全由Action触发。</p>\n<h4 id=\"4-redux\"><a href=\"#4-redux\" class=\"headerlink\" title=\"4. redux\"></a>4. redux</h4><p>redux主要分为三个部分：action、reducer、store</p>\n<p>action和reducer为多对多的关系</p>\n<p><strong>action</strong></p>\n<p>主要用来传递操作State的信息</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面是一个 增加电影 的操作</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">addFilm</span>(name) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">&#123;</span> <span class=\"keyword\">type</span>: <span class=\"symbol\">'ADD_FILM</span>', name: name &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>reducer</strong></p>\n<p>根据action的指示来更新State</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">state</span>指的是旧的<span class=\"keyword\">state</span></span><br><span class=\"line\">//指示操作的action</span><br><span class=\"line\">function films(<span class=\"keyword\">state</span>, action) &#123;</span><br><span class=\"line\">\tswitch(action.type) &#123;</span><br><span class=\"line\">\t\tcase 'ADD_FILM':</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//进行增加电影的操作</span><br><span class=\"line\">\t\treturn...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>combineReducers() 接收一个对象作为参数，对象的key为state中的一部分数据，其value值为对应的reducer</p>\n<p><strong>store</strong></p>\n<p>redux中，store是单一的，维护着一个全局的State，根据Action进行事件分发处理State。</p>\n"},{"layout":"post","title":"Two Sum","date":"2016-09-02T16:00:00.000Z","description":null,"_content":"\n**数组中找出和为N的两个数**\n\n要求输入：数组，例如： numbers = [1,7,9,10,16]，target = 17;\n\n输出： index1 = 1, index2 = 3\n\n### 1. 如果数组是无序的\n\n#### 方法一\n\n**思想：**\n\n- 先将数组进行排序\n- 然后使用2个指针，一个从数组头部进行遍历，一个从数组尾部进行遍历\n\n\t如果两个数相加 = 输入的值，那么就返回当前的数，跳出循环\n\n\t如果两个数相加 != 输入的值，当两个数的和 > 目标值，则后面一个指针向前移动；当两个数的和 < 目标值，则前面一个指针向后移动\n\n- 然后再在排序之前的数组中找到该值对应的下标作为程序的输出\n\n**需要考虑的几种特殊情况：**\n\n- 在数组中找不到两个数的和等于给定的数\n- 在程序中会找到两对数相加都等于给定的数?????下面的两个程序没有考虑这个问题\n\n```\nvar twoSum = function(arr, target) {\n\t//复制数组\n\tvar temp = arr.slice(0);\n\t\n\t//对数组副本进行排序\n\ttemp = temp.sort(function(a,b) {\n\t\treturn a - b;\n\t});\n\t\n\t//设定两个指针，一个从数组头部开始移动，一个从数组尾部开始移动\n\tvar i = 0;\n\tvar j = temp.length - 1;\n\n\t//如果首尾两个数相加不等于目标值，判断它们的和与目标值的大小\n\twhile(i < j) {\n\n\t\t//两个数的和比目标值大的话，后面一个指针往前移\n\t\t//两个数的和比目标值小的话，前面一个指针往后移\n\t\tif(temp[i] + temp[j] > target) {\n\t\t\tj--;\n\t\t} else if(temp[i] + temp[j] < target) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//当两个数的和等于目标值时，跳出循环\n\tif(i == j) {\t\t\n\t\tconsole.log('找不到这样的2个数');\n\t\treturn;\n\t}\n\t\n\t//找到原数组对应的序号\n\tvar index = [];\n\tindex[0] = arr.indexOf(temp[i]);\n\tindex[1] = arr.indexOf(temp[j]);\n\tconsole.log(index);\n}\n```\n\n#### 方法二\n\n使用hash表\n\n\nvar twoSum = function(arr,target) {\n\tvar subArr = arr.map(function(item, index, arr) {\n\t\treturn target - item;\n\t});\n\t\n\tvar hash = {};\n\t\n\tfor(var i = 0; i < arr.length; i++) {\n\t\n\t\t//这里的i+1是为了让hash表里面的每个存在的元素，都为真\n\t\thash[arr[i]] = i + 1;\n\t}\n\t\n\tvar index = [];\n\n\tfor(var i = 0; i < subArr.length; i++) {\n\t\tif(hash[subArr[i]]) {\n\t\t\tindex[0] = hash[target - subArr[i]] - 1;\n\t\t\tindex[1] = hash[subArr[i]] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconsole.log(index);\n\n}\n\n\n### 2. 如果数组是有序的\n\n比无序的解法少了排序的步骤","source":"_posts/2016-09-03-Two Sum.md","raw":"---\nlayout: post\ntitle: Two Sum\ndate: 2016-09-03\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n**数组中找出和为N的两个数**\n\n要求输入：数组，例如： numbers = [1,7,9,10,16]，target = 17;\n\n输出： index1 = 1, index2 = 3\n\n### 1. 如果数组是无序的\n\n#### 方法一\n\n**思想：**\n\n- 先将数组进行排序\n- 然后使用2个指针，一个从数组头部进行遍历，一个从数组尾部进行遍历\n\n\t如果两个数相加 = 输入的值，那么就返回当前的数，跳出循环\n\n\t如果两个数相加 != 输入的值，当两个数的和 > 目标值，则后面一个指针向前移动；当两个数的和 < 目标值，则前面一个指针向后移动\n\n- 然后再在排序之前的数组中找到该值对应的下标作为程序的输出\n\n**需要考虑的几种特殊情况：**\n\n- 在数组中找不到两个数的和等于给定的数\n- 在程序中会找到两对数相加都等于给定的数?????下面的两个程序没有考虑这个问题\n\n```\nvar twoSum = function(arr, target) {\n\t//复制数组\n\tvar temp = arr.slice(0);\n\t\n\t//对数组副本进行排序\n\ttemp = temp.sort(function(a,b) {\n\t\treturn a - b;\n\t});\n\t\n\t//设定两个指针，一个从数组头部开始移动，一个从数组尾部开始移动\n\tvar i = 0;\n\tvar j = temp.length - 1;\n\n\t//如果首尾两个数相加不等于目标值，判断它们的和与目标值的大小\n\twhile(i < j) {\n\n\t\t//两个数的和比目标值大的话，后面一个指针往前移\n\t\t//两个数的和比目标值小的话，前面一个指针往后移\n\t\tif(temp[i] + temp[j] > target) {\n\t\t\tj--;\n\t\t} else if(temp[i] + temp[j] < target) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//当两个数的和等于目标值时，跳出循环\n\tif(i == j) {\t\t\n\t\tconsole.log('找不到这样的2个数');\n\t\treturn;\n\t}\n\t\n\t//找到原数组对应的序号\n\tvar index = [];\n\tindex[0] = arr.indexOf(temp[i]);\n\tindex[1] = arr.indexOf(temp[j]);\n\tconsole.log(index);\n}\n```\n\n#### 方法二\n\n使用hash表\n\n\nvar twoSum = function(arr,target) {\n\tvar subArr = arr.map(function(item, index, arr) {\n\t\treturn target - item;\n\t});\n\t\n\tvar hash = {};\n\t\n\tfor(var i = 0; i < arr.length; i++) {\n\t\n\t\t//这里的i+1是为了让hash表里面的每个存在的元素，都为真\n\t\thash[arr[i]] = i + 1;\n\t}\n\t\n\tvar index = [];\n\n\tfor(var i = 0; i < subArr.length; i++) {\n\t\tif(hash[subArr[i]]) {\n\t\t\tindex[0] = hash[target - subArr[i]] - 1;\n\t\t\tindex[1] = hash[subArr[i]] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconsole.log(index);\n\n}\n\n\n### 2. 如果数组是有序的\n\n比无序的解法少了排序的步骤","slug":"2016-09-03-Two Sum","published":1,"updated":"2016-09-03T12:05:04.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjy00c4d5u8bjbqwrf9","content":"<p><strong>数组中找出和为N的两个数</strong></p>\n<p>要求输入：数组，例如： numbers = [1,7,9,10,16]，target = 17;</p>\n<p>输出： index1 = 1, index2 = 3</p>\n<h3 id=\"1-如果数组是无序的\"><a href=\"#1-如果数组是无序的\" class=\"headerlink\" title=\"1. 如果数组是无序的\"></a>1. 如果数组是无序的</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p><strong>思想：</strong></p>\n<ul>\n<li>先将数组进行排序</li>\n<li><p>然后使用2个指针，一个从数组头部进行遍历，一个从数组尾部进行遍历</p>\n<p>  如果两个数相加 = 输入的值，那么就返回当前的数，跳出循环</p>\n<p>  如果两个数相加 != 输入的值，当两个数的和 &gt; 目标值，则后面一个指针向前移动；当两个数的和 &lt; 目标值，则前面一个指针向后移动</p>\n</li>\n<li><p>然后再在排序之前的数组中找到该值对应的下标作为程序的输出</p>\n</li>\n</ul>\n<p><strong>需要考虑的几种特殊情况：</strong></p>\n<ul>\n<li>在数组中找不到两个数的和等于给定的数</li>\n<li>在程序中会找到两对数相加都等于给定的数?????下面的两个程序没有考虑这个问题</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, target</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//复制数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = arr.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//对数组副本进行排序</span></span><br><span class=\"line\">\ttemp = temp.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//设定两个指针，一个从数组头部开始移动，一个从数组尾部开始移动</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> j = temp.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果首尾两个数相加不等于目标值，判断它们的和与目标值的大小</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//两个数的和比目标值大的话，后面一个指针往前移</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//两个数的和比目标值小的话，前面一个指针往后移</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(temp[i] + temp[j] &gt; target) &#123;</span><br><span class=\"line\">\t\t\tj--;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(temp[i] + temp[j] &lt; target) &#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//当两个数的和等于目标值时，跳出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i == j) &#123;\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'找不到这样的2个数'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//找到原数组对应的序号</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> index = [];</span><br><span class=\"line\">\tindex[<span class=\"number\">0</span>] = arr.indexOf(temp[i]);</span><br><span class=\"line\">\tindex[<span class=\"number\">1</span>] = arr.indexOf(temp[j]);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用hash表</p>\n<p>var twoSum = function(arr,target) {<br>    var subArr = arr.map(function(item, index, arr) {<br>        return target - item;<br>    });</p>\n<pre><code>var hash = {};\n\nfor(var i = 0; i &lt; arr.length; i++) {\n\n    //这里的i+1是为了让hash表里面的每个存在的元素，都为真\n    hash[arr[i]] = i + 1;\n}\n\nvar index = [];\n\nfor(var i = 0; i &lt; subArr.length; i++) {\n    if(hash[subArr[i]]) {\n        index[0] = hash[target - subArr[i]] - 1;\n        index[1] = hash[subArr[i]] - 1;\n        break;\n    }\n}\n\nconsole.log(index);\n</code></pre><p>}</p>\n<h3 id=\"2-如果数组是有序的\"><a href=\"#2-如果数组是有序的\" class=\"headerlink\" title=\"2. 如果数组是有序的\"></a>2. 如果数组是有序的</h3><p>比无序的解法少了排序的步骤</p>\n","excerpt":"","more":"<p><strong>数组中找出和为N的两个数</strong></p>\n<p>要求输入：数组，例如： numbers = [1,7,9,10,16]，target = 17;</p>\n<p>输出： index1 = 1, index2 = 3</p>\n<h3 id=\"1-如果数组是无序的\"><a href=\"#1-如果数组是无序的\" class=\"headerlink\" title=\"1. 如果数组是无序的\"></a>1. 如果数组是无序的</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p><strong>思想：</strong></p>\n<ul>\n<li>先将数组进行排序</li>\n<li><p>然后使用2个指针，一个从数组头部进行遍历，一个从数组尾部进行遍历</p>\n<p>  如果两个数相加 = 输入的值，那么就返回当前的数，跳出循环</p>\n<p>  如果两个数相加 != 输入的值，当两个数的和 &gt; 目标值，则后面一个指针向前移动；当两个数的和 &lt; 目标值，则前面一个指针向后移动</p>\n</li>\n<li><p>然后再在排序之前的数组中找到该值对应的下标作为程序的输出</p>\n</li>\n</ul>\n<p><strong>需要考虑的几种特殊情况：</strong></p>\n<ul>\n<li>在数组中找不到两个数的和等于给定的数</li>\n<li>在程序中会找到两对数相加都等于给定的数?????下面的两个程序没有考虑这个问题</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr, target</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//复制数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = arr.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//对数组副本进行排序</span></span><br><span class=\"line\">\ttemp = temp.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//设定两个指针，一个从数组头部开始移动，一个从数组尾部开始移动</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> j = temp.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果首尾两个数相加不等于目标值，判断它们的和与目标值的大小</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//两个数的和比目标值大的话，后面一个指针往前移</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//两个数的和比目标值小的话，前面一个指针往后移</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(temp[i] + temp[j] &gt; target) &#123;</span><br><span class=\"line\">\t\t\tj--;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(temp[i] + temp[j] &lt; target) &#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//当两个数的和等于目标值时，跳出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i == j) &#123;\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'找不到这样的2个数'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//找到原数组对应的序号</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> index = [];</span><br><span class=\"line\">\tindex[<span class=\"number\">0</span>] = arr.indexOf(temp[i]);</span><br><span class=\"line\">\tindex[<span class=\"number\">1</span>] = arr.indexOf(temp[j]);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用hash表</p>\n<p>var twoSum = function(arr,target) {<br>    var subArr = arr.map(function(item, index, arr) {<br>        return target - item;<br>    });</p>\n<pre><code>var hash = {};\n\nfor(var i = 0; i &lt; arr.length; i++) {\n\n    //这里的i+1是为了让hash表里面的每个存在的元素，都为真\n    hash[arr[i]] = i + 1;\n}\n\nvar index = [];\n\nfor(var i = 0; i &lt; subArr.length; i++) {\n    if(hash[subArr[i]]) {\n        index[0] = hash[target - subArr[i]] - 1;\n        index[1] = hash[subArr[i]] - 1;\n        break;\n    }\n}\n\nconsole.log(index);\n</code></pre><p>}</p>\n<h3 id=\"2-如果数组是有序的\"><a href=\"#2-如果数组是有序的\" class=\"headerlink\" title=\"2. 如果数组是有序的\"></a>2. 如果数组是有序的</h3><p>比无序的解法少了排序的步骤</p>\n"},{"layout":"post","title":"响应式布局的方法","date":"2016-09-02T16:00:00.000Z","description":null,"_content":"\n- 流式布局：通过百分比布局\n- 固定宽度布局：超出部分留白\n- 响应式布局\n- 设置viewport进行缩放\n\n\n### 一. 什么是响应式布局\n\n根据不同的屏幕宽度自动调整网页的布局\n\n### 二. 实现响应式的方式\n\n#### 1. 使用媒体查询\n\n##### css文件中使用媒体查询\n\n```\n@media screen and (min-width: 768px) and (max-width: 1200px) {\n\t.class {\n\t\tbackground: #fff;\n\t}\n}\n```\n\n##### 在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\n\n```\n<link rel='stylesheet' type='text/css' href='index.css' media='screen and (min-width: 1200px)'>\n```\n\n#### 2. 使用百分比和auto\n\n#### 3. 使用rem\n\n#### 4. 使用js获取设备宽度，然后动态创建<link>标签，将css插入\n\n#### 5. 使用flex-box\n\n### 三. 移动端如何屏幕适配的几种方法\n\n#### 1. 使用view-port\n\nviewport是网页默认宽度和高度的意思\n\n移动端禁止缩放\n\n`<meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />`\n\n- width=device-width 宽度等于设备的宽度\n- minimum-scale=1.0 最小缩放为1.0（不允许缩小）\n- maxinum-scale=1.0 最大缩放为1.0（不允许放大）\n- user-scalable=no  不允许缩放\n\n#### 2. 使用transform:scale;进行缩放\n\n用px为单位按视觉进行开发，然后通过计算屏幕与网页的宽高比，用transform:scale来对网页进行全局缩放。\n\n#### 3. 使用rem\n\n设置html标签上的font-size，然后使用rem\n\n不同屏幕宽度设置不同的font-size，可以使用js动态获取，也可以使用媒体查询\n\n","source":"_posts/2016-09-03-响应式布局.md","raw":"---\nlayout: post\ntitle: 响应式布局的方法\ndate: 2016-09-03\ncategories: CSS\ntags: [css]\ndescription: \n---\n\n- 流式布局：通过百分比布局\n- 固定宽度布局：超出部分留白\n- 响应式布局\n- 设置viewport进行缩放\n\n\n### 一. 什么是响应式布局\n\n根据不同的屏幕宽度自动调整网页的布局\n\n### 二. 实现响应式的方式\n\n#### 1. 使用媒体查询\n\n##### css文件中使用媒体查询\n\n```\n@media screen and (min-width: 768px) and (max-width: 1200px) {\n\t.class {\n\t\tbackground: #fff;\n\t}\n}\n```\n\n##### 在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\n\n```\n<link rel='stylesheet' type='text/css' href='index.css' media='screen and (min-width: 1200px)'>\n```\n\n#### 2. 使用百分比和auto\n\n#### 3. 使用rem\n\n#### 4. 使用js获取设备宽度，然后动态创建<link>标签，将css插入\n\n#### 5. 使用flex-box\n\n### 三. 移动端如何屏幕适配的几种方法\n\n#### 1. 使用view-port\n\nviewport是网页默认宽度和高度的意思\n\n移动端禁止缩放\n\n`<meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />`\n\n- width=device-width 宽度等于设备的宽度\n- minimum-scale=1.0 最小缩放为1.0（不允许缩小）\n- maxinum-scale=1.0 最大缩放为1.0（不允许放大）\n- user-scalable=no  不允许缩放\n\n#### 2. 使用transform:scale;进行缩放\n\n用px为单位按视觉进行开发，然后通过计算屏幕与网页的宽高比，用transform:scale来对网页进行全局缩放。\n\n#### 3. 使用rem\n\n设置html标签上的font-size，然后使用rem\n\n不同屏幕宽度设置不同的font-size，可以使用js动态获取，也可以使用媒体查询\n\n","slug":"2016-09-03-响应式布局","published":1,"updated":"2016-09-07T03:03:36.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocjz00c7d5u8pm5qidd5","content":"<ul>\n<li>流式布局：通过百分比布局</li>\n<li>固定宽度布局：超出部分留白</li>\n<li>响应式布局</li>\n<li>设置viewport进行缩放</li>\n</ul>\n<h3 id=\"一-什么是响应式布局\"><a href=\"#一-什么是响应式布局\" class=\"headerlink\" title=\"一. 什么是响应式布局\"></a>一. 什么是响应式布局</h3><p>根据不同的屏幕宽度自动调整网页的布局</p>\n<h3 id=\"二-实现响应式的方式\"><a href=\"#二-实现响应式的方式\" class=\"headerlink\" title=\"二. 实现响应式的方式\"></a>二. 实现响应式的方式</h3><h4 id=\"1-使用媒体查询\"><a href=\"#1-使用媒体查询\" class=\"headerlink\" title=\"1. 使用媒体查询\"></a>1. 使用媒体查询</h4><h5 id=\"css文件中使用媒体查询\"><a href=\"#css文件中使用媒体查询\" class=\"headerlink\" title=\"css文件中使用媒体查询\"></a>css文件中使用媒体查询</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> screen and (min-width: <span class=\"number\">768px</span>) and (max-width: <span class=\"number\">1200px</span>) &#123;</span><br><span class=\"line\">\t<span class=\"selector-class\">.class</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\"><a href=\"#在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\" class=\"headerlink\" title=\"在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\"></a>在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件</h5><figure class=\"highlight sml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=<span class=\"symbol\">'stylesheet'</span> <span class=\"keyword\">type</span>=<span class=\"symbol\">'text</span>/css' href=<span class=\"symbol\">'index</span>.css' media=<span class=\"symbol\">'screen</span> <span class=\"keyword\">and</span> (min-width: <span class=\"number\">1200</span>px)<span class=\"string\">'&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用百分比和auto\"><a href=\"#2-使用百分比和auto\" class=\"headerlink\" title=\"2. 使用百分比和auto\"></a>2. 使用百分比和auto</h4><h4 id=\"3-使用rem\"><a href=\"#3-使用rem\" class=\"headerlink\" title=\"3. 使用rem\"></a>3. 使用rem</h4><h4 id=\"4-使用js获取设备宽度，然后动态创建标签，将css插入\"><a href=\"#4-使用js获取设备宽度，然后动态创建标签，将css插入\" class=\"headerlink\" title=\"4. 使用js获取设备宽度，然后动态创建标签，将css插入\"></a>4. 使用js获取设备宽度，然后动态创建<link>标签，将css插入</h4><h4 id=\"5-使用flex-box\"><a href=\"#5-使用flex-box\" class=\"headerlink\" title=\"5. 使用flex-box\"></a>5. 使用flex-box</h4><h3 id=\"三-移动端如何屏幕适配的几种方法\"><a href=\"#三-移动端如何屏幕适配的几种方法\" class=\"headerlink\" title=\"三. 移动端如何屏幕适配的几种方法\"></a>三. 移动端如何屏幕适配的几种方法</h3><h4 id=\"1-使用view-port\"><a href=\"#1-使用view-port\" class=\"headerlink\" title=\"1. 使用view-port\"></a>1. 使用view-port</h4><p>viewport是网页默认宽度和高度的意思</p>\n<p>移动端禁止缩放</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</code></p>\n<ul>\n<li>width=device-width 宽度等于设备的宽度</li>\n<li>minimum-scale=1.0 最小缩放为1.0（不允许缩小）</li>\n<li>maxinum-scale=1.0 最大缩放为1.0（不允许放大）</li>\n<li>user-scalable=no  不允许缩放</li>\n</ul>\n<h4 id=\"2-使用transform-scale-进行缩放\"><a href=\"#2-使用transform-scale-进行缩放\" class=\"headerlink\" title=\"2. 使用transform:scale;进行缩放\"></a>2. 使用transform:scale;进行缩放</h4><p>用px为单位按视觉进行开发，然后通过计算屏幕与网页的宽高比，用transform:scale来对网页进行全局缩放。</p>\n<h4 id=\"3-使用rem-1\"><a href=\"#3-使用rem-1\" class=\"headerlink\" title=\"3. 使用rem\"></a>3. 使用rem</h4><p>设置html标签上的font-size，然后使用rem</p>\n<p>不同屏幕宽度设置不同的font-size，可以使用js动态获取，也可以使用媒体查询</p>\n","excerpt":"","more":"<ul>\n<li>流式布局：通过百分比布局</li>\n<li>固定宽度布局：超出部分留白</li>\n<li>响应式布局</li>\n<li>设置viewport进行缩放</li>\n</ul>\n<h3 id=\"一-什么是响应式布局\"><a href=\"#一-什么是响应式布局\" class=\"headerlink\" title=\"一. 什么是响应式布局\"></a>一. 什么是响应式布局</h3><p>根据不同的屏幕宽度自动调整网页的布局</p>\n<h3 id=\"二-实现响应式的方式\"><a href=\"#二-实现响应式的方式\" class=\"headerlink\" title=\"二. 实现响应式的方式\"></a>二. 实现响应式的方式</h3><h4 id=\"1-使用媒体查询\"><a href=\"#1-使用媒体查询\" class=\"headerlink\" title=\"1. 使用媒体查询\"></a>1. 使用媒体查询</h4><h5 id=\"css文件中使用媒体查询\"><a href=\"#css文件中使用媒体查询\" class=\"headerlink\" title=\"css文件中使用媒体查询\"></a>css文件中使用媒体查询</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> screen and (min-width: <span class=\"number\">768px</span>) and (max-width: <span class=\"number\">1200px</span>) &#123;</span><br><span class=\"line\">\t<span class=\"selector-class\">.class</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\"><a href=\"#在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\" class=\"headerlink\" title=\"在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件\"></a>在link文件中使用媒体查询判断设备的尺寸，然后引用不同的css文件</h5><figure class=\"highlight sml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=<span class=\"symbol\">'stylesheet'</span> <span class=\"keyword\">type</span>=<span class=\"symbol\">'text</span>/css' href=<span class=\"symbol\">'index</span>.css' media=<span class=\"symbol\">'screen</span> <span class=\"keyword\">and</span> (min-width: <span class=\"number\">1200</span>px)<span class=\"string\">'&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-使用百分比和auto\"><a href=\"#2-使用百分比和auto\" class=\"headerlink\" title=\"2. 使用百分比和auto\"></a>2. 使用百分比和auto</h4><h4 id=\"3-使用rem\"><a href=\"#3-使用rem\" class=\"headerlink\" title=\"3. 使用rem\"></a>3. 使用rem</h4><h4 id=\"4-使用js获取设备宽度，然后动态创建标签，将css插入\"><a href=\"#4-使用js获取设备宽度，然后动态创建标签，将css插入\" class=\"headerlink\" title=\"4. 使用js获取设备宽度，然后动态创建标签，将css插入\"></a>4. 使用js获取设备宽度，然后动态创建<link>标签，将css插入</h4><h4 id=\"5-使用flex-box\"><a href=\"#5-使用flex-box\" class=\"headerlink\" title=\"5. 使用flex-box\"></a>5. 使用flex-box</h4><h3 id=\"三-移动端如何屏幕适配的几种方法\"><a href=\"#三-移动端如何屏幕适配的几种方法\" class=\"headerlink\" title=\"三. 移动端如何屏幕适配的几种方法\"></a>三. 移动端如何屏幕适配的几种方法</h3><h4 id=\"1-使用view-port\"><a href=\"#1-使用view-port\" class=\"headerlink\" title=\"1. 使用view-port\"></a>1. 使用view-port</h4><p>viewport是网页默认宽度和高度的意思</p>\n<p>移动端禁止缩放</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</code></p>\n<ul>\n<li>width=device-width 宽度等于设备的宽度</li>\n<li>minimum-scale=1.0 最小缩放为1.0（不允许缩小）</li>\n<li>maxinum-scale=1.0 最大缩放为1.0（不允许放大）</li>\n<li>user-scalable=no  不允许缩放</li>\n</ul>\n<h4 id=\"2-使用transform-scale-进行缩放\"><a href=\"#2-使用transform-scale-进行缩放\" class=\"headerlink\" title=\"2. 使用transform:scale;进行缩放\"></a>2. 使用transform:scale;进行缩放</h4><p>用px为单位按视觉进行开发，然后通过计算屏幕与网页的宽高比，用transform:scale来对网页进行全局缩放。</p>\n<h4 id=\"3-使用rem-1\"><a href=\"#3-使用rem-1\" class=\"headerlink\" title=\"3. 使用rem\"></a>3. 使用rem</h4><p>设置html标签上的font-size，然后使用rem</p>\n<p>不同屏幕宽度设置不同的font-size，可以使用js动态获取，也可以使用媒体查询</p>\n"},{"layout":"post","title":"斐波那契数列","date":"2016-09-02T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是斐波那契数列\n\n0 1 1 2 3 5 8 13 21 34...\n\n在数学上，斐波纳契数列以如下被以递归的方法定义：\n\nF（0）= 0，F（1）= 1，F（n）= F(n-1) + F(n-2)\n\n### 二. 用程序实现\n\n#### 1. 用递归的思想：\n\n\t```js\n    function fib(n){\n    \tif(n == 1){\n    \t\treturn 0;\n    \t}else if(n == 2){\n    \t\treturn 1;\n    \t}else{\n    \t\treturn fib(n-1)+fib(n-2);\n    \t}\n    }\n\n\t输入的n代表是第几个数\n\t函数返回的是第几个数的值\n\t```\n\n用递归的缺点：可能会造成内存溢出的情形\n\n#### 2. 使用循环代替递归\n\n\t```js\n    function fib(n){\n    \tvar n1,n2,res;\n    \tn1 = 0;\n    \tn2 = 1;\n    \tfor(var i = 1;i <= n;i++){\n    \t\tres = n1 + n2;\n    \t\tn1 = n2;\n    \t\tn2 = res;\n    \t}\n\t\treturn res;\n    }\n\t```\n\n### 三. 由斐波拉契数列扩展的题目\n\n#### 1. 上楼梯问题\n\n一个人一次只能上1或2阶楼梯，求问上到n阶楼梯有多少种上法？\n\n**思路：**\n\n从最简单的开始想起\n\n上1层楼梯，有1种上法（1）\n\n上2层楼梯，有2种上法（1+1 、 2）\n\n上3层楼梯，从1层上2阶（1+2），从2层上1阶（1+1+1、2+1）\n\n·\n·\n·\n\n上n层楼梯，那么可以从n-1上1层，或者 从n-2上2层\n\nf(n) = f(n-1) + f(n-2)\n\nf(n)表示上n层楼梯需要使用的方法。","source":"_posts/2016-09-03-斐波那契数列.md","raw":"---\nlayout: post\ntitle: 斐波那契数列\ndate: 2016-09-03\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一. 什么是斐波那契数列\n\n0 1 1 2 3 5 8 13 21 34...\n\n在数学上，斐波纳契数列以如下被以递归的方法定义：\n\nF（0）= 0，F（1）= 1，F（n）= F(n-1) + F(n-2)\n\n### 二. 用程序实现\n\n#### 1. 用递归的思想：\n\n\t```js\n    function fib(n){\n    \tif(n == 1){\n    \t\treturn 0;\n    \t}else if(n == 2){\n    \t\treturn 1;\n    \t}else{\n    \t\treturn fib(n-1)+fib(n-2);\n    \t}\n    }\n\n\t输入的n代表是第几个数\n\t函数返回的是第几个数的值\n\t```\n\n用递归的缺点：可能会造成内存溢出的情形\n\n#### 2. 使用循环代替递归\n\n\t```js\n    function fib(n){\n    \tvar n1,n2,res;\n    \tn1 = 0;\n    \tn2 = 1;\n    \tfor(var i = 1;i <= n;i++){\n    \t\tres = n1 + n2;\n    \t\tn1 = n2;\n    \t\tn2 = res;\n    \t}\n\t\treturn res;\n    }\n\t```\n\n### 三. 由斐波拉契数列扩展的题目\n\n#### 1. 上楼梯问题\n\n一个人一次只能上1或2阶楼梯，求问上到n阶楼梯有多少种上法？\n\n**思路：**\n\n从最简单的开始想起\n\n上1层楼梯，有1种上法（1）\n\n上2层楼梯，有2种上法（1+1 、 2）\n\n上3层楼梯，从1层上2阶（1+2），从2层上1阶（1+1+1、2+1）\n\n·\n·\n·\n\n上n层楼梯，那么可以从n-1上1层，或者 从n-2上2层\n\nf(n) = f(n-1) + f(n-2)\n\nf(n)表示上n层楼梯需要使用的方法。","slug":"2016-09-03-斐波那契数列","published":1,"updated":"2016-09-03T03:52:18.000Z","comments":1,"photos":[],"link":"","_id":"cj035ock200ccd5u8rjayjver","content":"<h3 id=\"一-什么是斐波那契数列\"><a href=\"#一-什么是斐波那契数列\" class=\"headerlink\" title=\"一. 什么是斐波那契数列\"></a>一. 什么是斐波那契数列</h3><p>0 1 1 2 3 5 8 13 21 34…</p>\n<p>在数学上，斐波纳契数列以如下被以递归的方法定义：</p>\n<p>F（0）= 0，F（1）= 1，F（n）= F(n-1) + F(n-2)</p>\n<h3 id=\"二-用程序实现\"><a href=\"#二-用程序实现\" class=\"headerlink\" title=\"二. 用程序实现\"></a>二. 用程序实现</h3><h4 id=\"1-用递归的思想：\"><a href=\"#1-用递归的思想：\" class=\"headerlink\" title=\"1. 用递归的思想：\"></a>1. 用递归的思想：</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   \t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   \t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输入的n代表是第几个数</span><br><span class=\"line\">函数返回的是第几个数的值</span><br></pre></td></tr></table></figure>\n</code></pre><p>用递归的缺点：可能会造成内存溢出的情形</p>\n<h4 id=\"2-使用循环代替递归\"><a href=\"#2-使用循环代替递归\" class=\"headerlink\" title=\"2. 使用循环代替递归\"></a>2. 使用循环代替递归</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">var</span> n1,n2,res;</span><br><span class=\"line\">  \tn1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  \tn2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>;i &lt;= n;i++)&#123;</span><br><span class=\"line\">  \t\tres = n1 + n2;</span><br><span class=\"line\">  \t\tn1 = n2;</span><br><span class=\"line\">  \t\tn2 = res;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"三-由斐波拉契数列扩展的题目\"><a href=\"#三-由斐波拉契数列扩展的题目\" class=\"headerlink\" title=\"三. 由斐波拉契数列扩展的题目\"></a>三. 由斐波拉契数列扩展的题目</h3><h4 id=\"1-上楼梯问题\"><a href=\"#1-上楼梯问题\" class=\"headerlink\" title=\"1. 上楼梯问题\"></a>1. 上楼梯问题</h4><p>一个人一次只能上1或2阶楼梯，求问上到n阶楼梯有多少种上法？</p>\n<p><strong>思路：</strong></p>\n<p>从最简单的开始想起</p>\n<p>上1层楼梯，有1种上法（1）</p>\n<p>上2层楼梯，有2种上法（1+1 、 2）</p>\n<p>上3层楼梯，从1层上2阶（1+2），从2层上1阶（1+1+1、2+1）</p>\n<p>·<br>·<br>·</p>\n<p>上n层楼梯，那么可以从n-1上1层，或者 从n-2上2层</p>\n<p>f(n) = f(n-1) + f(n-2)</p>\n<p>f(n)表示上n层楼梯需要使用的方法。</p>\n","excerpt":"","more":"<h3 id=\"一-什么是斐波那契数列\"><a href=\"#一-什么是斐波那契数列\" class=\"headerlink\" title=\"一. 什么是斐波那契数列\"></a>一. 什么是斐波那契数列</h3><p>0 1 1 2 3 5 8 13 21 34…</p>\n<p>在数学上，斐波纳契数列以如下被以递归的方法定义：</p>\n<p>F（0）= 0，F（1）= 1，F（n）= F(n-1) + F(n-2)</p>\n<h3 id=\"二-用程序实现\"><a href=\"#二-用程序实现\" class=\"headerlink\" title=\"二. 用程序实现\"></a>二. 用程序实现</h3><h4 id=\"1-用递归的思想：\"><a href=\"#1-用递归的思想：\" class=\"headerlink\" title=\"1. 用递归的思想：\"></a>1. 用递归的思想：</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   \t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   \t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输入的n代表是第几个数</span><br><span class=\"line\">函数返回的是第几个数的值</span><br></pre></td></tr></table></figure>\n</code></pre><p>用递归的缺点：可能会造成内存溢出的情形</p>\n<h4 id=\"2-使用循环代替递归\"><a href=\"#2-使用循环代替递归\" class=\"headerlink\" title=\"2. 使用循环代替递归\"></a>2. 使用循环代替递归</h4><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">var</span> n1,n2,res;</span><br><span class=\"line\">  \tn1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  \tn2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>;i &lt;= n;i++)&#123;</span><br><span class=\"line\">  \t\tres = n1 + n2;</span><br><span class=\"line\">  \t\tn1 = n2;</span><br><span class=\"line\">  \t\tn2 = res;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"三-由斐波拉契数列扩展的题目\"><a href=\"#三-由斐波拉契数列扩展的题目\" class=\"headerlink\" title=\"三. 由斐波拉契数列扩展的题目\"></a>三. 由斐波拉契数列扩展的题目</h3><h4 id=\"1-上楼梯问题\"><a href=\"#1-上楼梯问题\" class=\"headerlink\" title=\"1. 上楼梯问题\"></a>1. 上楼梯问题</h4><p>一个人一次只能上1或2阶楼梯，求问上到n阶楼梯有多少种上法？</p>\n<p><strong>思路：</strong></p>\n<p>从最简单的开始想起</p>\n<p>上1层楼梯，有1种上法（1）</p>\n<p>上2层楼梯，有2种上法（1+1 、 2）</p>\n<p>上3层楼梯，从1层上2阶（1+2），从2层上1阶（1+1+1、2+1）</p>\n<p>·<br>·<br>·</p>\n<p>上n层楼梯，那么可以从n-1上1层，或者 从n-2上2层</p>\n<p>f(n) = f(n-1) + f(n-2)</p>\n<p>f(n)表示上n层楼梯需要使用的方法。</p>\n"},{"layout":"post","title":"数据结构与算法——javaScript","date":"2016-08-27T16:00:00.000Z","description":null,"_content":"\n### 一. 数组\n\njs中的数组的一些基本方法见博客<http://>\n\n#### 1. 二维数组\n\n#####  (1). 二维数组的创建\n\n```\nfunction matrix(row,col,init) {\n\tvar arr = [];\n\tfor(var i = 0; i < row; i++) {\n\t\tarr[i] = [];\n\t\tfor(var j = 0; j < col; j++) {\n\t\t\tarr[i][j] = init;\n\t\t}\n\t}\n\treturn arr;\n}\n\nmatrix(2,3,0);\n```\n\n##### (2). 访问二维数组\n\n**按行访问**\n\n```\nvar grade = [ [11,12,13],\n\t\t\t  [21,22,23],\n\t\t\t  [31,32,33] ];\nfor(var row = 0; row < grade.length; row++) {\n\tfor(var col = 0; col < grade[row].length; col++) {\n\t\tconsole.log(grade[row][col]);\n\t}\n}\n```\n**按列访问**\n\n```\nvar grade = [ [11,12,13],\n\t\t\t  [21,22,23],\n\t\t\t  [31,32,33] ];\nfor(var col = 0; col < grade.length; col++) {\n\tfor(var row = 0; row < grade[col].length; row++) {\n\t\tconsole.log(grade[row][col]);\n\t}\n}\n```\n#### 2. 对象数组、数组对象\n\n**对象数组**\n\n数组中的元素是对象\n\n`eg: [{a: 1},{b: 2}]`\n\n**数组对象**\n\n对象中的属性是数组\n\n`eg: {a: [1,2,3]}`\n\n### 二. 列表\n\n当不需要在一个很长的序列中查找元素，或者对其进行排序时，可以使用列表。\n\n### 三. 栈\n\n#### 1. 栈是一种特殊的列表，只能通过一端访问。后入先出。\n\nfunction Stack() {\n\tthis.dataStore = []; //存放栈中的元素\n\tthis.top = 0; //栈顶的位置 ＋ 1\n\tthis.push = push; //入栈的函数\n\tthis.pop = pop; //出栈的函数\n\tthis.peek = peek; //返回栈顶的元素\n}\n\n#### 2.使用栈的例子\n\n**数制间的相互转换**\n\n输入的数字是n，转换为以b为基数的数字\n\n- 最低位是`n%b`，将此位压入栈\n- 使用`Math.floor(n/b)`代替之前的n再次输入\n- 重复前2个步骤，直到`Math.floor(n/b)`为0，则不再循环\n\n```\nfunction mulBase(num, base) {\n\tvar stack = [];\n\t\n\t//将每一次求得得余数入栈\n\tdo {\n\t\tstack.push(num % base);\n\t\tnum = Math.floor(num / base);\n\t} while (num > 0)\n\t\n\tvar result = '';\n\t\n\t//依次出栈\n\twhile(stack.length > 0) {\n\t\tresult += stack.pop();\n\t}\n\t\n\t//返回输出的结果\n\treturn result;\n}\n```\n\n**回文**\n\n字符串反转之后是否与原字符串相等，如果相等，则为回文\n\n使用栈的思想，首先将字符串依次入栈，再依次出栈，判断两个字符串是否相等\n\n<font color='red'>注意：js中字符串没有反转操作的函数，而数组有arr.reverse()</font>\n\n```\nfunction isHuiWen(str) {\n\tvar arr = str.split();\n\tvar reverseStr = '';\n\twhile(arr.length > 0) {\n\t\treverseStr += arr.pop();\n\t}\n\t\n\tif(reverseStr == str) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n\t\n}\n```\n\n### 四. 队列\n\n先入先出\n\nfunction Queue() {\n\tthis.dataStore = []; //存放队列中元素的数组\n\tthis.enqueue = enqueue; //入队列，队尾增加元素\n\tthis.dequeue = dequeue; //出队列，队头删除元素\n\tthis.front = front;\n\tthis.back = back;\n\tthis.toString = toString;\n\tthis.empty = empty;\n}\n\n","source":"_posts/2016-08-28-数据结构与算法——javaScript.md","raw":"---\nlayout: post\ntitle: 数据结构与算法——javaScript\ndate: 2016-08-28\ncategories: 算法学习\ntags: [读书笔记,算法]\ndescription: \n---\n\n### 一. 数组\n\njs中的数组的一些基本方法见博客<http://>\n\n#### 1. 二维数组\n\n#####  (1). 二维数组的创建\n\n```\nfunction matrix(row,col,init) {\n\tvar arr = [];\n\tfor(var i = 0; i < row; i++) {\n\t\tarr[i] = [];\n\t\tfor(var j = 0; j < col; j++) {\n\t\t\tarr[i][j] = init;\n\t\t}\n\t}\n\treturn arr;\n}\n\nmatrix(2,3,0);\n```\n\n##### (2). 访问二维数组\n\n**按行访问**\n\n```\nvar grade = [ [11,12,13],\n\t\t\t  [21,22,23],\n\t\t\t  [31,32,33] ];\nfor(var row = 0; row < grade.length; row++) {\n\tfor(var col = 0; col < grade[row].length; col++) {\n\t\tconsole.log(grade[row][col]);\n\t}\n}\n```\n**按列访问**\n\n```\nvar grade = [ [11,12,13],\n\t\t\t  [21,22,23],\n\t\t\t  [31,32,33] ];\nfor(var col = 0; col < grade.length; col++) {\n\tfor(var row = 0; row < grade[col].length; row++) {\n\t\tconsole.log(grade[row][col]);\n\t}\n}\n```\n#### 2. 对象数组、数组对象\n\n**对象数组**\n\n数组中的元素是对象\n\n`eg: [{a: 1},{b: 2}]`\n\n**数组对象**\n\n对象中的属性是数组\n\n`eg: {a: [1,2,3]}`\n\n### 二. 列表\n\n当不需要在一个很长的序列中查找元素，或者对其进行排序时，可以使用列表。\n\n### 三. 栈\n\n#### 1. 栈是一种特殊的列表，只能通过一端访问。后入先出。\n\nfunction Stack() {\n\tthis.dataStore = []; //存放栈中的元素\n\tthis.top = 0; //栈顶的位置 ＋ 1\n\tthis.push = push; //入栈的函数\n\tthis.pop = pop; //出栈的函数\n\tthis.peek = peek; //返回栈顶的元素\n}\n\n#### 2.使用栈的例子\n\n**数制间的相互转换**\n\n输入的数字是n，转换为以b为基数的数字\n\n- 最低位是`n%b`，将此位压入栈\n- 使用`Math.floor(n/b)`代替之前的n再次输入\n- 重复前2个步骤，直到`Math.floor(n/b)`为0，则不再循环\n\n```\nfunction mulBase(num, base) {\n\tvar stack = [];\n\t\n\t//将每一次求得得余数入栈\n\tdo {\n\t\tstack.push(num % base);\n\t\tnum = Math.floor(num / base);\n\t} while (num > 0)\n\t\n\tvar result = '';\n\t\n\t//依次出栈\n\twhile(stack.length > 0) {\n\t\tresult += stack.pop();\n\t}\n\t\n\t//返回输出的结果\n\treturn result;\n}\n```\n\n**回文**\n\n字符串反转之后是否与原字符串相等，如果相等，则为回文\n\n使用栈的思想，首先将字符串依次入栈，再依次出栈，判断两个字符串是否相等\n\n<font color='red'>注意：js中字符串没有反转操作的函数，而数组有arr.reverse()</font>\n\n```\nfunction isHuiWen(str) {\n\tvar arr = str.split();\n\tvar reverseStr = '';\n\twhile(arr.length > 0) {\n\t\treverseStr += arr.pop();\n\t}\n\t\n\tif(reverseStr == str) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n\t\n}\n```\n\n### 四. 队列\n\n先入先出\n\nfunction Queue() {\n\tthis.dataStore = []; //存放队列中元素的数组\n\tthis.enqueue = enqueue; //入队列，队尾增加元素\n\tthis.dequeue = dequeue; //出队列，队头删除元素\n\tthis.front = front;\n\tthis.back = back;\n\tthis.toString = toString;\n\tthis.empty = empty;\n}\n\n","slug":"2016-08-28-数据结构与算法——javaScript","published":1,"updated":"2016-08-30T02:35:30.000Z","comments":1,"photos":[],"link":"","_id":"cj035ock400cfd5u84bov6kk8","content":"<h3 id=\"一-数组\"><a href=\"#一-数组\" class=\"headerlink\" title=\"一. 数组\"></a>一. 数组</h3><p>js中的数组的一些基本方法见博客<a href=\"http://\" target=\"_blank\" rel=\"external\">http://</a></p>\n<h4 id=\"1-二维数组\"><a href=\"#1-二维数组\" class=\"headerlink\" title=\"1. 二维数组\"></a>1. 二维数组</h4><h5 id=\"1-二维数组的创建\"><a href=\"#1-二维数组的创建\" class=\"headerlink\" title=\"(1). 二维数组的创建\"></a>(1). 二维数组的创建</h5><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"built_in\">matrix</span>(<span class=\"built_in\">row</span>,<span class=\"built_in\">col</span>,init) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> arr = [];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">row</span>; i++) &#123;</span><br><span class=\"line\">\t\tarr[i] = [];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">col</span>; j++) &#123;</span><br><span class=\"line\">\t\t\tarr[i][j] = init;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">matrix</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-访问二维数组\"><a href=\"#2-访问二维数组\" class=\"headerlink\" title=\"(2). 访问二维数组\"></a>(2). 访问二维数组</h5><p><strong>按行访问</strong></p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> grade = [ [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>] ];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">row</span> = <span class=\"number\">0</span>; <span class=\"built_in\">row</span> &lt; grade.<span class=\"built_in\">length</span>; <span class=\"built_in\">row</span>++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">col</span> = <span class=\"number\">0</span>; <span class=\"built_in\">col</span> &lt; grade[<span class=\"built_in\">row</span>].<span class=\"built_in\">length</span>; <span class=\"built_in\">col</span>++) &#123;</span><br><span class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(grade[<span class=\"built_in\">row</span>][<span class=\"built_in\">col</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>按列访问</strong></p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> grade = [ [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>] ];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">col</span> = <span class=\"number\">0</span>; <span class=\"built_in\">col</span> &lt; grade.<span class=\"built_in\">length</span>; <span class=\"built_in\">col</span>++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">row</span> = <span class=\"number\">0</span>; <span class=\"built_in\">row</span> &lt; grade[<span class=\"built_in\">col</span>].<span class=\"built_in\">length</span>; <span class=\"built_in\">row</span>++) &#123;</span><br><span class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(grade[<span class=\"built_in\">row</span>][<span class=\"built_in\">col</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-对象数组、数组对象\"><a href=\"#2-对象数组、数组对象\" class=\"headerlink\" title=\"2. 对象数组、数组对象\"></a>2. 对象数组、数组对象</h4><p><strong>对象数组</strong></p>\n<p>数组中的元素是对象</p>\n<p><code>eg: [{a: 1},{b: 2}]</code></p>\n<p><strong>数组对象</strong></p>\n<p>对象中的属性是数组</p>\n<p><code>eg: {a: [1,2,3]}</code></p>\n<h3 id=\"二-列表\"><a href=\"#二-列表\" class=\"headerlink\" title=\"二. 列表\"></a>二. 列表</h3><p>当不需要在一个很长的序列中查找元素，或者对其进行排序时，可以使用列表。</p>\n<h3 id=\"三-栈\"><a href=\"#三-栈\" class=\"headerlink\" title=\"三. 栈\"></a>三. 栈</h3><h4 id=\"1-栈是一种特殊的列表，只能通过一端访问。后入先出。\"><a href=\"#1-栈是一种特殊的列表，只能通过一端访问。后入先出。\" class=\"headerlink\" title=\"1. 栈是一种特殊的列表，只能通过一端访问。后入先出。\"></a>1. 栈是一种特殊的列表，只能通过一端访问。后入先出。</h4><p>function Stack() {<br>    this.dataStore = []; //存放栈中的元素<br>    this.top = 0; //栈顶的位置 ＋ 1<br>    this.push = push; //入栈的函数<br>    this.pop = pop; //出栈的函数<br>    this.peek = peek; //返回栈顶的元素<br>}</p>\n<h4 id=\"2-使用栈的例子\"><a href=\"#2-使用栈的例子\" class=\"headerlink\" title=\"2.使用栈的例子\"></a>2.使用栈的例子</h4><p><strong>数制间的相互转换</strong></p>\n<p>输入的数字是n，转换为以b为基数的数字</p>\n<ul>\n<li>最低位是<code>n%b</code>，将此位压入栈</li>\n<li>使用<code>Math.floor(n/b)</code>代替之前的n再次输入</li>\n<li>重复前2个步骤，直到<code>Math.floor(n/b)</code>为0，则不再循环</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mulBase(<span class=\"built_in\">num</span>, base) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//将每一次求得得余数入栈</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tstack.push(<span class=\"built_in\">num</span> % base);</span><br><span class=\"line\">\t\t<span class=\"built_in\">num</span> = Math.floor(<span class=\"built_in\">num</span> / base);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">num</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result = <span class=\"string\">''</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//依次出栈</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tresult += stack.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//返回输出的结果</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>回文</strong></p>\n<p>字符串反转之后是否与原字符串相等，如果相等，则为回文</p>\n<p>使用栈的思想，首先将字符串依次入栈，再依次出栈，判断两个字符串是否相等</p>\n<font color=\"red\">注意：js中字符串没有反转操作的函数，而数组有arr.reverse()</font>\n\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isHuiWen</span><span class=\"params\">(str)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> arr = str.split();</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> reverseStr = <span class=\"string\">''</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(arr.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\treverseStr += arr.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(reverseStr == str) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-队列\"><a href=\"#四-队列\" class=\"headerlink\" title=\"四. 队列\"></a>四. 队列</h3><p>先入先出</p>\n<p>function Queue() {<br>    this.dataStore = []; //存放队列中元素的数组<br>    this.enqueue = enqueue; //入队列，队尾增加元素<br>    this.dequeue = dequeue; //出队列，队头删除元素<br>    this.front = front;<br>    this.back = back;<br>    this.toString = toString;<br>    this.empty = empty;<br>}</p>\n","excerpt":"","more":"<h3 id=\"一-数组\"><a href=\"#一-数组\" class=\"headerlink\" title=\"一. 数组\"></a>一. 数组</h3><p>js中的数组的一些基本方法见博客<a href=\"http://\">http://</a></p>\n<h4 id=\"1-二维数组\"><a href=\"#1-二维数组\" class=\"headerlink\" title=\"1. 二维数组\"></a>1. 二维数组</h4><h5 id=\"1-二维数组的创建\"><a href=\"#1-二维数组的创建\" class=\"headerlink\" title=\"(1). 二维数组的创建\"></a>(1). 二维数组的创建</h5><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"built_in\">matrix</span>(<span class=\"built_in\">row</span>,<span class=\"built_in\">col</span>,init) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> arr = [];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">row</span>; i++) &#123;</span><br><span class=\"line\">\t\tarr[i] = [];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">col</span>; j++) &#123;</span><br><span class=\"line\">\t\t\tarr[i][j] = init;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">matrix</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-访问二维数组\"><a href=\"#2-访问二维数组\" class=\"headerlink\" title=\"(2). 访问二维数组\"></a>(2). 访问二维数组</h5><p><strong>按行访问</strong></p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> grade = [ [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>] ];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">row</span> = <span class=\"number\">0</span>; <span class=\"built_in\">row</span> &lt; grade.<span class=\"built_in\">length</span>; <span class=\"built_in\">row</span>++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">col</span> = <span class=\"number\">0</span>; <span class=\"built_in\">col</span> &lt; grade[<span class=\"built_in\">row</span>].<span class=\"built_in\">length</span>; <span class=\"built_in\">col</span>++) &#123;</span><br><span class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(grade[<span class=\"built_in\">row</span>][<span class=\"built_in\">col</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>按列访问</strong></p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> grade = [ [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>],</span><br><span class=\"line\">\t\t\t  [<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>] ];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">col</span> = <span class=\"number\">0</span>; <span class=\"built_in\">col</span> &lt; grade.<span class=\"built_in\">length</span>; <span class=\"built_in\">col</span>++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> <span class=\"built_in\">row</span> = <span class=\"number\">0</span>; <span class=\"built_in\">row</span> &lt; grade[<span class=\"built_in\">col</span>].<span class=\"built_in\">length</span>; <span class=\"built_in\">row</span>++) &#123;</span><br><span class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(grade[<span class=\"built_in\">row</span>][<span class=\"built_in\">col</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-对象数组、数组对象\"><a href=\"#2-对象数组、数组对象\" class=\"headerlink\" title=\"2. 对象数组、数组对象\"></a>2. 对象数组、数组对象</h4><p><strong>对象数组</strong></p>\n<p>数组中的元素是对象</p>\n<p><code>eg: [{a: 1},{b: 2}]</code></p>\n<p><strong>数组对象</strong></p>\n<p>对象中的属性是数组</p>\n<p><code>eg: {a: [1,2,3]}</code></p>\n<h3 id=\"二-列表\"><a href=\"#二-列表\" class=\"headerlink\" title=\"二. 列表\"></a>二. 列表</h3><p>当不需要在一个很长的序列中查找元素，或者对其进行排序时，可以使用列表。</p>\n<h3 id=\"三-栈\"><a href=\"#三-栈\" class=\"headerlink\" title=\"三. 栈\"></a>三. 栈</h3><h4 id=\"1-栈是一种特殊的列表，只能通过一端访问。后入先出。\"><a href=\"#1-栈是一种特殊的列表，只能通过一端访问。后入先出。\" class=\"headerlink\" title=\"1. 栈是一种特殊的列表，只能通过一端访问。后入先出。\"></a>1. 栈是一种特殊的列表，只能通过一端访问。后入先出。</h4><p>function Stack() {<br>    this.dataStore = []; //存放栈中的元素<br>    this.top = 0; //栈顶的位置 ＋ 1<br>    this.push = push; //入栈的函数<br>    this.pop = pop; //出栈的函数<br>    this.peek = peek; //返回栈顶的元素<br>}</p>\n<h4 id=\"2-使用栈的例子\"><a href=\"#2-使用栈的例子\" class=\"headerlink\" title=\"2.使用栈的例子\"></a>2.使用栈的例子</h4><p><strong>数制间的相互转换</strong></p>\n<p>输入的数字是n，转换为以b为基数的数字</p>\n<ul>\n<li>最低位是<code>n%b</code>，将此位压入栈</li>\n<li>使用<code>Math.floor(n/b)</code>代替之前的n再次输入</li>\n<li>重复前2个步骤，直到<code>Math.floor(n/b)</code>为0，则不再循环</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mulBase(<span class=\"built_in\">num</span>, base) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//将每一次求得得余数入栈</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\tstack.push(<span class=\"built_in\">num</span> % base);</span><br><span class=\"line\">\t\t<span class=\"built_in\">num</span> = Math.floor(<span class=\"built_in\">num</span> / base);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">num</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result = <span class=\"string\">''</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//依次出栈</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tresult += stack.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//返回输出的结果</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>回文</strong></p>\n<p>字符串反转之后是否与原字符串相等，如果相等，则为回文</p>\n<p>使用栈的思想，首先将字符串依次入栈，再依次出栈，判断两个字符串是否相等</p>\n<font color='red'>注意：js中字符串没有反转操作的函数，而数组有arr.reverse()</font>\n\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isHuiWen</span><span class=\"params\">(str)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> arr = str.split();</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> reverseStr = <span class=\"string\">''</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(arr.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\treverseStr += arr.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(reverseStr == str) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-队列\"><a href=\"#四-队列\" class=\"headerlink\" title=\"四. 队列\"></a>四. 队列</h3><p>先入先出</p>\n<p>function Queue() {<br>    this.dataStore = []; //存放队列中元素的数组<br>    this.enqueue = enqueue; //入队列，队尾增加元素<br>    this.dequeue = dequeue; //出队列，队头删除元素<br>    this.front = front;<br>    this.back = back;<br>    this.toString = toString;<br>    this.empty = empty;<br>}</p>\n"},{"layout":"post","title":"js中的正则表达式","date":"2016-09-08T16:00:00.000Z","description":null,"_content":"\n### 一. RegExp类型\n\n正则表达式 = /pattern/flags\n\n**pattern是模式匹配**\n\n模式匹配中的元字符：带有特定的作用\n\n`( [ { \\ ^ $ | ) ? * + .] }`\n\n```\n^ 以...开头\n$ 以...结尾\n\n? 出现0次或者1次（最多出现1次）\n* 出现任意次\n{n} 出现n次\n{n,m} 出现n到m次\n{n,} 至少出现n次\n\n.      等价于   [^\\n\\r]          处了回车和换行之外的所有字符\n\\d     等价于   [0-9]            数字字符\n\\D     等价于   [^0-9]           非数字字符\n\\s     等价于   [\\t\\n\\x0B\\f\\r]   空白符\n\\S     等价于   [^ \\t\\n\\x0B\\f\\r] 非空白符\n\\w     等价于   [a-zA-Z_0-9]     单词字符（字母、数字、下划线）\n\\W     等价于   [^a-zA-Z_0-9]    非单词字符\n\\b     单词边界\n\\B     非单词边界\n```\n分组()\n\n或 |\n\n\n**flags表明三种匹配的标志：**\n\n- g 全局匹配\n- i 不区分大小写的匹配\n- m 多行模式\n\n#### 1. 创建RegExp类型\n\n**字面量定义的方法**\n\n`var pattern1 = /[ba]t/g ;`\n\n**使用RegExp构造函数**\n\n`var pattern2 = new RegExp('[ba]t','g');`\n\n参数是字符串\n\n#### 2. RegExp对象的方法\n\nvar reg = /.../;\n\n**test()方法**\n\nreg.test(字符串) 返回值为true或者false\n\n**exec()方法**\n\n获取捕获组的方法，返回的是一个数组\n\nmatch()和replace()是字符串的方法","source":"_posts/2016-09-09-js中的正则表达式.md","raw":"---\nlayout: post\ntitle: js中的正则表达式\ndate: 2016-09-09\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. RegExp类型\n\n正则表达式 = /pattern/flags\n\n**pattern是模式匹配**\n\n模式匹配中的元字符：带有特定的作用\n\n`( [ { \\ ^ $ | ) ? * + .] }`\n\n```\n^ 以...开头\n$ 以...结尾\n\n? 出现0次或者1次（最多出现1次）\n* 出现任意次\n{n} 出现n次\n{n,m} 出现n到m次\n{n,} 至少出现n次\n\n.      等价于   [^\\n\\r]          处了回车和换行之外的所有字符\n\\d     等价于   [0-9]            数字字符\n\\D     等价于   [^0-9]           非数字字符\n\\s     等价于   [\\t\\n\\x0B\\f\\r]   空白符\n\\S     等价于   [^ \\t\\n\\x0B\\f\\r] 非空白符\n\\w     等价于   [a-zA-Z_0-9]     单词字符（字母、数字、下划线）\n\\W     等价于   [^a-zA-Z_0-9]    非单词字符\n\\b     单词边界\n\\B     非单词边界\n```\n分组()\n\n或 |\n\n\n**flags表明三种匹配的标志：**\n\n- g 全局匹配\n- i 不区分大小写的匹配\n- m 多行模式\n\n#### 1. 创建RegExp类型\n\n**字面量定义的方法**\n\n`var pattern1 = /[ba]t/g ;`\n\n**使用RegExp构造函数**\n\n`var pattern2 = new RegExp('[ba]t','g');`\n\n参数是字符串\n\n#### 2. RegExp对象的方法\n\nvar reg = /.../;\n\n**test()方法**\n\nreg.test(字符串) 返回值为true或者false\n\n**exec()方法**\n\n获取捕获组的方法，返回的是一个数组\n\nmatch()和replace()是字符串的方法","slug":"2016-09-09-js中的正则表达式","published":1,"updated":"2016-09-09T09:24:56.000Z","comments":1,"photos":[],"link":"","_id":"cj035ock600ckd5u8on5hjffa","content":"<h3 id=\"一-RegExp类型\"><a href=\"#一-RegExp类型\" class=\"headerlink\" title=\"一. RegExp类型\"></a>一. RegExp类型</h3><p>正则表达式 = /pattern/flags</p>\n<p><strong>pattern是模式匹配</strong></p>\n<p>模式匹配中的元字符：带有特定的作用</p>\n<p><code>( [ { \\ ^ $ | ) ? * + .] }</code></p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^ 以...开头</span><br><span class=\"line\">$ 以...结尾</span><br><span class=\"line\"></span><br><span class=\"line\">? 出现0次或者1次（最多出现1次）</span><br><span class=\"line\">* 出现任意次</span><br><span class=\"line\">&#123;n&#125; 出现n次</span><br><span class=\"line\">&#123;n,m&#125; 出现n到m次</span><br><span class=\"line\">&#123;n,&#125; 至少出现n次</span><br><span class=\"line\"></span><br><span class=\"line\">.      等价于   [^<span class=\"symbol\">\\n</span><span class=\"symbol\">\\r</span>]          处了回车和换行之外的所有字符</span><br><span class=\"line\"><span class=\"symbol\">\\d</span>     等价于   [0-9]            数字字符</span><br><span class=\"line\"><span class=\"symbol\">\\D</span>     等价于   [^0-9]           非数字字符</span><br><span class=\"line\"><span class=\"symbol\">\\s</span>     等价于   [<span class=\"symbol\">\\t</span><span class=\"symbol\">\\n</span><span class=\"symbol\">\\x</span>0B<span class=\"symbol\">\\f</span><span class=\"symbol\">\\r</span>]   空白符</span><br><span class=\"line\"><span class=\"symbol\">\\S</span>     等价于   [^ <span class=\"symbol\">\\t</span><span class=\"symbol\">\\n</span><span class=\"symbol\">\\x</span>0B<span class=\"symbol\">\\f</span><span class=\"symbol\">\\r</span>] 非空白符</span><br><span class=\"line\"><span class=\"symbol\">\\w</span>     等价于   [a-zA-Z_0-9]     单词字符（字母、数字、下划线）</span><br><span class=\"line\"><span class=\"symbol\">\\W</span>     等价于   [^a-zA-Z_0-9]    非单词字符</span><br><span class=\"line\"><span class=\"symbol\">\\b</span>     单词边界</span><br><span class=\"line\"><span class=\"symbol\">\\B</span>     非单词边界</span><br></pre></td></tr></table></figure>\n<p>分组()</p>\n<p>或 |</p>\n<p><strong>flags表明三种匹配的标志：</strong></p>\n<ul>\n<li>g 全局匹配</li>\n<li>i 不区分大小写的匹配</li>\n<li>m 多行模式</li>\n</ul>\n<h4 id=\"1-创建RegExp类型\"><a href=\"#1-创建RegExp类型\" class=\"headerlink\" title=\"1. 创建RegExp类型\"></a>1. 创建RegExp类型</h4><p><strong>字面量定义的方法</strong></p>\n<p><code>var pattern1 = /[ba]t/g ;</code></p>\n<p><strong>使用RegExp构造函数</strong></p>\n<p><code>var pattern2 = new RegExp(&#39;[ba]t&#39;,&#39;g&#39;);</code></p>\n<p>参数是字符串</p>\n<h4 id=\"2-RegExp对象的方法\"><a href=\"#2-RegExp对象的方法\" class=\"headerlink\" title=\"2. RegExp对象的方法\"></a>2. RegExp对象的方法</h4><p>var reg = /…/;</p>\n<p><strong>test()方法</strong></p>\n<p>reg.test(字符串) 返回值为true或者false</p>\n<p><strong>exec()方法</strong></p>\n<p>获取捕获组的方法，返回的是一个数组</p>\n<p>match()和replace()是字符串的方法</p>\n","excerpt":"","more":"<h3 id=\"一-RegExp类型\"><a href=\"#一-RegExp类型\" class=\"headerlink\" title=\"一. RegExp类型\"></a>一. RegExp类型</h3><p>正则表达式 = /pattern/flags</p>\n<p><strong>pattern是模式匹配</strong></p>\n<p>模式匹配中的元字符：带有特定的作用</p>\n<p><code>( [ { \\ ^ $ | ) ? * + .] }</code></p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^ 以...开头</span><br><span class=\"line\">$ 以...结尾</span><br><span class=\"line\"></span><br><span class=\"line\">? 出现0次或者1次（最多出现1次）</span><br><span class=\"line\">* 出现任意次</span><br><span class=\"line\">&#123;n&#125; 出现n次</span><br><span class=\"line\">&#123;n,m&#125; 出现n到m次</span><br><span class=\"line\">&#123;n,&#125; 至少出现n次</span><br><span class=\"line\"></span><br><span class=\"line\">.      等价于   [^<span class=\"symbol\">\\n</span><span class=\"symbol\">\\r</span>]          处了回车和换行之外的所有字符</span><br><span class=\"line\"><span class=\"symbol\">\\d</span>     等价于   [0-9]            数字字符</span><br><span class=\"line\"><span class=\"symbol\">\\D</span>     等价于   [^0-9]           非数字字符</span><br><span class=\"line\"><span class=\"symbol\">\\s</span>     等价于   [<span class=\"symbol\">\\t</span><span class=\"symbol\">\\n</span><span class=\"symbol\">\\x</span>0B<span class=\"symbol\">\\f</span><span class=\"symbol\">\\r</span>]   空白符</span><br><span class=\"line\"><span class=\"symbol\">\\S</span>     等价于   [^ <span class=\"symbol\">\\t</span><span class=\"symbol\">\\n</span><span class=\"symbol\">\\x</span>0B<span class=\"symbol\">\\f</span><span class=\"symbol\">\\r</span>] 非空白符</span><br><span class=\"line\"><span class=\"symbol\">\\w</span>     等价于   [a-zA-Z_0-9]     单词字符（字母、数字、下划线）</span><br><span class=\"line\"><span class=\"symbol\">\\W</span>     等价于   [^a-zA-Z_0-9]    非单词字符</span><br><span class=\"line\"><span class=\"symbol\">\\b</span>     单词边界</span><br><span class=\"line\"><span class=\"symbol\">\\B</span>     非单词边界</span><br></pre></td></tr></table></figure>\n<p>分组()</p>\n<p>或 |</p>\n<p><strong>flags表明三种匹配的标志：</strong></p>\n<ul>\n<li>g 全局匹配</li>\n<li>i 不区分大小写的匹配</li>\n<li>m 多行模式</li>\n</ul>\n<h4 id=\"1-创建RegExp类型\"><a href=\"#1-创建RegExp类型\" class=\"headerlink\" title=\"1. 创建RegExp类型\"></a>1. 创建RegExp类型</h4><p><strong>字面量定义的方法</strong></p>\n<p><code>var pattern1 = /[ba]t/g ;</code></p>\n<p><strong>使用RegExp构造函数</strong></p>\n<p><code>var pattern2 = new RegExp(&#39;[ba]t&#39;,&#39;g&#39;);</code></p>\n<p>参数是字符串</p>\n<h4 id=\"2-RegExp对象的方法\"><a href=\"#2-RegExp对象的方法\" class=\"headerlink\" title=\"2. RegExp对象的方法\"></a>2. RegExp对象的方法</h4><p>var reg = /…/;</p>\n<p><strong>test()方法</strong></p>\n<p>reg.test(字符串) 返回值为true或者false</p>\n<p><strong>exec()方法</strong></p>\n<p>获取捕获组的方法，返回的是一个数组</p>\n<p>match()和replace()是字符串的方法</p>\n"},{"layout":"post","title":"react中的虚拟dom","date":"2016-09-11T16:00:00.000Z","description":null,"_content":"\n### 一. 虚拟dom的思想\n\nreact最大的特点之一，就是其运用了虚拟dom的技术。\n\n首先看一个例子：[http://panpanfish.com/myDemo/research/sortTable.html](http://panpanfish.com/myDemo/research/sortTable.html)\n\n这是我之前做过的一个排序表格的demo，就是点击表格的头部，然后对整个表格进行排序，当时的实现思想是：用一个二维数组将表格的数据存放起来，然后根据某一列对二维数组排序，最后由排序后的二维数组再重新渲染整个表格。\n\n这种做法虽然避免了复杂的dom操作，但是每次整个页面都要重新渲染一遍，这样性能肯定是很差的。\n\n但是这个就是虚拟dom的思想，只不过每次都不是重新更新实际的dom，而是每次都在内存中重新构建一次dom树，然后将当前的dom树，和上一次的dom树进行对比，将不同的部分进行实际的浏览器dom更新。\n \n### 二. 虚拟dom实现\n\n#### 1. 用js构建虚拟dom树\n\n构建dom对象\n\n```\n\n\tfunction Element(tagName, props, children) {\n\t\tthis.tagName = tagName;\n\t\tthis.props = prrops;\n\t\tthis.children = children;\n\t}\n\n\tElement.prototype = {\n\t\trender: function() {\n\t\t\tvar el = document.createElement(this.tagName);\n\t\t\tvar props = this.props;\n\n\t\t\tfor(var propName in props) {\n\t\t\t\tvar propValue = props[propName];\n\t\t\t\tel.setAttribute(propName,propValue);\n\t\t\t}\n\n\t\t\tvar children = this.children || [];\n\n\t\t\tchildren.foreach(function(child) {\n\n\t\t\t\t//如果子节点也是Element，那么递归调用render构建dom\n\t\t\t\tvar childEl = child instanceof Element ? child.render : document.createTextNode(child);\n\t\t\t\tel.appendChild(childEl);\n\t\t\t});\n\t\t}\n\n\t\treturn el;\n\t}\n\n\tvar ul = new Element('ul', {id: 'list'}, [\n\t\tElement('li', {class: 'item'}, ['item1']),\n\t\tElement('li', {class: 'item'}, ['item2']),\n\t\tElement('li', {class: 'item'}, ['item3'])\n\t]);\n\n\t//利用Element.render()方法构建一个dom树\n\tvar ulElement = ul.render();\n\n\t//将构建的dom树插入到真实的文档中\n\tdocument.body.appendChild(ulElement);\n```\n\n#### 2. 虚拟dom的diff算法\n\n比较新的dom和之前的dom树，将不同的地方保存下来\n\n\n#### 3. 在真正的元素上应用变更\n\n\n参考：《深度剖析：如何实现一个 Virtual DOM 算法》[https://github.com/livoras/blog/issues/13](https://github.com/livoras/blog/issues/13)","source":"_posts/2016-09-12-react中的虚拟dom.md","raw":"---\nlayout: post\ntitle: react中的虚拟dom\ndate: 2016-09-12\ncategories: 前端框架\ntags: [框架]\ndescription: \n---\n\n### 一. 虚拟dom的思想\n\nreact最大的特点之一，就是其运用了虚拟dom的技术。\n\n首先看一个例子：[http://panpanfish.com/myDemo/research/sortTable.html](http://panpanfish.com/myDemo/research/sortTable.html)\n\n这是我之前做过的一个排序表格的demo，就是点击表格的头部，然后对整个表格进行排序，当时的实现思想是：用一个二维数组将表格的数据存放起来，然后根据某一列对二维数组排序，最后由排序后的二维数组再重新渲染整个表格。\n\n这种做法虽然避免了复杂的dom操作，但是每次整个页面都要重新渲染一遍，这样性能肯定是很差的。\n\n但是这个就是虚拟dom的思想，只不过每次都不是重新更新实际的dom，而是每次都在内存中重新构建一次dom树，然后将当前的dom树，和上一次的dom树进行对比，将不同的部分进行实际的浏览器dom更新。\n \n### 二. 虚拟dom实现\n\n#### 1. 用js构建虚拟dom树\n\n构建dom对象\n\n```\n\n\tfunction Element(tagName, props, children) {\n\t\tthis.tagName = tagName;\n\t\tthis.props = prrops;\n\t\tthis.children = children;\n\t}\n\n\tElement.prototype = {\n\t\trender: function() {\n\t\t\tvar el = document.createElement(this.tagName);\n\t\t\tvar props = this.props;\n\n\t\t\tfor(var propName in props) {\n\t\t\t\tvar propValue = props[propName];\n\t\t\t\tel.setAttribute(propName,propValue);\n\t\t\t}\n\n\t\t\tvar children = this.children || [];\n\n\t\t\tchildren.foreach(function(child) {\n\n\t\t\t\t//如果子节点也是Element，那么递归调用render构建dom\n\t\t\t\tvar childEl = child instanceof Element ? child.render : document.createTextNode(child);\n\t\t\t\tel.appendChild(childEl);\n\t\t\t});\n\t\t}\n\n\t\treturn el;\n\t}\n\n\tvar ul = new Element('ul', {id: 'list'}, [\n\t\tElement('li', {class: 'item'}, ['item1']),\n\t\tElement('li', {class: 'item'}, ['item2']),\n\t\tElement('li', {class: 'item'}, ['item3'])\n\t]);\n\n\t//利用Element.render()方法构建一个dom树\n\tvar ulElement = ul.render();\n\n\t//将构建的dom树插入到真实的文档中\n\tdocument.body.appendChild(ulElement);\n```\n\n#### 2. 虚拟dom的diff算法\n\n比较新的dom和之前的dom树，将不同的地方保存下来\n\n\n#### 3. 在真正的元素上应用变更\n\n\n参考：《深度剖析：如何实现一个 Virtual DOM 算法》[https://github.com/livoras/blog/issues/13](https://github.com/livoras/blog/issues/13)","slug":"2016-09-12-react中的虚拟dom","published":1,"updated":"2016-10-14T12:13:18.000Z","comments":1,"photos":[],"link":"","_id":"cj035ock800cnd5u8f2fnobc4","content":"<h3 id=\"一-虚拟dom的思想\"><a href=\"#一-虚拟dom的思想\" class=\"headerlink\" title=\"一. 虚拟dom的思想\"></a>一. 虚拟dom的思想</h3><p>react最大的特点之一，就是其运用了虚拟dom的技术。</p>\n<p>首先看一个例子：<a href=\"http://panpanfish.com/myDemo/research/sortTable.html\">http://panpanfish.com/myDemo/research/sortTable.html</a></p>\n<p>这是我之前做过的一个排序表格的demo，就是点击表格的头部，然后对整个表格进行排序，当时的实现思想是：用一个二维数组将表格的数据存放起来，然后根据某一列对二维数组排序，最后由排序后的二维数组再重新渲染整个表格。</p>\n<p>这种做法虽然避免了复杂的dom操作，但是每次整个页面都要重新渲染一遍，这样性能肯定是很差的。</p>\n<p>但是这个就是虚拟dom的思想，只不过每次都不是重新更新实际的dom，而是每次都在内存中重新构建一次dom树，然后将当前的dom树，和上一次的dom树进行对比，将不同的部分进行实际的浏览器dom更新。</p>\n<h3 id=\"二-虚拟dom实现\"><a href=\"#二-虚拟dom实现\" class=\"headerlink\" title=\"二. 虚拟dom实现\"></a>二. 虚拟dom实现</h3><h4 id=\"1-用js构建虚拟dom树\"><a href=\"#1-用js构建虚拟dom树\" class=\"headerlink\" title=\"1. 用js构建虚拟dom树\"></a>1. 用js构建虚拟dom树</h4><p>构建dom对象</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function Element(tagName, props, children) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.tagName = tagName;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.props = prrops;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.children = children;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Element.prototype = &#123;</span><br><span class=\"line\">\trender: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> el = document.createElement(<span class=\"keyword\">this</span>.tagName);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> props = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> propName <span class=\"keyword\">in</span> props) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> propValue = props[propName];</span><br><span class=\"line\">\t\t\tel.setAttribute(propName,propValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> children = <span class=\"keyword\">this</span>.children || [];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tchildren.foreach(function(child) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果子节点也是Element，那么递归调用render构建dom</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> childEl = child instanceof Element ? child.render : document.createTextNode(child);</span><br><span class=\"line\">\t\t\tel.appendChild(childEl);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ul = new Element(<span class=\"string\">'ul'</span>, &#123;id: <span class=\"string\">'list'</span>&#125;, [</span><br><span class=\"line\">\tElement(<span class=\"string\">'li'</span>, &#123;<span class=\"class\"><span class=\"keyword\">class</span>: <span class=\"type\">'item'&#125;</span>, <span class=\"type\">['item1'])</span>,</span><br><span class=\"line\">\t<span class=\"type\">Element</span></span>(<span class=\"string\">'li'</span>, &#123;<span class=\"class\"><span class=\"keyword\">class</span>: <span class=\"type\">'item'&#125;</span>, <span class=\"type\">['item2'])</span>,</span><br><span class=\"line\">\t<span class=\"type\">Element</span></span>(<span class=\"string\">'li'</span>, &#123;<span class=\"class\"><span class=\"keyword\">class</span>: <span class=\"type\">'item'&#125;</span>, <span class=\"type\">['item3'])</span></span></span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//利用Element.render()方法构建一个dom树</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ulElement = ul.render();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将构建的dom树插入到真实的文档中</span></span><br><span class=\"line\">document.body.appendChild(ulElement);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-虚拟dom的diff算法\"><a href=\"#2-虚拟dom的diff算法\" class=\"headerlink\" title=\"2. 虚拟dom的diff算法\"></a>2. 虚拟dom的diff算法</h4><p>比较新的dom和之前的dom树，将不同的地方保存下来</p>\n<h4 id=\"3-在真正的元素上应用变更\"><a href=\"#3-在真正的元素上应用变更\" class=\"headerlink\" title=\"3. 在真正的元素上应用变更\"></a>3. 在真正的元素上应用变更</h4><p>参考：《深度剖析：如何实现一个 Virtual DOM 算法》<a href=\"https://github.com/livoras/blog/issues/13\" target=\"_blank\" rel=\"external\">https://github.com/livoras/blog/issues/13</a></p>\n","excerpt":"","more":"<h3 id=\"一-虚拟dom的思想\"><a href=\"#一-虚拟dom的思想\" class=\"headerlink\" title=\"一. 虚拟dom的思想\"></a>一. 虚拟dom的思想</h3><p>react最大的特点之一，就是其运用了虚拟dom的技术。</p>\n<p>首先看一个例子：<a href=\"http://panpanfish.com/myDemo/research/sortTable.html\">http://panpanfish.com/myDemo/research/sortTable.html</a></p>\n<p>这是我之前做过的一个排序表格的demo，就是点击表格的头部，然后对整个表格进行排序，当时的实现思想是：用一个二维数组将表格的数据存放起来，然后根据某一列对二维数组排序，最后由排序后的二维数组再重新渲染整个表格。</p>\n<p>这种做法虽然避免了复杂的dom操作，但是每次整个页面都要重新渲染一遍，这样性能肯定是很差的。</p>\n<p>但是这个就是虚拟dom的思想，只不过每次都不是重新更新实际的dom，而是每次都在内存中重新构建一次dom树，然后将当前的dom树，和上一次的dom树进行对比，将不同的部分进行实际的浏览器dom更新。</p>\n<h3 id=\"二-虚拟dom实现\"><a href=\"#二-虚拟dom实现\" class=\"headerlink\" title=\"二. 虚拟dom实现\"></a>二. 虚拟dom实现</h3><h4 id=\"1-用js构建虚拟dom树\"><a href=\"#1-用js构建虚拟dom树\" class=\"headerlink\" title=\"1. 用js构建虚拟dom树\"></a>1. 用js构建虚拟dom树</h4><p>构建dom对象</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function Element(tagName, props, children) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.tagName = tagName;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.props = prrops;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.children = children;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Element.prototype = &#123;</span><br><span class=\"line\">\trender: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> el = document.createElement(<span class=\"keyword\">this</span>.tagName);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> props = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> propName <span class=\"keyword\">in</span> props) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> propValue = props[propName];</span><br><span class=\"line\">\t\t\tel.setAttribute(propName,propValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> children = <span class=\"keyword\">this</span>.children || [];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tchildren.foreach(function(child) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果子节点也是Element，那么递归调用render构建dom</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> childEl = child instanceof Element ? child.render : document.createTextNode(child);</span><br><span class=\"line\">\t\t\tel.appendChild(childEl);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ul = new Element(<span class=\"string\">'ul'</span>, &#123;id: <span class=\"string\">'list'</span>&#125;, [</span><br><span class=\"line\">\tElement(<span class=\"string\">'li'</span>, &#123;<span class=\"class\"><span class=\"keyword\">class</span>: <span class=\"type\">'item'&#125;</span>, <span class=\"type\">['item1'])</span>,</span><br><span class=\"line\">\t<span class=\"type\">Element</span></span>(<span class=\"string\">'li'</span>, &#123;<span class=\"class\"><span class=\"keyword\">class</span>: <span class=\"type\">'item'&#125;</span>, <span class=\"type\">['item2'])</span>,</span><br><span class=\"line\">\t<span class=\"type\">Element</span></span>(<span class=\"string\">'li'</span>, &#123;<span class=\"class\"><span class=\"keyword\">class</span>: <span class=\"type\">'item'&#125;</span>, <span class=\"type\">['item3'])</span></span></span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//利用Element.render()方法构建一个dom树</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ulElement = ul.render();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将构建的dom树插入到真实的文档中</span></span><br><span class=\"line\">document.body.appendChild(ulElement);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-虚拟dom的diff算法\"><a href=\"#2-虚拟dom的diff算法\" class=\"headerlink\" title=\"2. 虚拟dom的diff算法\"></a>2. 虚拟dom的diff算法</h4><p>比较新的dom和之前的dom树，将不同的地方保存下来</p>\n<h4 id=\"3-在真正的元素上应用变更\"><a href=\"#3-在真正的元素上应用变更\" class=\"headerlink\" title=\"3. 在真正的元素上应用变更\"></a>3. 在真正的元素上应用变更</h4><p>参考：《深度剖析：如何实现一个 Virtual DOM 算法》<a href=\"https://github.com/livoras/blog/issues/13\">https://github.com/livoras/blog/issues/13</a></p>\n"},{"layout":"post","title":"二分查找","date":"2016-09-17T16:00:00.000Z","description":null,"_content":"\n### 一. 二分查找的思想\n\n对于一个有序数组，每次取最中间的一个数，与要目标数进行比较\n\n### 二. 二分查找的实现\n\n```\nfunction binSearch(arr,data) {\n\tvar upperBound = arr.length - 1;\n\tvar lowerBound = 0;\n\twhile(lowerBound <= upperBound) {\n\t\tvar mid = Math.floor((upperBound + lowerBound)/2);\n\t\tif(arr[mid] < data) {\n\t\t\tlowerBound = mid + 1;\n\t\t} else if(arr[mid] > data) {\n\t\t\tupperBound = mid - 1;\t\t\t\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvar arr = [1,4,6,7,10,15,18];\nbinSearch(arr,10); //4\n```","source":"_posts/2016-09-18-二分查找.md","raw":"---\nlayout: post\ntitle: 二分查找\ndate: 2016-09-18\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一. 二分查找的思想\n\n对于一个有序数组，每次取最中间的一个数，与要目标数进行比较\n\n### 二. 二分查找的实现\n\n```\nfunction binSearch(arr,data) {\n\tvar upperBound = arr.length - 1;\n\tvar lowerBound = 0;\n\twhile(lowerBound <= upperBound) {\n\t\tvar mid = Math.floor((upperBound + lowerBound)/2);\n\t\tif(arr[mid] < data) {\n\t\t\tlowerBound = mid + 1;\n\t\t} else if(arr[mid] > data) {\n\t\t\tupperBound = mid - 1;\t\t\t\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvar arr = [1,4,6,7,10,15,18];\nbinSearch(arr,10); //4\n```","slug":"2016-09-18-二分查找","published":1,"updated":"2016-09-18T13:41:34.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocka00crd5u8u15k2s12","content":"<h3 id=\"一-二分查找的思想\"><a href=\"#一-二分查找的思想\" class=\"headerlink\" title=\"一. 二分查找的思想\"></a>一. 二分查找的思想</h3><p>对于一个有序数组，每次取最中间的一个数，与要目标数进行比较</p>\n<h3 id=\"二-二分查找的实现\"><a href=\"#二-二分查找的实现\" class=\"headerlink\" title=\"二. 二分查找的实现\"></a>二. 二分查找的实现</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function binSearch(arr,<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> upperBound = arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> lowerBound = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(lowerBound &lt;= upperBound) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> mid = Math.floor((upperBound + lowerBound)/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[mid] &lt; <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\tlowerBound = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[mid] &gt; <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\tupperBound = mid - <span class=\"number\">1</span>;\t\t\t</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">15</span>,<span class=\"number\">18</span>];</span><br><span class=\"line\">binSearch(arr,<span class=\"number\">10</span>); <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-二分查找的思想\"><a href=\"#一-二分查找的思想\" class=\"headerlink\" title=\"一. 二分查找的思想\"></a>一. 二分查找的思想</h3><p>对于一个有序数组，每次取最中间的一个数，与要目标数进行比较</p>\n<h3 id=\"二-二分查找的实现\"><a href=\"#二-二分查找的实现\" class=\"headerlink\" title=\"二. 二分查找的实现\"></a>二. 二分查找的实现</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function binSearch(arr,<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> upperBound = arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> lowerBound = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(lowerBound &lt;= upperBound) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> mid = Math.floor((upperBound + lowerBound)/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[mid] &lt; <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\tlowerBound = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[mid] &gt; <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\tupperBound = mid - <span class=\"number\">1</span>;\t\t\t</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">15</span>,<span class=\"number\">18</span>];</span><br><span class=\"line\">binSearch(arr,<span class=\"number\">10</span>); <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"web worker","date":"2016-09-11T16:00:00.000Z","description":null,"_content":"\n### 一. 浏览器的js引擎是单线程地处理任务队列\n\n浏览器多线程\njs是单线程\n\najax请求是异步的，是由**浏览器新开一个线程**请求，事件回调的时候放入事件队列等候处理。\n\n### 二. 如何实现js的多线程\n\nweb worker是html5中提出的一个javascript多线程解决方案。\n\n**在主线程中：**\n\n```\n//创建一个Worker对象，并将新线程代码的url作为参数传入\nvar worker = new Worker('worker.js');\n\n//向worker发送数据\nworker.postMessage({type: 'command', message: 'start!'});\n\n//监听worker向主线程发送数据，数据保存在onmessage事件的event.data中\nworker.onmessage = function(event) {\n\tconsole.log(event.data); //输出worker发送来的数据\n}\n```\n\n**在新开的线程中(worker.js文件中)：**\n\n```\n//获取从主线程中传来的数据\nthis.onmessage = function(event) {\n\tvar data = event.data;\n\n\t//对数据进行处理\n\t...\n\n\t//将处理之后的数据发回给主线程\n\tthis.postMessage(data);\n}\n```\n\n**主线程中的API：**\n\n```\nvar worker = new Worker('...')\nworker.postMessage()\nworker.onmessage\nworker.onerror\nworker.terminate()\n```\n\n**新开的线程中的API：**\n\n在新开的线程中，self和this都是指的worker对象，不能访问页面中的DOM\n\n```\nthis.postMessage()\nthis.onmessage\nthis.close()\n```\n\n注意：在本地文件中不能运行web worker\n\nXMLHttpRequest的异步执行模式，相当于是一个拥有专用API的web worker。","source":"_posts/2016-09-12-web worker.md","raw":"---\nlayout: post\ntitle: web worker\ndate: 2016-09-12\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 浏览器的js引擎是单线程地处理任务队列\n\n浏览器多线程\njs是单线程\n\najax请求是异步的，是由**浏览器新开一个线程**请求，事件回调的时候放入事件队列等候处理。\n\n### 二. 如何实现js的多线程\n\nweb worker是html5中提出的一个javascript多线程解决方案。\n\n**在主线程中：**\n\n```\n//创建一个Worker对象，并将新线程代码的url作为参数传入\nvar worker = new Worker('worker.js');\n\n//向worker发送数据\nworker.postMessage({type: 'command', message: 'start!'});\n\n//监听worker向主线程发送数据，数据保存在onmessage事件的event.data中\nworker.onmessage = function(event) {\n\tconsole.log(event.data); //输出worker发送来的数据\n}\n```\n\n**在新开的线程中(worker.js文件中)：**\n\n```\n//获取从主线程中传来的数据\nthis.onmessage = function(event) {\n\tvar data = event.data;\n\n\t//对数据进行处理\n\t...\n\n\t//将处理之后的数据发回给主线程\n\tthis.postMessage(data);\n}\n```\n\n**主线程中的API：**\n\n```\nvar worker = new Worker('...')\nworker.postMessage()\nworker.onmessage\nworker.onerror\nworker.terminate()\n```\n\n**新开的线程中的API：**\n\n在新开的线程中，self和this都是指的worker对象，不能访问页面中的DOM\n\n```\nthis.postMessage()\nthis.onmessage\nthis.close()\n```\n\n注意：在本地文件中不能运行web worker\n\nXMLHttpRequest的异步执行模式，相当于是一个拥有专用API的web worker。","slug":"2016-09-12-web worker","published":1,"updated":"2016-09-12T06:18:40.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockc00cud5u8xyjujo27","content":"<h3 id=\"一-浏览器的js引擎是单线程地处理任务队列\"><a href=\"#一-浏览器的js引擎是单线程地处理任务队列\" class=\"headerlink\" title=\"一. 浏览器的js引擎是单线程地处理任务队列\"></a>一. 浏览器的js引擎是单线程地处理任务队列</h3><p>浏览器多线程<br>js是单线程</p>\n<p>ajax请求是异步的，是由<strong>浏览器新开一个线程</strong>请求，事件回调的时候放入事件队列等候处理。</p>\n<h3 id=\"二-如何实现js的多线程\"><a href=\"#二-如何实现js的多线程\" class=\"headerlink\" title=\"二. 如何实现js的多线程\"></a>二. 如何实现js的多线程</h3><p>web worker是html5中提出的一个javascript多线程解决方案。</p>\n<p><strong>在主线程中：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个Worker对象，并将新线程代码的url作为参数传入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向worker发送数据</span></span><br><span class=\"line\">worker.postMessage(&#123;type: <span class=\"string\">'command'</span>, message: <span class=\"string\">'start!'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听worker向主线程发送数据，数据保存在onmessage事件的event.data中</span></span><br><span class=\"line\">worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(event.data); <span class=\"comment\">//输出worker发送来的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在新开的线程中(worker.js文件中)：</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取从主线程中传来的数据</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.onmessage = function(event) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = event.<span class=\"keyword\">data</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对数据进行处理</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将处理之后的数据发回给主线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.postMessage(<span class=\"keyword\">data</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>主线程中的API：</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> worker = new Worker(<span class=\"string\">'...'</span>)</span><br><span class=\"line\">worker.postMessage()</span><br><span class=\"line\">worker<span class=\"selector-class\">.onmessage</span></span><br><span class=\"line\">worker<span class=\"selector-class\">.onerror</span></span><br><span class=\"line\">worker.terminate()</span><br></pre></td></tr></table></figure>\n<p><strong>新开的线程中的API：</strong></p>\n<p>在新开的线程中，self和this都是指的worker对象，不能访问页面中的DOM</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.postMessage()</span><br><span class=\"line\"><span class=\"keyword\">this</span>.onmessage</span><br><span class=\"line\"><span class=\"keyword\">this</span>.close()</span><br></pre></td></tr></table></figure>\n<p>注意：在本地文件中不能运行web worker</p>\n<p>XMLHttpRequest的异步执行模式，相当于是一个拥有专用API的web worker。</p>\n","excerpt":"","more":"<h3 id=\"一-浏览器的js引擎是单线程地处理任务队列\"><a href=\"#一-浏览器的js引擎是单线程地处理任务队列\" class=\"headerlink\" title=\"一. 浏览器的js引擎是单线程地处理任务队列\"></a>一. 浏览器的js引擎是单线程地处理任务队列</h3><p>浏览器多线程<br>js是单线程</p>\n<p>ajax请求是异步的，是由<strong>浏览器新开一个线程</strong>请求，事件回调的时候放入事件队列等候处理。</p>\n<h3 id=\"二-如何实现js的多线程\"><a href=\"#二-如何实现js的多线程\" class=\"headerlink\" title=\"二. 如何实现js的多线程\"></a>二. 如何实现js的多线程</h3><p>web worker是html5中提出的一个javascript多线程解决方案。</p>\n<p><strong>在主线程中：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个Worker对象，并将新线程代码的url作为参数传入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向worker发送数据</span></span><br><span class=\"line\">worker.postMessage(&#123;type: <span class=\"string\">'command'</span>, message: <span class=\"string\">'start!'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听worker向主线程发送数据，数据保存在onmessage事件的event.data中</span></span><br><span class=\"line\">worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(event.data); <span class=\"comment\">//输出worker发送来的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在新开的线程中(worker.js文件中)：</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取从主线程中传来的数据</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.onmessage = function(event) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"keyword\">data</span> = event.<span class=\"keyword\">data</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对数据进行处理</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将处理之后的数据发回给主线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.postMessage(<span class=\"keyword\">data</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>主线程中的API：</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> worker = new Worker(<span class=\"string\">'...'</span>)</span><br><span class=\"line\">worker.postMessage()</span><br><span class=\"line\">worker<span class=\"selector-class\">.onmessage</span></span><br><span class=\"line\">worker<span class=\"selector-class\">.onerror</span></span><br><span class=\"line\">worker.terminate()</span><br></pre></td></tr></table></figure>\n<p><strong>新开的线程中的API：</strong></p>\n<p>在新开的线程中，self和this都是指的worker对象，不能访问页面中的DOM</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.postMessage()</span><br><span class=\"line\"><span class=\"keyword\">this</span>.onmessage</span><br><span class=\"line\"><span class=\"keyword\">this</span>.close()</span><br></pre></td></tr></table></figure>\n<p>注意：在本地文件中不能运行web worker</p>\n<p>XMLHttpRequest的异步执行模式，相当于是一个拥有专用API的web worker。</p>\n"},{"layout":"post","title":"字典","date":"2016-09-19T16:00:00.000Z","description":null,"_content":"\n### 一. 字典\n\n#### 1. 什么是二叉树？\n\n字典是一种以**键值对**形式存储数据的数据结构。\n\n#### 2. 二叉树的实现\n\n```\n\tfunction Dictionary() {\n\t\tthis.dataStore = new Array(); // 为啥是数组不是对象？？？\n\t\tthis.add = add;\n\t\tthis.find = find;\n\t\tthis.remove = remove;\n\t\tthis.showAll = showAll;\n\t}\n\n\tDictionary.prototype = {\n\t\tconstructor: Dictionary,\n\t\tadd: function() {},\n\t}\n```\n\n**字典类增加一个键值对**\n\nfunction add(key, value) {\n\tthis.dataStore[key] = value;\n}\n\n**找到字典类里面的某一个键对应的值**\n\nfunction find(key) {\n\treturn this.dataStore[key];\n}\n\n","source":"_posts/2016-09-20-字典.md","raw":"---\nlayout: post\ntitle: 字典\ndate: 2016-09-20\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一. 字典\n\n#### 1. 什么是二叉树？\n\n字典是一种以**键值对**形式存储数据的数据结构。\n\n#### 2. 二叉树的实现\n\n```\n\tfunction Dictionary() {\n\t\tthis.dataStore = new Array(); // 为啥是数组不是对象？？？\n\t\tthis.add = add;\n\t\tthis.find = find;\n\t\tthis.remove = remove;\n\t\tthis.showAll = showAll;\n\t}\n\n\tDictionary.prototype = {\n\t\tconstructor: Dictionary,\n\t\tadd: function() {},\n\t}\n```\n\n**字典类增加一个键值对**\n\nfunction add(key, value) {\n\tthis.dataStore[key] = value;\n}\n\n**找到字典类里面的某一个键对应的值**\n\nfunction find(key) {\n\treturn this.dataStore[key];\n}\n\n","slug":"2016-09-20-字典","published":1,"updated":"2016-10-16T01:49:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockj00cyd5u83trm62zj","content":"<h3 id=\"一-字典\"><a href=\"#一-字典\" class=\"headerlink\" title=\"一. 字典\"></a>一. 字典</h3><h4 id=\"1-什么是二叉树？\"><a href=\"#1-什么是二叉树？\" class=\"headerlink\" title=\"1. 什么是二叉树？\"></a>1. 什么是二叉树？</h4><p>字典是一种以<strong>键值对</strong>形式存储数据的数据结构。</p>\n<h4 id=\"2-二叉树的实现\"><a href=\"#2-二叉树的实现\" class=\"headerlink\" title=\"2. 二叉树的实现\"></a>2. 二叉树的实现</h4><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dictionary</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.dataStore = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(); <span class=\"comment\">// 为啥是数组不是对象？？？</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.add = add;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.find = find;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.remove = remove;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.showAll = showAll;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dictionary.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">constructor</span>: Dictionary,</span><br><span class=\"line\">\t<span class=\"attribute\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>字典类增加一个键值对</strong></p>\n<p>function add(key, value) {<br>    this.dataStore[key] = value;<br>}</p>\n<p><strong>找到字典类里面的某一个键对应的值</strong></p>\n<p>function find(key) {<br>    return this.dataStore[key];<br>}</p>\n","excerpt":"","more":"<h3 id=\"一-字典\"><a href=\"#一-字典\" class=\"headerlink\" title=\"一. 字典\"></a>一. 字典</h3><h4 id=\"1-什么是二叉树？\"><a href=\"#1-什么是二叉树？\" class=\"headerlink\" title=\"1. 什么是二叉树？\"></a>1. 什么是二叉树？</h4><p>字典是一种以<strong>键值对</strong>形式存储数据的数据结构。</p>\n<h4 id=\"2-二叉树的实现\"><a href=\"#2-二叉树的实现\" class=\"headerlink\" title=\"2. 二叉树的实现\"></a>2. 二叉树的实现</h4><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dictionary</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.dataStore = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(); <span class=\"comment\">// 为啥是数组不是对象？？？</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.add = add;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.find = find;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.remove = remove;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.showAll = showAll;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dictionary.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">constructor</span>: Dictionary,</span><br><span class=\"line\">\t<span class=\"attribute\">add</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>字典类增加一个键值对</strong></p>\n<p>function add(key, value) {<br>    this.dataStore[key] = value;<br>}</p>\n<p><strong>找到字典类里面的某一个键对应的值</strong></p>\n<p>function find(key) {<br>    return this.dataStore[key];<br>}</p>\n"},{"layout":"post","title":"javaScript中的异步编程方法","date":"2016-09-20T16:00:00.000Z","description":null,"_content":"\n### 一. 回调函数\n\n```\n//jQuery中，第一次发起ajax请求\n$.ajax({\n\t...\n\tsuccess: function(data) {\n\t\t\n\t\t//第一次ajax请求成功执行第二次ajax请求\n\t\t$.ajax({\n\t\t\t...\n\t\t\tsuccess: function(data) {\n\t\t\t\n\t\t\t}\n\t\t});\n\t}\n})\n```\n\n回调函数的缺点：回调地狱\n\n### 二. 事件监听\n\n### 三. 订阅/发布\n\n### 四. Promise对象\n\n>Promise到底解决什么问题？\n\n>正如上面代码所示，笔者认为，Promise的意义就在于 **then 链式调用** ，它避免了异步函数之间的层层嵌套，将原来异步函数的 **嵌套关系** 转变为便于阅读和理解的 **链式步骤关系** 。\n\npromise对象表示一个异步操作。\n\n#### 1. promise对象的状态\n\n由于promise对象表示的是一个异步操作，因此promise对象的状态有三种：\n\n- pending 进行中\n- resolved 已完成\n- rejected 已失败\n\n#### 2. 创建promise对象\n\n```\n\t\n\t//接收一个函数作为参数，该函数又有两个参数，这两个参数也是函数\n\tvar promise = new Promise(function(resolve, reject){\n\n\t});\n```\n\n**resolve()函数的作用：**\n\n将Promise对象的状态由pending ——> resolved\nresolve()中传入的参数，将会作为后续成功的函数的参数\n\n**reject()函数的作用：**\n\n将Promise对象的状态由pending ——> rejected\nreject()中传入的参数，将会作为后续失败的函数的参数\n\n**promise对象一新建之后，传入的函数参数就会立即执行**\n\n```\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n输出的结果为：\nPromise\nHi!\nResolved.\n```\n\n#### 3. promise实例上的方法\n\n**then()方法：根据promise对象的状态来确定执行的操作**\n\npromise.then(resolve, reject);\n\nthen的第一个参数resolve是异步操作成功时执行的函数，第二个参数reject是异步操作失败时执行的函数。\n\n- 在then方法的第一个参数 resolve 中，如果返回一个新的promise对象，那么就可以进行链式调用。\n- 在 then方法的 resolve 的函数中，如果返回某个值，该值可以作为后续操作的参数。\n\n例如：\n\n```\n\n\t\tvar p1 = new Promise(function(resolve, reject) {\n\t\t\tresolve('第一步完成');\n\t\t});\n\n\t\tvar p2 = new Promise(function(resolve, reject) {\n\t\t\tresolve('第二步完成');\n\t\t});\n\t\n\t\tp1.then(function(data) {\n\t\t\tconsole.log(data);\n\t\t\treturn p2;\n\t\t}).then(function(data) {\n\t\t\tconsole.log(data);\n\t\t});\n\n\t\t控制台输出：\n\t\t第一步完成\n\t\t第二步完成\n```\n\n**catch()方法：相当于then()第二个参数的简单写法**\n\npromise.then(null,function)\npromise.catch(reject)\n\n\n**Promise.all()**\n\n多个异步任务被触发时，要在所有的异步任务都完成之后才做出回应。\n\nPromise.all()的参数是一个promise对象组成的数组，在这些promise对象**全部resolved之后**触发回调函数；或者只有一个promise失败时会触发catch()\n\n**使用场景：在执行多个请求之后再做一些操作。**\n\n```\n\n\tvar req1 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { resolve('First!'); }, 4000);\n\t});\n\n\tvar req2 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { reject('Second!'); }, 3000);\n\t});\n\n\tPromise.all([req1, req2]).then(function(results) {\n    \tconsole.log('Then: ', one);\n\t}).catch(function(err) {\n    \tconsole.log('Catch: ', err);\n\t});\n\n\t// From the console:\n\t// Catch: Second!\n```\n\n**Promise.race()**\n\n只要数组中有一个promise对象被resolved或者rejected就会触发。\n\n使用场景：在有两个请求资源时可以使用。\n\n```\n\n\tvar req1 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { resolve('First!'); }, 8000);\n\t});\n\n\tvar req2 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { resolve('Second!'); }, 3000);\n\t});\n\n\tPromise.race([req1, req2]).then(function(one) {\n    \tconsole.log('Then: ', one);\n\t}).catch(function(one, two) {\n    \tconsole.log('Catch: ', one);\n\t});\n\n\t// From the console:\n\t// Then: Second!\n```\n\n**Promise.reject(reason)返回一个失败的promise对象**\n\n**Promise.resolve(value)返回一个成功的promise对象**\n\n#### 5. 实现Promise对象\n\n**Promise对象的属性：**\n\ndoneList：数组，存放异步操作成功时的回调函数队列\nfailList：数组，存放异步操作失败时的回调函数队列\nstate：保存当前Promise对象的状态\n\n**Promise对象的方法：**\n\nthen：分别向doneList和failList添加回调函数\ncatch：向failList中添加失败的回调函数\nalways：\nresolve：将状态改为resolved，并触发绑定的所有成功的回调函数\nreject：将状态改为rejected，并触发绑定的所有失败的回调函数\n\n**静态方法:**\n\nPromise.all：参数是多个promise对象组成的数组，\n\n```\n\n\tvar Promise = function() {\n    \tthis.doneList = [];\n    \tthis.failList = [];\n    \tthis.state = 'pending';\n\t};\n\n\tPromise.prototype = {\n    \tconstructor: 'Promise',\n\n    \tresolve: function() {\n        \tthis.state = 'resolved';\n        \tvar list = this.doneList;\n        \tfor(var i = 0, len = list.length; i < len; i++) {\n            \tlist[0].call(this);\n            \tlist.shift();\n        \t}\n    \t},\n\n    \treject: function() {\n        \tthis.state = 'rejected';\n        \tvar list = this.failList;\n        \tfor(var i = 0, len = list.length; i < len; i++){\n            \tlist[0].call(this);\n            \tlist.shift();\n        \t}\n    \t},\n\n    \tdone: function(func) {\n        \tif(typeof func === 'function') {\n            \tthis.doneList.push(func);\n        \t}\n        \treturn this;\n    \t},\n\n    \tfail: function(func) {\n        \tif(typeof func === 'function') {\n            \tthis.failList.push(func);\n        \t}\n        \treturn this;\n    \t},\n\n    \tthen: function(doneFn, failFn) {\n        \tthis.done(doneFn).fail(failFn);\n        \treturn this;\n    \t},\n\n    \talways: function(fn) {\n        \tthis.done(fn).fail(fn);\n        \treturn this;\n    \t}\n\t};\n\n\tfunction when() {\n    \tvar p = new Promise();\n    \tvar success = true;\n    \tvar len = arguments.length;\n    \tfor(var i = 0; i < len; i++) {\n        \tif(!(arguments[i] instanceof Promise)) {\n            \treturn false;\n        \t}\n        \telse {\n            \targuments[i].always(function() {\n                \tif(this.state != 'resolved'){\n                    \tsuccess = false;\n                \t}\n                \tlen--;\n                \tif(len == 0) {\n                    \tsuccess ? p.resolve() : p.reject();\n                \t}\n            \t});\n        \t}\n    \t}\n    \treturn p;\n\t}\n```\n\n```\n\t\t\t/*\n            我们要满足状态只能三种状态：PENDING,FULFILLED,REJECTED三种状态，且状态只能由PENDING=>FULFILLED,或者PENDING=>REJECTED\n            */\n            var PENDING = 0;\n            var FULFILLED = 1;\n            var REJECTED = 2;\n\n            /*\n            value的值为异步操作成功之后，传入resolve函数的参数；或者失败时，传入reject函数的参数。\n\t\t\tdeffered保存着状态改变之后的需要处理的函数以及promise子节点，构造函数里面应该包含这三个属性的初始化\n             */\n            function Promise(callback) {\n\t\t\t\t\n\t\t\t\t//status属性存放的是promise对象的状态\n                this.status = PENDING;\n                this.value = null;\n                this.defferd = [];\n\n\t\t\t\t//bind()函数返回的是一个匿名函数，callback函数的两个参数是resolve、reject函数\n                setTimeout(callback.bind(this, this.resolve.bind(this), this.reject.bind(this)), 0);\n            }\n            \n            Promise.prototype = {\n                constructor: Promise,\n\n                //将promise状态改变为FULFILLED\n                resolve: function (result) {\n                    this.status = FULFILLED;\n                    this.value = result;\n                    this.done();\n                },\n\n                //将promise状态改变为REJECTED\n                reject: function (error) {\n                    this.status = REJECTED;\n                    this.value = error;\n                },\n\n                //处理defferd\n                handle: function (fn) {\n                    if (!fn) {\n                        return;\n                    }\n\n                    var value = this.value;\n                    var t = this.status;\n                    var p;\n\n                    if (t == PENDING) {\n                         this.defferd.push(fn);\n                    } else {\n\n                        if (t == FULFILLED && typeof fn.onfulfiled == 'function') {\n                            p = fn.onfulfiled(value);\n                        }\n\n                        if (t == REJECTED && typeof fn.onrejected == 'function') {\n                            p = fn.onrejected(value);\n                        }\n\n                    \tvar promise = fn.promise;\n\n                    \tif (promise) {\n                        \tif (p && p.constructor == Promise) {\n                            \tp.defferd = promise.defferd;\n                        \t} else {\n                            \tp = this;\n                            \tp.defferd = promise.defferd;\n                            \tthis.done();\n                        \t}\n                    \t}\n                    }\n                },\n\n                //触发promise defferd里面需要执行的函数\n                done: function () {\n                    var status = this.status;\n                    if (status == PENDING) {\n                        return;\n                    }\n                    var defferd = this.defferd;\n                    for (var i = 0; i < defferd.length; i++) {\n                        this.handle(defferd[i]);\n                    }\n                },\n\n                /*储存then函数里面的事件\n                返回promise对象\n                defferd函数当前promise对象里面\n                */\n                then: function (success, fail) {\n                   var o = {\n                        onfulfiled: success,\n                        onrejected: fail\n                    };\n                    var status = this.status;\n                    o.promise = new this.constructor(function () {\n            \n                    });\n                    if (status == PENDING) {\n                        this.defferd.push(o);\n                    } else if (status == FULFILLED || status == REJECTED) {\n                        this.handle(o);\n                    }\n                    return o.promise;\n                }\n            };\n```","source":"_posts/2016-09-21-javaScript中的异步编程方法.md","raw":"---\nlayout: post\ntitle: javaScript中的异步编程方法\ndate: 2016-09-21\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 回调函数\n\n```\n//jQuery中，第一次发起ajax请求\n$.ajax({\n\t...\n\tsuccess: function(data) {\n\t\t\n\t\t//第一次ajax请求成功执行第二次ajax请求\n\t\t$.ajax({\n\t\t\t...\n\t\t\tsuccess: function(data) {\n\t\t\t\n\t\t\t}\n\t\t});\n\t}\n})\n```\n\n回调函数的缺点：回调地狱\n\n### 二. 事件监听\n\n### 三. 订阅/发布\n\n### 四. Promise对象\n\n>Promise到底解决什么问题？\n\n>正如上面代码所示，笔者认为，Promise的意义就在于 **then 链式调用** ，它避免了异步函数之间的层层嵌套，将原来异步函数的 **嵌套关系** 转变为便于阅读和理解的 **链式步骤关系** 。\n\npromise对象表示一个异步操作。\n\n#### 1. promise对象的状态\n\n由于promise对象表示的是一个异步操作，因此promise对象的状态有三种：\n\n- pending 进行中\n- resolved 已完成\n- rejected 已失败\n\n#### 2. 创建promise对象\n\n```\n\t\n\t//接收一个函数作为参数，该函数又有两个参数，这两个参数也是函数\n\tvar promise = new Promise(function(resolve, reject){\n\n\t});\n```\n\n**resolve()函数的作用：**\n\n将Promise对象的状态由pending ——> resolved\nresolve()中传入的参数，将会作为后续成功的函数的参数\n\n**reject()函数的作用：**\n\n将Promise对象的状态由pending ——> rejected\nreject()中传入的参数，将会作为后续失败的函数的参数\n\n**promise对象一新建之后，传入的函数参数就会立即执行**\n\n```\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n输出的结果为：\nPromise\nHi!\nResolved.\n```\n\n#### 3. promise实例上的方法\n\n**then()方法：根据promise对象的状态来确定执行的操作**\n\npromise.then(resolve, reject);\n\nthen的第一个参数resolve是异步操作成功时执行的函数，第二个参数reject是异步操作失败时执行的函数。\n\n- 在then方法的第一个参数 resolve 中，如果返回一个新的promise对象，那么就可以进行链式调用。\n- 在 then方法的 resolve 的函数中，如果返回某个值，该值可以作为后续操作的参数。\n\n例如：\n\n```\n\n\t\tvar p1 = new Promise(function(resolve, reject) {\n\t\t\tresolve('第一步完成');\n\t\t});\n\n\t\tvar p2 = new Promise(function(resolve, reject) {\n\t\t\tresolve('第二步完成');\n\t\t});\n\t\n\t\tp1.then(function(data) {\n\t\t\tconsole.log(data);\n\t\t\treturn p2;\n\t\t}).then(function(data) {\n\t\t\tconsole.log(data);\n\t\t});\n\n\t\t控制台输出：\n\t\t第一步完成\n\t\t第二步完成\n```\n\n**catch()方法：相当于then()第二个参数的简单写法**\n\npromise.then(null,function)\npromise.catch(reject)\n\n\n**Promise.all()**\n\n多个异步任务被触发时，要在所有的异步任务都完成之后才做出回应。\n\nPromise.all()的参数是一个promise对象组成的数组，在这些promise对象**全部resolved之后**触发回调函数；或者只有一个promise失败时会触发catch()\n\n**使用场景：在执行多个请求之后再做一些操作。**\n\n```\n\n\tvar req1 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { resolve('First!'); }, 4000);\n\t});\n\n\tvar req2 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { reject('Second!'); }, 3000);\n\t});\n\n\tPromise.all([req1, req2]).then(function(results) {\n    \tconsole.log('Then: ', one);\n\t}).catch(function(err) {\n    \tconsole.log('Catch: ', err);\n\t});\n\n\t// From the console:\n\t// Catch: Second!\n```\n\n**Promise.race()**\n\n只要数组中有一个promise对象被resolved或者rejected就会触发。\n\n使用场景：在有两个请求资源时可以使用。\n\n```\n\n\tvar req1 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { resolve('First!'); }, 8000);\n\t});\n\n\tvar req2 = new Promise(function(resolve, reject) { \n    \t// A mock async action using setTimeout\n    \tsetTimeout(function() { resolve('Second!'); }, 3000);\n\t});\n\n\tPromise.race([req1, req2]).then(function(one) {\n    \tconsole.log('Then: ', one);\n\t}).catch(function(one, two) {\n    \tconsole.log('Catch: ', one);\n\t});\n\n\t// From the console:\n\t// Then: Second!\n```\n\n**Promise.reject(reason)返回一个失败的promise对象**\n\n**Promise.resolve(value)返回一个成功的promise对象**\n\n#### 5. 实现Promise对象\n\n**Promise对象的属性：**\n\ndoneList：数组，存放异步操作成功时的回调函数队列\nfailList：数组，存放异步操作失败时的回调函数队列\nstate：保存当前Promise对象的状态\n\n**Promise对象的方法：**\n\nthen：分别向doneList和failList添加回调函数\ncatch：向failList中添加失败的回调函数\nalways：\nresolve：将状态改为resolved，并触发绑定的所有成功的回调函数\nreject：将状态改为rejected，并触发绑定的所有失败的回调函数\n\n**静态方法:**\n\nPromise.all：参数是多个promise对象组成的数组，\n\n```\n\n\tvar Promise = function() {\n    \tthis.doneList = [];\n    \tthis.failList = [];\n    \tthis.state = 'pending';\n\t};\n\n\tPromise.prototype = {\n    \tconstructor: 'Promise',\n\n    \tresolve: function() {\n        \tthis.state = 'resolved';\n        \tvar list = this.doneList;\n        \tfor(var i = 0, len = list.length; i < len; i++) {\n            \tlist[0].call(this);\n            \tlist.shift();\n        \t}\n    \t},\n\n    \treject: function() {\n        \tthis.state = 'rejected';\n        \tvar list = this.failList;\n        \tfor(var i = 0, len = list.length; i < len; i++){\n            \tlist[0].call(this);\n            \tlist.shift();\n        \t}\n    \t},\n\n    \tdone: function(func) {\n        \tif(typeof func === 'function') {\n            \tthis.doneList.push(func);\n        \t}\n        \treturn this;\n    \t},\n\n    \tfail: function(func) {\n        \tif(typeof func === 'function') {\n            \tthis.failList.push(func);\n        \t}\n        \treturn this;\n    \t},\n\n    \tthen: function(doneFn, failFn) {\n        \tthis.done(doneFn).fail(failFn);\n        \treturn this;\n    \t},\n\n    \talways: function(fn) {\n        \tthis.done(fn).fail(fn);\n        \treturn this;\n    \t}\n\t};\n\n\tfunction when() {\n    \tvar p = new Promise();\n    \tvar success = true;\n    \tvar len = arguments.length;\n    \tfor(var i = 0; i < len; i++) {\n        \tif(!(arguments[i] instanceof Promise)) {\n            \treturn false;\n        \t}\n        \telse {\n            \targuments[i].always(function() {\n                \tif(this.state != 'resolved'){\n                    \tsuccess = false;\n                \t}\n                \tlen--;\n                \tif(len == 0) {\n                    \tsuccess ? p.resolve() : p.reject();\n                \t}\n            \t});\n        \t}\n    \t}\n    \treturn p;\n\t}\n```\n\n```\n\t\t\t/*\n            我们要满足状态只能三种状态：PENDING,FULFILLED,REJECTED三种状态，且状态只能由PENDING=>FULFILLED,或者PENDING=>REJECTED\n            */\n            var PENDING = 0;\n            var FULFILLED = 1;\n            var REJECTED = 2;\n\n            /*\n            value的值为异步操作成功之后，传入resolve函数的参数；或者失败时，传入reject函数的参数。\n\t\t\tdeffered保存着状态改变之后的需要处理的函数以及promise子节点，构造函数里面应该包含这三个属性的初始化\n             */\n            function Promise(callback) {\n\t\t\t\t\n\t\t\t\t//status属性存放的是promise对象的状态\n                this.status = PENDING;\n                this.value = null;\n                this.defferd = [];\n\n\t\t\t\t//bind()函数返回的是一个匿名函数，callback函数的两个参数是resolve、reject函数\n                setTimeout(callback.bind(this, this.resolve.bind(this), this.reject.bind(this)), 0);\n            }\n            \n            Promise.prototype = {\n                constructor: Promise,\n\n                //将promise状态改变为FULFILLED\n                resolve: function (result) {\n                    this.status = FULFILLED;\n                    this.value = result;\n                    this.done();\n                },\n\n                //将promise状态改变为REJECTED\n                reject: function (error) {\n                    this.status = REJECTED;\n                    this.value = error;\n                },\n\n                //处理defferd\n                handle: function (fn) {\n                    if (!fn) {\n                        return;\n                    }\n\n                    var value = this.value;\n                    var t = this.status;\n                    var p;\n\n                    if (t == PENDING) {\n                         this.defferd.push(fn);\n                    } else {\n\n                        if (t == FULFILLED && typeof fn.onfulfiled == 'function') {\n                            p = fn.onfulfiled(value);\n                        }\n\n                        if (t == REJECTED && typeof fn.onrejected == 'function') {\n                            p = fn.onrejected(value);\n                        }\n\n                    \tvar promise = fn.promise;\n\n                    \tif (promise) {\n                        \tif (p && p.constructor == Promise) {\n                            \tp.defferd = promise.defferd;\n                        \t} else {\n                            \tp = this;\n                            \tp.defferd = promise.defferd;\n                            \tthis.done();\n                        \t}\n                    \t}\n                    }\n                },\n\n                //触发promise defferd里面需要执行的函数\n                done: function () {\n                    var status = this.status;\n                    if (status == PENDING) {\n                        return;\n                    }\n                    var defferd = this.defferd;\n                    for (var i = 0; i < defferd.length; i++) {\n                        this.handle(defferd[i]);\n                    }\n                },\n\n                /*储存then函数里面的事件\n                返回promise对象\n                defferd函数当前promise对象里面\n                */\n                then: function (success, fail) {\n                   var o = {\n                        onfulfiled: success,\n                        onrejected: fail\n                    };\n                    var status = this.status;\n                    o.promise = new this.constructor(function () {\n            \n                    });\n                    if (status == PENDING) {\n                        this.defferd.push(o);\n                    } else if (status == FULFILLED || status == REJECTED) {\n                        this.handle(o);\n                    }\n                    return o.promise;\n                }\n            };\n```","slug":"2016-09-21-javaScript中的异步编程方法","published":1,"updated":"2016-10-14T13:10:06.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockl00d1d5u86c9nsj3j","content":"<h3 id=\"一-回调函数\"><a href=\"#一-回调函数\" class=\"headerlink\" title=\"一. 回调函数\"></a>一. 回调函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jQuery中，第一次发起ajax请求</span></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tsuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次ajax请求成功执行第二次ajax请求</span></span><br><span class=\"line\">\t\t$.ajax(&#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t\tsuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>回调函数的缺点：回调地狱</p>\n<h3 id=\"二-事件监听\"><a href=\"#二-事件监听\" class=\"headerlink\" title=\"二. 事件监听\"></a>二. 事件监听</h3><h3 id=\"三-订阅-发布\"><a href=\"#三-订阅-发布\" class=\"headerlink\" title=\"三. 订阅/发布\"></a>三. 订阅/发布</h3><h3 id=\"四-Promise对象\"><a href=\"#四-Promise对象\" class=\"headerlink\" title=\"四. Promise对象\"></a>四. Promise对象</h3><blockquote>\n<p>Promise到底解决什么问题？</p>\n<p>正如上面代码所示，笔者认为，Promise的意义就在于 <strong>then 链式调用</strong> ，它避免了异步函数之间的层层嵌套，将原来异步函数的 <strong>嵌套关系</strong> 转变为便于阅读和理解的 <strong>链式步骤关系</strong> 。</p>\n</blockquote>\n<p>promise对象表示一个异步操作。</p>\n<h4 id=\"1-promise对象的状态\"><a href=\"#1-promise对象的状态\" class=\"headerlink\" title=\"1. promise对象的状态\"></a>1. promise对象的状态</h4><p>由于promise对象表示的是一个异步操作，因此promise对象的状态有三种：</p>\n<ul>\n<li>pending 进行中</li>\n<li>resolved 已完成</li>\n<li>rejected 已失败</li>\n</ul>\n<h4 id=\"2-创建promise对象\"><a href=\"#2-创建promise对象\" class=\"headerlink\" title=\"2. 创建promise对象\"></a>2. 创建promise对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接收一个函数作为参数，该函数又有两个参数，这两个参数也是函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>resolve()函数的作用：</strong></p>\n<p>将Promise对象的状态由pending ——&gt; resolved<br>resolve()中传入的参数，将会作为后续成功的函数的参数</p>\n<p><strong>reject()函数的作用：</strong></p>\n<p>将Promise对象的状态由pending ——&gt; rejected<br>reject()中传入的参数，将会作为后续失败的函数的参数</p>\n<p><strong>promise对象一新建之后，传入的函数参数就会立即执行</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">输出的结果为：</span><br><span class=\"line\"><span class=\"built_in\">Promise</span></span><br><span class=\"line\">Hi!</span><br><span class=\"line\">Resolved.</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-promise实例上的方法\"><a href=\"#3-promise实例上的方法\" class=\"headerlink\" title=\"3. promise实例上的方法\"></a>3. promise实例上的方法</h4><p><strong>then()方法：根据promise对象的状态来确定执行的操作</strong></p>\n<p>promise.then(resolve, reject);</p>\n<p>then的第一个参数resolve是异步操作成功时执行的函数，第二个参数reject是异步操作失败时执行的函数。</p>\n<ul>\n<li>在then方法的第一个参数 resolve 中，如果返回一个新的promise对象，那么就可以进行链式调用。</li>\n<li>在 then方法的 resolve 的函数中，如果返回某个值，该值可以作为后续操作的参数。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"string\">'第一步完成'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"string\">'第二步完成'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">控制台输出：</span><br><span class=\"line\">第一步完成</span><br><span class=\"line\">第二步完成</span><br></pre></td></tr></table></figure>\n<p><strong>catch()方法：相当于then()第二个参数的简单写法</strong></p>\n<p>promise.then(null,function)<br>promise.catch(reject)</p>\n<p><strong>Promise.all()</strong></p>\n<p>多个异步任务被触发时，要在所有的异步任务都完成之后才做出回应。</p>\n<p>Promise.all()的参数是一个promise对象组成的数组，在这些promise对象<strong>全部resolved之后</strong>触发回调函数；或者只有一个promise失败时会触发catch()</p>\n<p><strong>使用场景：在执行多个请求之后再做一些操作。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(<span class=\"string\">'First!'</span>); &#125;, <span class=\"number\">4000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; reject(<span class=\"string\">'Second!'</span>); &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([req1, req2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">results</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Then: '</span>, one);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch: '</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// From the console:</span></span><br><span class=\"line\"><span class=\"comment\">// Catch: Second!</span></span><br></pre></td></tr></table></figure>\n<p><strong>Promise.race()</strong></p>\n<p>只要数组中有一个promise对象被resolved或者rejected就会触发。</p>\n<p>使用场景：在有两个请求资源时可以使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(<span class=\"string\">'First!'</span>); &#125;, <span class=\"number\">8000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(<span class=\"string\">'Second!'</span>); &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([req1, req2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">one</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Then: '</span>, one);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">one, two</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch: '</span>, one);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// From the console:</span></span><br><span class=\"line\"><span class=\"comment\">// Then: Second!</span></span><br></pre></td></tr></table></figure>\n<p><strong>Promise.reject(reason)返回一个失败的promise对象</strong></p>\n<p><strong>Promise.resolve(value)返回一个成功的promise对象</strong></p>\n<h4 id=\"5-实现Promise对象\"><a href=\"#5-实现Promise对象\" class=\"headerlink\" title=\"5. 实现Promise对象\"></a>5. 实现Promise对象</h4><p><strong>Promise对象的属性：</strong></p>\n<p>doneList：数组，存放异步操作成功时的回调函数队列<br>failList：数组，存放异步操作失败时的回调函数队列<br>state：保存当前Promise对象的状态</p>\n<p><strong>Promise对象的方法：</strong></p>\n<p>then：分别向doneList和failList添加回调函数<br>catch：向failList中添加失败的回调函数<br>always：<br>resolve：将状态改为resolved，并触发绑定的所有成功的回调函数<br>reject：将状态改为rejected，并触发绑定的所有失败的回调函数</p>\n<p><strong>静态方法:</strong></p>\n<p>Promise.all：参数是多个promise对象组成的数组，</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> Promise = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.doneList = [];</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.failList = [];</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.state = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.prototype = &#123;</span><br><span class=\"line\">   \t<span class=\"attribute\">constructor</span>: <span class=\"string\">'Promise'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">resolve</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.state = <span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">       \t<span class=\"built_in\">var</span> <span class=\"built_in\">list</span> = <span class=\"keyword\">this</span>.doneList;</span><br><span class=\"line\">       \t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">list</span>.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>[<span class=\"number\">0</span>].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>.shift();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">reject</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.state = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">       \t<span class=\"built_in\">var</span> <span class=\"built_in\">list</span> = <span class=\"keyword\">this</span>.failList;</span><br><span class=\"line\">       \t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">list</span>.length; i &lt; len; i++)&#123;</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>[<span class=\"number\">0</span>].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>.shift();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">done</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> func === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">           \t<span class=\"keyword\">this</span>.doneList.push(func);</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> func === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">           \t<span class=\"keyword\">this</span>.failList.push(func);</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">then</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">doneFn, failFn</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.done(doneFn).fail(failFn);</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">always</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.done(fn).fail(fn);</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">when</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> p = <span class=\"keyword\">new</span> Promise();</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> len = <span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">   \t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(!(<span class=\"built_in\">arguments</span>[i] <span class=\"keyword\">instanceof</span> Promise)) &#123;</span><br><span class=\"line\">           \t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">       \t<span class=\"title\">else</span> &#123;</span><br><span class=\"line\">           \t<span class=\"built_in\">arguments</span>[i].always(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               \t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state != <span class=\"string\">'resolved'</span>)&#123;</span><br><span class=\"line\">                   \tsuccess = <span class=\"literal\">false</span>;</span><br><span class=\"line\">               \t&#125;</span><br><span class=\"line\">               \tlen--;</span><br><span class=\"line\">               \t<span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                   \tsuccess ? p.resolve() : p.reject();</span><br><span class=\"line\">               \t&#125;</span><br><span class=\"line\">           \t&#125;);</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\">         我们要满足状态只能三种状态：PENDING,FULFILLED,REJECTED三种状态，且状态只能由PENDING=&gt;FULFILLED,或者PENDING=&gt;REJECTED</span><br><span class=\"line\">         */</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> PENDING = <span class=\"number\">0</span>;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> FULFILLED = <span class=\"number\">1</span>;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> REJECTED = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">/*</span><br><span class=\"line\">         value的值为异步操作成功之后，传入resolve函数的参数；或者失败时，传入reject函数的参数。</span><br><span class=\"line\">deffered保存着状态改变之后的需要处理的函数以及promise子节点，构造函数里面应该包含这三个属性的初始化</span><br><span class=\"line\">          */</span></span><br><span class=\"line\">         function Promise(callback) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//status属性存放的是promise对象的状态</span></span><br><span class=\"line\">             <span class=\"keyword\">this</span>.status = PENDING;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.defferd = [];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//bind()函数返回的是一个匿名函数，callback函数的两个参数是resolve、reject函数</span></span><br><span class=\"line\">             setTimeout(callback.bind(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>.reject.bind(<span class=\"keyword\">this</span>)), <span class=\"number\">0</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">         Promise.prototype = &#123;</span><br><span class=\"line\">             <span class=\"keyword\">constructor</span>: Promise,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//将promise状态改变为FULFILLED</span></span><br><span class=\"line\">             resolve: function (result) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.status = FULFILLED;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.value = result;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.done();</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//将promise状态改变为REJECTED</span></span><br><span class=\"line\">             reject: function (error) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.status = REJECTED;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.value = error;</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//处理defferd</span></span><br><span class=\"line\">             handle: function (fn) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (!fn) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                 <span class=\"keyword\">var</span> value = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> t = <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (t == PENDING) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">this</span>.defferd.push(fn);</span><br><span class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                     <span class=\"keyword\">if</span> (t == FULFILLED &amp;&amp; typeof fn.onfulfiled == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                         p = fn.onfulfiled(value);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                     <span class=\"keyword\">if</span> (t == REJECTED &amp;&amp; typeof fn.onrejected == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                         p = fn.onrejected(value);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                 \t<span class=\"keyword\">var</span> promise = fn.promise;</span><br><span class=\"line\"></span><br><span class=\"line\">                 \t<span class=\"keyword\">if</span> (promise) &#123;</span><br><span class=\"line\">                     \t<span class=\"keyword\">if</span> (p &amp;&amp; p.<span class=\"keyword\">constructor</span> == Promise) &#123;</span><br><span class=\"line\">                         \tp.defferd = promise.defferd;</span><br><span class=\"line\">                     \t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                         \tp = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">                         \tp.defferd = promise.defferd;</span><br><span class=\"line\">                         \t<span class=\"keyword\">this</span>.done();</span><br><span class=\"line\">                     \t&#125;</span><br><span class=\"line\">                 \t&#125;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//触发promise defferd里面需要执行的函数</span></span><br><span class=\"line\">             done: function () &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> status = <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (status == PENDING) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> defferd = <span class=\"keyword\">this</span>.defferd;</span><br><span class=\"line\">                 <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; defferd.length; i++) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">this</span>.handle(defferd[i]);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">/*储存then函数里面的事件</span><br><span class=\"line\">             返回promise对象</span><br><span class=\"line\">             defferd函数当前promise对象里面</span><br><span class=\"line\">             */</span></span><br><span class=\"line\">             then: function (success, fail) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">                     onfulfiled: success,</span><br><span class=\"line\">                     onrejected: fail</span><br><span class=\"line\">                 &#125;;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> status = <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">                 o.promise = new <span class=\"keyword\">this</span>.<span class=\"keyword\">constructor</span>(function () &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">                 &#125;);</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (status == PENDING) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">this</span>.defferd.push(o);</span><br><span class=\"line\">                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == FULFILLED || status == REJECTED) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">this</span>.handle(o);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> o.promise;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-回调函数\"><a href=\"#一-回调函数\" class=\"headerlink\" title=\"一. 回调函数\"></a>一. 回调函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jQuery中，第一次发起ajax请求</span></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tsuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次ajax请求成功执行第二次ajax请求</span></span><br><span class=\"line\">\t\t$.ajax(&#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t\tsuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>回调函数的缺点：回调地狱</p>\n<h3 id=\"二-事件监听\"><a href=\"#二-事件监听\" class=\"headerlink\" title=\"二. 事件监听\"></a>二. 事件监听</h3><h3 id=\"三-订阅-发布\"><a href=\"#三-订阅-发布\" class=\"headerlink\" title=\"三. 订阅/发布\"></a>三. 订阅/发布</h3><h3 id=\"四-Promise对象\"><a href=\"#四-Promise对象\" class=\"headerlink\" title=\"四. Promise对象\"></a>四. Promise对象</h3><blockquote>\n<p>Promise到底解决什么问题？</p>\n<p>正如上面代码所示，笔者认为，Promise的意义就在于 <strong>then 链式调用</strong> ，它避免了异步函数之间的层层嵌套，将原来异步函数的 <strong>嵌套关系</strong> 转变为便于阅读和理解的 <strong>链式步骤关系</strong> 。</p>\n</blockquote>\n<p>promise对象表示一个异步操作。</p>\n<h4 id=\"1-promise对象的状态\"><a href=\"#1-promise对象的状态\" class=\"headerlink\" title=\"1. promise对象的状态\"></a>1. promise对象的状态</h4><p>由于promise对象表示的是一个异步操作，因此promise对象的状态有三种：</p>\n<ul>\n<li>pending 进行中</li>\n<li>resolved 已完成</li>\n<li>rejected 已失败</li>\n</ul>\n<h4 id=\"2-创建promise对象\"><a href=\"#2-创建promise对象\" class=\"headerlink\" title=\"2. 创建promise对象\"></a>2. 创建promise对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接收一个函数作为参数，该函数又有两个参数，这两个参数也是函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>resolve()函数的作用：</strong></p>\n<p>将Promise对象的状态由pending ——&gt; resolved<br>resolve()中传入的参数，将会作为后续成功的函数的参数</p>\n<p><strong>reject()函数的作用：</strong></p>\n<p>将Promise对象的状态由pending ——&gt; rejected<br>reject()中传入的参数，将会作为后续失败的函数的参数</p>\n<p><strong>promise对象一新建之后，传入的函数参数就会立即执行</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">输出的结果为：</span><br><span class=\"line\"><span class=\"built_in\">Promise</span></span><br><span class=\"line\">Hi!</span><br><span class=\"line\">Resolved.</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-promise实例上的方法\"><a href=\"#3-promise实例上的方法\" class=\"headerlink\" title=\"3. promise实例上的方法\"></a>3. promise实例上的方法</h4><p><strong>then()方法：根据promise对象的状态来确定执行的操作</strong></p>\n<p>promise.then(resolve, reject);</p>\n<p>then的第一个参数resolve是异步操作成功时执行的函数，第二个参数reject是异步操作失败时执行的函数。</p>\n<ul>\n<li>在then方法的第一个参数 resolve 中，如果返回一个新的promise对象，那么就可以进行链式调用。</li>\n<li>在 then方法的 resolve 的函数中，如果返回某个值，该值可以作为后续操作的参数。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"string\">'第一步完成'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"string\">'第二步完成'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">控制台输出：</span><br><span class=\"line\">第一步完成</span><br><span class=\"line\">第二步完成</span><br></pre></td></tr></table></figure>\n<p><strong>catch()方法：相当于then()第二个参数的简单写法</strong></p>\n<p>promise.then(null,function)<br>promise.catch(reject)</p>\n<p><strong>Promise.all()</strong></p>\n<p>多个异步任务被触发时，要在所有的异步任务都完成之后才做出回应。</p>\n<p>Promise.all()的参数是一个promise对象组成的数组，在这些promise对象<strong>全部resolved之后</strong>触发回调函数；或者只有一个promise失败时会触发catch()</p>\n<p><strong>使用场景：在执行多个请求之后再做一些操作。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(<span class=\"string\">'First!'</span>); &#125;, <span class=\"number\">4000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; reject(<span class=\"string\">'Second!'</span>); &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([req1, req2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">results</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Then: '</span>, one);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch: '</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// From the console:</span></span><br><span class=\"line\"><span class=\"comment\">// Catch: Second!</span></span><br></pre></td></tr></table></figure>\n<p><strong>Promise.race()</strong></p>\n<p>只要数组中有一个promise对象被resolved或者rejected就会触发。</p>\n<p>使用场景：在有两个请求资源时可以使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(<span class=\"string\">'First!'</span>); &#125;, <span class=\"number\">8000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> req2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">   \t<span class=\"comment\">// A mock async action using setTimeout</span></span><br><span class=\"line\">   \tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(<span class=\"string\">'Second!'</span>); &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([req1, req2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">one</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Then: '</span>, one);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">one, two</span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch: '</span>, one);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// From the console:</span></span><br><span class=\"line\"><span class=\"comment\">// Then: Second!</span></span><br></pre></td></tr></table></figure>\n<p><strong>Promise.reject(reason)返回一个失败的promise对象</strong></p>\n<p><strong>Promise.resolve(value)返回一个成功的promise对象</strong></p>\n<h4 id=\"5-实现Promise对象\"><a href=\"#5-实现Promise对象\" class=\"headerlink\" title=\"5. 实现Promise对象\"></a>5. 实现Promise对象</h4><p><strong>Promise对象的属性：</strong></p>\n<p>doneList：数组，存放异步操作成功时的回调函数队列<br>failList：数组，存放异步操作失败时的回调函数队列<br>state：保存当前Promise对象的状态</p>\n<p><strong>Promise对象的方法：</strong></p>\n<p>then：分别向doneList和failList添加回调函数<br>catch：向failList中添加失败的回调函数<br>always：<br>resolve：将状态改为resolved，并触发绑定的所有成功的回调函数<br>reject：将状态改为rejected，并触发绑定的所有失败的回调函数</p>\n<p><strong>静态方法:</strong></p>\n<p>Promise.all：参数是多个promise对象组成的数组，</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> Promise = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.doneList = [];</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.failList = [];</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.state = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.prototype = &#123;</span><br><span class=\"line\">   \t<span class=\"attribute\">constructor</span>: <span class=\"string\">'Promise'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">resolve</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.state = <span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">       \t<span class=\"built_in\">var</span> <span class=\"built_in\">list</span> = <span class=\"keyword\">this</span>.doneList;</span><br><span class=\"line\">       \t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">list</span>.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>[<span class=\"number\">0</span>].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>.shift();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">reject</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.state = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">       \t<span class=\"built_in\">var</span> <span class=\"built_in\">list</span> = <span class=\"keyword\">this</span>.failList;</span><br><span class=\"line\">       \t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>, len = <span class=\"built_in\">list</span>.length; i &lt; len; i++)&#123;</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>[<span class=\"number\">0</span>].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">           \t<span class=\"built_in\">list</span>.shift();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">done</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> func === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">           \t<span class=\"keyword\">this</span>.doneList.push(func);</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> func === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">           \t<span class=\"keyword\">this</span>.failList.push(func);</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">then</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">doneFn, failFn</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.done(doneFn).fail(failFn);</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"attribute\">always</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">this</span>.done(fn).fail(fn);</span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">when</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> p = <span class=\"keyword\">new</span> Promise();</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> len = <span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">   \t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(!(<span class=\"built_in\">arguments</span>[i] <span class=\"keyword\">instanceof</span> Promise)) &#123;</span><br><span class=\"line\">           \t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">       \t<span class=\"title\">else</span> &#123;</span><br><span class=\"line\">           \t<span class=\"built_in\">arguments</span>[i].always(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               \t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state != <span class=\"string\">'resolved'</span>)&#123;</span><br><span class=\"line\">                   \tsuccess = <span class=\"literal\">false</span>;</span><br><span class=\"line\">               \t&#125;</span><br><span class=\"line\">               \tlen--;</span><br><span class=\"line\">               \t<span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                   \tsuccess ? p.resolve() : p.reject();</span><br><span class=\"line\">               \t&#125;</span><br><span class=\"line\">           \t&#125;);</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\">         我们要满足状态只能三种状态：PENDING,FULFILLED,REJECTED三种状态，且状态只能由PENDING=&gt;FULFILLED,或者PENDING=&gt;REJECTED</span><br><span class=\"line\">         */</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> PENDING = <span class=\"number\">0</span>;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> FULFILLED = <span class=\"number\">1</span>;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> REJECTED = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">/*</span><br><span class=\"line\">         value的值为异步操作成功之后，传入resolve函数的参数；或者失败时，传入reject函数的参数。</span><br><span class=\"line\">deffered保存着状态改变之后的需要处理的函数以及promise子节点，构造函数里面应该包含这三个属性的初始化</span><br><span class=\"line\">          */</span></span><br><span class=\"line\">         function Promise(callback) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//status属性存放的是promise对象的状态</span></span><br><span class=\"line\">             <span class=\"keyword\">this</span>.status = PENDING;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.value = <span class=\"literal\">null</span>;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.defferd = [];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//bind()函数返回的是一个匿名函数，callback函数的两个参数是resolve、reject函数</span></span><br><span class=\"line\">             setTimeout(callback.bind(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>.reject.bind(<span class=\"keyword\">this</span>)), <span class=\"number\">0</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">         Promise.prototype = &#123;</span><br><span class=\"line\">             <span class=\"keyword\">constructor</span>: Promise,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//将promise状态改变为FULFILLED</span></span><br><span class=\"line\">             resolve: function (result) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.status = FULFILLED;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.value = result;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.done();</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//将promise状态改变为REJECTED</span></span><br><span class=\"line\">             reject: function (error) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.status = REJECTED;</span><br><span class=\"line\">                 <span class=\"keyword\">this</span>.value = error;</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//处理defferd</span></span><br><span class=\"line\">             handle: function (fn) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (!fn) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                 <span class=\"keyword\">var</span> value = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> t = <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (t == PENDING) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">this</span>.defferd.push(fn);</span><br><span class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                     <span class=\"keyword\">if</span> (t == FULFILLED &amp;&amp; typeof fn.onfulfiled == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                         p = fn.onfulfiled(value);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                     <span class=\"keyword\">if</span> (t == REJECTED &amp;&amp; typeof fn.onrejected == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                         p = fn.onrejected(value);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                 \t<span class=\"keyword\">var</span> promise = fn.promise;</span><br><span class=\"line\"></span><br><span class=\"line\">                 \t<span class=\"keyword\">if</span> (promise) &#123;</span><br><span class=\"line\">                     \t<span class=\"keyword\">if</span> (p &amp;&amp; p.<span class=\"keyword\">constructor</span> == Promise) &#123;</span><br><span class=\"line\">                         \tp.defferd = promise.defferd;</span><br><span class=\"line\">                     \t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                         \tp = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">                         \tp.defferd = promise.defferd;</span><br><span class=\"line\">                         \t<span class=\"keyword\">this</span>.done();</span><br><span class=\"line\">                     \t&#125;</span><br><span class=\"line\">                 \t&#125;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">//触发promise defferd里面需要执行的函数</span></span><br><span class=\"line\">             done: function () &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> status = <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (status == PENDING) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> defferd = <span class=\"keyword\">this</span>.defferd;</span><br><span class=\"line\">                 <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; defferd.length; i++) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">this</span>.handle(defferd[i]);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">/*储存then函数里面的事件</span><br><span class=\"line\">             返回promise对象</span><br><span class=\"line\">             defferd函数当前promise对象里面</span><br><span class=\"line\">             */</span></span><br><span class=\"line\">             then: function (success, fail) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">                     onfulfiled: success,</span><br><span class=\"line\">                     onrejected: fail</span><br><span class=\"line\">                 &#125;;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> status = <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">                 o.promise = new <span class=\"keyword\">this</span>.<span class=\"keyword\">constructor</span>(function () &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">                 &#125;);</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (status == PENDING) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">this</span>.defferd.push(o);</span><br><span class=\"line\">                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == FULFILLED || status == REJECTED) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">this</span>.handle(o);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> o.promise;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"时间戳","date":"2016-09-17T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是Unix时间戳？\n\nUnix时间戳指的是：当前时刻（年-月-日-时-分-秒）距离格林威治时间（1970年1月1日00时00分00秒）的**总秒数**（单位是秒不是毫秒）。\n\n**在js中获得时间戳：**\n\n1. 使用Date.now()\n\n返回当前时刻的时间戳\n\n2. 使用+操作符\n\n在不支持Date.now()的浏览器中可以如下所示获得当前时刻的时间戳：\n\nvar t = +new Date();\n\n3. 获得某一个指定时间的时间戳\n\n**date.getTime()对象方法**\n\n```\neg: var date = new Date(2016,8,20,19,54,11);\n    var t = date.getTime()/1000; //getTime()得到的单位是毫秒\n```\n\n**Date.parse()静态方法**\n\n```\neg: var date = new Date(2016,8,20,19,54,11);\n    Date.parse(date)/1000; //Date.parse()得到的单位是毫秒\n```\n\n**已知时间戳，输出日期：date.setTime(毫秒)**\n\nvar timestamp = 1403058804;\nvar newDate = new Date();\nnewDate.setTime(timestamp * 1000);\n\n### 二. moment.js\n\nmoment.js是一个js日期处理类库\n\n#### 1. 实现comment.js中按规定格式输出日期\n\n```\nDate.prototype.format = function(format) {\n       var date = {\n              \"M+\": this.getMonth() + 1,\n              \"D+\": this.getDate(),\n              \"h+\": this.getHours(),\n              \"m+\": this.getMinutes(),\n              \"s+\": this.getSeconds(),\n       };\n       if (/(Y+)/i.test(format)) {\n              format = format.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length));\n       }\n       for (var k in date) {\n              if (new RegExp(\"(\" + k + \")\").test(format)) {\n                     format = format.replace(RegExp.$1, RegExp.$1.length == 1\n                            ? date[k] : (\"00\" + date[k]).substr((\"\" + date[k]).length));\n              }\n       }\n       return format;\n}\nconsole.log(newDate.format('YYYY-MM-DD h:m:s'));\n```\n\n#### 2. 输出当前日期YYYY-MM-DD（不使用正则表达式）\n\n```\n\tfunction nowDate() {\n\t  \t\tvar nowDate = new Date();\n\t  \t\tvar year = nowDate.getFullYear();\n\t  \t\tvar month = parseInt(nowDate.getMonth()) + 1;\n\t  \t\tvar day = parseInt(nowDate.getDate());\n\t  \t\tif(month < 10) {\n\t  \t\t\tmonth = '0' + month;\n\t  \t\t}\n\n\t  \t\tif(day < 10) {\n\t  \t\t\tday = '0' + day;\n\t  \t\t}\n\n\t  \t\tvar result = year + '-' + month + '-' + day;\n\t  \t\treturn result;\n\t  \t}\n\t  \tconsole.log(nowDate());\n```\n\n**要注意的地方：**\n\n- 获取年份的函数是：date.getFullyear()\n- 获取月份的函数是从0开始算起：12月份 date.getMonth() = 11\n- 获取天数的函数是：date.getDate()\n- 获取星期的函数是：date.getDay() 注意，周天不是7而是0","source":"_posts/2016-09-20-时间戳.md","raw":"---\nlayout: post\ntitle: 时间戳\ndate: 2016-09-18\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 什么是Unix时间戳？\n\nUnix时间戳指的是：当前时刻（年-月-日-时-分-秒）距离格林威治时间（1970年1月1日00时00分00秒）的**总秒数**（单位是秒不是毫秒）。\n\n**在js中获得时间戳：**\n\n1. 使用Date.now()\n\n返回当前时刻的时间戳\n\n2. 使用+操作符\n\n在不支持Date.now()的浏览器中可以如下所示获得当前时刻的时间戳：\n\nvar t = +new Date();\n\n3. 获得某一个指定时间的时间戳\n\n**date.getTime()对象方法**\n\n```\neg: var date = new Date(2016,8,20,19,54,11);\n    var t = date.getTime()/1000; //getTime()得到的单位是毫秒\n```\n\n**Date.parse()静态方法**\n\n```\neg: var date = new Date(2016,8,20,19,54,11);\n    Date.parse(date)/1000; //Date.parse()得到的单位是毫秒\n```\n\n**已知时间戳，输出日期：date.setTime(毫秒)**\n\nvar timestamp = 1403058804;\nvar newDate = new Date();\nnewDate.setTime(timestamp * 1000);\n\n### 二. moment.js\n\nmoment.js是一个js日期处理类库\n\n#### 1. 实现comment.js中按规定格式输出日期\n\n```\nDate.prototype.format = function(format) {\n       var date = {\n              \"M+\": this.getMonth() + 1,\n              \"D+\": this.getDate(),\n              \"h+\": this.getHours(),\n              \"m+\": this.getMinutes(),\n              \"s+\": this.getSeconds(),\n       };\n       if (/(Y+)/i.test(format)) {\n              format = format.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length));\n       }\n       for (var k in date) {\n              if (new RegExp(\"(\" + k + \")\").test(format)) {\n                     format = format.replace(RegExp.$1, RegExp.$1.length == 1\n                            ? date[k] : (\"00\" + date[k]).substr((\"\" + date[k]).length));\n              }\n       }\n       return format;\n}\nconsole.log(newDate.format('YYYY-MM-DD h:m:s'));\n```\n\n#### 2. 输出当前日期YYYY-MM-DD（不使用正则表达式）\n\n```\n\tfunction nowDate() {\n\t  \t\tvar nowDate = new Date();\n\t  \t\tvar year = nowDate.getFullYear();\n\t  \t\tvar month = parseInt(nowDate.getMonth()) + 1;\n\t  \t\tvar day = parseInt(nowDate.getDate());\n\t  \t\tif(month < 10) {\n\t  \t\t\tmonth = '0' + month;\n\t  \t\t}\n\n\t  \t\tif(day < 10) {\n\t  \t\t\tday = '0' + day;\n\t  \t\t}\n\n\t  \t\tvar result = year + '-' + month + '-' + day;\n\t  \t\treturn result;\n\t  \t}\n\t  \tconsole.log(nowDate());\n```\n\n**要注意的地方：**\n\n- 获取年份的函数是：date.getFullyear()\n- 获取月份的函数是从0开始算起：12月份 date.getMonth() = 11\n- 获取天数的函数是：date.getDate()\n- 获取星期的函数是：date.getDay() 注意，周天不是7而是0","slug":"2016-09-20-时间戳","published":1,"updated":"2016-09-20T12:15:14.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockn00d4d5u8tq23cb1s","content":"<h3 id=\"一-什么是Unix时间戳？\"><a href=\"#一-什么是Unix时间戳？\" class=\"headerlink\" title=\"一. 什么是Unix时间戳？\"></a>一. 什么是Unix时间戳？</h3><p>Unix时间戳指的是：当前时刻（年-月-日-时-分-秒）距离格林威治时间（1970年1月1日00时00分00秒）的<strong>总秒数</strong>（单位是秒不是毫秒）。</p>\n<p><strong>在js中获得时间戳：</strong></p>\n<ol>\n<li>使用Date.now()</li>\n</ol>\n<p>返回当前时刻的时间戳</p>\n<ol>\n<li>使用+操作符</li>\n</ol>\n<p>在不支持Date.now()的浏览器中可以如下所示获得当前时刻的时间戳：</p>\n<p>var t = +new Date();</p>\n<ol>\n<li>获得某一个指定时间的时间戳</li>\n</ol>\n<p><strong>date.getTime()对象方法</strong></p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: <span class=\"built_in\">var</span> <span class=\"built_in\">date</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2016</span>,<span class=\"number\">8</span>,<span class=\"number\">20</span>,<span class=\"number\">19</span>,<span class=\"number\">54</span>,<span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"built_in\">var</span> t = <span class=\"built_in\">date</span>.getTime()/<span class=\"number\">1000</span>; <span class=\"comment\">//getTime()得到的单位是毫秒</span></span><br></pre></td></tr></table></figure>\n<p><strong>Date.parse()静态方法</strong></p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: var <span class=\"built_in\">date</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2016</span>,<span class=\"number\">8</span>,<span class=\"number\">20</span>,<span class=\"number\">19</span>,<span class=\"number\">54</span>,<span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>.<span class=\"built_in\">parse</span>(<span class=\"built_in\">date</span>)/<span class=\"number\">1000</span>; <span class=\"comment\">//Date.parse()得到的单位是毫秒</span></span><br></pre></td></tr></table></figure>\n<p><strong>已知时间戳，输出日期：date.setTime(毫秒)</strong></p>\n<p>var timestamp = 1403058804;<br>var newDate = new Date();<br>newDate.setTime(timestamp * 1000);</p>\n<h3 id=\"二-moment-js\"><a href=\"#二-moment-js\" class=\"headerlink\" title=\"二. moment.js\"></a>二. moment.js</h3><p>moment.js是一个js日期处理类库</p>\n<h4 id=\"1-实现comment-js中按规定格式输出日期\"><a href=\"#1-实现comment-js中按规定格式输出日期\" class=\"headerlink\" title=\"1. 实现comment.js中按规定格式输出日期\"></a>1. 实现comment.js中按规定格式输出日期</h4><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.format = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">format</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">var</span> <span class=\"built_in\">date</span> = &#123;</span><br><span class=\"line\">              <span class=\"string\">\"M+\"</span>: <span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">1</span>,</span><br><span class=\"line\">              <span class=\"string\">\"D+\"</span>: <span class=\"keyword\">this</span>.getDate(),</span><br><span class=\"line\">              <span class=\"string\">\"h+\"</span>: <span class=\"keyword\">this</span>.getHours(),</span><br><span class=\"line\">              <span class=\"string\">\"m+\"</span>: <span class=\"keyword\">this</span>.getMinutes(),</span><br><span class=\"line\">              <span class=\"string\">\"s+\"</span>: <span class=\"keyword\">this</span>.getSeconds(),</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"regexp\">/(Y+)/i</span>.test(format)) &#123;</span><br><span class=\"line\">              format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, (<span class=\"keyword\">this</span>.getFullYear() + <span class=\"string\">''</span>).substr(<span class=\"number\">4</span> - <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"built_in\">var</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">date</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(\"</span> + k + <span class=\"string\">\")\"</span>).test(format)) &#123;</span><br><span class=\"line\">                     format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length == <span class=\"number\">1</span></span><br><span class=\"line\">                            ? <span class=\"built_in\">date</span>[k] : (<span class=\"string\">\"00\"</span> + <span class=\"built_in\">date</span>[k]).substr((<span class=\"string\">\"\"</span> + <span class=\"built_in\">date</span>[k]).length));</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> format;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newDate.format(<span class=\"string\">'YYYY-MM-DD h:m:s'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-输出当前日期YYYY-MM-DD（不使用正则表达式）\"><a href=\"#2-输出当前日期YYYY-MM-DD（不使用正则表达式）\" class=\"headerlink\" title=\"2. 输出当前日期YYYY-MM-DD（不使用正则表达式）\"></a>2. 输出当前日期YYYY-MM-DD（不使用正则表达式）</h4><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function nowDate() &#123;</span><br><span class=\"line\">  \t\tvar nowDate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">  \t\tvar <span class=\"built_in\">year</span> = nowDate.getFullYear();</span><br><span class=\"line\">  \t\tvar <span class=\"built_in\">month</span> = parseInt(nowDate.getMonth()) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  \t\tvar <span class=\"built_in\">day</span> = parseInt(nowDate.getDate());</span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">month</span> &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"built_in\">month</span> = <span class=\"string\">'0'</span> + <span class=\"built_in\">month</span>;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">day</span> &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"built_in\">day</span> = <span class=\"string\">'0'</span> + <span class=\"built_in\">day</span>;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t\tvar result = <span class=\"built_in\">year</span> + <span class=\"string\">'-'</span> + <span class=\"built_in\">month</span> + <span class=\"string\">'-'</span> + <span class=\"built_in\">day</span>;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \tconsole.<span class=\"built_in\">log</span>(nowDate());</span><br></pre></td></tr></table></figure>\n<p><strong>要注意的地方：</strong></p>\n<ul>\n<li>获取年份的函数是：date.getFullyear()</li>\n<li>获取月份的函数是从0开始算起：12月份 date.getMonth() = 11</li>\n<li>获取天数的函数是：date.getDate()</li>\n<li>获取星期的函数是：date.getDay() 注意，周天不是7而是0</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-什么是Unix时间戳？\"><a href=\"#一-什么是Unix时间戳？\" class=\"headerlink\" title=\"一. 什么是Unix时间戳？\"></a>一. 什么是Unix时间戳？</h3><p>Unix时间戳指的是：当前时刻（年-月-日-时-分-秒）距离格林威治时间（1970年1月1日00时00分00秒）的<strong>总秒数</strong>（单位是秒不是毫秒）。</p>\n<p><strong>在js中获得时间戳：</strong></p>\n<ol>\n<li>使用Date.now()</li>\n</ol>\n<p>返回当前时刻的时间戳</p>\n<ol>\n<li>使用+操作符</li>\n</ol>\n<p>在不支持Date.now()的浏览器中可以如下所示获得当前时刻的时间戳：</p>\n<p>var t = +new Date();</p>\n<ol>\n<li>获得某一个指定时间的时间戳</li>\n</ol>\n<p><strong>date.getTime()对象方法</strong></p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: <span class=\"built_in\">var</span> <span class=\"built_in\">date</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2016</span>,<span class=\"number\">8</span>,<span class=\"number\">20</span>,<span class=\"number\">19</span>,<span class=\"number\">54</span>,<span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"built_in\">var</span> t = <span class=\"built_in\">date</span>.getTime()/<span class=\"number\">1000</span>; <span class=\"comment\">//getTime()得到的单位是毫秒</span></span><br></pre></td></tr></table></figure>\n<p><strong>Date.parse()静态方法</strong></p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg: var <span class=\"built_in\">date</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2016</span>,<span class=\"number\">8</span>,<span class=\"number\">20</span>,<span class=\"number\">19</span>,<span class=\"number\">54</span>,<span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>.<span class=\"built_in\">parse</span>(<span class=\"built_in\">date</span>)/<span class=\"number\">1000</span>; <span class=\"comment\">//Date.parse()得到的单位是毫秒</span></span><br></pre></td></tr></table></figure>\n<p><strong>已知时间戳，输出日期：date.setTime(毫秒)</strong></p>\n<p>var timestamp = 1403058804;<br>var newDate = new Date();<br>newDate.setTime(timestamp * 1000);</p>\n<h3 id=\"二-moment-js\"><a href=\"#二-moment-js\" class=\"headerlink\" title=\"二. moment.js\"></a>二. moment.js</h3><p>moment.js是一个js日期处理类库</p>\n<h4 id=\"1-实现comment-js中按规定格式输出日期\"><a href=\"#1-实现comment-js中按规定格式输出日期\" class=\"headerlink\" title=\"1. 实现comment.js中按规定格式输出日期\"></a>1. 实现comment.js中按规定格式输出日期</h4><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.format = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">format</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">var</span> <span class=\"built_in\">date</span> = &#123;</span><br><span class=\"line\">              <span class=\"string\">\"M+\"</span>: <span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">1</span>,</span><br><span class=\"line\">              <span class=\"string\">\"D+\"</span>: <span class=\"keyword\">this</span>.getDate(),</span><br><span class=\"line\">              <span class=\"string\">\"h+\"</span>: <span class=\"keyword\">this</span>.getHours(),</span><br><span class=\"line\">              <span class=\"string\">\"m+\"</span>: <span class=\"keyword\">this</span>.getMinutes(),</span><br><span class=\"line\">              <span class=\"string\">\"s+\"</span>: <span class=\"keyword\">this</span>.getSeconds(),</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"regexp\">/(Y+)/i</span>.test(format)) &#123;</span><br><span class=\"line\">              format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, (<span class=\"keyword\">this</span>.getFullYear() + <span class=\"string\">''</span>).substr(<span class=\"number\">4</span> - <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"built_in\">var</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">date</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(\"</span> + k + <span class=\"string\">\")\"</span>).test(format)) &#123;</span><br><span class=\"line\">                     format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length == <span class=\"number\">1</span></span><br><span class=\"line\">                            ? <span class=\"built_in\">date</span>[k] : (<span class=\"string\">\"00\"</span> + <span class=\"built_in\">date</span>[k]).substr((<span class=\"string\">\"\"</span> + <span class=\"built_in\">date</span>[k]).length));</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> format;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newDate.format(<span class=\"string\">'YYYY-MM-DD h:m:s'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-输出当前日期YYYY-MM-DD（不使用正则表达式）\"><a href=\"#2-输出当前日期YYYY-MM-DD（不使用正则表达式）\" class=\"headerlink\" title=\"2. 输出当前日期YYYY-MM-DD（不使用正则表达式）\"></a>2. 输出当前日期YYYY-MM-DD（不使用正则表达式）</h4><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function nowDate() &#123;</span><br><span class=\"line\">  \t\tvar nowDate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">  \t\tvar <span class=\"built_in\">year</span> = nowDate.getFullYear();</span><br><span class=\"line\">  \t\tvar <span class=\"built_in\">month</span> = parseInt(nowDate.getMonth()) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  \t\tvar <span class=\"built_in\">day</span> = parseInt(nowDate.getDate());</span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">month</span> &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"built_in\">month</span> = <span class=\"string\">'0'</span> + <span class=\"built_in\">month</span>;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">day</span> &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"built_in\">day</span> = <span class=\"string\">'0'</span> + <span class=\"built_in\">day</span>;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t\tvar result = <span class=\"built_in\">year</span> + <span class=\"string\">'-'</span> + <span class=\"built_in\">month</span> + <span class=\"string\">'-'</span> + <span class=\"built_in\">day</span>;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \tconsole.<span class=\"built_in\">log</span>(nowDate());</span><br></pre></td></tr></table></figure>\n<p><strong>要注意的地方：</strong></p>\n<ul>\n<li>获取年份的函数是：date.getFullyear()</li>\n<li>获取月份的函数是从0开始算起：12月份 date.getMonth() = 11</li>\n<li>获取天数的函数是：date.getDate()</li>\n<li>获取星期的函数是：date.getDay() 注意，周天不是7而是0</li>\n</ul>\n"},{"layout":"post","title":"二叉树的遍历——找出和为n的路径","date":"2016-09-19T16:00:00.000Z","description":null,"_content":"\n### 一. 二叉树\n\n#### 1. 什么是二叉树？\n\n**树**是一种非线性的数据结构，以分层的方式存储数据。\n\n**二叉树**是一种特殊的树，子节点数不超过2个。\n\n**二叉查找树**是一种特殊的二叉树，较小的数存在左子节点中，较大的数存在右子节点中。\n\n#### 2. 二叉树的实现\n\n**二叉树中的一个节点类：**\n\n```\n\n\tfunction Node(data, left, right, parent, count) {\n\t\n\t\t//五个属性，分别保存该节点的数值，左子节点，右子节点，父节点，该值出现的次数\n\t\tthis.data = data;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.parent = parent;\n\t\tthis.count = 1;\n\n\t\t//一个方法，用来得到当前节点的值\n\t\tthis.show = show;\n\t}\n\n\tNode.prototype = {\n\t\tconstructor: Node,\n\t\n\t\tshow: function() {\n\t\t\treturn this.data;\n\t\t}\n\t}\n```\n\n**二叉查找类BST**\n\n```\n\tfunction BST() {\n\t\t//二叉查找树当前的根节点（最上面的节点）\n\t\tthis.root = null;\n\t}\n\n\tBST.prototype = {\n\t\tconstructor: BST,\n\n\t\t//插入节点\n\t\tinsert: function(){},\n\n\t\t//遍历节点\n\t\tpreOrder: fuction(){},\n\t\tinOrder: function(){},\n\t\tbeforeOrder: function(){},\n\n\t\t//由给定值获取节点\n\t\tgetMin: function(){},\n\t\tgetMax: function(){},\n\t\tgetNum: function(){},\n\n\t\t//删除节点\n\t\tremove: function(){},\n\t\tremoveNode: function(){},\n\n\t\t//统计节点出现的次数\n\t\tupdateCount: function(){}\t\t\n\t}\n```\n\n(1) 插入节点\n\n```\n\t\t//插入给定值\n\t\tinsert: function(data) {\n\t\t\n\t\t\t//创建当前需要插入的节点\n\t\t\tvar newNode = new Node(data, null, null);\n\t\t\n\t\t\t//如果当前没有根节点，那么将待插入的节点作为根节点\n\t\t\tif(this.root == null) {\n\t\t\t\tthis.root = newNode;\n\t\t\t}else {\n\n\t\t\t\t//当前节点初始值是根节点\n\t\t\t\tvar current = this.root;\n\t\t\t\tvar parent;\n\t\t\t\twhile(true) {\n\t\t\t\t\tparent = current;\n\t\t\t\t\n\t\t\t\t\t//如果待插入的值<当前节点的数值\n\t\t\t\t\tif(data < current.data) {\n\t\t\t\t\t\n\t\t\t\t\t\t//将当前节点的左子节点变为新的当前节点\n\t\t\t\t\t\tcurrent = current.left;\n\n\t\t\t\t\t\t//当当前节点变为空的时候，就找到了插入的位置，跳出循环\n\t\t\t\t\t\tif(current == null) {\n\t\t\t\t\t\t\tparent.left = newNode;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcurrent = current.right;\n\t\t\t\t\t\tif(current == null) {\n\t\t\t\t\t\t\tparent.right = newNode;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n(2) 遍历所有节点\n\n```\n\t\t\n\t\t//先序遍历，先中，再左，最后右\n\t\tpreOrder: function(node) {\n\t\t\tif(!node) {\n\t\t\t\tconsole.log(node.show() + ' ');\n\t\t\t\tinOrder(node.left);\n\t\t\t\tinOrder(node.right);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//中序遍历，先左，再中，最后右\n\t\tinOrder: function(node) {\n\t\t\tif(!node) {\n\t\t\t\tinOrder(node.left);\n\t\t\t\tconsole.log(node.show() + ' ');\n\t\t\t\tinOrder(node.right);\n\t\t\t}\n\t\t}\n\n\t\t//后序遍历，先左，后右，再中\n\t\tbeforeOrder: function(node) {\n\t\t\tif(!node) {\t\t\t\t\n\t\t\t\tinOrder(node.left);\t\t\t\t\n\t\t\t\tinOrder(node.right);\n\t\t\t\tconsole.log(node.show() + ' ');\n\t\t\t}\n\t\t}\n```\n\n(3) 查找节点\n\n```\n\n\t//找最小值，二叉查找树上找最小值，只需要找到最左边的一个子节点即可\n\t\tgetMin: function() {\n\t\t\tvar current = this.root;\n\t\t\twhile(!current.left) {\n\t\t\t\tcurrent = current.left;\n\t\t\t}\n\t\t\treturn current.data;\n\t\t}\n\n\t\t//找最大值，二叉查找树上找最大值，只需要找到最右边的一个子节点即可\n\t\tgetMax: function() {\n\t\t\tvar current = this.root;\n\t\t\twhile(!current.right) {\n\t\t\t\tcurrent = current.right;\n\t\t\t}\n\t\t\treturn current.data;\n\t\t}\n\t\t\n\t\t//找到给定值\n\t\tgetNum: function(data) {\n\t\t\tvar current = this.root;\n\t\t\twhile(!current) {\n\t\t\t\tif(current.data == data) {\n\t\t\t\t\treturn current;\n\t\t\t\t}else if(data < current.data) {\n\t\t\t\t\tcurrent = current.left;\n\t\t\t\t}else {\n\t\t\t\t\tcurrent = current.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n```\n\n(4) 删除节点\n\n```\n\n\tfunction remove(data) {\n\t\tthis.root = removeNode(this.root, data);\n\t}\n\n\t//node指的是遍历的节点，data是需要删除的数据\n\tfunction removeNode(node, data) {\n\t\tif(node == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//如果该节点的数值等于需要删除的数据\n\t\tif(data == node.data) {\n\t\t\t\n\t\t\t//没有子节点的节点\n\t\t\tif(node.left == null && node.right == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t//没有左子节点的节点\n\t\t\tif(node.left == left) {\n\t\t\t\treturn node.right;\n\t\t\t}\n\n\t\t\t//没有右子节点的节点\n\t\t\tif(node.right == right) {\n\t\t\t\treturn node.left;\n\t\t\t}\n\n\t\t\t//有两个子节点的节点，将node上值变为右子节点中的最小值，然后删除右子节点中的最小值\n\t\t\tvar tempNode = getSmallest(node.right);//获取一层子节点中的最小值\n\t\t\tnode.data = tempNode.data;\n\t\t\tnode.right = removeNode(node.right, tempNode.data);\n\t\t\treturn node;\n\n\t\t//当要删除的值小于该节点的数值时\t\t\t\n\t\t} else if(data < node.data) {\n\t\t\tnode.left = removeNode(node.left, data);\n\t\t\treturn node;\n\n\t\t//当要删除的值大于该节点的数值时\n\t\t} else {\n\t\t\tnode.right = removeNode(node.right, data);\n\t\t\treturn node;\n\t\t}\n\t}\n```\n\n（5）统计节点出现的次数\n\n```\n\n\t\t//更新节点出现的次数\n\t\tupdateCount: function(data) {\n\t\t\tvar grade = this.getNum(data);\n\t\t\tgrade.count++;\n\t\t\treturn grade;\n\t\t}\n```\n\n### 二. 二叉树的相关问题\n\n#### 1. 统计一个数据集中某个数字出现的次数\n\n```\n\n\tfunction findNumCount(arr,n) {\n\t\tvar grades = new BST();\n\t\n\t\tfor(var i = 0; i < arr.length; i++) {\n\t\t\tvar g = arr[i];\n\t\t\tvar grade = grades.getNum(g);\n\n\t\t\tif(grade) {\n\t\t\t\tgrades.insert(g);\n\t\t\t}else {\n\t\t\t\tgrades.updateCount(g);\n\t\t\t}\n\t\t}\n\n\t\tvar some = grades.getNum(n);\n\t\treturn some.count;\n\t}\n```\n\n#### 2. 给定一个二叉树，找出和为n的路径\n\n```\n\n\tfunction toSumN(sum) {\n\t\tvar curSum = 0;\n\t\tvar count = 0;\n\t\tvar path = [];\n\t\t\n\t\tfunction findPath(sum, p) {\n\t\t\tif(p != null) {\n\t\t\t\tpath.push(p);\n\t\t\t\tcurSum = curSum + p.value;\n\t\t\t\t\n\t\t\t\tif(p.leftChild == null && p.rightChild == null) {\n\t\t\t\t\tif(curSum == sum) {\n\t\t\t\t\t\tconsole.log(path);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcurSum = curSum - path[path.length - 1].value;\n\t\t\t\t\tpath.pop();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(p.leftChild != null) {\n\t\t\t\t\t\tfindPath(sum, p.leftChild);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(p.rightChild != null) {\n\t\t\t\t\t\tfindPath(sum, p.rightChild);\n\t\t\t\t\t}\n\t\t\t\t\tcurSum = curSum - path[path.length - 1].value;\n\t\t\t\t\tpath.pop();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n```","source":"_posts/2016-09-20-二叉树的遍历——找出和为n的路径.md","raw":"---\nlayout: post\ntitle: 二叉树的遍历——找出和为n的路径\ndate: 2016-09-20\ncategories: 算法学习\ntags: [算法]\ndescription: \n---\n\n### 一. 二叉树\n\n#### 1. 什么是二叉树？\n\n**树**是一种非线性的数据结构，以分层的方式存储数据。\n\n**二叉树**是一种特殊的树，子节点数不超过2个。\n\n**二叉查找树**是一种特殊的二叉树，较小的数存在左子节点中，较大的数存在右子节点中。\n\n#### 2. 二叉树的实现\n\n**二叉树中的一个节点类：**\n\n```\n\n\tfunction Node(data, left, right, parent, count) {\n\t\n\t\t//五个属性，分别保存该节点的数值，左子节点，右子节点，父节点，该值出现的次数\n\t\tthis.data = data;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.parent = parent;\n\t\tthis.count = 1;\n\n\t\t//一个方法，用来得到当前节点的值\n\t\tthis.show = show;\n\t}\n\n\tNode.prototype = {\n\t\tconstructor: Node,\n\t\n\t\tshow: function() {\n\t\t\treturn this.data;\n\t\t}\n\t}\n```\n\n**二叉查找类BST**\n\n```\n\tfunction BST() {\n\t\t//二叉查找树当前的根节点（最上面的节点）\n\t\tthis.root = null;\n\t}\n\n\tBST.prototype = {\n\t\tconstructor: BST,\n\n\t\t//插入节点\n\t\tinsert: function(){},\n\n\t\t//遍历节点\n\t\tpreOrder: fuction(){},\n\t\tinOrder: function(){},\n\t\tbeforeOrder: function(){},\n\n\t\t//由给定值获取节点\n\t\tgetMin: function(){},\n\t\tgetMax: function(){},\n\t\tgetNum: function(){},\n\n\t\t//删除节点\n\t\tremove: function(){},\n\t\tremoveNode: function(){},\n\n\t\t//统计节点出现的次数\n\t\tupdateCount: function(){}\t\t\n\t}\n```\n\n(1) 插入节点\n\n```\n\t\t//插入给定值\n\t\tinsert: function(data) {\n\t\t\n\t\t\t//创建当前需要插入的节点\n\t\t\tvar newNode = new Node(data, null, null);\n\t\t\n\t\t\t//如果当前没有根节点，那么将待插入的节点作为根节点\n\t\t\tif(this.root == null) {\n\t\t\t\tthis.root = newNode;\n\t\t\t}else {\n\n\t\t\t\t//当前节点初始值是根节点\n\t\t\t\tvar current = this.root;\n\t\t\t\tvar parent;\n\t\t\t\twhile(true) {\n\t\t\t\t\tparent = current;\n\t\t\t\t\n\t\t\t\t\t//如果待插入的值<当前节点的数值\n\t\t\t\t\tif(data < current.data) {\n\t\t\t\t\t\n\t\t\t\t\t\t//将当前节点的左子节点变为新的当前节点\n\t\t\t\t\t\tcurrent = current.left;\n\n\t\t\t\t\t\t//当当前节点变为空的时候，就找到了插入的位置，跳出循环\n\t\t\t\t\t\tif(current == null) {\n\t\t\t\t\t\t\tparent.left = newNode;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcurrent = current.right;\n\t\t\t\t\t\tif(current == null) {\n\t\t\t\t\t\t\tparent.right = newNode;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n(2) 遍历所有节点\n\n```\n\t\t\n\t\t//先序遍历，先中，再左，最后右\n\t\tpreOrder: function(node) {\n\t\t\tif(!node) {\n\t\t\t\tconsole.log(node.show() + ' ');\n\t\t\t\tinOrder(node.left);\n\t\t\t\tinOrder(node.right);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//中序遍历，先左，再中，最后右\n\t\tinOrder: function(node) {\n\t\t\tif(!node) {\n\t\t\t\tinOrder(node.left);\n\t\t\t\tconsole.log(node.show() + ' ');\n\t\t\t\tinOrder(node.right);\n\t\t\t}\n\t\t}\n\n\t\t//后序遍历，先左，后右，再中\n\t\tbeforeOrder: function(node) {\n\t\t\tif(!node) {\t\t\t\t\n\t\t\t\tinOrder(node.left);\t\t\t\t\n\t\t\t\tinOrder(node.right);\n\t\t\t\tconsole.log(node.show() + ' ');\n\t\t\t}\n\t\t}\n```\n\n(3) 查找节点\n\n```\n\n\t//找最小值，二叉查找树上找最小值，只需要找到最左边的一个子节点即可\n\t\tgetMin: function() {\n\t\t\tvar current = this.root;\n\t\t\twhile(!current.left) {\n\t\t\t\tcurrent = current.left;\n\t\t\t}\n\t\t\treturn current.data;\n\t\t}\n\n\t\t//找最大值，二叉查找树上找最大值，只需要找到最右边的一个子节点即可\n\t\tgetMax: function() {\n\t\t\tvar current = this.root;\n\t\t\twhile(!current.right) {\n\t\t\t\tcurrent = current.right;\n\t\t\t}\n\t\t\treturn current.data;\n\t\t}\n\t\t\n\t\t//找到给定值\n\t\tgetNum: function(data) {\n\t\t\tvar current = this.root;\n\t\t\twhile(!current) {\n\t\t\t\tif(current.data == data) {\n\t\t\t\t\treturn current;\n\t\t\t\t}else if(data < current.data) {\n\t\t\t\t\tcurrent = current.left;\n\t\t\t\t}else {\n\t\t\t\t\tcurrent = current.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n```\n\n(4) 删除节点\n\n```\n\n\tfunction remove(data) {\n\t\tthis.root = removeNode(this.root, data);\n\t}\n\n\t//node指的是遍历的节点，data是需要删除的数据\n\tfunction removeNode(node, data) {\n\t\tif(node == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//如果该节点的数值等于需要删除的数据\n\t\tif(data == node.data) {\n\t\t\t\n\t\t\t//没有子节点的节点\n\t\t\tif(node.left == null && node.right == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t//没有左子节点的节点\n\t\t\tif(node.left == left) {\n\t\t\t\treturn node.right;\n\t\t\t}\n\n\t\t\t//没有右子节点的节点\n\t\t\tif(node.right == right) {\n\t\t\t\treturn node.left;\n\t\t\t}\n\n\t\t\t//有两个子节点的节点，将node上值变为右子节点中的最小值，然后删除右子节点中的最小值\n\t\t\tvar tempNode = getSmallest(node.right);//获取一层子节点中的最小值\n\t\t\tnode.data = tempNode.data;\n\t\t\tnode.right = removeNode(node.right, tempNode.data);\n\t\t\treturn node;\n\n\t\t//当要删除的值小于该节点的数值时\t\t\t\n\t\t} else if(data < node.data) {\n\t\t\tnode.left = removeNode(node.left, data);\n\t\t\treturn node;\n\n\t\t//当要删除的值大于该节点的数值时\n\t\t} else {\n\t\t\tnode.right = removeNode(node.right, data);\n\t\t\treturn node;\n\t\t}\n\t}\n```\n\n（5）统计节点出现的次数\n\n```\n\n\t\t//更新节点出现的次数\n\t\tupdateCount: function(data) {\n\t\t\tvar grade = this.getNum(data);\n\t\t\tgrade.count++;\n\t\t\treturn grade;\n\t\t}\n```\n\n### 二. 二叉树的相关问题\n\n#### 1. 统计一个数据集中某个数字出现的次数\n\n```\n\n\tfunction findNumCount(arr,n) {\n\t\tvar grades = new BST();\n\t\n\t\tfor(var i = 0; i < arr.length; i++) {\n\t\t\tvar g = arr[i];\n\t\t\tvar grade = grades.getNum(g);\n\n\t\t\tif(grade) {\n\t\t\t\tgrades.insert(g);\n\t\t\t}else {\n\t\t\t\tgrades.updateCount(g);\n\t\t\t}\n\t\t}\n\n\t\tvar some = grades.getNum(n);\n\t\treturn some.count;\n\t}\n```\n\n#### 2. 给定一个二叉树，找出和为n的路径\n\n```\n\n\tfunction toSumN(sum) {\n\t\tvar curSum = 0;\n\t\tvar count = 0;\n\t\tvar path = [];\n\t\t\n\t\tfunction findPath(sum, p) {\n\t\t\tif(p != null) {\n\t\t\t\tpath.push(p);\n\t\t\t\tcurSum = curSum + p.value;\n\t\t\t\t\n\t\t\t\tif(p.leftChild == null && p.rightChild == null) {\n\t\t\t\t\tif(curSum == sum) {\n\t\t\t\t\t\tconsole.log(path);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcurSum = curSum - path[path.length - 1].value;\n\t\t\t\t\tpath.pop();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif(p.leftChild != null) {\n\t\t\t\t\t\tfindPath(sum, p.leftChild);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(p.rightChild != null) {\n\t\t\t\t\t\tfindPath(sum, p.rightChild);\n\t\t\t\t\t}\n\t\t\t\t\tcurSum = curSum - path[path.length - 1].value;\n\t\t\t\t\tpath.pop();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n```","slug":"2016-09-20-二叉树的遍历——找出和为n的路径","published":1,"updated":"2016-10-16T01:37:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockp00d8d5u8e2qzkfy5","content":"<h3 id=\"一-二叉树\"><a href=\"#一-二叉树\" class=\"headerlink\" title=\"一. 二叉树\"></a>一. 二叉树</h3><h4 id=\"1-什么是二叉树？\"><a href=\"#1-什么是二叉树？\" class=\"headerlink\" title=\"1. 什么是二叉树？\"></a>1. 什么是二叉树？</h4><p><strong>树</strong>是一种非线性的数据结构，以分层的方式存储数据。</p>\n<p><strong>二叉树</strong>是一种特殊的树，子节点数不超过2个。</p>\n<p><strong>二叉查找树</strong>是一种特殊的二叉树，较小的数存在左子节点中，较大的数存在右子节点中。</p>\n<h4 id=\"2-二叉树的实现\"><a href=\"#2-二叉树的实现\" class=\"headerlink\" title=\"2. 二叉树的实现\"></a>2. 二叉树的实现</h4><p><strong>二叉树中的一个节点类：</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function Node(<span class=\"keyword\">data</span>, left, right, parent, count) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//五个属性，分别保存该节点的数值，左子节点，右子节点，父节点，该值出现的次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = <span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.left = left;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.right = right;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.count = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//一个方法，用来得到当前节点的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.show = show;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Node.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Node,</span><br><span class=\"line\"></span><br><span class=\"line\">\tshow: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二叉查找类BST</strong></p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BST</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//二叉查找树当前的根节点（最上面的节点）</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BST.prototype = &#123;</span><br><span class=\"line\">\tconstructor: BST,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//插入节点</span></span><br><span class=\"line\">\tinsert: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历节点</span></span><br><span class=\"line\">\tpreOrder: fuction()&#123;&#125;,</span><br><span class=\"line\">\tinOrder: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tbeforeOrder: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//由给定值获取节点</span></span><br><span class=\"line\">\tgetMin: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tgetMax: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tgetNum: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//删除节点</span></span><br><span class=\"line\">\tremove: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tremoveNode: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//统计节点出现的次数</span></span><br><span class=\"line\">\tupdateCount: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(1) 插入节点</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入给定值</span></span><br><span class=\"line\">insert: function(<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//创建当前需要插入的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> newNode = new Node(<span class=\"keyword\">data</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果当前没有根节点，那么将待插入的节点作为根节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.root = newNode;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//当前节点初始值是根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tparent = current;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果待插入的值&lt;当前节点的数值</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">data</span> &lt; current.<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将当前节点的左子节点变为新的当前节点</span></span><br><span class=\"line\">\t\t\t\tcurrent = current.left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//当当前节点变为空的时候，就找到了插入的位置，跳出循环</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tparent.left = newNode;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tcurrent = current.right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tparent.right = newNode;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(2) 遍历所有节点</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">//先序遍历，先中，再左，最后右</span><br><span class=\"line\">preOrder: function(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\tif</span>(!<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\t\tconsole</span>.log(<span class=\"keyword\">node</span>.<span class=\"title\">show</span>() + ' ');</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">left</span>);</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//中序遍历，先左，再中，最后右</span><br><span class=\"line\">inOrder: function(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\tif</span>(!<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\t\tinOrder</span>(<span class=\"keyword\">node</span>.<span class=\"title\">left</span>);</span><br><span class=\"line\">\t\tconsole.log(<span class=\"keyword\">node</span>.<span class=\"title\">show</span>() + ' ');</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//后序遍历，先左，后右，再中</span><br><span class=\"line\">beforeOrder: function(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\tif</span>(!<span class=\"keyword\">node</span><span class=\"title\">) &#123;\t\t\t\t</span><br><span class=\"line\">\t\tinOrder</span>(<span class=\"keyword\">node</span>.<span class=\"title\">left</span>);\t\t\t\t</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);</span><br><span class=\"line\">\t\tconsole.log(<span class=\"keyword\">node</span>.<span class=\"title\">show</span>() + ' ');</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(3) 查找节点</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//找最小值，二叉查找树上找最小值，只需要找到最左边的一个子节点即可</span></span><br><span class=\"line\">\tgetMin: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!current.left) &#123;</span><br><span class=\"line\">\t\t\tcurrent = current.left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> current.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//找最大值，二叉查找树上找最大值，只需要找到最右边的一个子节点即可</span></span><br><span class=\"line\">\tgetMax: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!current.right) &#123;</span><br><span class=\"line\">\t\t\tcurrent = current.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> current.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//找到给定值</span></span><br><span class=\"line\">\tgetNum: function(<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!current) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(current.<span class=\"keyword\">data</span> == <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> current;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">data</span> &lt; current.<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\t\tcurrent = current.left;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tcurrent = current.right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>(4) 删除节点</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function remove(data) &#123;</span><br><span class=\"line\">\tthis.root = removeNode(this.root, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//<span class=\"keyword\">node</span><span class=\"title\">指的是遍历的节点，data</span>是需要删除的数据</span><br><span class=\"line\">function removeNode(<span class=\"keyword\">node</span><span class=\"title\">, data</span>) &#123;</span><br><span class=\"line\">\tif(<span class=\"keyword\">node</span> <span class=\"title\">== null</span>) &#123;</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//如果该节点的数值等于需要删除的数据</span><br><span class=\"line\">\tif(data == <span class=\"keyword\">node</span>.<span class=\"title\">data</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//没有子节点的节点</span><br><span class=\"line\">\t\tif(<span class=\"keyword\">node</span>.<span class=\"title\">left</span> == null &amp;&amp; <span class=\"keyword\">node</span>.<span class=\"title\">right</span> == null) &#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//没有左子节点的节点</span><br><span class=\"line\">\t\tif(<span class=\"keyword\">node</span>.<span class=\"title\">left</span> == left) &#123;</span><br><span class=\"line\">\t\t\treturn <span class=\"keyword\">node</span>.<span class=\"title\">right</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//没有右子节点的节点</span><br><span class=\"line\">\t\tif(<span class=\"keyword\">node</span>.<span class=\"title\">right</span> == right) &#123;</span><br><span class=\"line\">\t\t\treturn <span class=\"keyword\">node</span>.<span class=\"title\">left</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//有两个子节点的节点，将<span class=\"keyword\">node</span><span class=\"title\">上值变为右子节点中的最小值，然后删除右子节点中的最小值</span><br><span class=\"line\">\t\tvar</span> tempNode = getSmallest(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);//获取一层子节点中的最小值</span><br><span class=\"line\">\t\t<span class=\"keyword\">node</span>.<span class=\"title\">data</span> = tempNode.data;</span><br><span class=\"line\">\t\t<span class=\"keyword\">node</span>.<span class=\"title\">right</span> = removeNode(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>, tempNode.data);</span><br><span class=\"line\">\t\treturn <span class=\"keyword\">node</span><span class=\"title\">;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//当要删除的值小于该节点的数值时\t\t\t</span><br><span class=\"line\">\t&#125; else</span> if(data <span class=\"tag\">&lt; node.data) &#123;</span><br><span class=\"line\">\t\tnode.left = removeNode(node.left, data);</span><br><span class=\"line\">\t\treturn node;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//当要删除的值大于该节点的数值时</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tnode.right = removeNode(node.right, data);</span><br><span class=\"line\">\t\treturn node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>（5）统计节点出现的次数</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新节点出现的次数</span></span><br><span class=\"line\">updateCount: function(<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> grade = <span class=\"keyword\">this</span>.getNum(<span class=\"keyword\">data</span>);</span><br><span class=\"line\">\tgrade.count++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> grade;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-二叉树的相关问题\"><a href=\"#二-二叉树的相关问题\" class=\"headerlink\" title=\"二. 二叉树的相关问题\"></a>二. 二叉树的相关问题</h3><h4 id=\"1-统计一个数据集中某个数字出现的次数\"><a href=\"#1-统计一个数据集中某个数字出现的次数\" class=\"headerlink\" title=\"1. 统计一个数据集中某个数字出现的次数\"></a>1. 统计一个数据集中某个数字出现的次数</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findNumCount</span><span class=\"params\">(arr,n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> grades = <span class=\"keyword\">new</span> BST();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> g = arr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> grade = grades.getNum(g);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(grade) &#123;</span><br><span class=\"line\">\t\t\tgrades.insert(g);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tgrades.updateCount(g);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> some = grades.getNum(n);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> some.count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-给定一个二叉树，找出和为n的路径\"><a href=\"#2-给定一个二叉树，找出和为n的路径\" class=\"headerlink\" title=\"2. 给定一个二叉树，找出和为n的路径\"></a>2. 给定一个二叉树，找出和为n的路径</h4><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> toSumN(<span class=\"built_in\">sum</span>) &#123;</span><br><span class=\"line\">\tvar curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tvar <span class=\"built_in\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tvar path = [];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span></span> findPath(<span class=\"built_in\">sum</span>, p) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p <span class=\"comment\">!= null) &#123;</span></span><br><span class=\"line\">\t\t\tpath.push(p);</span><br><span class=\"line\">\t\t\tcurSum = curSum + p.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(p.leftChild == null &amp;&amp; p.rightChild == null) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(curSum == <span class=\"built_in\">sum</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tconsole.<span class=\"built_in\">log</span>(path);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">count</span>++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\tcurSum = curSum - path[path.length - <span class=\"number\">1</span>].<span class=\"keyword\">value</span>;</span><br><span class=\"line\">\t\t\t\tpath.pop();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(p.leftChild <span class=\"comment\">!= null) &#123;</span></span><br><span class=\"line\">\t\t\t\t\tfindPath(<span class=\"built_in\">sum</span>, p.leftChild);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(p.rightChild <span class=\"comment\">!= null) &#123;</span></span><br><span class=\"line\">\t\t\t\t\tfindPath(<span class=\"built_in\">sum</span>, p.rightChild);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tcurSum = curSum - path[path.length - <span class=\"number\">1</span>].<span class=\"keyword\">value</span>;</span><br><span class=\"line\">\t\t\t\tpath.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-二叉树\"><a href=\"#一-二叉树\" class=\"headerlink\" title=\"一. 二叉树\"></a>一. 二叉树</h3><h4 id=\"1-什么是二叉树？\"><a href=\"#1-什么是二叉树？\" class=\"headerlink\" title=\"1. 什么是二叉树？\"></a>1. 什么是二叉树？</h4><p><strong>树</strong>是一种非线性的数据结构，以分层的方式存储数据。</p>\n<p><strong>二叉树</strong>是一种特殊的树，子节点数不超过2个。</p>\n<p><strong>二叉查找树</strong>是一种特殊的二叉树，较小的数存在左子节点中，较大的数存在右子节点中。</p>\n<h4 id=\"2-二叉树的实现\"><a href=\"#2-二叉树的实现\" class=\"headerlink\" title=\"2. 二叉树的实现\"></a>2. 二叉树的实现</h4><p><strong>二叉树中的一个节点类：</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function Node(<span class=\"keyword\">data</span>, left, right, parent, count) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//五个属性，分别保存该节点的数值，左子节点，右子节点，父节点，该值出现的次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = <span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.left = left;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.right = right;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.count = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//一个方法，用来得到当前节点的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.show = show;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Node.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Node,</span><br><span class=\"line\"></span><br><span class=\"line\">\tshow: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>二叉查找类BST</strong></p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BST</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//二叉查找树当前的根节点（最上面的节点）</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BST.prototype = &#123;</span><br><span class=\"line\">\tconstructor: BST,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//插入节点</span></span><br><span class=\"line\">\tinsert: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历节点</span></span><br><span class=\"line\">\tpreOrder: fuction()&#123;&#125;,</span><br><span class=\"line\">\tinOrder: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tbeforeOrder: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//由给定值获取节点</span></span><br><span class=\"line\">\tgetMin: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tgetMax: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tgetNum: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//删除节点</span></span><br><span class=\"line\">\tremove: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\">\tremoveNode: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//统计节点出现的次数</span></span><br><span class=\"line\">\tupdateCount: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;&#125;\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(1) 插入节点</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入给定值</span></span><br><span class=\"line\">insert: function(<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//创建当前需要插入的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> newNode = new Node(<span class=\"keyword\">data</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果当前没有根节点，那么将待插入的节点作为根节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.root = newNode;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//当前节点初始值是根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tparent = current;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果待插入的值&lt;当前节点的数值</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">data</span> &lt; current.<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将当前节点的左子节点变为新的当前节点</span></span><br><span class=\"line\">\t\t\t\tcurrent = current.left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//当当前节点变为空的时候，就找到了插入的位置，跳出循环</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tparent.left = newNode;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tcurrent = current.right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tparent.right = newNode;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(2) 遍历所有节点</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">//先序遍历，先中，再左，最后右</span><br><span class=\"line\">preOrder: function(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\tif</span>(!<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\t\tconsole</span>.log(<span class=\"keyword\">node</span>.<span class=\"title\">show</span>() + ' ');</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">left</span>);</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//中序遍历，先左，再中，最后右</span><br><span class=\"line\">inOrder: function(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\tif</span>(!<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\t\tinOrder</span>(<span class=\"keyword\">node</span>.<span class=\"title\">left</span>);</span><br><span class=\"line\">\t\tconsole.log(<span class=\"keyword\">node</span>.<span class=\"title\">show</span>() + ' ');</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//后序遍历，先左，后右，再中</span><br><span class=\"line\">beforeOrder: function(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span><br><span class=\"line\">\tif</span>(!<span class=\"keyword\">node</span><span class=\"title\">) &#123;\t\t\t\t</span><br><span class=\"line\">\t\tinOrder</span>(<span class=\"keyword\">node</span>.<span class=\"title\">left</span>);\t\t\t\t</span><br><span class=\"line\">\t\tinOrder(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);</span><br><span class=\"line\">\t\tconsole.log(<span class=\"keyword\">node</span>.<span class=\"title\">show</span>() + ' ');</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(3) 查找节点</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//找最小值，二叉查找树上找最小值，只需要找到最左边的一个子节点即可</span></span><br><span class=\"line\">\tgetMin: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!current.left) &#123;</span><br><span class=\"line\">\t\t\tcurrent = current.left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> current.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//找最大值，二叉查找树上找最大值，只需要找到最右边的一个子节点即可</span></span><br><span class=\"line\">\tgetMax: function() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!current.right) &#123;</span><br><span class=\"line\">\t\t\tcurrent = current.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> current.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//找到给定值</span></span><br><span class=\"line\">\tgetNum: function(<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!current) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(current.<span class=\"keyword\">data</span> == <span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> current;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">data</span> &lt; current.<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t\t\t\tcurrent = current.left;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tcurrent = current.right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>(4) 删除节点</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function remove(data) &#123;</span><br><span class=\"line\">\tthis.root = removeNode(this.root, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//<span class=\"keyword\">node</span><span class=\"title\">指的是遍历的节点，data</span>是需要删除的数据</span><br><span class=\"line\">function removeNode(<span class=\"keyword\">node</span><span class=\"title\">, data</span>) &#123;</span><br><span class=\"line\">\tif(<span class=\"keyword\">node</span> <span class=\"title\">== null</span>) &#123;</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//如果该节点的数值等于需要删除的数据</span><br><span class=\"line\">\tif(data == <span class=\"keyword\">node</span>.<span class=\"title\">data</span>) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//没有子节点的节点</span><br><span class=\"line\">\t\tif(<span class=\"keyword\">node</span>.<span class=\"title\">left</span> == null &amp;&amp; <span class=\"keyword\">node</span>.<span class=\"title\">right</span> == null) &#123;</span><br><span class=\"line\">\t\t\treturn null;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//没有左子节点的节点</span><br><span class=\"line\">\t\tif(<span class=\"keyword\">node</span>.<span class=\"title\">left</span> == left) &#123;</span><br><span class=\"line\">\t\t\treturn <span class=\"keyword\">node</span>.<span class=\"title\">right</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//没有右子节点的节点</span><br><span class=\"line\">\t\tif(<span class=\"keyword\">node</span>.<span class=\"title\">right</span> == right) &#123;</span><br><span class=\"line\">\t\t\treturn <span class=\"keyword\">node</span>.<span class=\"title\">left</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//有两个子节点的节点，将<span class=\"keyword\">node</span><span class=\"title\">上值变为右子节点中的最小值，然后删除右子节点中的最小值</span><br><span class=\"line\">\t\tvar</span> tempNode = getSmallest(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>);//获取一层子节点中的最小值</span><br><span class=\"line\">\t\t<span class=\"keyword\">node</span>.<span class=\"title\">data</span> = tempNode.data;</span><br><span class=\"line\">\t\t<span class=\"keyword\">node</span>.<span class=\"title\">right</span> = removeNode(<span class=\"keyword\">node</span>.<span class=\"title\">right</span>, tempNode.data);</span><br><span class=\"line\">\t\treturn <span class=\"keyword\">node</span><span class=\"title\">;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//当要删除的值小于该节点的数值时\t\t\t</span><br><span class=\"line\">\t&#125; else</span> if(data <span class=\"tag\">&lt; node.data) &#123;</span><br><span class=\"line\">\t\tnode.left = removeNode(node.left, data);</span><br><span class=\"line\">\t\treturn node;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//当要删除的值大于该节点的数值时</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tnode.right = removeNode(node.right, data);</span><br><span class=\"line\">\t\treturn node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>（5）统计节点出现的次数</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新节点出现的次数</span></span><br><span class=\"line\">updateCount: function(<span class=\"keyword\">data</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> grade = <span class=\"keyword\">this</span>.getNum(<span class=\"keyword\">data</span>);</span><br><span class=\"line\">\tgrade.count++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> grade;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-二叉树的相关问题\"><a href=\"#二-二叉树的相关问题\" class=\"headerlink\" title=\"二. 二叉树的相关问题\"></a>二. 二叉树的相关问题</h3><h4 id=\"1-统计一个数据集中某个数字出现的次数\"><a href=\"#1-统计一个数据集中某个数字出现的次数\" class=\"headerlink\" title=\"1. 统计一个数据集中某个数字出现的次数\"></a>1. 统计一个数据集中某个数字出现的次数</h4><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findNumCount</span><span class=\"params\">(arr,n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> grades = <span class=\"keyword\">new</span> BST();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> g = arr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> grade = grades.getNum(g);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(grade) &#123;</span><br><span class=\"line\">\t\t\tgrades.insert(g);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tgrades.updateCount(g);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> some = grades.getNum(n);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> some.count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-给定一个二叉树，找出和为n的路径\"><a href=\"#2-给定一个二叉树，找出和为n的路径\" class=\"headerlink\" title=\"2. 给定一个二叉树，找出和为n的路径\"></a>2. 给定一个二叉树，找出和为n的路径</h4><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> toSumN(<span class=\"built_in\">sum</span>) &#123;</span><br><span class=\"line\">\tvar curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tvar <span class=\"built_in\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tvar path = [];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span></span> findPath(<span class=\"built_in\">sum</span>, p) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p <span class=\"comment\">!= null) &#123;</span></span><br><span class=\"line\">\t\t\tpath.push(p);</span><br><span class=\"line\">\t\t\tcurSum = curSum + p.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(p.leftChild == null &amp;&amp; p.rightChild == null) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(curSum == <span class=\"built_in\">sum</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tconsole.<span class=\"built_in\">log</span>(path);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">count</span>++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\tcurSum = curSum - path[path.length - <span class=\"number\">1</span>].<span class=\"keyword\">value</span>;</span><br><span class=\"line\">\t\t\t\tpath.pop();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(p.leftChild <span class=\"comment\">!= null) &#123;</span></span><br><span class=\"line\">\t\t\t\t\tfindPath(<span class=\"built_in\">sum</span>, p.leftChild);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(p.rightChild <span class=\"comment\">!= null) &#123;</span></span><br><span class=\"line\">\t\t\t\t\tfindPath(<span class=\"built_in\">sum</span>, p.rightChild);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tcurSum = curSum - path[path.length - <span class=\"number\">1</span>].<span class=\"keyword\">value</span>;</span><br><span class=\"line\">\t\t\t\tpath.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"js中的两种作用域","date":"2016-09-20T16:00:00.000Z","description":null,"_content":"\n- 词法作用域\n- 动态作用域\n\n### 一. 什么是词法作用域和动态作用域？\n\n词法作用域：注重的是write-time，也就是编程的上下文。\n动态作用域：注重的是run-time，也就是运行时的上下文。\n\n词法作用域关注的是函数在何处被定义，动态作用域关注的是函数在何处被调用。\n\njs是词法作用域的语言，但是js里面的this指针却是动态作用域。\n\n**证明js是词法作用域的例子：**\n\n```\n\n\tvar a = 10;\n\tfunction con() {\n\t\tconsole.log(a);\n\t}\n\n\t(function() {\n\t\tvar a = 20;\n\t\tcon(); //打印出的结果是10\n\t})();\n```\n\n这里打印出的结果是10，因为函数con是在全局作用域里面定义的，所以con的作用域为全局作用域，所以函数con里面只能访问到全局作用域里面的变量，而不能访问到匿名函数里面的变量a。\n\n将程序改成下面这样，就会报错：\n\n```\n\n\tfunction con() {\n\t\tconsole.log(a);\n\t}\n\n\t(function() {\n\t\tvar a = 20;\n\t\tcon(); //a is not defined\n\t})();\n```\n\n### 二. ES6中的箭头函数\n\njs中的this是在函数运行时绑定的，根据函数的不同的执行方式，指向的上下文不同。\n\n具体可以看这篇博客：[http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/](http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/)\n\nES6中的箭头函数改变了this的指向，总是指向词法作用域，也就是定义函数时的作用域。\n\n**在ES5中：**\n\n```\n\n\tvar obj = {\n\t\tname: 'aa',\n\t\tgetName: function() {\n\t\t\tvar fn = function() {\n\t\t\t\t//由于这里的fn是作为一个普通函数调用的，所以这里的this指向window\n\t\t\t\tconsole.log(this.name);\n\t\t\t\tconsole.log(this);\n\t\t\t}\n\t\t\tfn();\n\t\t}\n\t}\n\n\tobj.getName();\n\n\t所以，在ES5中如果需要让上述打印出正确的值，需要对this进行hack\n```\n\n**在ES6中使用箭头函数：**\n\n```\n\tvar obj = {\n\t\tname: 'aa',\n\t\tgetName: function() {\n\t\t\t//箭头函数内部的this指向定义函数时的词法作用域\n\t\t\tvar fn = () => {\n\t\t\t\tconsole.log(this.name);\n\t\t\t\tconsole.log(this);\n\t\t\t}\n\t\t\tfn();\n\t\t}\n\t}\n\n\tobj.getName();\n\n```\n\n","source":"_posts/2016-09-21-js中的两种作用域.md","raw":"---\nlayout: post\ntitle: js中的两种作用域\ndate: 2016-09-21\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n- 词法作用域\n- 动态作用域\n\n### 一. 什么是词法作用域和动态作用域？\n\n词法作用域：注重的是write-time，也就是编程的上下文。\n动态作用域：注重的是run-time，也就是运行时的上下文。\n\n词法作用域关注的是函数在何处被定义，动态作用域关注的是函数在何处被调用。\n\njs是词法作用域的语言，但是js里面的this指针却是动态作用域。\n\n**证明js是词法作用域的例子：**\n\n```\n\n\tvar a = 10;\n\tfunction con() {\n\t\tconsole.log(a);\n\t}\n\n\t(function() {\n\t\tvar a = 20;\n\t\tcon(); //打印出的结果是10\n\t})();\n```\n\n这里打印出的结果是10，因为函数con是在全局作用域里面定义的，所以con的作用域为全局作用域，所以函数con里面只能访问到全局作用域里面的变量，而不能访问到匿名函数里面的变量a。\n\n将程序改成下面这样，就会报错：\n\n```\n\n\tfunction con() {\n\t\tconsole.log(a);\n\t}\n\n\t(function() {\n\t\tvar a = 20;\n\t\tcon(); //a is not defined\n\t})();\n```\n\n### 二. ES6中的箭头函数\n\njs中的this是在函数运行时绑定的，根据函数的不同的执行方式，指向的上下文不同。\n\n具体可以看这篇博客：[http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/](http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/)\n\nES6中的箭头函数改变了this的指向，总是指向词法作用域，也就是定义函数时的作用域。\n\n**在ES5中：**\n\n```\n\n\tvar obj = {\n\t\tname: 'aa',\n\t\tgetName: function() {\n\t\t\tvar fn = function() {\n\t\t\t\t//由于这里的fn是作为一个普通函数调用的，所以这里的this指向window\n\t\t\t\tconsole.log(this.name);\n\t\t\t\tconsole.log(this);\n\t\t\t}\n\t\t\tfn();\n\t\t}\n\t}\n\n\tobj.getName();\n\n\t所以，在ES5中如果需要让上述打印出正确的值，需要对this进行hack\n```\n\n**在ES6中使用箭头函数：**\n\n```\n\tvar obj = {\n\t\tname: 'aa',\n\t\tgetName: function() {\n\t\t\t//箭头函数内部的this指向定义函数时的词法作用域\n\t\t\tvar fn = () => {\n\t\t\t\tconsole.log(this.name);\n\t\t\t\tconsole.log(this);\n\t\t\t}\n\t\t\tfn();\n\t\t}\n\t}\n\n\tobj.getName();\n\n```\n\n","slug":"2016-09-21-js中的两种作用域","published":1,"updated":"2016-09-21T09:28:00.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockq00dbd5u8z0uxodf9","content":"<ul>\n<li>词法作用域</li>\n<li>动态作用域</li>\n</ul>\n<h3 id=\"一-什么是词法作用域和动态作用域？\"><a href=\"#一-什么是词法作用域和动态作用域？\" class=\"headerlink\" title=\"一. 什么是词法作用域和动态作用域？\"></a>一. 什么是词法作用域和动态作用域？</h3><p>词法作用域：注重的是write-time，也就是编程的上下文。<br>动态作用域：注重的是run-time，也就是运行时的上下文。</p>\n<p>词法作用域关注的是函数在何处被定义，动态作用域关注的是函数在何处被调用。</p>\n<p>js是词法作用域的语言，但是js里面的this指针却是动态作用域。</p>\n<p><strong>证明js是词法作用域的例子：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">con</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\tcon(); <span class=\"comment\">//打印出的结果是10</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这里打印出的结果是10，因为函数con是在全局作用域里面定义的，所以con的作用域为全局作用域，所以函数con里面只能访问到全局作用域里面的变量，而不能访问到匿名函数里面的变量a。</p>\n<p>将程序改成下面这样，就会报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">con</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\tcon(); <span class=\"comment\">//a is not defined</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-ES6中的箭头函数\"><a href=\"#二-ES6中的箭头函数\" class=\"headerlink\" title=\"二. ES6中的箭头函数\"></a>二. ES6中的箭头函数</h3><p>js中的this是在函数运行时绑定的，根据函数的不同的执行方式，指向的上下文不同。</p>\n<p>具体可以看这篇博客：<a href=\"http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/\">http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/</a></p>\n<p>ES6中的箭头函数改变了this的指向，总是指向词法作用域，也就是定义函数时的作用域。</p>\n<p><strong>在ES5中：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'aa'</span>,</span><br><span class=\"line\">\tgetName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//由于这里的fn是作为一个普通函数调用的，所以这里的this指向window</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfn();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">所以，在ES5中如果需要让上述打印出正确的值，需要对<span class=\"keyword\">this</span>进行hack</span><br></pre></td></tr></table></figure>\n<p><strong>在ES6中使用箭头函数：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'aa'</span>,</span><br><span class=\"line\">\tgetName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//箭头函数内部的this指向定义函数时的词法作用域</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fn = () =&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfn();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName();</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<ul>\n<li>词法作用域</li>\n<li>动态作用域</li>\n</ul>\n<h3 id=\"一-什么是词法作用域和动态作用域？\"><a href=\"#一-什么是词法作用域和动态作用域？\" class=\"headerlink\" title=\"一. 什么是词法作用域和动态作用域？\"></a>一. 什么是词法作用域和动态作用域？</h3><p>词法作用域：注重的是write-time，也就是编程的上下文。<br>动态作用域：注重的是run-time，也就是运行时的上下文。</p>\n<p>词法作用域关注的是函数在何处被定义，动态作用域关注的是函数在何处被调用。</p>\n<p>js是词法作用域的语言，但是js里面的this指针却是动态作用域。</p>\n<p><strong>证明js是词法作用域的例子：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">con</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\tcon(); <span class=\"comment\">//打印出的结果是10</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这里打印出的结果是10，因为函数con是在全局作用域里面定义的，所以con的作用域为全局作用域，所以函数con里面只能访问到全局作用域里面的变量，而不能访问到匿名函数里面的变量a。</p>\n<p>将程序改成下面这样，就会报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">con</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\tcon(); <span class=\"comment\">//a is not defined</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-ES6中的箭头函数\"><a href=\"#二-ES6中的箭头函数\" class=\"headerlink\" title=\"二. ES6中的箭头函数\"></a>二. ES6中的箭头函数</h3><p>js中的this是在函数运行时绑定的，根据函数的不同的执行方式，指向的上下文不同。</p>\n<p>具体可以看这篇博客：<a href=\"http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/\">http://panpanfish.com/2016/05/08/2016-05-08-js%E4%B8%AD%E7%9A%84this%E5%AF%B9%E8%B1%A1/</a></p>\n<p>ES6中的箭头函数改变了this的指向，总是指向词法作用域，也就是定义函数时的作用域。</p>\n<p><strong>在ES5中：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'aa'</span>,</span><br><span class=\"line\">\tgetName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//由于这里的fn是作为一个普通函数调用的，所以这里的this指向window</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfn();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">所以，在ES5中如果需要让上述打印出正确的值，需要对<span class=\"keyword\">this</span>进行hack</span><br></pre></td></tr></table></figure>\n<p><strong>在ES6中使用箭头函数：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'aa'</span>,</span><br><span class=\"line\">\tgetName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//箭头函数内部的this指向定义函数时的词法作用域</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> fn = () =&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfn();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName();</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"实现lazyload","date":"2016-09-21T16:00:00.000Z","description":null,"_content":"\n### 一. 什么是lazyload？\n\nlazyload也叫延迟加载，按需加载\n\n**lazyload的应用举例：**\n\n1. 一个页面中有很多张图片，但是只将页面中可见的图片加载进来，而页面中不可见的图片不加载。\n\n2. 页面滚动到底部才动态加载数据\n\n**lazyload的好处：**\n\n- 网页优化，提高网页加载速度\n- 减少服务器压力\n\n\n### 二. 如何实现图片的lazyload？\n\n原理：判断图片是否出现在视窗内，如果是，则给图片的src赋值。\n\n懒加载实现的过程：\n\n- 可以将网页中的图片都设置为同一张图片\n- 给图片增加自定义属性data-origin='img/example.jpg'\n- 当滚动条到达用户可视区之后，改变图片的src属性为我们缓存的地址\n- 浏览器加载可视区域图\n\n**如何判断图片是否在视窗内：**\n\n`img.offsetTop 是否小于 document.body.scrollTop + document.body.clientHeight`\n\n原生的js实现：\n\n```\n\n\tvar imgs = document.getElementsByTagName('img');\n\t\n\tfunction lazyload() {\n\t\tvar scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n\n\t\tvar viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\n\t\tfor(var i = 0; i < imgs.length; i++) {\n\t\t\tvar y = scrollTop + veiwportSize - img[i].offsetTop;\n\t\t\t\n\t\t\tif(y > 0) {\n\t\t\t\timgs[i].src = imgs[i].getAttribute('data-origin');\n\t\t\t}\n\t\t}\n\t}\n\n\tsetInterval(lazyload, 1000);\n```\n\n### 三. 滚动条滚动到底部，加载更多内容\n\n需要判断是否到达了文件的底部\n\n`document.body.scrollTop + clientHeight 是否大于 document.body.scrollHeight`\n\n实现代码：\n\n```\n//给窗口绑定一个滚动事件\nwindow.onscroll = function() {\n    //垂直滚动的距离\n\tvar scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n\t\n\t//可视窗口的高度\n\tvar clientHeight = document.body.clientHeight || document.documentElement.clientHeight;\n\n    //文档的完整高度\n\tvar scrollHeight = document.body.scrollHeight || document.documentElement.scrollHeight;\n\t\n\t//判断是否到达了文档的最底部，如果是，那么再动态添加元素\n\tif(scrollTop + clientHeight == scrollHeight) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tif(!xhr) {\n\t\t\txhr.open('get', '/...', 'true');\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\tif(xhr.readystate == 4) {\n\t\t\t\t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {\n\t\t\t\t\t\tvar newNode = document.createElement('div');\n\t\t\t\t\t\tnewNode.innerHTML = xhr.responseText;\n\t\t\t\t\t\tdocument.body.appendChild(newNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txhr.send(null);\n\t\t}\n\t}\n}\n\n```","source":"_posts/2016-09-22-实现lazyload.md","raw":"---\nlayout: post\ntitle: 实现lazyload\ndate: 2016-09-22\ncategories: javaScript\ntags: [javaScript]\ndescription: \n---\n\n### 一. 什么是lazyload？\n\nlazyload也叫延迟加载，按需加载\n\n**lazyload的应用举例：**\n\n1. 一个页面中有很多张图片，但是只将页面中可见的图片加载进来，而页面中不可见的图片不加载。\n\n2. 页面滚动到底部才动态加载数据\n\n**lazyload的好处：**\n\n- 网页优化，提高网页加载速度\n- 减少服务器压力\n\n\n### 二. 如何实现图片的lazyload？\n\n原理：判断图片是否出现在视窗内，如果是，则给图片的src赋值。\n\n懒加载实现的过程：\n\n- 可以将网页中的图片都设置为同一张图片\n- 给图片增加自定义属性data-origin='img/example.jpg'\n- 当滚动条到达用户可视区之后，改变图片的src属性为我们缓存的地址\n- 浏览器加载可视区域图\n\n**如何判断图片是否在视窗内：**\n\n`img.offsetTop 是否小于 document.body.scrollTop + document.body.clientHeight`\n\n原生的js实现：\n\n```\n\n\tvar imgs = document.getElementsByTagName('img');\n\t\n\tfunction lazyload() {\n\t\tvar scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n\n\t\tvar viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\n\t\tfor(var i = 0; i < imgs.length; i++) {\n\t\t\tvar y = scrollTop + veiwportSize - img[i].offsetTop;\n\t\t\t\n\t\t\tif(y > 0) {\n\t\t\t\timgs[i].src = imgs[i].getAttribute('data-origin');\n\t\t\t}\n\t\t}\n\t}\n\n\tsetInterval(lazyload, 1000);\n```\n\n### 三. 滚动条滚动到底部，加载更多内容\n\n需要判断是否到达了文件的底部\n\n`document.body.scrollTop + clientHeight 是否大于 document.body.scrollHeight`\n\n实现代码：\n\n```\n//给窗口绑定一个滚动事件\nwindow.onscroll = function() {\n    //垂直滚动的距离\n\tvar scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n\t\n\t//可视窗口的高度\n\tvar clientHeight = document.body.clientHeight || document.documentElement.clientHeight;\n\n    //文档的完整高度\n\tvar scrollHeight = document.body.scrollHeight || document.documentElement.scrollHeight;\n\t\n\t//判断是否到达了文档的最底部，如果是，那么再动态添加元素\n\tif(scrollTop + clientHeight == scrollHeight) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tif(!xhr) {\n\t\t\txhr.open('get', '/...', 'true');\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\tif(xhr.readystate == 4) {\n\t\t\t\t\tif(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {\n\t\t\t\t\t\tvar newNode = document.createElement('div');\n\t\t\t\t\t\tnewNode.innerHTML = xhr.responseText;\n\t\t\t\t\t\tdocument.body.appendChild(newNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txhr.send(null);\n\t\t}\n\t}\n}\n\n```","slug":"2016-09-22-实现lazyload","published":1,"updated":"2016-10-15T07:44:44.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocks00dfd5u8aqnq1s86","content":"<h3 id=\"一-什么是lazyload？\"><a href=\"#一-什么是lazyload？\" class=\"headerlink\" title=\"一. 什么是lazyload？\"></a>一. 什么是lazyload？</h3><p>lazyload也叫延迟加载，按需加载</p>\n<p><strong>lazyload的应用举例：</strong></p>\n<ol>\n<li><p>一个页面中有很多张图片，但是只将页面中可见的图片加载进来，而页面中不可见的图片不加载。</p>\n</li>\n<li><p>页面滚动到底部才动态加载数据</p>\n</li>\n</ol>\n<p><strong>lazyload的好处：</strong></p>\n<ul>\n<li>网页优化，提高网页加载速度</li>\n<li>减少服务器压力</li>\n</ul>\n<h3 id=\"二-如何实现图片的lazyload？\"><a href=\"#二-如何实现图片的lazyload？\" class=\"headerlink\" title=\"二. 如何实现图片的lazyload？\"></a>二. 如何实现图片的lazyload？</h3><p>原理：判断图片是否出现在视窗内，如果是，则给图片的src赋值。</p>\n<p>懒加载实现的过程：</p>\n<ul>\n<li>可以将网页中的图片都设置为同一张图片</li>\n<li>给图片增加自定义属性data-origin=’img/example.jpg’</li>\n<li>当滚动条到达用户可视区之后，改变图片的src属性为我们缓存的地址</li>\n<li>浏览器加载可视区域图</li>\n</ul>\n<p><strong>如何判断图片是否在视窗内：</strong></p>\n<p><code>img.offsetTop 是否小于 document.body.scrollTop + document.body.clientHeight</code></p>\n<p>原生的js实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> imgs = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'img'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazyload</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">window</span>.pageYOffset || <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> viewportSize = <span class=\"built_in\">window</span>.innerHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight || <span class=\"built_in\">document</span>.body.clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> y = scrollTop + veiwportSize - img[i].offsetTop;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\timgs[i].src = imgs[i].getAttribute(<span class=\"string\">'data-origin'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(lazyload, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-滚动条滚动到底部，加载更多内容\"><a href=\"#三-滚动条滚动到底部，加载更多内容\" class=\"headerlink\" title=\"三. 滚动条滚动到底部，加载更多内容\"></a>三. 滚动条滚动到底部，加载更多内容</h3><p>需要判断是否到达了文件的底部</p>\n<p><code>document.body.scrollTop + clientHeight 是否大于 document.body.scrollHeight</code></p>\n<p>实现代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//给窗口绑定一个滚动事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//垂直滚动的距离</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">window</span>.pageYOffset || <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//可视窗口的高度</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> clientHeight = <span class=\"built_in\">document</span>.body.clientHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//文档的完整高度</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> scrollHeight = <span class=\"built_in\">document</span>.body.scrollHeight || <span class=\"built_in\">document</span>.documentElement.scrollHeight;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否到达了文档的最底部，如果是，那么再动态添加元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(scrollTop + clientHeight == scrollHeight) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!xhr) &#123;</span><br><span class=\"line\">\t\t\txhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/...'</span>, <span class=\"string\">'true'</span>);</span><br><span class=\"line\">\t\t\txhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(xhr.readystate == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> newNode = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">\t\t\t\t\t\tnewNode.innerHTML = xhr.responseText;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.body.appendChild(newNode);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\txhr.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"一-什么是lazyload？\"><a href=\"#一-什么是lazyload？\" class=\"headerlink\" title=\"一. 什么是lazyload？\"></a>一. 什么是lazyload？</h3><p>lazyload也叫延迟加载，按需加载</p>\n<p><strong>lazyload的应用举例：</strong></p>\n<ol>\n<li><p>一个页面中有很多张图片，但是只将页面中可见的图片加载进来，而页面中不可见的图片不加载。</p>\n</li>\n<li><p>页面滚动到底部才动态加载数据</p>\n</li>\n</ol>\n<p><strong>lazyload的好处：</strong></p>\n<ul>\n<li>网页优化，提高网页加载速度</li>\n<li>减少服务器压力</li>\n</ul>\n<h3 id=\"二-如何实现图片的lazyload？\"><a href=\"#二-如何实现图片的lazyload？\" class=\"headerlink\" title=\"二. 如何实现图片的lazyload？\"></a>二. 如何实现图片的lazyload？</h3><p>原理：判断图片是否出现在视窗内，如果是，则给图片的src赋值。</p>\n<p>懒加载实现的过程：</p>\n<ul>\n<li>可以将网页中的图片都设置为同一张图片</li>\n<li>给图片增加自定义属性data-origin=’img/example.jpg’</li>\n<li>当滚动条到达用户可视区之后，改变图片的src属性为我们缓存的地址</li>\n<li>浏览器加载可视区域图</li>\n</ul>\n<p><strong>如何判断图片是否在视窗内：</strong></p>\n<p><code>img.offsetTop 是否小于 document.body.scrollTop + document.body.clientHeight</code></p>\n<p>原生的js实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> imgs = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'img'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazyload</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">window</span>.pageYOffset || <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> viewportSize = <span class=\"built_in\">window</span>.innerHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight || <span class=\"built_in\">document</span>.body.clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> y = scrollTop + veiwportSize - img[i].offsetTop;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\timgs[i].src = imgs[i].getAttribute(<span class=\"string\">'data-origin'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(lazyload, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-滚动条滚动到底部，加载更多内容\"><a href=\"#三-滚动条滚动到底部，加载更多内容\" class=\"headerlink\" title=\"三. 滚动条滚动到底部，加载更多内容\"></a>三. 滚动条滚动到底部，加载更多内容</h3><p>需要判断是否到达了文件的底部</p>\n<p><code>document.body.scrollTop + clientHeight 是否大于 document.body.scrollHeight</code></p>\n<p>实现代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//给窗口绑定一个滚动事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//垂直滚动的距离</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> scrollTop = <span class=\"built_in\">window</span>.pageYOffset || <span class=\"built_in\">document</span>.documentElement.scrollTop || <span class=\"built_in\">document</span>.body.scrollTop;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//可视窗口的高度</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> clientHeight = <span class=\"built_in\">document</span>.body.clientHeight || <span class=\"built_in\">document</span>.documentElement.clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//文档的完整高度</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> scrollHeight = <span class=\"built_in\">document</span>.body.scrollHeight || <span class=\"built_in\">document</span>.documentElement.scrollHeight;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否到达了文档的最底部，如果是，那么再动态添加元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(scrollTop + clientHeight == scrollHeight) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!xhr) &#123;</span><br><span class=\"line\">\t\t\txhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/...'</span>, <span class=\"string\">'true'</span>);</span><br><span class=\"line\">\t\t\txhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(xhr.readystate == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span> || xhr.status == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> newNode = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">\t\t\t\t\t\tnewNode.innerHTML = xhr.responseText;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">document</span>.body.appendChild(newNode);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\txhr.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"一台电脑对应多个git账户","date":"2017-03-08T16:00:00.000Z","description":null,"_content":"\n场景：一台电脑与2个git账户连接，很多时候公司会有一个帐号，自己也会又一个git帐号，用来记录或者积累自己学到的一些东西。\n\n### 一. git的两种登录方式\n\n之前对git有一些了解，但是由于最最开始的时候一直使用的是git的图形化操作界面，囧。。。所以好多东西都是只知道表面。\n\n**git支持两种登录方式：**SSH 和 HTTPS\n\n- SSH：密钥的方式，简单来说就是生成一对密钥（公钥和私钥），私钥存在自己的电脑里，公钥存在git网站的设置里，通过这一对钥匙进行配对。\n\n\t优点：每次登录无需输入账号密码，很方便。\n\t\n- HTTPS：使用HTTPS方式，每次都需要输入密码\n\n### 二. 同一个电脑上配置多个git账号\n\n#### 1. 生成SSH Key\n\n```\n\tssh-keygen -t rsa -C \"your_email@163.com\"\n```\n\n注意：这里的`your_email@163.com`是自己的git账号，这个命令也就是为这个账号生成一对密钥。\n\n**这个时候会提示：**\n\n让你输入保存密钥的文件的名字\n\n![image1](/uploads/post/20170309/1.png)\n\n注意：括号里的是默认的文件名，如果你的电脑里已经存在一对SSH Key了的话，那么在这一步一定要输入一个和默认文件名，要不然就会将电脑里面本身的那对SSH Key覆盖掉。\n\n我这里用id_rsa_myself保存我自己git账户的密钥。\n\n```\n\tGenerating public/private rsa key pair.\n\tEnter file in which to save the key (/Users/yupan/.ssh/id_rsa):id_rsa_myself\n```\n\n**接下来：**\n\n这两步可以不用管\n\n![image2](/uploads/post/20170309/2.png)\n\n**密钥生成成功：**\n\n![image3](/uploads/post/20170309/3.png)\n\n\n#### 2. 为系统添加SSH代理(SSH-agent)\n\n**将保存在本机的私钥添加到SSH-Key的代理里**\n\n查看系统的SSH-Key代理\n\n`ssh-add -l`\n\n删除系统原有的SSH-Key代理\n\n`ssh-add -D`\n\n为系统添加自己所有想要添加的代理\n\n`ssh-add ~/.ssh/id_rsa`\n\n`ssh-add ~/.ssh/id_rsa_myself`\n\n#### 3. 将公钥保存在github上\n\ngithub页面 => Settings => SSH and GPG keys\n\n点击 `New SSH key`，然后将`~/.ssh/`文件夹中的 `id_rsa_myself.pub`文件中的内容复制进去，保存即可。\n\n#### 4. 修改.ssh文件中的config配置文件\n\n```\n\t#aaa  (账号1配置)\n\tHost aaa\n    \tHostName github.com （主机地址）\n    \tUser git\t\t\t （用户名）\n    \tIdentityFile ~/.ssh/id_rsa_aaa （相关的认证的SSH文件）\n\n\t#bbb  (账号2配置)\n\tHost bbb\n    \tHostName git.oschina.net \n    \tUser git\n    \tIdentityFile ~/.ssh/id_rsa_bbb\n```\n\n##### 5. 项目与git账号的对应关系\n\n**我们采用ssh的方式克隆一个项目时：**\n\n`git clone git@github.com:userName/myDemo.git`\n\n这里的`github.com`是上面的配置文件中的`HostName`，`userName`是账户名，`myDemo`是项目名。\n\n由于是从远程的`git@github.com:userName/myDemo.git`这个仓库中克隆下来的，因此每次做的改动也会push到对应的账户中。","source":"_posts/2017-03-09-一台电脑对应多个git账户.md","raw":"---\nlayout: post\ntitle: 一台电脑对应多个git账户\ndate: 2017-03-09\ncategories: 工具\ntags: [github]\ndescription: \n---\n\n场景：一台电脑与2个git账户连接，很多时候公司会有一个帐号，自己也会又一个git帐号，用来记录或者积累自己学到的一些东西。\n\n### 一. git的两种登录方式\n\n之前对git有一些了解，但是由于最最开始的时候一直使用的是git的图形化操作界面，囧。。。所以好多东西都是只知道表面。\n\n**git支持两种登录方式：**SSH 和 HTTPS\n\n- SSH：密钥的方式，简单来说就是生成一对密钥（公钥和私钥），私钥存在自己的电脑里，公钥存在git网站的设置里，通过这一对钥匙进行配对。\n\n\t优点：每次登录无需输入账号密码，很方便。\n\t\n- HTTPS：使用HTTPS方式，每次都需要输入密码\n\n### 二. 同一个电脑上配置多个git账号\n\n#### 1. 生成SSH Key\n\n```\n\tssh-keygen -t rsa -C \"your_email@163.com\"\n```\n\n注意：这里的`your_email@163.com`是自己的git账号，这个命令也就是为这个账号生成一对密钥。\n\n**这个时候会提示：**\n\n让你输入保存密钥的文件的名字\n\n![image1](/uploads/post/20170309/1.png)\n\n注意：括号里的是默认的文件名，如果你的电脑里已经存在一对SSH Key了的话，那么在这一步一定要输入一个和默认文件名，要不然就会将电脑里面本身的那对SSH Key覆盖掉。\n\n我这里用id_rsa_myself保存我自己git账户的密钥。\n\n```\n\tGenerating public/private rsa key pair.\n\tEnter file in which to save the key (/Users/yupan/.ssh/id_rsa):id_rsa_myself\n```\n\n**接下来：**\n\n这两步可以不用管\n\n![image2](/uploads/post/20170309/2.png)\n\n**密钥生成成功：**\n\n![image3](/uploads/post/20170309/3.png)\n\n\n#### 2. 为系统添加SSH代理(SSH-agent)\n\n**将保存在本机的私钥添加到SSH-Key的代理里**\n\n查看系统的SSH-Key代理\n\n`ssh-add -l`\n\n删除系统原有的SSH-Key代理\n\n`ssh-add -D`\n\n为系统添加自己所有想要添加的代理\n\n`ssh-add ~/.ssh/id_rsa`\n\n`ssh-add ~/.ssh/id_rsa_myself`\n\n#### 3. 将公钥保存在github上\n\ngithub页面 => Settings => SSH and GPG keys\n\n点击 `New SSH key`，然后将`~/.ssh/`文件夹中的 `id_rsa_myself.pub`文件中的内容复制进去，保存即可。\n\n#### 4. 修改.ssh文件中的config配置文件\n\n```\n\t#aaa  (账号1配置)\n\tHost aaa\n    \tHostName github.com （主机地址）\n    \tUser git\t\t\t （用户名）\n    \tIdentityFile ~/.ssh/id_rsa_aaa （相关的认证的SSH文件）\n\n\t#bbb  (账号2配置)\n\tHost bbb\n    \tHostName git.oschina.net \n    \tUser git\n    \tIdentityFile ~/.ssh/id_rsa_bbb\n```\n\n##### 5. 项目与git账号的对应关系\n\n**我们采用ssh的方式克隆一个项目时：**\n\n`git clone git@github.com:userName/myDemo.git`\n\n这里的`github.com`是上面的配置文件中的`HostName`，`userName`是账户名，`myDemo`是项目名。\n\n由于是从远程的`git@github.com:userName/myDemo.git`这个仓库中克隆下来的，因此每次做的改动也会push到对应的账户中。","slug":"2017-03-09-一台电脑对应多个git账户","published":1,"updated":"2017-03-10T01:39:33.000Z","comments":1,"photos":[],"link":"","_id":"cj035ocku00did5u8q00nfdz5","content":"<p>场景：一台电脑与2个git账户连接，很多时候公司会有一个帐号，自己也会又一个git帐号，用来记录或者积累自己学到的一些东西。</p>\n<h3 id=\"一-git的两种登录方式\"><a href=\"#一-git的两种登录方式\" class=\"headerlink\" title=\"一. git的两种登录方式\"></a>一. git的两种登录方式</h3><p>之前对git有一些了解，但是由于最最开始的时候一直使用的是git的图形化操作界面，囧。。。所以好多东西都是只知道表面。</p>\n<p><strong>git支持两种登录方式：</strong>SSH 和 HTTPS</p>\n<ul>\n<li><p>SSH：密钥的方式，简单来说就是生成一对密钥（公钥和私钥），私钥存在自己的电脑里，公钥存在git网站的设置里，通过这一对钥匙进行配对。</p>\n<p>  优点：每次登录无需输入账号密码，很方便。</p>\n</li>\n<li><p>HTTPS：使用HTTPS方式，每次都需要输入密码</p>\n</li>\n</ul>\n<h3 id=\"二-同一个电脑上配置多个git账号\"><a href=\"#二-同一个电脑上配置多个git账号\" class=\"headerlink\" title=\"二. 同一个电脑上配置多个git账号\"></a>二. 同一个电脑上配置多个git账号</h3><h4 id=\"1-生成SSH-Key\"><a href=\"#1-生成SSH-Key\" class=\"headerlink\" title=\"1. 生成SSH Key\"></a>1. 生成SSH Key</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh-keygen</span> <span class=\"selector-tag\">-t</span> <span class=\"selector-tag\">rsa</span> <span class=\"selector-tag\">-C</span> \"<span class=\"selector-tag\">your_email</span>@<span class=\"keyword\">163</span>.<span class=\"keyword\">com</span>\"</span><br></pre></td></tr></table></figure>\n<p>注意：这里的<code>your_email@163.com</code>是自己的git账号，这个命令也就是为这个账号生成一对密钥。</p>\n<p><strong>这个时候会提示：</strong></p>\n<p>让你输入保存密钥的文件的名字</p>\n<p><img src=\"/uploads/post/20170309/1.png\" alt=\"image1\"></p>\n<p>注意：括号里的是默认的文件名，如果你的电脑里已经存在一对SSH Key了的话，那么在这一步一定要输入一个和默认文件名，要不然就会将电脑里面本身的那对SSH Key覆盖掉。</p>\n<p>我这里用id_rsa_myself保存我自己git账户的密钥。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating <span class=\"keyword\">public</span>/<span class=\"keyword\">private</span> rsa <span class=\"keyword\">key</span> pair.</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> which <span class=\"keyword\">to</span> save the <span class=\"keyword\">key</span> (/Users/yupan/.ssh/id_rsa):id_rsa_myself</span><br></pre></td></tr></table></figure>\n<p><strong>接下来：</strong></p>\n<p>这两步可以不用管</p>\n<p><img src=\"/uploads/post/20170309/2.png\" alt=\"image2\"></p>\n<p><strong>密钥生成成功：</strong></p>\n<p><img src=\"/uploads/post/20170309/3.png\" alt=\"image3\"></p>\n<h4 id=\"2-为系统添加SSH代理-SSH-agent\"><a href=\"#2-为系统添加SSH代理-SSH-agent\" class=\"headerlink\" title=\"2. 为系统添加SSH代理(SSH-agent)\"></a>2. 为系统添加SSH代理(SSH-agent)</h4><p><strong>将保存在本机的私钥添加到SSH-Key的代理里</strong></p>\n<p>查看系统的SSH-Key代理</p>\n<p><code>ssh-add -l</code></p>\n<p>删除系统原有的SSH-Key代理</p>\n<p><code>ssh-add -D</code></p>\n<p>为系统添加自己所有想要添加的代理</p>\n<p><code>ssh-add ~/.ssh/id_rsa</code></p>\n<p><code>ssh-add ~/.ssh/id_rsa_myself</code></p>\n<h4 id=\"3-将公钥保存在github上\"><a href=\"#3-将公钥保存在github上\" class=\"headerlink\" title=\"3. 将公钥保存在github上\"></a>3. 将公钥保存在github上</h4><p>github页面 =&gt; Settings =&gt; SSH and GPG keys</p>\n<p>点击 <code>New SSH key</code>，然后将<code>~/.ssh/</code>文件夹中的 <code>id_rsa_myself.pub</code>文件中的内容复制进去，保存即可。</p>\n<h4 id=\"4-修改-ssh文件中的config配置文件\"><a href=\"#4-修改-ssh文件中的config配置文件\" class=\"headerlink\" title=\"4. 修改.ssh文件中的config配置文件\"></a>4. 修改.ssh文件中的config配置文件</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#aaa  (账号1配置)</span></span><br><span class=\"line\">Host aaa</span><br><span class=\"line\">   \tHostName github.com （主机地址）</span><br><span class=\"line\">   \t<span class=\"keyword\">User</span> <span class=\"title\">git</span>\t\t\t （用户名）</span><br><span class=\"line\">   \tIdentityFile ~/.ssh/id_rsa_aaa （相关的认证的SSH文件）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#bbb  (账号2配置)</span></span><br><span class=\"line\">Host bbb</span><br><span class=\"line\">   \tHostName git.oschina.net </span><br><span class=\"line\">   \t<span class=\"keyword\">User</span> <span class=\"title\">git</span></span><br><span class=\"line\">   \tIdentityFile ~/.ssh/id_rsa_bbb</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-项目与git账号的对应关系\"><a href=\"#5-项目与git账号的对应关系\" class=\"headerlink\" title=\"5. 项目与git账号的对应关系\"></a>5. 项目与git账号的对应关系</h5><p><strong>我们采用ssh的方式克隆一个项目时：</strong></p>\n<p><code>git clone git@github.com:userName/myDemo.git</code></p>\n<p>这里的<code>github.com</code>是上面的配置文件中的<code>HostName</code>，<code>userName</code>是账户名，<code>myDemo</code>是项目名。</p>\n<p>由于是从远程的<code>git@github.com:userName/myDemo.git</code>这个仓库中克隆下来的，因此每次做的改动也会push到对应的账户中。</p>\n","excerpt":"","more":"<p>场景：一台电脑与2个git账户连接，很多时候公司会有一个帐号，自己也会又一个git帐号，用来记录或者积累自己学到的一些东西。</p>\n<h3 id=\"一-git的两种登录方式\"><a href=\"#一-git的两种登录方式\" class=\"headerlink\" title=\"一. git的两种登录方式\"></a>一. git的两种登录方式</h3><p>之前对git有一些了解，但是由于最最开始的时候一直使用的是git的图形化操作界面，囧。。。所以好多东西都是只知道表面。</p>\n<p><strong>git支持两种登录方式：</strong>SSH 和 HTTPS</p>\n<ul>\n<li><p>SSH：密钥的方式，简单来说就是生成一对密钥（公钥和私钥），私钥存在自己的电脑里，公钥存在git网站的设置里，通过这一对钥匙进行配对。</p>\n<p>  优点：每次登录无需输入账号密码，很方便。</p>\n</li>\n<li><p>HTTPS：使用HTTPS方式，每次都需要输入密码</p>\n</li>\n</ul>\n<h3 id=\"二-同一个电脑上配置多个git账号\"><a href=\"#二-同一个电脑上配置多个git账号\" class=\"headerlink\" title=\"二. 同一个电脑上配置多个git账号\"></a>二. 同一个电脑上配置多个git账号</h3><h4 id=\"1-生成SSH-Key\"><a href=\"#1-生成SSH-Key\" class=\"headerlink\" title=\"1. 生成SSH Key\"></a>1. 生成SSH Key</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh-keygen</span> <span class=\"selector-tag\">-t</span> <span class=\"selector-tag\">rsa</span> <span class=\"selector-tag\">-C</span> \"<span class=\"selector-tag\">your_email</span>@<span class=\"keyword\">163</span>.<span class=\"keyword\">com</span>\"</span><br></pre></td></tr></table></figure>\n<p>注意：这里的<code>your_email@163.com</code>是自己的git账号，这个命令也就是为这个账号生成一对密钥。</p>\n<p><strong>这个时候会提示：</strong></p>\n<p>让你输入保存密钥的文件的名字</p>\n<p><img src=\"/uploads/post/20170309/1.png\" alt=\"image1\"></p>\n<p>注意：括号里的是默认的文件名，如果你的电脑里已经存在一对SSH Key了的话，那么在这一步一定要输入一个和默认文件名，要不然就会将电脑里面本身的那对SSH Key覆盖掉。</p>\n<p>我这里用id_rsa_myself保存我自己git账户的密钥。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating <span class=\"keyword\">public</span>/<span class=\"keyword\">private</span> rsa <span class=\"keyword\">key</span> pair.</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> which <span class=\"keyword\">to</span> save the <span class=\"keyword\">key</span> (/Users/yupan/.ssh/id_rsa):id_rsa_myself</span><br></pre></td></tr></table></figure>\n<p><strong>接下来：</strong></p>\n<p>这两步可以不用管</p>\n<p><img src=\"/uploads/post/20170309/2.png\" alt=\"image2\"></p>\n<p><strong>密钥生成成功：</strong></p>\n<p><img src=\"/uploads/post/20170309/3.png\" alt=\"image3\"></p>\n<h4 id=\"2-为系统添加SSH代理-SSH-agent\"><a href=\"#2-为系统添加SSH代理-SSH-agent\" class=\"headerlink\" title=\"2. 为系统添加SSH代理(SSH-agent)\"></a>2. 为系统添加SSH代理(SSH-agent)</h4><p><strong>将保存在本机的私钥添加到SSH-Key的代理里</strong></p>\n<p>查看系统的SSH-Key代理</p>\n<p><code>ssh-add -l</code></p>\n<p>删除系统原有的SSH-Key代理</p>\n<p><code>ssh-add -D</code></p>\n<p>为系统添加自己所有想要添加的代理</p>\n<p><code>ssh-add ~/.ssh/id_rsa</code></p>\n<p><code>ssh-add ~/.ssh/id_rsa_myself</code></p>\n<h4 id=\"3-将公钥保存在github上\"><a href=\"#3-将公钥保存在github上\" class=\"headerlink\" title=\"3. 将公钥保存在github上\"></a>3. 将公钥保存在github上</h4><p>github页面 =&gt; Settings =&gt; SSH and GPG keys</p>\n<p>点击 <code>New SSH key</code>，然后将<code>~/.ssh/</code>文件夹中的 <code>id_rsa_myself.pub</code>文件中的内容复制进去，保存即可。</p>\n<h4 id=\"4-修改-ssh文件中的config配置文件\"><a href=\"#4-修改-ssh文件中的config配置文件\" class=\"headerlink\" title=\"4. 修改.ssh文件中的config配置文件\"></a>4. 修改.ssh文件中的config配置文件</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#aaa  (账号1配置)</span></span><br><span class=\"line\">Host aaa</span><br><span class=\"line\">   \tHostName github.com （主机地址）</span><br><span class=\"line\">   \t<span class=\"keyword\">User</span> <span class=\"title\">git</span>\t\t\t （用户名）</span><br><span class=\"line\">   \tIdentityFile ~/.ssh/id_rsa_aaa （相关的认证的SSH文件）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#bbb  (账号2配置)</span></span><br><span class=\"line\">Host bbb</span><br><span class=\"line\">   \tHostName git.oschina.net </span><br><span class=\"line\">   \t<span class=\"keyword\">User</span> <span class=\"title\">git</span></span><br><span class=\"line\">   \tIdentityFile ~/.ssh/id_rsa_bbb</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-项目与git账号的对应关系\"><a href=\"#5-项目与git账号的对应关系\" class=\"headerlink\" title=\"5. 项目与git账号的对应关系\"></a>5. 项目与git账号的对应关系</h5><p><strong>我们采用ssh的方式克隆一个项目时：</strong></p>\n<p><code>git clone git@github.com:userName/myDemo.git</code></p>\n<p>这里的<code>github.com</code>是上面的配置文件中的<code>HostName</code>，<code>userName</code>是账户名，<code>myDemo</code>是项目名。</p>\n<p>由于是从远程的<code>git@github.com:userName/myDemo.git</code>这个仓库中克隆下来的，因此每次做的改动也会push到对应的账户中。</p>\n"},{"layout":"post","title":"使用koa搭建服务器模拟跨域","date":"2016-09-22T16:00:00.000Z","description":null,"_content":"\n### 一. 使用Koa搭建服务器\n\n使用koa-router\n\n**监听端口3000:**\n\n```\n\n\tvar app = require('koa')();\n\tvar router = require('koa-router')();\n\tvar bodyparser = require('koa-bodyparser');\n\n\t//引入读取本地文件的模块\n\tvar fs = require('fs');\n\n\trouter.get('/', function *() {\n\t\t//将需要展示的html页面内容读取进来\n\t\tvar text = fs.readFileSync(process.cwd() + '/layout.html', 'utf8');\n\t\tthis.body = text;\t\t\n\t});\n\n\trouter.post('/ajax/deal', function *(next) {\t\n\t\tvar reqBody = this.request.body;\n    \tconsole.log(\"server accept: \", reqBody.name, reqBody.id)\n    \tvar data = {\n        \tname: reqBody.name + ' - server 3000 process',\n        \tid: reqBody.id + ' - server 3000 process'\n    \t}\n    \tthis.body = JSON.stringify(data); \n\t});\n\n\tapp\n\t\t.use(bodyparser())\n\t\t.use((router).routes())\n\n\tapp.listen(3000, function() {\n\t\tconsole.log('run 3000');\n\t})\n```\n\n**使用`localhost:3000`访问到的页面`layout.html`**\n\n```\n\n\t<!DOCTYPE html>\n\t<html>\n  \t<head>\n    \t<meta charset=\"utf-8\">\n    \t<title>React Tutorial</title>\n    </head>\n  \t<body>\n    \t<div id=\"content\">\n    \t\t<h1>Ajax跨域请求</h1>\n    \t\t<div>\n    \t\t\t<p>\n    \t\t\t\t<label>名称</label>\n    \t\t\t\t<input id='name' type='text' />\n    \t\t\t</p>\n    \t\t\t<p>\n    \t\t\t\t<label>id</label>\n    \t\t\t\t<input id='id' type='text' />\n    \t\t\t</p>\n    \t\t\t<input id='submit' type='button' value='submit' />\n    \t\t</div>\n    \t</div>\n    \t<script type='text/javaScript' src='//cdn.bootcss.com/jquery/3.1.0/jquery.js'></script>\n    \t<script>\n    \t\t\t$(function() {\n    \t    \t\t$(\"#submit\").click(function() {\n    \t        \t\tvar data = {\n    \t            \t\tname: $(\"#name\").val(),\n    \t            \t\tid: $(\"#id\").val()\n    \t        \t\t};\n    \t        \t$.ajax({\n    \t            \ttype: 'POST',\n    \t            \tdata: data,\n    \t            \turl: 'http://localhost:3000/ajax/deal',\n    \t            \tdataType: 'json',\n    \t            \tcache: false,\n    \t            \ttimeout: 5000,\n    \t            \tsuccess: function(data) {\n    \t                \tconsole.log(data);\n    \t            \t},\n    \t            \terror: function(jqXHR, textStatus, errorThrown) {\n    \t                \tconsole.log('error ' + textStatus + ' ' + errorThrown);\n    \t            \t\t}\n    \t        \t\t});\n    \t   \t \t\t});\n    \t\t\t});\n    \t</script>\n   </body>\n</html>\n```\n\n**监听端口3001：**\n\n```\n\n\tvar app = require('koa')();\n\tvar router = require('koa-router')();\n\n\tvar bodyparser = require('koa-bodyparser');\n\t//引入读取本地文件的模块\n\tvar fs = require('fs');\n\n\trouter.post('/ajax/deal', function *(next) {\t\n\t\tvar reqBody = this.request.body;\n    \tconsole.log(\"server accept: \", reqBody.name, reqBody.id)\n    \tvar data = {\n        \tname: reqBody.name + ' - server 3000 process',\n        \tid: reqBody.id + ' - server 3000 process'\n    \t}\n    \tthis.body = JSON.stringify(data); \n\t});\n\n\tapp\n\t\t.use(bodyparser())\n\t\t.use((router).routes())\n\n\tapp.listen(3001, function() {\n\t\tconsole.log('run 3001');\n\t})\n```\n\n在3000端口的页面发起ajax的post请求，如果请求的地址是\n`url: 'http://localhost:3000/ajax/deal'`，ajax请求的域名相同（端口也是3000），那么就会输出正确的值。\n\n在3000端口的页面发起ajax的post请求，如果请求的地址是\n`url: 'http://localhost:3001/ajax/deal'`，ajax进行了跨域请求（端口是3001），控制台就会报如下错误：\n\n\n### 二. 跨域操作\n\n#### 1. jsnop\n\n","source":"_posts/2016-09-23-使用koa搭建服务器模拟跨域.md","raw":"---\nlayout: post\ntitle: 使用koa搭建服务器模拟跨域\ndate: 2016-09-23\ncategories: javaScript\ntags: [javaScript,koa]\ndescription: \n---\n\n### 一. 使用Koa搭建服务器\n\n使用koa-router\n\n**监听端口3000:**\n\n```\n\n\tvar app = require('koa')();\n\tvar router = require('koa-router')();\n\tvar bodyparser = require('koa-bodyparser');\n\n\t//引入读取本地文件的模块\n\tvar fs = require('fs');\n\n\trouter.get('/', function *() {\n\t\t//将需要展示的html页面内容读取进来\n\t\tvar text = fs.readFileSync(process.cwd() + '/layout.html', 'utf8');\n\t\tthis.body = text;\t\t\n\t});\n\n\trouter.post('/ajax/deal', function *(next) {\t\n\t\tvar reqBody = this.request.body;\n    \tconsole.log(\"server accept: \", reqBody.name, reqBody.id)\n    \tvar data = {\n        \tname: reqBody.name + ' - server 3000 process',\n        \tid: reqBody.id + ' - server 3000 process'\n    \t}\n    \tthis.body = JSON.stringify(data); \n\t});\n\n\tapp\n\t\t.use(bodyparser())\n\t\t.use((router).routes())\n\n\tapp.listen(3000, function() {\n\t\tconsole.log('run 3000');\n\t})\n```\n\n**使用`localhost:3000`访问到的页面`layout.html`**\n\n```\n\n\t<!DOCTYPE html>\n\t<html>\n  \t<head>\n    \t<meta charset=\"utf-8\">\n    \t<title>React Tutorial</title>\n    </head>\n  \t<body>\n    \t<div id=\"content\">\n    \t\t<h1>Ajax跨域请求</h1>\n    \t\t<div>\n    \t\t\t<p>\n    \t\t\t\t<label>名称</label>\n    \t\t\t\t<input id='name' type='text' />\n    \t\t\t</p>\n    \t\t\t<p>\n    \t\t\t\t<label>id</label>\n    \t\t\t\t<input id='id' type='text' />\n    \t\t\t</p>\n    \t\t\t<input id='submit' type='button' value='submit' />\n    \t\t</div>\n    \t</div>\n    \t<script type='text/javaScript' src='//cdn.bootcss.com/jquery/3.1.0/jquery.js'></script>\n    \t<script>\n    \t\t\t$(function() {\n    \t    \t\t$(\"#submit\").click(function() {\n    \t        \t\tvar data = {\n    \t            \t\tname: $(\"#name\").val(),\n    \t            \t\tid: $(\"#id\").val()\n    \t        \t\t};\n    \t        \t$.ajax({\n    \t            \ttype: 'POST',\n    \t            \tdata: data,\n    \t            \turl: 'http://localhost:3000/ajax/deal',\n    \t            \tdataType: 'json',\n    \t            \tcache: false,\n    \t            \ttimeout: 5000,\n    \t            \tsuccess: function(data) {\n    \t                \tconsole.log(data);\n    \t            \t},\n    \t            \terror: function(jqXHR, textStatus, errorThrown) {\n    \t                \tconsole.log('error ' + textStatus + ' ' + errorThrown);\n    \t            \t\t}\n    \t        \t\t});\n    \t   \t \t\t});\n    \t\t\t});\n    \t</script>\n   </body>\n</html>\n```\n\n**监听端口3001：**\n\n```\n\n\tvar app = require('koa')();\n\tvar router = require('koa-router')();\n\n\tvar bodyparser = require('koa-bodyparser');\n\t//引入读取本地文件的模块\n\tvar fs = require('fs');\n\n\trouter.post('/ajax/deal', function *(next) {\t\n\t\tvar reqBody = this.request.body;\n    \tconsole.log(\"server accept: \", reqBody.name, reqBody.id)\n    \tvar data = {\n        \tname: reqBody.name + ' - server 3000 process',\n        \tid: reqBody.id + ' - server 3000 process'\n    \t}\n    \tthis.body = JSON.stringify(data); \n\t});\n\n\tapp\n\t\t.use(bodyparser())\n\t\t.use((router).routes())\n\n\tapp.listen(3001, function() {\n\t\tconsole.log('run 3001');\n\t})\n```\n\n在3000端口的页面发起ajax的post请求，如果请求的地址是\n`url: 'http://localhost:3000/ajax/deal'`，ajax请求的域名相同（端口也是3000），那么就会输出正确的值。\n\n在3000端口的页面发起ajax的post请求，如果请求的地址是\n`url: 'http://localhost:3001/ajax/deal'`，ajax进行了跨域请求（端口是3001），控制台就会报如下错误：\n\n\n### 二. 跨域操作\n\n#### 1. jsnop\n\n","slug":"2016-09-23-使用koa搭建服务器模拟跨域","published":1,"updated":"2016-09-23T14:10:24.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockw00dmd5u8a75b6hgf","content":"<h3 id=\"一-使用Koa搭建服务器\"><a href=\"#一-使用Koa搭建服务器\" class=\"headerlink\" title=\"一. 使用Koa搭建服务器\"></a>一. 使用Koa搭建服务器</h3><p>使用koa-router</p>\n<p><strong>监听端口3000:</strong></p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>)();</span><br><span class=\"line\"><span class=\"built_in\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</span><br><span class=\"line\"><span class=\"built_in\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-bodyparser'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引入读取本地文件的模块</span></span><br><span class=\"line\"><span class=\"built_in\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将需要展示的html页面内容读取进来</span></span><br><span class=\"line\">\t<span class=\"built_in\">var</span> text = fs.readFileSync(process.cwd() + <span class=\"string\">'/layout.html'</span>, <span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.body = text;\t\t</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/ajax/deal'</span>, <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\">next</span>) </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> reqBody = <span class=\"keyword\">this</span>.request.body;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"server accept: \"</span>, reqBody.name, reqBody.id)</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> data = &#123;</span><br><span class=\"line\">       \t<span class=\"attribute\">name</span>: reqBody.name + <span class=\"string\">' - server 3000 process'</span>,</span><br><span class=\"line\">       \t<span class=\"attribute\">id:</span><span class=\"string\"> reqBody.id</span> + <span class=\"string\">' - server 3000 process'</span></span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.body = <span class=\"built_in\">JSON</span>.stringify(data); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app</span><br><span class=\"line\">\t.use(bodyparser())</span><br><span class=\"line\">\t.use((router).routes())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'run 3000'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>使用<code>localhost:3000</code>访问到的页面<code>layout.html</code></strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>React Tutorial<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Ajax跨域请求<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>名称<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">'name'</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> /&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>id<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">'id'</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> /&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">'submit'</span> <span class=\"attr\">type</span>=<span class=\"string\">'button'</span> <span class=\"attr\">value</span>=<span class=\"string\">'submit'</span> /&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">'text/javaScript'</span> <span class=\"attr\">src</span>=<span class=\"string\">'//cdn.bootcss.com/jquery/3.1.0/jquery.js'</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">    \t\t\t$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \t    \t\t$(<span class=\"string\">\"#submit\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \t        \t\t<span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">    \t            \t\tname: $(<span class=\"string\">\"#name\"</span>).val(),</span><br><span class=\"line\">    \t            \t\tid: $(<span class=\"string\">\"#id\"</span>).val()</span><br><span class=\"line\">    \t        \t\t&#125;;</span><br><span class=\"line\">    \t        \t$.ajax(&#123;</span><br><span class=\"line\">    \t            \ttype: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    \t            \tdata: data,</span><br><span class=\"line\">    \t            \turl: <span class=\"string\">'http://localhost:3000/ajax/deal'</span>,</span><br><span class=\"line\">    \t            \tdataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    \t            \tcache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    \t            \ttimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">    \t            \tsuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    \t                \t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    \t            \t&#125;,</span><br><span class=\"line\">    \t            \terror: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">    \t                \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'error '</span> + textStatus + <span class=\"string\">' '</span> + errorThrown);</span><br><span class=\"line\">    \t            \t\t&#125;</span><br><span class=\"line\">    \t        \t\t&#125;);</span><br><span class=\"line\">    \t   \t \t\t&#125;);</span><br><span class=\"line\">    \t\t\t&#125;);</span><br><span class=\"line\">    \t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>监听端口3001：</strong></p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>)();</span><br><span class=\"line\"><span class=\"built_in\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-bodyparser'</span>);</span><br><span class=\"line\"><span class=\"comment\">//引入读取本地文件的模块</span></span><br><span class=\"line\"><span class=\"built_in\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/ajax/deal'</span>, <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\">next</span>) </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> reqBody = <span class=\"keyword\">this</span>.request.body;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"server accept: \"</span>, reqBody.name, reqBody.id)</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> data = &#123;</span><br><span class=\"line\">       \t<span class=\"attribute\">name</span>: reqBody.name + <span class=\"string\">' - server 3000 process'</span>,</span><br><span class=\"line\">       \t<span class=\"attribute\">id:</span><span class=\"string\"> reqBody.id</span> + <span class=\"string\">' - server 3000 process'</span></span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.body = <span class=\"built_in\">JSON</span>.stringify(data); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app</span><br><span class=\"line\">\t.use(bodyparser())</span><br><span class=\"line\">\t.use((router).routes())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3001</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'run 3001'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在3000端口的页面发起ajax的post请求，如果请求的地址是<br><code>url: &#39;http://localhost:3000/ajax/deal&#39;</code>，ajax请求的域名相同（端口也是3000），那么就会输出正确的值。</p>\n<p>在3000端口的页面发起ajax的post请求，如果请求的地址是<br><code>url: &#39;http://localhost:3001/ajax/deal&#39;</code>，ajax进行了跨域请求（端口是3001），控制台就会报如下错误：</p>\n<h3 id=\"二-跨域操作\"><a href=\"#二-跨域操作\" class=\"headerlink\" title=\"二. 跨域操作\"></a>二. 跨域操作</h3><h4 id=\"1-jsnop\"><a href=\"#1-jsnop\" class=\"headerlink\" title=\"1. jsnop\"></a>1. jsnop</h4>","excerpt":"","more":"<h3 id=\"一-使用Koa搭建服务器\"><a href=\"#一-使用Koa搭建服务器\" class=\"headerlink\" title=\"一. 使用Koa搭建服务器\"></a>一. 使用Koa搭建服务器</h3><p>使用koa-router</p>\n<p><strong>监听端口3000:</strong></p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>)();</span><br><span class=\"line\"><span class=\"built_in\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</span><br><span class=\"line\"><span class=\"built_in\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-bodyparser'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//引入读取本地文件的模块</span></span><br><span class=\"line\"><span class=\"built_in\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将需要展示的html页面内容读取进来</span></span><br><span class=\"line\">\t<span class=\"built_in\">var</span> text = fs.readFileSync(process.cwd() + <span class=\"string\">'/layout.html'</span>, <span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.body = text;\t\t</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/ajax/deal'</span>, <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\">next</span>) </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> reqBody = <span class=\"keyword\">this</span>.request.body;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"server accept: \"</span>, reqBody.name, reqBody.id)</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> data = &#123;</span><br><span class=\"line\">       \t<span class=\"attribute\">name</span>: reqBody.name + <span class=\"string\">' - server 3000 process'</span>,</span><br><span class=\"line\">       \t<span class=\"attribute\">id:</span><span class=\"string\"> reqBody.id</span> + <span class=\"string\">' - server 3000 process'</span></span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.body = <span class=\"built_in\">JSON</span>.stringify(data); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app</span><br><span class=\"line\">\t.use(bodyparser())</span><br><span class=\"line\">\t.use((router).routes())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'run 3000'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>使用<code>localhost:3000</code>访问到的页面<code>layout.html</code></strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>React Tutorial<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Ajax跨域请求<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>名称<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">'name'</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> /&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>id<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    \t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">'id'</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> /&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    \t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">'submit'</span> <span class=\"attr\">type</span>=<span class=\"string\">'button'</span> <span class=\"attr\">value</span>=<span class=\"string\">'submit'</span> /&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">'text/javaScript'</span> <span class=\"attr\">src</span>=<span class=\"string\">'//cdn.bootcss.com/jquery/3.1.0/jquery.js'</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">    \t\t\t$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \t    \t\t$(<span class=\"string\">\"#submit\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \t        \t\t<span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">    \t            \t\tname: $(<span class=\"string\">\"#name\"</span>).val(),</span><br><span class=\"line\">    \t            \t\tid: $(<span class=\"string\">\"#id\"</span>).val()</span><br><span class=\"line\">    \t        \t\t&#125;;</span><br><span class=\"line\">    \t        \t$.ajax(&#123;</span><br><span class=\"line\">    \t            \ttype: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    \t            \tdata: data,</span><br><span class=\"line\">    \t            \turl: <span class=\"string\">'http://localhost:3000/ajax/deal'</span>,</span><br><span class=\"line\">    \t            \tdataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    \t            \tcache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    \t            \ttimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">    \t            \tsuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    \t                \t<span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    \t            \t&#125;,</span><br><span class=\"line\">    \t            \terror: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">    \t                \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'error '</span> + textStatus + <span class=\"string\">' '</span> + errorThrown);</span><br><span class=\"line\">    \t            \t\t&#125;</span><br><span class=\"line\">    \t        \t\t&#125;);</span><br><span class=\"line\">    \t   \t \t\t&#125;);</span><br><span class=\"line\">    \t\t\t&#125;);</span><br><span class=\"line\">    \t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>监听端口3001：</strong></p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>)();</span><br><span class=\"line\"><span class=\"built_in\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-bodyparser'</span>);</span><br><span class=\"line\"><span class=\"comment\">//引入读取本地文件的模块</span></span><br><span class=\"line\"><span class=\"built_in\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/ajax/deal'</span>, <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\">next</span>) </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"built_in\">var</span> reqBody = <span class=\"keyword\">this</span>.request.body;</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"server accept: \"</span>, reqBody.name, reqBody.id)</span><br><span class=\"line\">   \t<span class=\"built_in\">var</span> data = &#123;</span><br><span class=\"line\">       \t<span class=\"attribute\">name</span>: reqBody.name + <span class=\"string\">' - server 3000 process'</span>,</span><br><span class=\"line\">       \t<span class=\"attribute\">id:</span><span class=\"string\"> reqBody.id</span> + <span class=\"string\">' - server 3000 process'</span></span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t<span class=\"keyword\">this</span>.body = <span class=\"built_in\">JSON</span>.stringify(data); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app</span><br><span class=\"line\">\t.use(bodyparser())</span><br><span class=\"line\">\t.use((router).routes())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3001</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'run 3001'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在3000端口的页面发起ajax的post请求，如果请求的地址是<br><code>url: &#39;http://localhost:3000/ajax/deal&#39;</code>，ajax请求的域名相同（端口也是3000），那么就会输出正确的值。</p>\n<p>在3000端口的页面发起ajax的post请求，如果请求的地址是<br><code>url: &#39;http://localhost:3001/ajax/deal&#39;</code>，ajax进行了跨域请求（端口是3001），控制台就会报如下错误：</p>\n<h3 id=\"二-跨域操作\"><a href=\"#二-跨域操作\" class=\"headerlink\" title=\"二. 跨域操作\"></a>二. 跨域操作</h3><h4 id=\"1-jsnop\"><a href=\"#1-jsnop\" class=\"headerlink\" title=\"1. jsnop\"></a>1. jsnop</h4>"},{"layout":"post","title":"折腾博客系列之二","date":"2017-03-07T16:00:00.000Z","description":null,"_content":"\n最近由于换电脑，又出现了一些问题，都添加到了文章内部。。。20170308\n\n－－－－－－－－－－－分割线－－－－－－－－－－－－－－－－－－－－\n\n之前弄的那个博客是基于`jekyll`,现在换成的这个博客是基于`hexo`。两者都是比较常用的静态博客系统。之所以将jekyll换成hexo呢，是因为看到了基于hexo的next模板（也就是本博客现在使用的模板），当时看到的时候，确实非常喜欢，简洁明了，再加上觉得之前的博客自己弄的样式太小清新了，额。。。当然现在的也还是走的小清新风格，弄成这样主要是为了和原生的next模板那种冷峻的style产生一丢丢辨识度。好了，废话不多说，下面简要介绍一下本博客搭建的过程。\n\n想学习如何使用jekyll生成博客，可以看我的上个博客的教程。\n\n### 一. jekyll和hexo的区别\n\n#### 1. jekyll\n\njekyll是基于ruby\n\n优点：把原文上传到github上，可以直接生成博客。\n\n缺点：在windows上安装ruby时，非常麻烦，哪一步出错就有可能安装不成功；文件的分类名或者文件名如果是中文，那么在本地调试时就显示不出来。\n\n#### 2. hexo\n\nhexo是基于nodejs\n\n优点:安装nodejs简单，生成起来快很多，主题种类多一些\n\n缺点：需要在本地生成html页面，再上传到git上\n\n### 二. 用hexo生成博客的过程\n\n#### 1. 用github pages生成自己的博客仓库\n\n#### 2. 安装github\n\n#### 3. 安装nodejs\n\n#### 4. 安装hexo\n\n打开git shell\n\n输入 \n```js\nnpm install -g hexo-cli\n```\n进入自己的博客文件夹（自己本地的github仓库your_user_name.github.io）\n\n依次输入\n```js\nhexo init //初始化一个博客\nnpm install\nhexo s --debug //在调试的状态下启动hexo\n```\n\n这样一个博客就生成了，就可以在http://localhost:4000本地查看\n\n### 三. 本地生成的博客上传到git上\n\n上面也说了，hexo博客是需要自己在本地根据.md文件生成`html`页面，然后再部署到git上。\n\n#### 1. 修改_config.yml配置文件（站点配置文件）\n\n将URL部分改成\n\n    # URL\n    ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n    url: http://panpanfish.com  （自己的博客的域名）\n    root: /\n    permalink: :year/:month/:day/:title/\n    permalink_defaults:\n\n将部署的部分改成\n\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: https://github.com/panpan040828/panpan040828.github.io.git   (自己的博客仓库地址)\n      branch: master\n\n#### 2. 在仓库的git shell中执行如下命令\n\n```\n\t安装hexo部署到git上的插件\n\tnpm install hexo-deployer-git --save\n\n\t执行清空之前生成的文件命令\n\thexo clean\n\n\t执行生成对应的页面命令\n\thexo generate\n\n\t执行部署命令\n\thexo deploy\n\n\t不需要再commit pull push了\n```\n\n#### 3. 每次写博客的步骤\n\n在`source/_posts/`里面添加自己的`.md`文件（博客文件），然后\n\nhexo clean\n\nhexo generate\n\nhexo deploy\n\n**注意：这里的部署文件并不是把所有的文件都push到了github上，一定要切记备份本地的文件夹，或者将本地的文件夹每一次也直接push到git上，要不然换了电脑，丢失了本地的文件夹就很麻烦，特别是`source/_posts/`里面的`.md`文件没有了，你的博客源文件就都没有了，哭。。。**\n\n![上传到git上的文件](/uploads/post/20170308/upload_to_git.png)\n\n![本地文件](/uploads/post/20170308/loaclhost.png)\n\n### 三. 修改next主题部分样式\n\n一些next主题自带的东西，在next的文档中都有详细的说明。\n\n为了不把原来的文件改错，我使用的是自定义样式，方法如下：\n\n在themes/next/source/css文件夹中的main.styl中的最后添加如下代码\n\n```js\n//my layer\n//-------------------\n@import \"_my/mycss\"\n```\n\n然后再在这个css文件夹里添加一个_my文件夹，里面创建一个mycss.styl文件，在文件中写上自己的样式。\n\n```js\n例如：\n.my-site-meta {\n    padding: 20px 0;\n    color: #fff;\n    background: #E49A9A;\n    margin: 0;\n  \ttext-align: center;\n}\n```\n然后再在自己的页面引用这些样式就行。\n\n在themes/next/layout这个文件夹里，放的都是html页面文件\n\n_partials文件夹里的都是可以复用的部分\n\n- head.swig是html页面的头部\n- header.swig是左侧导航栏\n- footer.swig是页面底部\n- pagination.swig是分页\n\n_layout.swig是整个页面，每个页面都会使用，其中通过如下形式引用的其他部分\n\n```js\n{% include '_scripts/vendors.swig' %}\n{% include '_scripts/commons.swig' %}\n```\n\n新增的demo页面是在page.swig里面修改的\n\n如果修改样式后，本地预览不对，可以重新启动一下hexo就可以了\n\n当然，还需要继续研究一下模板的各个文件代表的是什么意思，才能更好地去修改，或者自己写一个模板，任重而道远啊~~~\n\n### 四. 遇见的问题\n\n后来博客又出现了一些问题，捣腾了半天之后又好了。\n\n#### 1. 在执行 hexo deploy 后,出现 error deployer not found:github 的错误\n\n没有安装使用hexo部署到git上的配置文件，在博客文件夹里执行如下命令\n\n```js\nnpm install hexo-deployer-git --save\n```\n\n再部署就会成功\n\n#### 2. 明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\n\n原因：把.git文件夹删掉了，这个文件夹千万不能删，里面含有很多配置信息。\n\n**.git文件夹是隐藏显示的，如何让其显示：**\n\n\t点击工具————>文件夹选项————>查看————>显示隐藏文件夹\n\n#### 3. 域名绑定文件CNAME文件放置的位置\n\n之前用jekyll搭建博客时，是直接将CNAME文件放在博客根目录下，但是使用hexo搭建博客时，**应该将CNAME文件放在source文件夹下**。\n\n使用hexo搭建博客，是利用source/_posts/文件夹下的.md文件生成.html文件，然后再部署到github上，所以并不是把整个博客文件夹push上去，github上只有.html文件，所以如果直接把CNAME文件放在根目录里，就不会被push到github上，因此会导致域名绑定不成功。\n\n#### 4. 往github上部署文件时出现failed to connect to github.com port 443:Timed out\n\n这个可能是由于网速的原因，可以访问一下github.com,在网速比较好的时候再重新提交。\n\n### 五. 了解hexo\n\n如果要做一些个性化的设置，还是需要对hexo进行全面的了解。\n\n#### 1. 默认生成的文件\n\n- scaffolds 脚手架，也就是一个工具模板\n- scripts 写文件的js，扩展hexo的功能\n- source 存放博客正文内容\n- source/_drafts 草稿箱\n- source/_posts 文件箱\n- themes 存放主题的目录\n- themes/landscape 默认的主题\n- _config.yml 全局的配置文件\n- db.json 静态常量\n- package.json 根据这个文件，安装相关依赖\n\n\n**全局配置文件：**`_config.yml` **设置的是网站的配置**\n\n- 站点信息: 定义标题，作者，语言\n- URL: URL访问路径\n- 文件目录: 正文的存储目录\n- 写博客配置：文章标题，文章类型，外部链接等\n- 目录和标签：默认分类，分类图，标签图\n- 归档设置：归档的类型\n- 服务器设置：IP，访问端口，日志输出\n- 时间和日期格式： 时间显示格式，日期显示格式\n- 分页设置：每页显示数量\n- 评论：外挂的Disqus评论系统\n- 插件和皮肤：换皮肤，安装插件\n- Markdown语言：markdown的标准\n- CSS的stylus格式：是否允许压缩\n- 部署配置：github发布\n\n### 六. 增加的一些第三方的应用\n\n#### 1. 评论功能\n\n#### 2. 页面访问统计功能\n\n#### 3. 文章阅读数统计功能\n\nLeanCloud\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-03-08-折腾博客系列之二.md","raw":"---\nlayout: post\ntitle: 折腾博客系列之二\ndate: 2017-03-08\ncategories: 搭建博客\ntags: [博客]\ndescription: \n---\n\n最近由于换电脑，又出现了一些问题，都添加到了文章内部。。。20170308\n\n－－－－－－－－－－－分割线－－－－－－－－－－－－－－－－－－－－\n\n之前弄的那个博客是基于`jekyll`,现在换成的这个博客是基于`hexo`。两者都是比较常用的静态博客系统。之所以将jekyll换成hexo呢，是因为看到了基于hexo的next模板（也就是本博客现在使用的模板），当时看到的时候，确实非常喜欢，简洁明了，再加上觉得之前的博客自己弄的样式太小清新了，额。。。当然现在的也还是走的小清新风格，弄成这样主要是为了和原生的next模板那种冷峻的style产生一丢丢辨识度。好了，废话不多说，下面简要介绍一下本博客搭建的过程。\n\n想学习如何使用jekyll生成博客，可以看我的上个博客的教程。\n\n### 一. jekyll和hexo的区别\n\n#### 1. jekyll\n\njekyll是基于ruby\n\n优点：把原文上传到github上，可以直接生成博客。\n\n缺点：在windows上安装ruby时，非常麻烦，哪一步出错就有可能安装不成功；文件的分类名或者文件名如果是中文，那么在本地调试时就显示不出来。\n\n#### 2. hexo\n\nhexo是基于nodejs\n\n优点:安装nodejs简单，生成起来快很多，主题种类多一些\n\n缺点：需要在本地生成html页面，再上传到git上\n\n### 二. 用hexo生成博客的过程\n\n#### 1. 用github pages生成自己的博客仓库\n\n#### 2. 安装github\n\n#### 3. 安装nodejs\n\n#### 4. 安装hexo\n\n打开git shell\n\n输入 \n```js\nnpm install -g hexo-cli\n```\n进入自己的博客文件夹（自己本地的github仓库your_user_name.github.io）\n\n依次输入\n```js\nhexo init //初始化一个博客\nnpm install\nhexo s --debug //在调试的状态下启动hexo\n```\n\n这样一个博客就生成了，就可以在http://localhost:4000本地查看\n\n### 三. 本地生成的博客上传到git上\n\n上面也说了，hexo博客是需要自己在本地根据.md文件生成`html`页面，然后再部署到git上。\n\n#### 1. 修改_config.yml配置文件（站点配置文件）\n\n将URL部分改成\n\n    # URL\n    ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n    url: http://panpanfish.com  （自己的博客的域名）\n    root: /\n    permalink: :year/:month/:day/:title/\n    permalink_defaults:\n\n将部署的部分改成\n\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: https://github.com/panpan040828/panpan040828.github.io.git   (自己的博客仓库地址)\n      branch: master\n\n#### 2. 在仓库的git shell中执行如下命令\n\n```\n\t安装hexo部署到git上的插件\n\tnpm install hexo-deployer-git --save\n\n\t执行清空之前生成的文件命令\n\thexo clean\n\n\t执行生成对应的页面命令\n\thexo generate\n\n\t执行部署命令\n\thexo deploy\n\n\t不需要再commit pull push了\n```\n\n#### 3. 每次写博客的步骤\n\n在`source/_posts/`里面添加自己的`.md`文件（博客文件），然后\n\nhexo clean\n\nhexo generate\n\nhexo deploy\n\n**注意：这里的部署文件并不是把所有的文件都push到了github上，一定要切记备份本地的文件夹，或者将本地的文件夹每一次也直接push到git上，要不然换了电脑，丢失了本地的文件夹就很麻烦，特别是`source/_posts/`里面的`.md`文件没有了，你的博客源文件就都没有了，哭。。。**\n\n![上传到git上的文件](/uploads/post/20170308/upload_to_git.png)\n\n![本地文件](/uploads/post/20170308/loaclhost.png)\n\n### 三. 修改next主题部分样式\n\n一些next主题自带的东西，在next的文档中都有详细的说明。\n\n为了不把原来的文件改错，我使用的是自定义样式，方法如下：\n\n在themes/next/source/css文件夹中的main.styl中的最后添加如下代码\n\n```js\n//my layer\n//-------------------\n@import \"_my/mycss\"\n```\n\n然后再在这个css文件夹里添加一个_my文件夹，里面创建一个mycss.styl文件，在文件中写上自己的样式。\n\n```js\n例如：\n.my-site-meta {\n    padding: 20px 0;\n    color: #fff;\n    background: #E49A9A;\n    margin: 0;\n  \ttext-align: center;\n}\n```\n然后再在自己的页面引用这些样式就行。\n\n在themes/next/layout这个文件夹里，放的都是html页面文件\n\n_partials文件夹里的都是可以复用的部分\n\n- head.swig是html页面的头部\n- header.swig是左侧导航栏\n- footer.swig是页面底部\n- pagination.swig是分页\n\n_layout.swig是整个页面，每个页面都会使用，其中通过如下形式引用的其他部分\n\n```js\n{% include '_scripts/vendors.swig' %}\n{% include '_scripts/commons.swig' %}\n```\n\n新增的demo页面是在page.swig里面修改的\n\n如果修改样式后，本地预览不对，可以重新启动一下hexo就可以了\n\n当然，还需要继续研究一下模板的各个文件代表的是什么意思，才能更好地去修改，或者自己写一个模板，任重而道远啊~~~\n\n### 四. 遇见的问题\n\n后来博客又出现了一些问题，捣腾了半天之后又好了。\n\n#### 1. 在执行 hexo deploy 后,出现 error deployer not found:github 的错误\n\n没有安装使用hexo部署到git上的配置文件，在博客文件夹里执行如下命令\n\n```js\nnpm install hexo-deployer-git --save\n```\n\n再部署就会成功\n\n#### 2. 明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\n\n原因：把.git文件夹删掉了，这个文件夹千万不能删，里面含有很多配置信息。\n\n**.git文件夹是隐藏显示的，如何让其显示：**\n\n\t点击工具————>文件夹选项————>查看————>显示隐藏文件夹\n\n#### 3. 域名绑定文件CNAME文件放置的位置\n\n之前用jekyll搭建博客时，是直接将CNAME文件放在博客根目录下，但是使用hexo搭建博客时，**应该将CNAME文件放在source文件夹下**。\n\n使用hexo搭建博客，是利用source/_posts/文件夹下的.md文件生成.html文件，然后再部署到github上，所以并不是把整个博客文件夹push上去，github上只有.html文件，所以如果直接把CNAME文件放在根目录里，就不会被push到github上，因此会导致域名绑定不成功。\n\n#### 4. 往github上部署文件时出现failed to connect to github.com port 443:Timed out\n\n这个可能是由于网速的原因，可以访问一下github.com,在网速比较好的时候再重新提交。\n\n### 五. 了解hexo\n\n如果要做一些个性化的设置，还是需要对hexo进行全面的了解。\n\n#### 1. 默认生成的文件\n\n- scaffolds 脚手架，也就是一个工具模板\n- scripts 写文件的js，扩展hexo的功能\n- source 存放博客正文内容\n- source/_drafts 草稿箱\n- source/_posts 文件箱\n- themes 存放主题的目录\n- themes/landscape 默认的主题\n- _config.yml 全局的配置文件\n- db.json 静态常量\n- package.json 根据这个文件，安装相关依赖\n\n\n**全局配置文件：**`_config.yml` **设置的是网站的配置**\n\n- 站点信息: 定义标题，作者，语言\n- URL: URL访问路径\n- 文件目录: 正文的存储目录\n- 写博客配置：文章标题，文章类型，外部链接等\n- 目录和标签：默认分类，分类图，标签图\n- 归档设置：归档的类型\n- 服务器设置：IP，访问端口，日志输出\n- 时间和日期格式： 时间显示格式，日期显示格式\n- 分页设置：每页显示数量\n- 评论：外挂的Disqus评论系统\n- 插件和皮肤：换皮肤，安装插件\n- Markdown语言：markdown的标准\n- CSS的stylus格式：是否允许压缩\n- 部署配置：github发布\n\n### 六. 增加的一些第三方的应用\n\n#### 1. 评论功能\n\n#### 2. 页面访问统计功能\n\n#### 3. 文章阅读数统计功能\n\nLeanCloud\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2017-03-08-折腾博客系列之二","published":1,"updated":"2017-03-09T08:07:40.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockx00dpd5u83ag87vc3","content":"<p>最近由于换电脑，又出现了一些问题，都添加到了文章内部。。。20170308</p>\n<p>－－－－－－－－－－－分割线－－－－－－－－－－－－－－－－－－－－</p>\n<p>之前弄的那个博客是基于<code>jekyll</code>,现在换成的这个博客是基于<code>hexo</code>。两者都是比较常用的静态博客系统。之所以将jekyll换成hexo呢，是因为看到了基于hexo的next模板（也就是本博客现在使用的模板），当时看到的时候，确实非常喜欢，简洁明了，再加上觉得之前的博客自己弄的样式太小清新了，额。。。当然现在的也还是走的小清新风格，弄成这样主要是为了和原生的next模板那种冷峻的style产生一丢丢辨识度。好了，废话不多说，下面简要介绍一下本博客搭建的过程。</p>\n<p>想学习如何使用jekyll生成博客，可以看我的上个博客的教程。</p>\n<h3 id=\"一-jekyll和hexo的区别\"><a href=\"#一-jekyll和hexo的区别\" class=\"headerlink\" title=\"一. jekyll和hexo的区别\"></a>一. jekyll和hexo的区别</h3><h4 id=\"1-jekyll\"><a href=\"#1-jekyll\" class=\"headerlink\" title=\"1. jekyll\"></a>1. jekyll</h4><p>jekyll是基于ruby</p>\n<p>优点：把原文上传到github上，可以直接生成博客。</p>\n<p>缺点：在windows上安装ruby时，非常麻烦，哪一步出错就有可能安装不成功；文件的分类名或者文件名如果是中文，那么在本地调试时就显示不出来。</p>\n<h4 id=\"2-hexo\"><a href=\"#2-hexo\" class=\"headerlink\" title=\"2. hexo\"></a>2. hexo</h4><p>hexo是基于nodejs</p>\n<p>优点:安装nodejs简单，生成起来快很多，主题种类多一些</p>\n<p>缺点：需要在本地生成html页面，再上传到git上</p>\n<h3 id=\"二-用hexo生成博客的过程\"><a href=\"#二-用hexo生成博客的过程\" class=\"headerlink\" title=\"二. 用hexo生成博客的过程\"></a>二. 用hexo生成博客的过程</h3><h4 id=\"1-用github-pages生成自己的博客仓库\"><a href=\"#1-用github-pages生成自己的博客仓库\" class=\"headerlink\" title=\"1. 用github pages生成自己的博客仓库\"></a>1. 用github pages生成自己的博客仓库</h4><h4 id=\"2-安装github\"><a href=\"#2-安装github\" class=\"headerlink\" title=\"2. 安装github\"></a>2. 安装github</h4><h4 id=\"3-安装nodejs\"><a href=\"#3-安装nodejs\" class=\"headerlink\" title=\"3. 安装nodejs\"></a>3. 安装nodejs</h4><h4 id=\"4-安装hexo\"><a href=\"#4-安装hexo\" class=\"headerlink\" title=\"4. 安装hexo\"></a>4. 安装hexo</h4><p>打开git shell</p>\n<p>输入<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>\n<p>进入自己的博客文件夹（自己本地的github仓库your_user_name.github.io）</p>\n<p>依次输入<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init <span class=\"comment\">//初始化一个博客</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo s --debug <span class=\"comment\">//在调试的状态下启动hexo</span></span><br></pre></td></tr></table></figure></p>\n<p>这样一个博客就生成了，就可以在<a href=\"http://localhost:4000本地查看\" target=\"_blank\" rel=\"external\">http://localhost:4000本地查看</a></p>\n<h3 id=\"三-本地生成的博客上传到git上\"><a href=\"#三-本地生成的博客上传到git上\" class=\"headerlink\" title=\"三. 本地生成的博客上传到git上\"></a>三. 本地生成的博客上传到git上</h3><p>上面也说了，hexo博客是需要自己在本地根据.md文件生成<code>html</code>页面，然后再部署到git上。</p>\n<h4 id=\"1-修改-config-yml配置文件（站点配置文件）\"><a href=\"#1-修改-config-yml配置文件（站点配置文件）\" class=\"headerlink\" title=\"1. 修改_config.yml配置文件（站点配置文件）\"></a>1. 修改_config.yml配置文件（站点配置文件）</h4><p>将URL部分改成</p>\n<pre><code># URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://panpanfish.com  （自己的博客的域名）\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n</code></pre><p>将部署的部分改成</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/panpan040828/panpan040828.github.io.git   (自己的博客仓库地址)\n  branch: master\n</code></pre><h4 id=\"2-在仓库的git-shell中执行如下命令\"><a href=\"#2-在仓库的git-shell中执行如下命令\" class=\"headerlink\" title=\"2. 在仓库的git shell中执行如下命令\"></a>2. 在仓库的git shell中执行如下命令</h4><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装hexo部署到git上的插件</span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\"></span><br><span class=\"line\">执行清空之前生成的文件命令</span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">执行生成对应的页面命令</span><br><span class=\"line\">hexo <span class=\"keyword\">generate</span></span><br><span class=\"line\"></span><br><span class=\"line\">执行部署命令</span><br><span class=\"line\">hexo deploy</span><br><span class=\"line\"></span><br><span class=\"line\">不需要再commit pull push了</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-每次写博客的步骤\"><a href=\"#3-每次写博客的步骤\" class=\"headerlink\" title=\"3. 每次写博客的步骤\"></a>3. 每次写博客的步骤</h4><p>在<code>source/_posts/</code>里面添加自己的<code>.md</code>文件（博客文件），然后</p>\n<p>hexo clean</p>\n<p>hexo generate</p>\n<p>hexo deploy</p>\n<p><strong>注意：这里的部署文件并不是把所有的文件都push到了github上，一定要切记备份本地的文件夹，或者将本地的文件夹每一次也直接push到git上，要不然换了电脑，丢失了本地的文件夹就很麻烦，特别是<code>source/_posts/</code>里面的<code>.md</code>文件没有了，你的博客源文件就都没有了，哭。。。</strong></p>\n<p><img src=\"/uploads/post/20170308/upload_to_git.png\" alt=\"上传到git上的文件\"></p>\n<p><img src=\"/uploads/post/20170308/loaclhost.png\" alt=\"本地文件\"></p>\n<h3 id=\"三-修改next主题部分样式\"><a href=\"#三-修改next主题部分样式\" class=\"headerlink\" title=\"三. 修改next主题部分样式\"></a>三. 修改next主题部分样式</h3><p>一些next主题自带的东西，在next的文档中都有详细的说明。</p>\n<p>为了不把原来的文件改错，我使用的是自定义样式，方法如下：</p>\n<p>在themes/next/source/css文件夹中的main.styl中的最后添加如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//my layer</span></span><br><span class=\"line\"><span class=\"comment\">//-------------------</span></span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"_my/mycss\"</span></span><br></pre></td></tr></table></figure>\n<p>然后再在这个css文件夹里添加一个_my文件夹，里面创建一个mycss.styl文件，在文件中写上自己的样式。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如：</span><br><span class=\"line\">.my-site-meta &#123;</span><br><span class=\"line\">    padding: 20px 0;</span><br><span class=\"line\">    color: #fff;</span><br><span class=\"line\">    background: #E49A9A;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  \ttext-align: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再在自己的页面引用这些样式就行。</p>\n<p>在themes/next/layout这个文件夹里，放的都是html页面文件</p>\n<p>_partials文件夹里的都是可以复用的部分</p>\n<ul>\n<li>head.swig是html页面的头部</li>\n<li>header.swig是左侧导航栏</li>\n<li>footer.swig是页面底部</li>\n<li>pagination.swig是分页</li>\n</ul>\n<p>_layout.swig是整个页面，每个页面都会使用，其中通过如下形式引用的其他部分</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% include <span class=\"string\">'_scripts/vendors.swig'</span> %&#125;</span><br><span class=\"line\">&#123;% include <span class=\"string\">'_scripts/commons.swig'</span> %&#125;</span><br></pre></td></tr></table></figure>\n<p>新增的demo页面是在page.swig里面修改的</p>\n<p>如果修改样式后，本地预览不对，可以重新启动一下hexo就可以了</p>\n<p>当然，还需要继续研究一下模板的各个文件代表的是什么意思，才能更好地去修改，或者自己写一个模板，任重而道远啊~~~</p>\n<h3 id=\"四-遇见的问题\"><a href=\"#四-遇见的问题\" class=\"headerlink\" title=\"四. 遇见的问题\"></a>四. 遇见的问题</h3><p>后来博客又出现了一些问题，捣腾了半天之后又好了。</p>\n<h4 id=\"1-在执行-hexo-deploy-后-出现-error-deployer-not-found-github-的错误\"><a href=\"#1-在执行-hexo-deploy-后-出现-error-deployer-not-found-github-的错误\" class=\"headerlink\" title=\"1. 在执行 hexo deploy 后,出现 error deployer not found:github 的错误\"></a>1. 在执行 hexo deploy 后,出现 error deployer not found:github 的错误</h4><p>没有安装使用hexo部署到git上的配置文件，在博客文件夹里执行如下命令</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>再部署就会成功</p>\n<h4 id=\"2-明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\"><a href=\"#2-明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\" class=\"headerlink\" title=\"2. 明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\"></a>2. 明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹</h4><p>原因：把.git文件夹删掉了，这个文件夹千万不能删，里面含有很多配置信息。</p>\n<p><strong>.git文件夹是隐藏显示的，如何让其显示：</strong></p>\n<pre><code>点击工具————&gt;文件夹选项————&gt;查看————&gt;显示隐藏文件夹\n</code></pre><h4 id=\"3-域名绑定文件CNAME文件放置的位置\"><a href=\"#3-域名绑定文件CNAME文件放置的位置\" class=\"headerlink\" title=\"3. 域名绑定文件CNAME文件放置的位置\"></a>3. 域名绑定文件CNAME文件放置的位置</h4><p>之前用jekyll搭建博客时，是直接将CNAME文件放在博客根目录下，但是使用hexo搭建博客时，<strong>应该将CNAME文件放在source文件夹下</strong>。</p>\n<p>使用hexo搭建博客，是利用source/_posts/文件夹下的.md文件生成.html文件，然后再部署到github上，所以并不是把整个博客文件夹push上去，github上只有.html文件，所以如果直接把CNAME文件放在根目录里，就不会被push到github上，因此会导致域名绑定不成功。</p>\n<h4 id=\"4-往github上部署文件时出现failed-to-connect-to-github-com-port-443-Timed-out\"><a href=\"#4-往github上部署文件时出现failed-to-connect-to-github-com-port-443-Timed-out\" class=\"headerlink\" title=\"4. 往github上部署文件时出现failed to connect to github.com port 443:Timed out\"></a>4. 往github上部署文件时出现failed to connect to github.com port 443:Timed out</h4><p>这个可能是由于网速的原因，可以访问一下github.com,在网速比较好的时候再重新提交。</p>\n<h3 id=\"五-了解hexo\"><a href=\"#五-了解hexo\" class=\"headerlink\" title=\"五. 了解hexo\"></a>五. 了解hexo</h3><p>如果要做一些个性化的设置，还是需要对hexo进行全面的了解。</p>\n<h4 id=\"1-默认生成的文件\"><a href=\"#1-默认生成的文件\" class=\"headerlink\" title=\"1. 默认生成的文件\"></a>1. 默认生成的文件</h4><ul>\n<li>scaffolds 脚手架，也就是一个工具模板</li>\n<li>scripts 写文件的js，扩展hexo的功能</li>\n<li>source 存放博客正文内容</li>\n<li>source/_drafts 草稿箱</li>\n<li>source/_posts 文件箱</li>\n<li>themes 存放主题的目录</li>\n<li>themes/landscape 默认的主题</li>\n<li>_config.yml 全局的配置文件</li>\n<li>db.json 静态常量</li>\n<li>package.json 根据这个文件，安装相关依赖</li>\n</ul>\n<p><strong>全局配置文件：</strong><code>_config.yml</code> <strong>设置的是网站的配置</strong></p>\n<ul>\n<li>站点信息: 定义标题，作者，语言</li>\n<li>URL: URL访问路径</li>\n<li>文件目录: 正文的存储目录</li>\n<li>写博客配置：文章标题，文章类型，外部链接等</li>\n<li>目录和标签：默认分类，分类图，标签图</li>\n<li>归档设置：归档的类型</li>\n<li>服务器设置：IP，访问端口，日志输出</li>\n<li>时间和日期格式： 时间显示格式，日期显示格式</li>\n<li>分页设置：每页显示数量</li>\n<li>评论：外挂的Disqus评论系统</li>\n<li>插件和皮肤：换皮肤，安装插件</li>\n<li>Markdown语言：markdown的标准</li>\n<li>CSS的stylus格式：是否允许压缩</li>\n<li>部署配置：github发布</li>\n</ul>\n<h3 id=\"六-增加的一些第三方的应用\"><a href=\"#六-增加的一些第三方的应用\" class=\"headerlink\" title=\"六. 增加的一些第三方的应用\"></a>六. 增加的一些第三方的应用</h3><h4 id=\"1-评论功能\"><a href=\"#1-评论功能\" class=\"headerlink\" title=\"1. 评论功能\"></a>1. 评论功能</h4><h4 id=\"2-页面访问统计功能\"><a href=\"#2-页面访问统计功能\" class=\"headerlink\" title=\"2. 页面访问统计功能\"></a>2. 页面访问统计功能</h4><h4 id=\"3-文章阅读数统计功能\"><a href=\"#3-文章阅读数统计功能\" class=\"headerlink\" title=\"3. 文章阅读数统计功能\"></a>3. 文章阅读数统计功能</h4><p>LeanCloud</p>\n","excerpt":"","more":"<p>最近由于换电脑，又出现了一些问题，都添加到了文章内部。。。20170308</p>\n<p>－－－－－－－－－－－分割线－－－－－－－－－－－－－－－－－－－－</p>\n<p>之前弄的那个博客是基于<code>jekyll</code>,现在换成的这个博客是基于<code>hexo</code>。两者都是比较常用的静态博客系统。之所以将jekyll换成hexo呢，是因为看到了基于hexo的next模板（也就是本博客现在使用的模板），当时看到的时候，确实非常喜欢，简洁明了，再加上觉得之前的博客自己弄的样式太小清新了，额。。。当然现在的也还是走的小清新风格，弄成这样主要是为了和原生的next模板那种冷峻的style产生一丢丢辨识度。好了，废话不多说，下面简要介绍一下本博客搭建的过程。</p>\n<p>想学习如何使用jekyll生成博客，可以看我的上个博客的教程。</p>\n<h3 id=\"一-jekyll和hexo的区别\"><a href=\"#一-jekyll和hexo的区别\" class=\"headerlink\" title=\"一. jekyll和hexo的区别\"></a>一. jekyll和hexo的区别</h3><h4 id=\"1-jekyll\"><a href=\"#1-jekyll\" class=\"headerlink\" title=\"1. jekyll\"></a>1. jekyll</h4><p>jekyll是基于ruby</p>\n<p>优点：把原文上传到github上，可以直接生成博客。</p>\n<p>缺点：在windows上安装ruby时，非常麻烦，哪一步出错就有可能安装不成功；文件的分类名或者文件名如果是中文，那么在本地调试时就显示不出来。</p>\n<h4 id=\"2-hexo\"><a href=\"#2-hexo\" class=\"headerlink\" title=\"2. hexo\"></a>2. hexo</h4><p>hexo是基于nodejs</p>\n<p>优点:安装nodejs简单，生成起来快很多，主题种类多一些</p>\n<p>缺点：需要在本地生成html页面，再上传到git上</p>\n<h3 id=\"二-用hexo生成博客的过程\"><a href=\"#二-用hexo生成博客的过程\" class=\"headerlink\" title=\"二. 用hexo生成博客的过程\"></a>二. 用hexo生成博客的过程</h3><h4 id=\"1-用github-pages生成自己的博客仓库\"><a href=\"#1-用github-pages生成自己的博客仓库\" class=\"headerlink\" title=\"1. 用github pages生成自己的博客仓库\"></a>1. 用github pages生成自己的博客仓库</h4><h4 id=\"2-安装github\"><a href=\"#2-安装github\" class=\"headerlink\" title=\"2. 安装github\"></a>2. 安装github</h4><h4 id=\"3-安装nodejs\"><a href=\"#3-安装nodejs\" class=\"headerlink\" title=\"3. 安装nodejs\"></a>3. 安装nodejs</h4><h4 id=\"4-安装hexo\"><a href=\"#4-安装hexo\" class=\"headerlink\" title=\"4. 安装hexo\"></a>4. 安装hexo</h4><p>打开git shell</p>\n<p>输入<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>\n<p>进入自己的博客文件夹（自己本地的github仓库your_user_name.github.io）</p>\n<p>依次输入<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init <span class=\"comment\">//初始化一个博客</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo s --debug <span class=\"comment\">//在调试的状态下启动hexo</span></span><br></pre></td></tr></table></figure></p>\n<p>这样一个博客就生成了，就可以在<a href=\"http://localhost:4000本地查看\">http://localhost:4000本地查看</a></p>\n<h3 id=\"三-本地生成的博客上传到git上\"><a href=\"#三-本地生成的博客上传到git上\" class=\"headerlink\" title=\"三. 本地生成的博客上传到git上\"></a>三. 本地生成的博客上传到git上</h3><p>上面也说了，hexo博客是需要自己在本地根据.md文件生成<code>html</code>页面，然后再部署到git上。</p>\n<h4 id=\"1-修改-config-yml配置文件（站点配置文件）\"><a href=\"#1-修改-config-yml配置文件（站点配置文件）\" class=\"headerlink\" title=\"1. 修改_config.yml配置文件（站点配置文件）\"></a>1. 修改_config.yml配置文件（站点配置文件）</h4><p>将URL部分改成</p>\n<pre><code># URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://panpanfish.com  （自己的博客的域名）\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n</code></pre><p>将部署的部分改成</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/panpan040828/panpan040828.github.io.git   (自己的博客仓库地址)\n  branch: master\n</code></pre><h4 id=\"2-在仓库的git-shell中执行如下命令\"><a href=\"#2-在仓库的git-shell中执行如下命令\" class=\"headerlink\" title=\"2. 在仓库的git shell中执行如下命令\"></a>2. 在仓库的git shell中执行如下命令</h4><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装hexo部署到git上的插件</span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\"></span><br><span class=\"line\">执行清空之前生成的文件命令</span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">执行生成对应的页面命令</span><br><span class=\"line\">hexo <span class=\"keyword\">generate</span></span><br><span class=\"line\"></span><br><span class=\"line\">执行部署命令</span><br><span class=\"line\">hexo deploy</span><br><span class=\"line\"></span><br><span class=\"line\">不需要再commit pull push了</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-每次写博客的步骤\"><a href=\"#3-每次写博客的步骤\" class=\"headerlink\" title=\"3. 每次写博客的步骤\"></a>3. 每次写博客的步骤</h4><p>在<code>source/_posts/</code>里面添加自己的<code>.md</code>文件（博客文件），然后</p>\n<p>hexo clean</p>\n<p>hexo generate</p>\n<p>hexo deploy</p>\n<p><strong>注意：这里的部署文件并不是把所有的文件都push到了github上，一定要切记备份本地的文件夹，或者将本地的文件夹每一次也直接push到git上，要不然换了电脑，丢失了本地的文件夹就很麻烦，特别是<code>source/_posts/</code>里面的<code>.md</code>文件没有了，你的博客源文件就都没有了，哭。。。</strong></p>\n<p><img src=\"/uploads/post/20170308/upload_to_git.png\" alt=\"上传到git上的文件\"></p>\n<p><img src=\"/uploads/post/20170308/loaclhost.png\" alt=\"本地文件\"></p>\n<h3 id=\"三-修改next主题部分样式\"><a href=\"#三-修改next主题部分样式\" class=\"headerlink\" title=\"三. 修改next主题部分样式\"></a>三. 修改next主题部分样式</h3><p>一些next主题自带的东西，在next的文档中都有详细的说明。</p>\n<p>为了不把原来的文件改错，我使用的是自定义样式，方法如下：</p>\n<p>在themes/next/source/css文件夹中的main.styl中的最后添加如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//my layer</span></span><br><span class=\"line\"><span class=\"comment\">//-------------------</span></span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"_my/mycss\"</span></span><br></pre></td></tr></table></figure>\n<p>然后再在这个css文件夹里添加一个_my文件夹，里面创建一个mycss.styl文件，在文件中写上自己的样式。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如：</span><br><span class=\"line\">.my-site-meta &#123;</span><br><span class=\"line\">    padding: 20px 0;</span><br><span class=\"line\">    color: #fff;</span><br><span class=\"line\">    background: #E49A9A;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  \ttext-align: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再在自己的页面引用这些样式就行。</p>\n<p>在themes/next/layout这个文件夹里，放的都是html页面文件</p>\n<p>_partials文件夹里的都是可以复用的部分</p>\n<ul>\n<li>head.swig是html页面的头部</li>\n<li>header.swig是左侧导航栏</li>\n<li>footer.swig是页面底部</li>\n<li>pagination.swig是分页</li>\n</ul>\n<p>_layout.swig是整个页面，每个页面都会使用，其中通过如下形式引用的其他部分</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% include <span class=\"string\">'_scripts/vendors.swig'</span> %&#125;</span><br><span class=\"line\">&#123;% include <span class=\"string\">'_scripts/commons.swig'</span> %&#125;</span><br></pre></td></tr></table></figure>\n<p>新增的demo页面是在page.swig里面修改的</p>\n<p>如果修改样式后，本地预览不对，可以重新启动一下hexo就可以了</p>\n<p>当然，还需要继续研究一下模板的各个文件代表的是什么意思，才能更好地去修改，或者自己写一个模板，任重而道远啊~~~</p>\n<h3 id=\"四-遇见的问题\"><a href=\"#四-遇见的问题\" class=\"headerlink\" title=\"四. 遇见的问题\"></a>四. 遇见的问题</h3><p>后来博客又出现了一些问题，捣腾了半天之后又好了。</p>\n<h4 id=\"1-在执行-hexo-deploy-后-出现-error-deployer-not-found-github-的错误\"><a href=\"#1-在执行-hexo-deploy-后-出现-error-deployer-not-found-github-的错误\" class=\"headerlink\" title=\"1. 在执行 hexo deploy 后,出现 error deployer not found:github 的错误\"></a>1. 在执行 hexo deploy 后,出现 error deployer not found:github 的错误</h4><p>没有安装使用hexo部署到git上的配置文件，在博客文件夹里执行如下命令</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>再部署就会成功</p>\n<h4 id=\"2-明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\"><a href=\"#2-明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\" class=\"headerlink\" title=\"2. 明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹\"></a>2. 明明本地有那个文件夹，但是使用git时老是显示找不到该文件夹</h4><p>原因：把.git文件夹删掉了，这个文件夹千万不能删，里面含有很多配置信息。</p>\n<p><strong>.git文件夹是隐藏显示的，如何让其显示：</strong></p>\n<pre><code>点击工具————&gt;文件夹选项————&gt;查看————&gt;显示隐藏文件夹\n</code></pre><h4 id=\"3-域名绑定文件CNAME文件放置的位置\"><a href=\"#3-域名绑定文件CNAME文件放置的位置\" class=\"headerlink\" title=\"3. 域名绑定文件CNAME文件放置的位置\"></a>3. 域名绑定文件CNAME文件放置的位置</h4><p>之前用jekyll搭建博客时，是直接将CNAME文件放在博客根目录下，但是使用hexo搭建博客时，<strong>应该将CNAME文件放在source文件夹下</strong>。</p>\n<p>使用hexo搭建博客，是利用source/_posts/文件夹下的.md文件生成.html文件，然后再部署到github上，所以并不是把整个博客文件夹push上去，github上只有.html文件，所以如果直接把CNAME文件放在根目录里，就不会被push到github上，因此会导致域名绑定不成功。</p>\n<h4 id=\"4-往github上部署文件时出现failed-to-connect-to-github-com-port-443-Timed-out\"><a href=\"#4-往github上部署文件时出现failed-to-connect-to-github-com-port-443-Timed-out\" class=\"headerlink\" title=\"4. 往github上部署文件时出现failed to connect to github.com port 443:Timed out\"></a>4. 往github上部署文件时出现failed to connect to github.com port 443:Timed out</h4><p>这个可能是由于网速的原因，可以访问一下github.com,在网速比较好的时候再重新提交。</p>\n<h3 id=\"五-了解hexo\"><a href=\"#五-了解hexo\" class=\"headerlink\" title=\"五. 了解hexo\"></a>五. 了解hexo</h3><p>如果要做一些个性化的设置，还是需要对hexo进行全面的了解。</p>\n<h4 id=\"1-默认生成的文件\"><a href=\"#1-默认生成的文件\" class=\"headerlink\" title=\"1. 默认生成的文件\"></a>1. 默认生成的文件</h4><ul>\n<li>scaffolds 脚手架，也就是一个工具模板</li>\n<li>scripts 写文件的js，扩展hexo的功能</li>\n<li>source 存放博客正文内容</li>\n<li>source/_drafts 草稿箱</li>\n<li>source/_posts 文件箱</li>\n<li>themes 存放主题的目录</li>\n<li>themes/landscape 默认的主题</li>\n<li>_config.yml 全局的配置文件</li>\n<li>db.json 静态常量</li>\n<li>package.json 根据这个文件，安装相关依赖</li>\n</ul>\n<p><strong>全局配置文件：</strong><code>_config.yml</code> <strong>设置的是网站的配置</strong></p>\n<ul>\n<li>站点信息: 定义标题，作者，语言</li>\n<li>URL: URL访问路径</li>\n<li>文件目录: 正文的存储目录</li>\n<li>写博客配置：文章标题，文章类型，外部链接等</li>\n<li>目录和标签：默认分类，分类图，标签图</li>\n<li>归档设置：归档的类型</li>\n<li>服务器设置：IP，访问端口，日志输出</li>\n<li>时间和日期格式： 时间显示格式，日期显示格式</li>\n<li>分页设置：每页显示数量</li>\n<li>评论：外挂的Disqus评论系统</li>\n<li>插件和皮肤：换皮肤，安装插件</li>\n<li>Markdown语言：markdown的标准</li>\n<li>CSS的stylus格式：是否允许压缩</li>\n<li>部署配置：github发布</li>\n</ul>\n<h3 id=\"六-增加的一些第三方的应用\"><a href=\"#六-增加的一些第三方的应用\" class=\"headerlink\" title=\"六. 增加的一些第三方的应用\"></a>六. 增加的一些第三方的应用</h3><h4 id=\"1-评论功能\"><a href=\"#1-评论功能\" class=\"headerlink\" title=\"1. 评论功能\"></a>1. 评论功能</h4><h4 id=\"2-页面访问统计功能\"><a href=\"#2-页面访问统计功能\" class=\"headerlink\" title=\"2. 页面访问统计功能\"></a>2. 页面访问统计功能</h4><h4 id=\"3-文章阅读数统计功能\"><a href=\"#3-文章阅读数统计功能\" class=\"headerlink\" title=\"3. 文章阅读数统计功能\"></a>3. 文章阅读数统计功能</h4><p>LeanCloud</p>\n"},{"layout":"post","title":"maoyan-pc项目记录","date":"2016-02-29T16:00:00.000Z","description":null,"_content":"\n将项目down下来，然后直接npm install就会根据package.json中的相关依赖来加载项目。\n\n安装nodemon\n\nnodemon是用来代替node启动应用\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2016-03-01-maoyanpc项目记录.md","raw":"---\nlayout: post\ntitle: maoyan-pc项目记录\ndate: 2016-03-01\ncategories: 前端笔记 \ntags: []\ndescription: \n---\n\n将项目down下来，然后直接npm install就会根据package.json中的相关依赖来加载项目。\n\n安装nodemon\n\nnodemon是用来代替node启动应用\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2016-03-01-maoyanpc项目记录","published":1,"updated":"2016-09-07T12:26:26.000Z","comments":1,"photos":[],"link":"","_id":"cj035ockz00dtd5u88o6ugzxo","content":"<p>将项目down下来，然后直接npm install就会根据package.json中的相关依赖来加载项目。</p>\n<p>安装nodemon</p>\n<p>nodemon是用来代替node启动应用</p>\n","excerpt":"","more":"<p>将项目down下来，然后直接npm install就会根据package.json中的相关依赖来加载项目。</p>\n<p>安装nodemon</p>\n<p>nodemon是用来代替node启动应用</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj035ocb80000d5u8tln5m5i0","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035occ3000bd5u8t6yy4j3a"},{"post_id":"cj035ocbf0002d5u8ld24uzju","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035occc000hd5u8jjvi2gw9"},{"post_id":"cj035occ3000cd5u8ysayrqr9","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035occf000md5u8aypvpwg0"},{"post_id":"cj035ocbl0005d5u8x79yb7f4","category_id":"cj035occ8000dd5u8jqx3n1mv","_id":"cj035occj000rd5u830b2t0bf"},{"post_id":"cj035ocbn0006d5u8pbl5erl9","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035occn000yd5u86o8kjwl4"},{"post_id":"cj035ocbq0008d5u8qexe4waz","category_id":"cj035occk000sd5u8rjuf0hne","_id":"cj035occu0015d5u8herw4xsw"},{"post_id":"cj035occl000xd5u8m1hkt6va","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035occx001ad5u89n4tdcgy"},{"post_id":"cj035occp0012d5u8funvffr7","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocd0001dd5u8800i9lrr"},{"post_id":"cj035occq0014d5u8vo58k4sm","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocd2001id5u87cwzaary"},{"post_id":"cj035occ0000ad5u8w2u8paru","category_id":"cj035occo000zd5u89gp8ta24","_id":"cj035ocd4001ld5u8vjsve1a1"},{"post_id":"cj035occv0017d5u8o42lxpb7","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocd8001qd5u87m51vzr3"},{"post_id":"cj035occx001cd5u8vet4u5pq","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocd9001td5u8gko1mfa1"},{"post_id":"cj035occa000gd5u81zxg2aji","category_id":"cj035occw0018d5u8ha9awwxk","_id":"cj035ocdc001wd5u8lh47k4t2"},{"post_id":"cj035ocd1001fd5u8t53eo374","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocde0020d5u8j2erkyx9"},{"post_id":"cj035ocd3001kd5u865snwpt7","category_id":"cj035occk000sd5u8rjuf0hne","_id":"cj035ocdk0024d5u8uxac707n"},{"post_id":"cj035occd000jd5u8y74jd3cj","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocdl0027d5u8jesg0o40"},{"post_id":"cj035occh000od5u8m8qpudu5","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocdn002ad5u8bga517d1"},{"post_id":"cj035ocdd001yd5u86duvz335","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocds002ed5u8f4pui5q8"},{"post_id":"cj035occi000qd5u8whpg3nbq","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocdt002hd5u8mtk2z7ns"},{"post_id":"cj035ocdk0026d5u8ulyha3v3","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocdw002md5u8oy5g0hdq"},{"post_id":"cj035occk000vd5u86bvihjnx","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035oce1002pd5u82x7wr7al"},{"post_id":"cj035ocdl0028d5u88x1dxha2","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035oce5002td5u8ey41shwj"},{"post_id":"cj035ocdp002bd5u8u7jd78pe","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035oce9002xd5u8cp887qqw"},{"post_id":"cj035ocd5001nd5u88w5u3j07","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocec0031d5u8pkif641w"},{"post_id":"cj035ocds002fd5u89auhcagj","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035oced0035d5u8pwewj9kk"},{"post_id":"cj035ocdu002jd5u80ri2ljr7","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocef0038d5u83eove68a"},{"post_id":"cj035ocdy002nd5u8wt1ght16","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035oceh003cd5u86z0makfl"},{"post_id":"cj035ocd8001rd5u8n0pss0ls","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ocej003fd5u8vx5jj80n"},{"post_id":"cj035oce2002qd5u8dqqz6kk6","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocek003jd5u8bin1sjc2"},{"post_id":"cj035oce6002vd5u8icyf7ax1","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocem003md5u80glp6nyk"},{"post_id":"cj035ocda001ud5u8zy9f6xo1","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocer003rd5u80c76u6wf"},{"post_id":"cj035oce9002yd5u8g4jd6alx","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035oceu003ud5u85zos31hj"},{"post_id":"cj035ocec0033d5u8x50qxgyq","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocew003yd5u8vgejz4m3"},{"post_id":"cj035ocde0021d5u8ue61a7dk","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocey0041d5u8tswlnwe1"},{"post_id":"cj035oced0036d5u8grb836b5","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocf00046d5u8ryh7yftq"},{"post_id":"cj035oceg003ad5u82cbzagm4","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocf20049d5u87x14c5ii"},{"post_id":"cj035oceh003dd5u8fwrg8elu","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocf3004dd5u86isgf40l"},{"post_id":"cj035ocel003kd5u8hzhri2fw","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocf6004gd5u8k02opfq1"},{"post_id":"cj035oceo003pd5u8ak5xj5mb","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocfa004kd5u8fi01h8is"},{"post_id":"cj035oces003sd5u8a16lago8","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocfd004nd5u8ua9cyovk"},{"post_id":"cj035ocej003hd5u8fpmyjyql","category_id":"cj035ocen003nd5u8w0y8tj8o","_id":"cj035ocff004rd5u8fgvy9jl8"},{"post_id":"cj035ocew003zd5u866x9rv0x","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocfg004ud5u82rdpv7t7"},{"post_id":"cj035ocey0043d5u8gr0k8lkd","category_id":"cj035ocen003nd5u8w0y8tj8o","_id":"cj035ocfk004yd5u8oq6as4o2"},{"post_id":"cj035ocf00047d5u8am7lzoj3","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocfm0051d5u8cip4igp0"},{"post_id":"cj035oceu003vd5u83fc1a177","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035ocfo0055d5u8in35l7ev"},{"post_id":"cj035ocf2004ad5u82p9ye0xp","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035ocfq0058d5u8mb9h8b3a"},{"post_id":"cj035ocf4004ed5u8d60x2m9f","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocfw005cd5u860nls7uk"},{"post_id":"cj035ocf6004hd5u820wy1t8o","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocfy005fd5u8hdfsceg8"},{"post_id":"cj035ocfb004ld5u8yie4m75o","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ocg0005id5u8hisqrpu5"},{"post_id":"cj035ocfd004od5u89axwv2st","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ocg2005md5u8w7g53l5e"},{"post_id":"cj035ocff004sd5u8wp4fto2s","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocg4005pd5u8sbefnmeh"},{"post_id":"cj035ocfh004vd5u8rdnu5ibv","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocg6005td5u855qu4mhk"},{"post_id":"cj035ocfk004zd5u8apc8ahcr","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocg9005wd5u832o5ge2o"},{"post_id":"cj035ocfm0052d5u85efh5ic1","category_id":"cj035occo000zd5u89gp8ta24","_id":"cj035ocgc0060d5u838pbn290"},{"post_id":"cj035ocfp0056d5u8ndngllco","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocgf0063d5u8sfsxypz1"},{"post_id":"cj035ocfr0059d5u8jammgbrx","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocgj0067d5u8zpnwvdph"},{"post_id":"cj035ocfw005dd5u87amj1gs4","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocgl006ad5u8s9nh0nfz"},{"post_id":"cj035ocfy005gd5u8n1cb7xfe","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocgn006ed5u8w92cfsmx"},{"post_id":"cj035ocg1005kd5u8buidgoq1","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocgp006hd5u8vi48wvhg"},{"post_id":"cj035ocg3005nd5u8olpgoria","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocgr006kd5u8zt7ilr2s"},{"post_id":"cj035ocg5005rd5u8zzpcwqjn","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocgt006od5u8jwls1xsa"},{"post_id":"cj035ocg6005ud5u8bewh2d3o","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocgv006rd5u85u9orfnw"},{"post_id":"cj035ocga005yd5u8hhfqw1ff","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocgz006vd5u8in7impqf"},{"post_id":"cj035ocgc0061d5u8pmhlq4pt","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035och0006yd5u8b9vom1nn"},{"post_id":"cj035ocgf0064d5u8caff8p4b","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035och20072d5u8ylsm2vu7"},{"post_id":"cj035ocgj0068d5u8eeun6u57","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035och30075d5u87ho9j1uu"},{"post_id":"cj035ocgl006bd5u8pnou1qj2","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035och50079d5u8eohttavr"},{"post_id":"cj035ocgn006fd5u87tldkjlo","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035och7007dd5u8uyn1pc68"},{"post_id":"cj035ocgp006id5u8te7ntv6e","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocha007hd5u8jqf7ntlc"},{"post_id":"cj035ocgs006md5u8pjqj1dzz","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ochc007ld5u81s45cxc3"},{"post_id":"cj035ocgt006pd5u8fg0xsimv","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ochg007pd5u89hw3hdaa"},{"post_id":"cj035ocgv006td5u84coici1k","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ochi007td5u8s2n4rx83"},{"post_id":"cj035ocgz006wd5u8ii0dhnll","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ochk007xd5u8iewpx9r6"},{"post_id":"cj035och10070d5u89pdt8dxj","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ochm0081d5u85yrvg27y"},{"post_id":"cj035och20073d5u8tcyy88qo","category_id":"cj035och6007ad5u8wia8o05l","_id":"cj035ocho0085d5u8dc12x8md"},{"post_id":"cj035ochc007md5u8u88l7qhh","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035ochq0089d5u88y0g02u8"},{"post_id":"cj035och40077d5u8uolufaiv","category_id":"cj035och6007ad5u8wia8o05l","_id":"cj035oci0008dd5u881zexgo9"},{"post_id":"cj035ochh007qd5u8eyc38osj","category_id":"cj035och6007ad5u8wia8o05l","_id":"cj035oci1008gd5u87qoh39a7"},{"post_id":"cj035ochj007ud5u8nrdmev5t","category_id":"cj035occk000sd5u8rjuf0hne","_id":"cj035oci3008kd5u8lmeixfwy"},{"post_id":"cj035och6007bd5u86oslch4d","category_id":"cj035och6007ad5u8wia8o05l","_id":"cj035oci5008od5u8cpyocgth"},{"post_id":"cj035ochk007yd5u8359ljaxm","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035oci6008rd5u8kukofrzo"},{"post_id":"cj035ochm0082d5u8clo74qcp","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035oci8008vd5u8ii52y66q"},{"post_id":"cj035och7007ed5u85531dk5g","category_id":"cj035ochm007zd5u8s8uq4fog","_id":"cj035ocia008yd5u8ik8nl9r7"},{"post_id":"cj035ochp0086d5u8uqu6s8sf","category_id":"cj035ocen003nd5u8w0y8tj8o","_id":"cj035ocic0092d5u8l817ybo1"},{"post_id":"cj035ocha007id5u8sgrw0kej","category_id":"cj035ochm007zd5u8s8uq4fog","_id":"cj035ocie0095d5u875m7yis0"},{"post_id":"cj035oci0008ed5u8mzoyo64k","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocif0099d5u8lvpmo10o"},{"post_id":"cj035oci1008id5u8xtsrkexg","category_id":"cj035ocen003nd5u8w0y8tj8o","_id":"cj035ocih009cd5u8r9ofi3xa"},{"post_id":"cj035oci4008md5u8abojri34","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocik009gd5u8mvwewm1p"},{"post_id":"cj035ochr008ad5u86d65tsn5","category_id":"cj035oci1008hd5u8mx45t0n1","_id":"cj035ocil009jd5u8ihsx9qrc"},{"post_id":"cj035oci5008pd5u8oumzeyqb","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocin009nd5u8c3fxurm7"},{"post_id":"cj035oci7008td5u81mp8sasv","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocio009qd5u85ntrglae"},{"post_id":"cj035oci9008wd5u88ht5xnml","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocir009ud5u8kjgv654s"},{"post_id":"cj035ocib0090d5u8f63wr5w6","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocis009xd5u8kxezrcn5"},{"post_id":"cj035ocic0093d5u8nlc33ife","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ociu00a1d5u80brk9tpl"},{"post_id":"cj035ocie0097d5u8glgwxxlc","category_id":"cj035ocen003nd5u8w0y8tj8o","_id":"cj035ociv00a4d5u8a7l7p37h"},{"post_id":"cj035ocig009ad5u8703fgpjp","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocix00a8d5u8yxzf3crw"},{"post_id":"cj035ocii009ed5u8wil1qu3y","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035ociz00abd5u89we0rrat"},{"post_id":"cj035ocik009hd5u8b9nn2rvs","category_id":"cj035occk000sd5u8rjuf0hne","_id":"cj035ocj100aed5u8eqmlufom"},{"post_id":"cj035ocil009kd5u8o8drbxqu","category_id":"cj035ocey0042d5u81g3lqy89","_id":"cj035ocj200aid5u8sqw0536s"},{"post_id":"cj035ocin009od5u8owzr0o38","category_id":"cj035occk000sd5u8rjuf0hne","_id":"cj035ocj400ald5u8973isebw"},{"post_id":"cj035ocio009rd5u8bc6rmnh8","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocj500apd5u8giu5on84"},{"post_id":"cj035ocir009vd5u8l4hrsjwy","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocj800asd5u8ivtsjh5x"},{"post_id":"cj035ocis009yd5u8i5ek0xqp","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocjc00awd5u8dquco0g7"},{"post_id":"cj035ociu00a2d5u81avh7x97","category_id":"cj035occk000sd5u8rjuf0hne","_id":"cj035ocje00azd5u8hp914tpr"},{"post_id":"cj035ociv00a5d5u84qfm9e13","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocjg00b3d5u8td6kxehz"},{"post_id":"cj035ocix00a9d5u8k9nujbni","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocjh00b6d5u8q2p2c59l"},{"post_id":"cj035ociz00acd5u8ohs2gmrq","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ocjj00bad5u8v4j8rly4"},{"post_id":"cj035ocj100agd5u83c3w8knw","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocjk00bdd5u8lg0lgp7n"},{"post_id":"cj035ocj300ajd5u8n9f9l0sx","category_id":"cj035occw0018d5u8ha9awwxk","_id":"cj035ocjm00bhd5u8uowkal15"},{"post_id":"cj035ocj400and5u8rs0naohg","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocjn00bkd5u84j8qaosi"},{"post_id":"cj035ocj600aqd5u83apyjkda","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocjp00bnd5u889pg6hmh"},{"post_id":"cj035ocj900aud5u82ukmitnt","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocjr00brd5u8n094ym7e"},{"post_id":"cj035ocjc00axd5u8qgc1kzku","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocjs00bud5u85cxp271u"},{"post_id":"cj035ocje00b1d5u8q9ju9fvd","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocjw00byd5u8n3m3rwxn"},{"post_id":"cj035ocjg00b4d5u8gk6s7u1n","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocjy00c2d5u8smkcl8k4"},{"post_id":"cj035ocjh00b7d5u8uh6l6xq4","category_id":"cj035ocd7001od5u8kkkigxeo","_id":"cj035ocjz00c6d5u86tpad7vl"},{"post_id":"cj035ocjj00bbd5u8lslarry5","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ock100cad5u87tb4f5dm"},{"post_id":"cj035ocjl00bed5u86e1st4nm","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ock400ced5u8ug1br7zi"},{"post_id":"cj035ocjm00bid5u8lr46bn54","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ock500cid5u87i2e0ujt"},{"post_id":"cj035ocjo00bld5u8ke6t1qb0","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ock800cmd5u8xj2mniyb"},{"post_id":"cj035ocjp00bpd5u8786shlzr","category_id":"cj035occw0018d5u8ha9awwxk","_id":"cj035ocka00cpd5u83ls3rx7n"},{"post_id":"cj035ocjy00c4d5u8bjbqwrf9","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ockc00ctd5u8fs3cnmjb"},{"post_id":"cj035ocjr00bsd5u8z5iuowjg","category_id":"cj035ocjw00bzd5u8m7egh4im","_id":"cj035ockj00cwd5u8r1obdhtw"},{"post_id":"cj035ocjz00c7d5u8pm5qidd5","category_id":"cj035ocdu002id5u8rwowq6d8","_id":"cj035ockl00d0d5u842ljz8xx"},{"post_id":"cj035ock200ccd5u8rjayjver","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ockn00d3d5u88y2wm7um"},{"post_id":"cj035ocjt00bwd5u8t8p28x67","category_id":"cj035ock100c8d5u8qqzn316m","_id":"cj035ockp00d7d5u8smtqtjdl"},{"post_id":"cj035ock400cfd5u84bov6kk8","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ockq00dad5u8k6p3qv46"},{"post_id":"cj035ock600ckd5u8on5hjffa","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocks00ded5u8mc9qtcci"},{"post_id":"cj035ocjw00c0d5u8fl73ub2k","category_id":"cj035ock100c8d5u8qqzn316m","_id":"cj035ockt00dhd5u8szckp193"},{"post_id":"cj035ock800cnd5u8f2fnobc4","category_id":"cj035ock100c8d5u8qqzn316m","_id":"cj035ockw00dld5u8jgcft6pt"},{"post_id":"cj035ocka00crd5u8u15k2s12","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ockx00dod5u846g2nmg6"},{"post_id":"cj035ockc00cud5u8xyjujo27","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ockz00dsd5u89vaom9t8"},{"post_id":"cj035ockj00cyd5u83trm62zj","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocl000dvd5u8fvym6n19"},{"post_id":"cj035ockl00d1d5u86c9nsj3j","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocl100dxd5u8uqjp9thd"},{"post_id":"cj035ockn00d4d5u8tq23cb1s","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocl200e0d5u81mdv0is1"},{"post_id":"cj035ockp00d8d5u8e2qzkfy5","category_id":"cj035ocdm0029d5u8zgpr9ruk","_id":"cj035ocl200e2d5u8g6jel6vi"},{"post_id":"cj035ockq00dbd5u8z0uxodf9","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocl200e5d5u8lf2hhpit"},{"post_id":"cj035ocks00dfd5u8aqnq1s86","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocl200e7d5u8abxe1fpd"},{"post_id":"cj035ocku00did5u8q00nfdz5","category_id":"cj035occw0018d5u8ha9awwxk","_id":"cj035ocl300ead5u8fgcw23nh"},{"post_id":"cj035ockw00dmd5u8a75b6hgf","category_id":"cj035occe000kd5u8jbdafmyt","_id":"cj035ocl300ecd5u8dg5fw38d"},{"post_id":"cj035ockx00dpd5u83ag87vc3","category_id":"cj035occ8000dd5u8jqx3n1mv","_id":"cj035ocl300efd5u8qh2qonmk"},{"post_id":"cj035ockz00dtd5u88o6ugzxo","category_id":"cj035ocbl0004d5u8uimq59st","_id":"cj035ocl300ehd5u8mhtfndmc"}],"PostTag":[{"post_id":"cj035ocb80000d5u8tln5m5i0","tag_id":"cj035ocbi0003d5u8h1ydk9kq","_id":"cj035occ9000fd5u85uvbw97o"},{"post_id":"cj035ocb80000d5u8tln5m5i0","tag_id":"cj035ocbq0007d5u8ave6549g","_id":"cj035occc000id5u8mbo6ied3"},{"post_id":"cj035occ3000cd5u8ysayrqr9","tag_id":"cj035ocbi0003d5u8h1ydk9kq","_id":"cj035occf000nd5u80fxou8z4"},{"post_id":"cj035occ3000cd5u8ysayrqr9","tag_id":"cj035ocbq0007d5u8ave6549g","_id":"cj035occi000pd5u8t0u4c7cr"},{"post_id":"cj035occd000jd5u8y74jd3cj","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035occk000ud5u8sdyw4ugh"},{"post_id":"cj035ocbf0002d5u8ld24uzju","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035occl000wd5u8ufdhel9b"},{"post_id":"cj035ocbf0002d5u8ld24uzju","tag_id":"cj035occe000ld5u8jdnqkjkx","_id":"cj035occp0011d5u8gfry3trz"},{"post_id":"cj035occl000xd5u8m1hkt6va","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035occq0013d5u8ifh33hrk"},{"post_id":"cj035occp0012d5u8funvffr7","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035occu0016d5u8h3a4r8pw"},{"post_id":"cj035occq0014d5u8vo58k4sm","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035occx001bd5u8fkiue0hg"},{"post_id":"cj035ocbl0005d5u8x79yb7f4","tag_id":"cj035occk000td5u8xskmriw2","_id":"cj035ocd0001ed5u84fhoo0oy"},{"post_id":"cj035ocbl0005d5u8x79yb7f4","tag_id":"cj035occo0010d5u8oc7p4tzm","_id":"cj035ocd2001jd5u89f4ucnek"},{"post_id":"cj035ocbn0006d5u8pbl5erl9","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocd5001md5u8sipcw01g"},{"post_id":"cj035ocbq0008d5u8qexe4waz","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035ocd9001sd5u81irki0tq"},{"post_id":"cj035occ0000ad5u8w2u8paru","tag_id":"cj035ocd7001pd5u8bty0t090","_id":"cj035ocde001zd5u82hx1ah72"},{"post_id":"cj035ocdd001yd5u86duvz335","tag_id":"cj035occo0010d5u8oc7p4tzm","_id":"cj035ocdi0022d5u80f3sbexm"},{"post_id":"cj035ocdl0028d5u88x1dxha2","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocds002dd5u81862o478"},{"post_id":"cj035occa000gd5u81zxg2aji","tag_id":"cj035ocdd001xd5u80qdv1u4x","_id":"cj035ocdt002gd5u85h70sqhp"},{"post_id":"cj035occa000gd5u81zxg2aji","tag_id":"cj035ocdk0025d5u8mcqe3qn1","_id":"cj035ocdw002ld5u8dlntkj7l"},{"post_id":"cj035occh000od5u8m8qpudu5","tag_id":"cj035ocdr002cd5u8cury73aj","_id":"cj035oce1002od5u8fv76rfen"},{"post_id":"cj035ocdu002jd5u80ri2ljr7","tag_id":"cj035ocdr002cd5u8cury73aj","_id":"cj035oce5002sd5u8zut8d9gq"},{"post_id":"cj035ocdy002nd5u8wt1ght16","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035oce8002wd5u8rhej3mjr"},{"post_id":"cj035occi000qd5u8whpg3nbq","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035oceb0030d5u8oyzmcom3"},{"post_id":"cj035occi000qd5u8whpg3nbq","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035oced0034d5u8vurti9s5"},{"post_id":"cj035occk000vd5u86bvihjnx","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocef0037d5u8li7ikvyf"},{"post_id":"cj035oce9002yd5u8g4jd6alx","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035oceh003bd5u8q3mwgwtw"},{"post_id":"cj035occv0017d5u8o42lxpb7","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocej003ed5u8d9kxh6z5"},{"post_id":"cj035occv0017d5u8o42lxpb7","tag_id":"cj035ocec0032d5u8t3ekmpxf","_id":"cj035ocek003id5u82dqdrz4c"},{"post_id":"cj035occx001cd5u8vet4u5pq","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocem003ld5u8vsszeeyu"},{"post_id":"cj035ocel003kd5u8hzhri2fw","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocer003qd5u88cpaba4d"},{"post_id":"cj035ocd1001fd5u8t53eo374","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035oceu003td5u8rlupbkkd"},{"post_id":"cj035oceo003pd5u8ak5xj5mb","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocew003xd5u87jttp3ir"},{"post_id":"cj035ocd3001kd5u865snwpt7","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035ocex0040d5u8qhg4o6zo"},{"post_id":"cj035ocd3001kd5u865snwpt7","tag_id":"cj035ocen003od5u89kp11kw7","_id":"cj035ocf00045d5u8im8krtci"},{"post_id":"cj035ocd5001nd5u88w5u3j07","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocf20048d5u84qq589ps"},{"post_id":"cj035ocf00047d5u8am7lzoj3","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocf3004cd5u8a590o75t"},{"post_id":"cj035ocd8001rd5u8n0pss0ls","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocf6004fd5u8hdg9x9n0"},{"post_id":"cj035ocf4004ed5u8d60x2m9f","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocfa004jd5u86871e5lj"},{"post_id":"cj035ocda001ud5u8zy9f6xo1","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocfd004md5u801aym9zc"},{"post_id":"cj035ocf6004hd5u820wy1t8o","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocff004qd5u8zstm31it"},{"post_id":"cj035ocfb004ld5u8yie4m75o","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocfg004td5u8jgfmjx3q"},{"post_id":"cj035ocde0021d5u8ue61a7dk","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocfj004xd5u80up0nmth"},{"post_id":"cj035ocfd004od5u89axwv2st","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocfm0050d5u8dsvlgxwa"},{"post_id":"cj035ocff004sd5u8wp4fto2s","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocfo0054d5u85klfxzij"},{"post_id":"cj035ocdk0026d5u8ulyha3v3","tag_id":"cj035ocdr002cd5u8cury73aj","_id":"cj035ocfq0057d5u8q1qz79xn"},{"post_id":"cj035ocfh004vd5u8rdnu5ibv","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocfw005bd5u81vk3czxa"},{"post_id":"cj035ocfk004zd5u8apc8ahcr","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocfy005ed5u89usdne1q"},{"post_id":"cj035ocdp002bd5u8u7jd78pe","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocg0005hd5u8bpwszi34"},{"post_id":"cj035ocfm0052d5u85efh5ic1","tag_id":"cj035ocd7001pd5u8bty0t090","_id":"cj035ocg2005ld5u8a19h2goc"},{"post_id":"cj035ocds002fd5u89auhcagj","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocg4005od5u82iuu6g8v"},{"post_id":"cj035ocfr0059d5u8jammgbrx","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocg6005sd5u895xftbb0"},{"post_id":"cj035ocfr0059d5u8jammgbrx","tag_id":"cj035ocbq0007d5u8ave6549g","_id":"cj035ocg8005vd5u8rg66dt1r"},{"post_id":"cj035ocfw005dd5u87amj1gs4","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocgc005zd5u8x0o1vu5n"},{"post_id":"cj035oce2002qd5u8dqqz6kk6","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocgf0062d5u8sm1es5al"},{"post_id":"cj035oce2002qd5u8dqqz6kk6","tag_id":"cj035ocfu005ad5u8iymwj45c","_id":"cj035ocgj0066d5u8q0h7zye7"},{"post_id":"cj035ocg3005nd5u8olpgoria","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocgl0069d5u8twkfr6mg"},{"post_id":"cj035oce6002vd5u8icyf7ax1","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocgn006dd5u8a8u383lz"},{"post_id":"cj035oce6002vd5u8icyf7ax1","tag_id":"cj035ocg0005jd5u85s8cb4h0","_id":"cj035ocgp006gd5u8gucsb4t8"},{"post_id":"cj035ocg5005rd5u8zzpcwqjn","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocgr006jd5u898xhyoa2"},{"post_id":"cj035ocec0033d5u8x50qxgyq","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocgt006nd5u885ni30a2"},{"post_id":"cj035ocgc0061d5u8pmhlq4pt","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocgu006qd5u8ojlhrtev"},{"post_id":"cj035oced0036d5u8grb836b5","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocgy006ud5u8wfva8upt"},{"post_id":"cj035oced0036d5u8grb836b5","tag_id":"cj035ocg9005xd5u8une1joy9","_id":"cj035och0006xd5u8k3vnkur9"},{"post_id":"cj035ocgf0064d5u8caff8p4b","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035och20071d5u88kzy47kq"},{"post_id":"cj035ocgf0064d5u8caff8p4b","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035och30074d5u8uvx6cik6"},{"post_id":"cj035ocgj0068d5u8eeun6u57","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035och50078d5u8obtbcdff"},{"post_id":"cj035oceg003ad5u82cbzagm4","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035och7007cd5u8w4m75r90"},{"post_id":"cj035oceg003ad5u82cbzagm4","tag_id":"cj035ocgi0065d5u81d94a1yb","_id":"cj035och9007gd5u83qlpiw89"},{"post_id":"cj035oceh003dd5u8fwrg8elu","tag_id":"cj035ocgn006cd5u85c5tv1af","_id":"cj035ochc007kd5u8v5ginmea"},{"post_id":"cj035ocgp006id5u8te7ntv6e","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ochf007od5u8iqap5gqj"},{"post_id":"cj035ocgs006md5u8pjqj1dzz","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ochi007sd5u8ep3gvuys"},{"post_id":"cj035ocej003hd5u8fpmyjyql","tag_id":"cj035ocgn006cd5u85c5tv1af","_id":"cj035ochk007wd5u83fsyl7oa"},{"post_id":"cj035ocgt006pd5u8fg0xsimv","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ochm0080d5u85nebi9u9"},{"post_id":"cj035ocgv006td5u84coici1k","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocho0084d5u8dy2ojt5l"},{"post_id":"cj035oces003sd5u8a16lago8","tag_id":"cj035ocgn006cd5u85c5tv1af","_id":"cj035ochq0088d5u8a22avjaa"},{"post_id":"cj035ocgz006wd5u8ii0dhnll","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035oci0008cd5u8oq1186cc"},{"post_id":"cj035oceu003vd5u83fc1a177","tag_id":"cj035och0006zd5u8n7kicduc","_id":"cj035oci1008fd5u8w00wqchg"},{"post_id":"cj035ocew003zd5u866x9rv0x","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035oci3008jd5u8lf7eu94y"},{"post_id":"cj035ocew003zd5u866x9rv0x","tag_id":"cj035och30076d5u8uztyyh3d","_id":"cj035oci5008nd5u8omqazc2s"},{"post_id":"cj035ocey0043d5u8gr0k8lkd","tag_id":"cj035ocgn006cd5u85c5tv1af","_id":"cj035oci6008qd5u8mojayk13"},{"post_id":"cj035ocf2004ad5u82p9ye0xp","tag_id":"cj035och0006zd5u8n7kicduc","_id":"cj035oci8008ud5u8130axa9s"},{"post_id":"cj035ochj007ud5u8nrdmev5t","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035ocia008xd5u8he8lhzcv"},{"post_id":"cj035ochk007yd5u8359ljaxm","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocic0091d5u848ig4hnb"},{"post_id":"cj035ochk007yd5u8359ljaxm","tag_id":"cj035ocec0032d5u8t3ekmpxf","_id":"cj035ocie0094d5u8kcejyfan"},{"post_id":"cj035ocfp0056d5u8ndngllco","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocif0098d5u8pl84refr"},{"post_id":"cj035ocfp0056d5u8ndngllco","tag_id":"cj035ochk007vd5u8u4zitw0w","_id":"cj035ocih009bd5u89sz6rfdm"},{"post_id":"cj035ochm0082d5u8clo74qcp","tag_id":"cj035och0006zd5u8n7kicduc","_id":"cj035ocik009fd5u8h451grdx"},{"post_id":"cj035ochp0086d5u8uqu6s8sf","tag_id":"cj035ocgn006cd5u85c5tv1af","_id":"cj035ocil009id5u850u36cjm"},{"post_id":"cj035ocfy005gd5u8n1cb7xfe","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocin009md5u8ts6b9sfh"},{"post_id":"cj035ocfy005gd5u8n1cb7xfe","tag_id":"cj035ochk007vd5u8u4zitw0w","_id":"cj035ocio009pd5u8rna2zcr3"},{"post_id":"cj035oci0008ed5u8mzoyo64k","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ociq009td5u8dbiexi4y"},{"post_id":"cj035ocg1005kd5u8buidgoq1","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocis009wd5u8tzddsx1p"},{"post_id":"cj035ocg1005kd5u8buidgoq1","tag_id":"cj035ochz008bd5u8km0uiiwp","_id":"cj035ociu00a0d5u88s6s1rfg"},{"post_id":"cj035oci1008id5u8xtsrkexg","tag_id":"cj035ocgn006cd5u85c5tv1af","_id":"cj035ociv00a3d5u83gac2fcn"},{"post_id":"cj035oci4008md5u8abojri34","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocix00a7d5u8jnzifq5e"},{"post_id":"cj035ocg6005ud5u8bewh2d3o","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ociz00aad5u8m0lqamzi"},{"post_id":"cj035ocg6005ud5u8bewh2d3o","tag_id":"cj035ochz008bd5u8km0uiiwp","_id":"cj035ocj100add5u87dl1sov1"},{"post_id":"cj035oci5008pd5u8oumzeyqb","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocj200ahd5u8bubl6yyo"},{"post_id":"cj035oci7008td5u81mp8sasv","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocj400akd5u8rpw762p7"},{"post_id":"cj035oci9008wd5u88ht5xnml","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocj500aod5u81tdwvdz3"},{"post_id":"cj035ocga005yd5u8hhfqw1ff","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocj800ard5u83nb0eu50"},{"post_id":"cj035ocga005yd5u8hhfqw1ff","tag_id":"cj035oci6008sd5u8a0skeha9","_id":"cj035ocjc00avd5u8hkbrl6b9"},{"post_id":"cj035ocib0090d5u8f63wr5w6","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocjd00ayd5u8owmqu327"},{"post_id":"cj035ocic0093d5u8nlc33ife","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocjf00b2d5u8ajwqubyg"},{"post_id":"cj035ocgl006bd5u8pnou1qj2","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocjh00b5d5u8na3jbwyo"},{"post_id":"cj035ocgl006bd5u8pnou1qj2","tag_id":"cj035ochz008bd5u8km0uiiwp","_id":"cj035ocjj00b9d5u8kcpo4sa3"},{"post_id":"cj035ocig009ad5u8703fgpjp","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocjk00bcd5u8wz64morr"},{"post_id":"cj035ocgn006fd5u87tldkjlo","tag_id":"cj035och0006zd5u8n7kicduc","_id":"cj035ocjm00bgd5u8rzm5jmq1"},{"post_id":"cj035ocii009ed5u8wil1qu3y","tag_id":"cj035och0006zd5u8n7kicduc","_id":"cj035ocjn00bjd5u8ipp7jzkt"},{"post_id":"cj035ocik009hd5u8b9nn2rvs","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035ocjp00bmd5u8ordg2fao"},{"post_id":"cj035och10070d5u89pdt8dxj","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocjr00bqd5u8kxfnn92b"},{"post_id":"cj035och10070d5u89pdt8dxj","tag_id":"cj035ocih009dd5u897hv74he","_id":"cj035ocjs00btd5u8epo4f5zk"},{"post_id":"cj035ocil009kd5u8o8drbxqu","tag_id":"cj035och0006zd5u8n7kicduc","_id":"cj035ocjw00bxd5u82caypu0t"},{"post_id":"cj035ocin009od5u8owzr0o38","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035ocjx00c1d5u805xzf4xb"},{"post_id":"cj035och20073d5u8tcyy88qo","tag_id":"cj035ocim009ld5u85uddsz1n","_id":"cj035ocjz00c5d5u8f4quuhyw"},{"post_id":"cj035ocir009vd5u8l4hrsjwy","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ock100c9d5u85067pzun"},{"post_id":"cj035och40077d5u8uolufaiv","tag_id":"cj035ocim009ld5u85uddsz1n","_id":"cj035ock300cdd5u880gexxm3"},{"post_id":"cj035ociu00a2d5u81avh7x97","tag_id":"cj035ocd1001gd5u8pdyh86dk","_id":"cj035ock500chd5u887xangm3"},{"post_id":"cj035och6007bd5u86oslch4d","tag_id":"cj035ocim009ld5u85uddsz1n","_id":"cj035ock800cld5u8irw10ql0"},{"post_id":"cj035ocix00a9d5u8k9nujbni","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ock900cod5u8f10ijv94"},{"post_id":"cj035och7007ed5u85531dk5g","tag_id":"cj035ociw00a6d5u836ef5kk1","_id":"cj035ockb00csd5u8o4domxvh"},{"post_id":"cj035ocha007id5u8sgrw0kej","tag_id":"cj035ociw00a6d5u836ef5kk1","_id":"cj035ockj00cvd5u852xc5thy"},{"post_id":"cj035ocj600aqd5u83apyjkda","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ockl00czd5u88y1gduy9"},{"post_id":"cj035ochc007md5u8u88l7qhh","tag_id":"cj035ocj400amd5u8nxfmogka","_id":"cj035ockn00d2d5u8oxp7cjd4"},{"post_id":"cj035ocj900aud5u82ukmitnt","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocko00d6d5u8oywcbhy7"},{"post_id":"cj035ocjc00axd5u8qgc1kzku","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ockq00d9d5u8iqilmkjc"},{"post_id":"cj035ochh007qd5u8eyc38osj","tag_id":"cj035ocim009ld5u85uddsz1n","_id":"cj035ocks00ddd5u8hw05j9d6"},{"post_id":"cj035ocjg00b4d5u8gk6s7u1n","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ockt00dgd5u8dum80pi5"},{"post_id":"cj035ochr008ad5u86d65tsn5","tag_id":"cj035ocje00b0d5u8yp9xyz16","_id":"cj035ockv00dkd5u8e84xwakv"},{"post_id":"cj035ocjh00b7d5u8uh6l6xq4","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ockx00dnd5u86lcb7eur"},{"post_id":"cj035ocie0097d5u8glgwxxlc","tag_id":"cj035ocjj00b8d5u8tmu97dn1","_id":"cj035ockz00drd5u8vcbgt6fq"},{"post_id":"cj035ocjl00bed5u86e1st4nm","tag_id":"cj035ocdd001xd5u80qdv1u4x","_id":"cj035ocl000dud5u872zncyx9"},{"post_id":"cj035ocjo00bld5u8ke6t1qb0","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl100dwd5u8xvjxs566"},{"post_id":"cj035ocjo00bld5u8ke6t1qb0","tag_id":"cj035ocec0032d5u8t3ekmpxf","_id":"cj035ocl100dzd5u88pepajtp"},{"post_id":"cj035ocjp00bpd5u8786shlzr","tag_id":"cj035ocdd001xd5u80qdv1u4x","_id":"cj035ocl200e1d5u8xqqjrpoa"},{"post_id":"cj035ocio009rd5u8bc6rmnh8","tag_id":"cj035ocjm00bfd5u8n2pqddi7","_id":"cj035ocl200e4d5u851hxsbdl"},{"post_id":"cj035ocio009rd5u8bc6rmnh8","tag_id":"cj035ocjj00b8d5u8tmu97dn1","_id":"cj035ocl200e6d5u8jxmyy0ls"},{"post_id":"cj035ocio009rd5u8bc6rmnh8","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocl300e9d5u8qdwsscsp"},{"post_id":"cj035ocjr00bsd5u8z5iuowjg","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocl300ebd5u8tbohfzcl"},{"post_id":"cj035ocis009yd5u8i5ek0xqp","tag_id":"cj035ocjm00bfd5u8n2pqddi7","_id":"cj035ocl300eed5u8bb2eay5j"},{"post_id":"cj035ocis009yd5u8i5ek0xqp","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl300egd5u882jpyf7l"},{"post_id":"cj035ocjy00c4d5u8bjbqwrf9","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocl400eid5u826pwq2ig"},{"post_id":"cj035ociv00a5d5u84qfm9e13","tag_id":"cj035ocjm00bfd5u8n2pqddi7","_id":"cj035ocl400ejd5u80br4xdvl"},{"post_id":"cj035ociv00a5d5u84qfm9e13","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl400ekd5u8gp25su73"},{"post_id":"cj035ocjz00c7d5u8pm5qidd5","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocl400eld5u821bd45gy"},{"post_id":"cj035ock200ccd5u8rjayjver","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocl400emd5u8j4g0cusv"},{"post_id":"cj035ock400cfd5u84bov6kk8","tag_id":"cj035ocjm00bfd5u8n2pqddi7","_id":"cj035ocl400end5u8xfpl4zok"},{"post_id":"cj035ock400cfd5u84bov6kk8","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocl400eod5u89zypa1ms"},{"post_id":"cj035ociz00acd5u8ohs2gmrq","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocl400epd5u8mk9x8mpa"},{"post_id":"cj035ociz00acd5u8ohs2gmrq","tag_id":"cj035ock100cbd5u86nhu3ofj","_id":"cj035ocl400eqd5u8t1nxbfmp"},{"post_id":"cj035ock600ckd5u8on5hjffa","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl400erd5u8wnedt1na"},{"post_id":"cj035ocj100agd5u83c3w8knw","tag_id":"cj035ocjm00bfd5u8n2pqddi7","_id":"cj035ocl400esd5u80dls0xj4"},{"post_id":"cj035ocj100agd5u83c3w8knw","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl400etd5u8rspvilb9"},{"post_id":"cj035ocka00crd5u8u15k2s12","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocl400eud5u8rfx2pjw8"},{"post_id":"cj035ockc00cud5u8xyjujo27","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl400evd5u8zpmw4shl"},{"post_id":"cj035ocj300ajd5u8n9f9l0sx","tag_id":"cj035ocdw002kd5u8sggamjqr","_id":"cj035ocl400ewd5u8rrg2mb44"},{"post_id":"cj035ocj300ajd5u8n9f9l0sx","tag_id":"cj035ock100cbd5u86nhu3ofj","_id":"cj035ocl400exd5u870u18xlh"},{"post_id":"cj035ockj00cyd5u83trm62zj","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocl400eyd5u8o9wqgq7y"},{"post_id":"cj035ockl00d1d5u86c9nsj3j","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl400ezd5u8mea3b9n9"},{"post_id":"cj035ockn00d4d5u8tq23cb1s","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl400f0d5u8zxtdbdrg"},{"post_id":"cj035ockp00d8d5u8e2qzkfy5","tag_id":"cj035ocev003wd5u8ao88jh2c","_id":"cj035ocl500f1d5u8c5zl1g2t"},{"post_id":"cj035ocj400and5u8rs0naohg","tag_id":"cj035ockj00cxd5u8f2gdmadi","_id":"cj035ocl500f2d5u8f5crdwih"},{"post_id":"cj035ocj400and5u8rs0naohg","tag_id":"cj035ock100cbd5u86nhu3ofj","_id":"cj035ocl500f3d5u8k1wtfej2"},{"post_id":"cj035ockq00dbd5u8z0uxodf9","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl500f4d5u8z8qkgghp"},{"post_id":"cj035ocks00dfd5u8aqnq1s86","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl500f5d5u8p3qe7f9x"},{"post_id":"cj035ocje00b1d5u8q9ju9fvd","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl500f6d5u8vvww2rcr"},{"post_id":"cj035ocje00b1d5u8q9ju9fvd","tag_id":"cj035ockj00cxd5u8f2gdmadi","_id":"cj035ocl500f7d5u8iz2buib1"},{"post_id":"cj035ocku00did5u8q00nfdz5","tag_id":"cj035occo0010d5u8oc7p4tzm","_id":"cj035ocl500f8d5u8m8fq8oxd"},{"post_id":"cj035ocjj00bbd5u8lslarry5","tag_id":"cj035ockv00djd5u81w3iclk1","_id":"cj035ocl500f9d5u8jp7cpbhk"},{"post_id":"cj035ockx00dpd5u83ag87vc3","tag_id":"cj035occk000td5u8xskmriw2","_id":"cj035ocl500fad5u84g3v8l6j"},{"post_id":"cj035ocjm00bid5u8lr46bn54","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl500fbd5u8isk4xd38"},{"post_id":"cj035ocjm00bid5u8lr46bn54","tag_id":"cj035ocky00dqd5u8c7pzg7dc","_id":"cj035ocl500fcd5u8n3knp3kn"},{"post_id":"cj035ocjt00bwd5u8t8p28x67","tag_id":"cj035ocl100dyd5u8a4yucn0v","_id":"cj035ocl500fdd5u8qp595fi4"},{"post_id":"cj035ocjw00c0d5u8fl73ub2k","tag_id":"cj035ocl100dyd5u8a4yucn0v","_id":"cj035ocl500fed5u8lgh6ue9z"},{"post_id":"cj035ock800cnd5u8f2fnobc4","tag_id":"cj035ocl100dyd5u8a4yucn0v","_id":"cj035ocl500ffd5u8c0iwcrur"},{"post_id":"cj035ockw00dmd5u8a75b6hgf","tag_id":"cj035occ8000ed5u83u4ac4fo","_id":"cj035ocl500fgd5u8h7xpjk05"},{"post_id":"cj035ockw00dmd5u8a75b6hgf","tag_id":"cj035ocl300edd5u8spz6ibcf","_id":"cj035ocl500fhd5u884o8q7kq"}],"Tag":[{"name":"jQuery","_id":"cj035ocbi0003d5u8h1ydk9kq"},{"name":"Ajax","_id":"cj035ocbq0007d5u8ave6549g"},{"name":"javaScript","_id":"cj035occ8000ed5u83u4ac4fo"},{"name":"代码规范","_id":"cj035occe000ld5u8jdnqkjkx"},{"name":"博客","_id":"cj035occk000td5u8xskmriw2"},{"name":"github","_id":"cj035occo0010d5u8oc7p4tzm"},{"name":"浏览器","_id":"cj035ocd1001gd5u8pdyh86dk"},{"name":"性能优化","_id":"cj035ocd7001pd5u8bty0t090"},{"name":"工具","_id":"cj035ocdd001xd5u80qdv1u4x"},{"name":"优化","_id":"cj035ocdk0025d5u8mcqe3qn1"},{"name":"BaiduIFE","_id":"cj035ocdr002cd5u8cury73aj"},{"name":"css","_id":"cj035ocdw002kd5u8sggamjqr"},{"name":"DOM","_id":"cj035ocec0032d5u8t3ekmpxf"},{"name":"缓存","_id":"cj035ocen003od5u89kp11kw7"},{"name":"算法","_id":"cj035ocev003wd5u8ao88jh2c"},{"name":"事件","_id":"cj035ocfu005ad5u8iymwj45c"},{"name":"javascript","_id":"cj035ocg0005jd5u85s8cb4h0"},{"name":"数组","_id":"cj035ocg9005xd5u8une1joy9"},{"name":"字符串","_id":"cj035ocgi0065d5u81d94a1yb"},{"name":"HTML5","_id":"cj035ocgn006cd5u85c5tv1af"},{"name":"http","_id":"cj035och0006zd5u8n7kicduc"},{"name":"链式调用","_id":"cj035och30076d5u8uztyyh3d"},{"name":"函数","_id":"cj035ochk007vd5u8u4zitw0w"},{"name":"定时器","_id":"cj035ochz008bd5u8km0uiiwp"},{"name":"JSON","_id":"cj035oci6008sd5u8a0skeha9"},{"name":"设计模式","_id":"cj035ocih009dd5u897hv74he"},{"name":"数据库","_id":"cj035ocim009ld5u85uddsz1n"},{"name":"nodejs","_id":"cj035ociw00a6d5u836ef5kk1"},{"name":"计算机网络","_id":"cj035ocj400amd5u8nxfmogka"},{"name":"php","_id":"cj035ocje00b0d5u8yp9xyz16"},{"name":"HTML","_id":"cj035ocjj00b8d5u8tmu97dn1"},{"name":"读书笔记","_id":"cj035ocjm00bfd5u8n2pqddi7"},{"name":"Sass","_id":"cj035ock100cbd5u86nhu3ofj"},{"name":"模块化","_id":"cj035ockj00cxd5u8f2gdmadi"},{"name":"HTTP","_id":"cj035ockv00djd5u81w3iclk1"},{"name":"ES6","_id":"cj035ocky00dqd5u8c7pzg7dc"},{"name":"框架","_id":"cj035ocl100dyd5u8a4yucn0v"},{"name":"koa","_id":"cj035ocl300edd5u8spz6ibcf"}]}}